<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android,面试," />





  <link rel="alternate" href="/atom.xml" title="EricChows" type="application/atom+xml" />






<meta name="description" content="APP –&amp;gt; Framework –&amp;gt; 底软学习 –&amp;gt; 使用 –&amp;gt; 实现原理 –&amp;gt; 形成自己的理解 –&amp;gt; 给自己留下烙印 A:基础通过关键字来梳理这些相关的知识点  开关机流程   ActivityManagerServiceActivity启动流程, Instrumentation类提供的各种流程控制方法ActivityStackActivityThread">
<meta name="keywords" content="Android,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试汇总">
<meta property="og:url" content="http://yoursite.com/Android-InterView/index.html">
<meta property="og:site_name" content="EricChows">
<meta property="og:description" content="APP –&amp;gt; Framework –&amp;gt; 底软学习 –&amp;gt; 使用 –&amp;gt; 实现原理 –&amp;gt; 形成自己的理解 –&amp;gt; 给自己留下烙印 A:基础通过关键字来梳理这些相关的知识点  开关机流程   ActivityManagerServiceActivity启动流程, Instrumentation类提供的各种流程控制方法ActivityStackActivityThread">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://camo.githubusercontent.com/b1974bdd58e78c12612907d0ad27b893f8fbdbb9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d653766656266333634643864383233352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/517258d1f1e996c7a728c8fe067c439722fc61ce/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d303630353231303738343961373630332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/bd0738100994d5221b0ae2783ae2db6851d0591f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d323465333963646166306436326337352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/6ed7adc069270fc38dc3975727e7c52eb0ef6f05/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383238666536386663646638333462342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/9dec3ec2d382a6c13ed4f7742e9abf9b8a653c11/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d376234353764663231343366613564642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/9fc1c7b7bd804977ad256f8b7b8ddf7fb1eddb2a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d343037376262616566356232376134622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/1dab04df36af09afb1d73542f9ba66dccc444e8c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d663464333339613639613862396539322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="https://camo.githubusercontent.com/fdb7d34b4c62c0dde7adca91c766e224ee3e11f3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333863336561343536326436646265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">
<meta property="og:image" content="http://yoursite.com/Android-InterView/">
<meta property="og:image" content="http://yoursite.com/Android-InterView/">
<meta property="og:updated_time" content="2018-08-31T07:09:05.874Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android面试汇总">
<meta name="twitter:description" content="APP –&amp;gt; Framework –&amp;gt; 底软学习 –&amp;gt; 使用 –&amp;gt; 实现原理 –&amp;gt; 形成自己的理解 –&amp;gt; 给自己留下烙印 A:基础通过关键字来梳理这些相关的知识点  开关机流程   ActivityManagerServiceActivity启动流程, Instrumentation类提供的各种流程控制方法ActivityStackActivityThread">
<meta name="twitter:image" content="https://camo.githubusercontent.com/b1974bdd58e78c12612907d0ad27b893f8fbdbb9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d653766656266333634643864383233352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/Android-InterView/"/>





  <title>Android面试汇总 | EricChows</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EricChows</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Android Developer</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/Android-InterView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chows">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myapple.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EricChows">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Android面试汇总</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-02-01T00:00:00+08:00">
                2015-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/Android-InterView/" class="leancloud_visitors" data-flag-title="Android面试汇总">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!--
# 自己简历上写的技能：
1.对Android非常感兴趣，对移动互联网充满激情，愿意未来二十年从事移动互联网行业;
2.Android SDK以及Android各组件应用、JNI开发、多线程、线程池的使用;
3.熟悉Android的SystemUI/Keyguard/Launcher三个模块;
4.熟练掌握Git/SVN/Android Studio/Eclipse/ADT/MyEclipse/VisualStudio等开发工具;
5.了解Android系统架构，具有解读Android源码的能力;
6.了解Android的Framework系统框架，AIDL，Binder和多进程通信(Socket)，多线程通讯，Handler(Message/MessagerQueue/Looper),View的绘制原理，滑动冲突，View的measure/layout/draw以及事件传递机制，动画;
7.了解Android的Framework中AMS/WMS/PMS
8.了解SeLinux，JNI相关知识;
9.Android性能优化LMK,卡顿,省电等
10.Android稳定性,ANR,Crash,Tombstone,Freeze,Panic,OOM问题的分析
11.了解设计模式
12.了解图像处理算法;
自己也要能够逐条的进行剖析，以及解答.
-->
<p>APP –&gt; Framework –&gt; 底软<br>学习 –&gt; 使用 –&gt; 实现原理 –&gt; 形成自己的理解 –&gt; 给自己留下烙印</p>
<p>A:基础<br>通过关键字来梳理这些相关的知识点</p>
<ol>
<li>开关机流程</li>
</ol>
<ol start="2">
<li><p>ActivityManagerService<br>Activity启动流程, Instrumentation类提供的各种流程控制方法<br>ActivityStack<br>ActivityThread</p>
</li>
<li><p>PackageManagerService</p>
</li>
<li><p>WindowManagerService</p>
</li>
<li><p>进程通讯IPC的方式:<br>Linux中有pipe管道，命名管道FIFO，内存映射(mapped memeory)，消息队列(message queue)，内存共享(shared memeory)，信号量(semaphore)，信号(signal)，套接字(socket) 等八种方式.<br>Binder<br>Serializable 和 Parcelable 进行序列化<br>AIDL<br>Messager<br>Android中IPC的方式：<br>1.Bundle<br>2.文件共享<br>3.Messenger<br>4.AIDL<br>5.ContentProvider<br>6.Socket</p>
</li>
</ol>
<ol start="6">
<li>JNI</li>
</ol>
<ol start="7">
<li><p>View<br>View的工作原理，Event事件<br>measure 测绘  测量View的宽和高<br>layout 布局   确定View最终宽和高，以及四个角的顶点<br>draw 绘制  </p>
</li>
<li><p>SeLinux</p>
</li>
</ol>
<ol start="9">
<li>ANR</li>
<li>Crash</li>
<li>Tombstone</li>
<li>Freeze</li>
<li>OOM</li>
<li>LMK </li>
<li>卡顿</li>
<li>省电</li>
<li>堆和栈<br>堆内存和栈内存的概念<br>栈内存：系统自动分配和释放，<br>保存全局、静态、局部变量，<br>在站上分配内存叫静态分配，<br>大小一般是固定的<br>堆内存：程序员手动分配(malloc/new)和释放(free/java不用手动释放，由GC回收)，<br>在堆上分配内存叫动态分配，<br>一般硬件内存有多大堆内存就有多大</li>
</ol>
<p><a href="https://blog.csdn.net/gyhgx/article/details/70161248" target="_blank" rel="noopener">一些底层基本知识（Android篇二）</a></p>
<ol start="18">
<li>Android的线程和线程池<br>AsyncTask：封装了线程池和Handler，主要是为了方便开发者在子线程中更新UI<br>IntentService<br>HandlerThread<br>线程池</li>
</ol>
<p>底软模块：</p>
<p>B:做过哪些工作</p>
<p>功耗、性能、稳定性三大块</p>
<p>性能优化：</p>
<p><a href="https://blog.csdn.net/csdn_aiyang/article/details/74989318" target="_blank" rel="noopener">Android 性能优化之内存检测、卡顿优化、耗电优化、APK瘦身</a><br><a href="https://www.jianshu.com/p/f7006ab64da7" target="_blank" rel="noopener">Android性能优化系列</a></p>
<p>一些有效的性能优化方法：布局优化、绘制优化、内存泄漏优化、响应速度优化、ListView优化、Bitmap优化、线程优化。<br>布局优化：尽量减少布局的层级<br>首先删除布局中无用的控件和层级，其次有选择地使用性能较低的ViewGroup，比如RelativeLayout。尽量使用性能较高的ViewGroup如LinearLayout。<br>另一种手段就是采用标签、标签和ViewStub.标签主要用于布局重用，标签和标签配合使用，降低减少布局的层级。而ViewStub则提供了按需加载功能，提高了程序的初始化效率。<br>绘制优化：<br>绘制优化是指View的onDraw方法要避免执行大量的操作。主要体现在两个方面： </p>
<ol>
<li>onDraw中不要创建新的局部对象。 </li>
<li>onDraw中不要做耗时的任务。<br>内存泄漏优化：<br><a href="http://zmywly8866.github.io/2016/05/04/android-application-leak-analysis-and-fix.html" target="_blank" rel="noopener">Android应用内存泄露分析、改善经验总结</a></li>
</ol>
<p>响应速度优化：<br>ListView优化：<br>Bitmap优化：<br>线程优化：</p>
<p>性能优化用到的工具<br>Android Studio的 Analyze-Inspect Code 对代码做静态分析，查找常见的内存泄漏问题<br><a href="https://blog.csdn.net/qq_17265737/article/details/77337207" target="_blank" rel="noopener">Android Sutdio自带的代码检查工具analyze的使用</a></p>
<p>代码检查的工具：</p>
<p>性能测试工具：<br>1.APP启动时间<br><a href="https://www.jianshu.com/p/eb82b321a0c9" target="_blank" rel="noopener">Android性能测试 | 启动时间篇</a><br><a href="https://blog.csdn.net/ylyg050518/article/details/80383478" target="_blank" rel="noopener">Android性能优化——优化应用启动时间</a> Google官网的翻译<br><a href="https://blog.csdn.net/zhangbijun1230/article/details/79590345" target="_blank" rel="noopener">Android 性能优化—（8）APP启动时间优化指南</a></p>
<p>思路： 启动方式/原理 –&gt; 查看启动时间的方式 –&gt; 查看启动时间的工具 –&gt; 启动时间的解决方案</p>
<p>APP启动方式：<br>a).冷启动：需要新建用户进程<br>冷启动时，系统需要执行三个任务<br>  1.加载和启动应用程序,<br>  2.在app启动后立即显示一个空白启动窗体<br>  3.创建App进程。<br>一旦系统创建了应用进程，应用进程就会执行下面步骤：<br>  1.创建应用程序对象<br>  2.启动主线程<br>  3.创建Main Activity<br>  4.初始化构造view<br>  5.在屏幕上布局。<br>  6.执行初始化绘制操作<br>b).热启动：<br>c).暖启动：</p>
<p>查看启动时间的方式：<br>a) 通过log中的Displayed字段查找<br>b) adb shell am start -S -W com.example.app/.MainActivity -c android.intent.category.LAUNCHER -a android.intent.action.MAIN<br>比如：adb shell am start -S -W com.android.systemui/.recents.RecentsActivity<br>c) 通过reportFullyDrawn函数确定完全显示耗时—针对应用有延长的情况比较有用<br>d)</p>
<p>启动时间查看工具：<br>a) Trace函数以及Systrace工具<br>b) AndroidStudio 中的 Method Tracer作用就是监听一段时间内，某个进程的某个线程，执行的所有方法，以及各个方法所消耗的时间 <a href="https://segmentfault.com/a/1190000011084104" target="_blank" rel="noopener">在Android Studio中使用Method trace,查看某进程的所有线程trace的方法</a></p>
<p>APP启动时间实例：<br>a)初始化开销大<br>Application 的创建过程中，如果执行复杂的逻辑或者初始化大量的对象，将会影响应用的启动体验<br>解决方案:</p>
<p>2.开机启动时间</p>
<p><a href="https://blog.csdn.net/zhangbijun1230/article/details/80562616" target="_blank" rel="noopener">Android 系统性能优化（58）—开机时间优化</a><br><a href="https://blog.csdn.net/ljp1205/article/details/78360701" target="_blank" rel="noopener">Android O 启动优化</a><br><a href="https://blog.csdn.net/u010164190/article/details/51463492" target="_blank" rel="noopener">Android 开机速度优化—–ART 预先优化</a></p>
<p><a href="https://blog.csdn.net/shirakawakanaki/article/details/53516325" target="_blank" rel="noopener">Android性能优化之路（一）</a><br>检测卡顿工具：<br>a)TraceView<br>b)MethodProfiling<br>c)Profile GPURendering(GPU显示配置文件)  在开发者工具里面有开关可以打开，</p>
<p><a href="https://www.aliyun.com/jiaocheng/2368.html" target="_blank" rel="noopener">Android系统的启动时间</a></p>
<p>3.内存<br>思路： 内存查看 –&gt; 内存泄漏与OOM的常见方式  –&gt; 检测工具  –&gt; 如何优化  –&gt; 自己的实战情况</p>
<p><a href="https://blog.csdn.net/heshushun/article/details/77893817" target="_blank" rel="noopener">Android客户端性能测试—内存（一）</a><br>android程序内存被分为2部分：native和dalvik，dalvik就是我们平常说的java堆，我们创建的对象是在这里面分配的，而bitmap是直接在native上分配的，对于内存的限制是 native+dalvik 不能超过最大限制。android程序内存一般限制在16M，当然也有24M的</p>
<p>两条命令查看内存：<br>a) adb shell dumpsys meminfo PID/包名  -d<br>在进入一个界面之前查看一遍Activity和View的数量，在退出这个界面之后再查看一遍Activity和View的数量，对比进入前和进入后Activity和View数量的变化情况，如果有差异，则说明存在内存泄露（在使用命令查看Activity和View的数量之前，记得手动触发GC）。<br>手动触发GC的方式：1.DDMS中有个按钮  2.代码中调用System.gc(); 3.当创建一个内存分析文件HPROF时触发,使用adb shell am dumpheap可以触发分析HPROF文件</p>
<p>b）adb shell procrank<br>Procrank可以同时获得以下几种内存的信息： VSS：Virtual Set Size虚拟耗用内存（包含共享库占用的内存）。This size also includes memory that may not be resident in RAM like mallocs that have been allocated but not written to，所以用VSS来衡量一个进程实际使用的内存意义不大。</p>
<p>RSS : Resident Set Size实际使用物理内存（包含共享库占用的内存）。 RSS can be misleading, because it reports the total all of the shared libraries that the process uses, even though a shared library is only loaded into memory once regardless of how many processes use，所以用RSS来衡量进程占用的内存信息不是特别准确。</p>
<p>PSS - Proportional Set Size实际使用的物理内存（比例分配共享库占用的内存）。 PSS is a very useful number because when the PSS for all processes in the system are summed together, that is a good representation for the total memory usage in the system，所以用pss衡量程序占用的内存误差比较小。</p>
<p>USS - Unique Set Size进程独自占用的物理内存（不包含共享库占用的内存）. USS is an extremely useful number because it indicates the true incremental cost of running a particular process，所以用USS描述进程占用内存的波动和峰值比较有意义。</p>
<p>一般存在以下关系VSS&gt;=RSS&gt;=PSS&gt;=USS。<br>c) adb shell getprop|grep heapgrowthlimit  查看最大内存<br>d) adb shell top  列出top*进程的cpu和内存占用情况，默认按照cpu占用降序排列。top可以获得进程的VSS和RSS信息，命令持续的监视</p>
<p>内存泄漏和OOM内存溢出<br>通过命令或者工具，如果发现内存一直在增长，说明发生了内存泄漏.<br>OOM内存溢出</p>
<p>常见的内存泄漏，可以用代码静态扫描找出来.<br>常见的代码静态扫描工具：<br><a href="https://www.jianshu.com/p/5834c56a5105" target="_blank" rel="noopener">Android 静态代码扫描流程及工具说明</a><br>1.Android Lint<br>2.Godeyes<br>3.Infer</p>
<p>常见的代码扫描案例：<br>[空指针]空指针引用<br>[内存泄露]Stream资源关闭<br>[性能]使用indexOf(字符)<br>[兼容]系统API兼容性隐患<br>[越界]数组下标越界隐患<br>[异常] 使用除法或求余没有判断分母长度隐患<br>[SQL]注入风险<br>[应用安全] AndroidMannifest.xml文件中allowBackup设置为true时会导致数据泄露</p>
<p>常见的内存泄漏：<br>1.IO操作后，没有关闭文件导致的内存泄露，比如Cursor、FileInputStream、FileOutputStream使用完后没有关闭<br>2.自定义View中使用TypedArray后，没有recycle<br>3.某些地方使用了四大组件的context，在离开这些组件后仍然持有其context导致的内存泄露，这种问题属于共识，在编写代码的过程中就应该按照规则来，使用Application的Context就可以解决这类内存泄露的问题了</p>
<p>分析内存泄漏的工具<br>1.MAT  <a href="https://blog.csdn.net/xiaanming/article/details/42396507" target="_blank" rel="noopener">Android 性能优化之使用MAT分析内存泄露问题</a><br>2.Android Studio的 Analyze-Inspect Code对代码做静态分析<br>3.Leakcanary</p>
<p>内存泄漏优化：<br><a href="http://zmywly8866.github.io/2016/05/04/android-application-leak-analysis-and-fix.html" target="_blank" rel="noopener">Android应用内存泄露分析、改善经验总结</a><br><a href="https://www.jianshu.com/p/f37f4e1e9500" target="_blank" rel="noopener">Android 内存泄露优化处理</a></p>
<p>3.CPU<br>安卓性能指标cpu主要关注两点：<br>（1）cpu总体使用率（2）应用程序cpu占用率。</p>
<p>CPU利用率：CPU执行非系统空闲进程的时间 / CPU总的执行时间。<br>Android关于进程使用率的限制：前台进程不超过95%,后台进程5%, 但是在系统没有前台进程时，后台进程可以超过5%。<br>cpu使用过高，可能引发的问题<br>1）整体性能降低<br>2）界面卡顿<br>3）响应慢，容易引起ANR<br>4）手机发热<br>CPU测试项<br>1.空闲状态下的应用CPU消耗情况<br>2.中等规格状态下的应用CPU消耗情况<br>3.满规格状态下的应用CPU消耗情况<br>4.应用CPU峰值情况<br>查看方式</p>
<ol>
<li>adb shell  dumpsys cpuinfo|grep ‘<package name="">‘<br>2.安卓sdk中tools下找到ddms，启动查看<br><a href="https://www.jianshu.com/p/edeabdb0c60a" target="_blank" rel="noopener">Android性能测试之cpu占用率</a><br><a href="https://blog.csdn.net/KfcCola/article/details/70597500" target="_blank" rel="noopener">Android CPU性能文件位置</a><br><a href="https://blog.csdn.net/heshushun/article/details/77932879" target="_blank" rel="noopener">Android客户端性能测试—CPU、启动时间（二）</a><br>上面的三篇文章都提到了使用adb相关的命令来查看CPU的情况<br>adb shell echo 3&gt;/proc/sys/vm/drop_caches 可以清除系统cache</package></li>
</ol>
<p><a href="https://www.jianshu.com/p/6bf564f7cdf0" target="_blank" rel="noopener">安卓性能测试之cpu占用率统计方法总结</a></p>
<p>设置CPU核心数和频率<br><a href="https://www.jianshu.com/p/111f79ab2106" target="_blank" rel="noopener">Android下设置CPU核心数和频率</a>  通过变化online的核心数和调整CPU频率可以做到功耗和性能的特殊要求。<br><a href="https://bbs.htc.com/cn/chat.php?mod=viewthread&amp;tid=88398&amp;extra=&amp;page=1" target="_blank" rel="noopener">分享一个最全的Android的CPU各种模式设置及作用</a></p>
<p>设置I/O调度<br><a href="https://www.jianshu.com/p/f32354f2c6fc" target="_blank" rel="noopener">Android手机I/O调度模式简介</a><br><a href="https://bbs.htc.com/cn/chat.php?mod=viewthread&amp;tid=88400&amp;extra=" target="_blank" rel="noopener">分享一个最全的Android的I/O调度各种模式设置及作用</a></p>
<p>解决CPU使用率高的实例？<br><a href="https://blog.csdn.net/qq_28607155/article/details/68927354" target="_blank" rel="noopener">Android CPU使用过大的问题解决以及造成的原因</a></p>
<p><a href="https://www.jianshu.com/p/eb82b321a0c9" target="_blank" rel="noopener">Android性能测试|流量、电量、弱网环境的测试方法</a></p>
<p>4.耗电量<br>APP耗电的原因：<br>1.http请求(GZIP压缩)<br>2.json数据解析(json解析效率主要是解析耗时)，大量的数据解析<br>3.数据库读写操作<br>4.SD卡读写操作<br>5.程序的执行的timer定时器（例如IM中的心跳包，用系统的Alarm优化）<br>6.网络切换（wifi会比手机的数据移动网络更加省电）<br>针对以上几种原因的耗电，分别处理<br><a href="https://blog.csdn.net/lhd201006/article/details/50546847" target="_blank" rel="noopener">Android App耗电分析</a></p>
<p>系统耗电的原因：<br>1.蓝牙耗电<br>2.wifi耗电<br>3.移动数据耗电<br>4.CPU耗电<br>5.摄像头耗电<br>6.GPS耗电<br>7.手电筒耗电<br>8.wakelock耗电<br>9.各种Sensor耗电<br><a href="https://blog.csdn.net/itfootball/article/details/49155979" target="_blank" rel="noopener">Android性能专项测试之耗电量统计API</a></p>
<p>耗电分析工具：<br>1.BatteryHistorian 由Google提供的Android系统电量分析工具,从手机中导出bugreport文件上传至页面,在网页中生成详细的图表数据来展示手机上各模块电量消耗过程,最后通过App数据的分析制定出相关的电量优化的方法。<br><a href="https://www.aliyun.com/jiaocheng/35531.html" target="_blank" rel="noopener">Android应用耗电量分析与优化建议</a><br><a href="https://blog.csdn.net/itheimach/article/details/70545139" target="_blank" rel="noopener">电量优化的工具battery-historien</a><br><a href="https://blog.csdn.net/zhaoshuyu111/article/details/52942161" target="_blank" rel="noopener">Android应用耗电问题排查</a></p>
<p>5.流量<br>获取流量信息的方法:<br><a href="https://blog.csdn.net/u013948858/article/details/76079367" target="_blank" rel="noopener">【Android】性能测试之获取Android流量数据</a><br><a href="https://testerhome.com/topics/2643" target="_blank" rel="noopener">Android 性能测试实践 (四) 流量</a></p>
<p>网络的优化<br><a href="https://www.jianshu.com/p/d4c2c62ffc35" target="_blank" rel="noopener">Android App优化之网络优化</a><br><a href="https://developer.android.google.cn/training/basics/network-ops/data-saver?hl=zh-cn" target="_blank" rel="noopener">优化网络流量消耗</a> 来自Android官网</p>
<p>弱网优化</p>
<p>网络优化工具：<br>1.tcpdump抓包<br>2.Wireshark抓包<br><a href="https://blog.csdn.net/java2013liu/article/details/53611913" target="_blank" rel="noopener">Android的app性能测试–流量</a></p>
<p>6.流畅度<br>又叫FPS，或者刷新率VS帧率<br>刷新率：每秒屏幕刷新次数，手机屏幕的刷新率是60HZ<br>帧率：GPU在一秒内绘制的帧数<br>撕裂<br>因为屏幕的刷新过程是自上而下、自左向右的，如果帧率&gt;刷新率，当屏幕还没有刷新n-1帧的数据时，就开始生成第n帧的数据了，从上到下，覆盖第n-1帧。如果此时刷新屏幕，就会出现图像的上半部分是第n帧的，下半部分是第n帧的现象。CPU/GPU一直都在渲染。<br>丢帧<br>Android系统每隔16ms发出VSYNC信号，触发GPU对UI进行渲染，如果你的某个操作花费时间是24ms，系统在得到VSYNC信号的时候由于还没有准备好，就无法进行更新任何内容，那么用户在32ms内看到的会是同一帧画面（卡顿现象），即丢帧现象。<br><a href="https://www.cnblogs.com/cloudiest/p/8485711.html" target="_blank" rel="noopener">Android App性能评测分析－流畅度篇</a></p>
<p><a href="https://blog.csdn.net/weixin_37730482/article/details/73810179" target="_blank" rel="noopener">Android流畅度总结</a></p>
<p>稳定性：<br>1.ANR<br>2.Crash<br>3.Tombstone<br>4.Freeze<br>5.黑屏<br>6.冻屏</p>
<p>功耗：</p>
<!--
15薪是写在工资里面的，有绩效，每个月有1000左右的补贴

# 关于传音的招聘
##职位一：android开发（Framework）
18-30万、包含年底双薪
职责描述：
1.紧跟行业水平，负责功耗相关标准的制定
2.负责用户实际场景下的功耗优化，解决相关的功耗问题；
3.紧跟行业技术，负责Android-Framework功耗优化相关的feature的设计和实现；
4.优化系统整体功耗，负责相关创新技术的设计和实现

任职要求：
1.计算机，通信，电子相关专业本科以上学历，一年以上ANDROID领域APP/Framework开发经验；
2.自我驱动，有强烈的责任感和好奇心，良好的团队合作精神，积极主动，善于沟通；
3.具备以下领域一项或者多项背景经验皆可
a)熟悉ANDROID框架，具有软件架构设计能力，尤其在以下领域之一有产品经验：Activity Manager Service，Package Manager Service，Windows Manager Service，Location Manager Service，Power Manager Service，Battery Status，Alarm Manager，ART/GC，Stagefright
b)具有实际场景下功耗优化经验，如Launhcer，web view，media player等等
c)熟悉LINUX-ANDROID平台的调试手段与工具，如Systrace， Perf，Historian，Function trace
4.良好的英语读写能力，能快速阅读相关英文资料



##职位二：Android 系统安全工程师
18-30万
职责描述：
1、负责Android系统中谷歌安全相关知识的解读和预研。
2、负责分析和跟踪手机产品系统安全行业趋势和最新动态。
4、负责公司安全策略的执行和监督，确保安全策略落地执行。
4、负责对内部研发人员进行系统安全的定期培训和考核。
5、负责Android系统安全技术的咨询和问题解决。

任职要求：
1、本科及以上学历，计算机工程、 计算机科学或相关专业背景；
2、2年Android手机开发经验，有Android手机相关安全功能的设计、开发经验者优先
3、具TEE/SE理论知识及TEE应用编程经验优先；
4、具备加密方法及证书使用相关经验优先；
5、了解安全编码方法及SSDLC知识经验优先；
6、英语读写流利。 


##职位三：android高级软件开发工程师
21-42万
职位描述：
1 参与产品需求分析，制定技术实施方案；
2 负责Android手机应用的架构设计和开发，并确保进度和质量要求；
3 负责重点技术问题的技术攻关；
4 参与制定特定的开发流程和规范，并指导执行；
5 指导并培养普通工程师，提升团队开发水平；

必备知识与技能 
有丰富的Android手机应用架构设计经验，对Android系统有全面的了解，能带领团队进行功能开发；
目前，系统稳定性，多媒体图库，通讯，系统应用等方向均有需求

##职位四：高级安卓开发工程师（systemui/framework/multimedia/launcher）
高级软件开发工程师
工作职责：
1 负责带领开发小组或者独立完成软件需求分析、风险评估、软件实现方案及开发计划制定、开发小组成员职责划分、概要设计
2 负责带领、协调开发小组或者独立完成代码框架搭建、软件编码，负责开发小组与其他部门的沟通协调
3 负责对软件开发工程师和新员工代码质量检查、培训指导
4 负责对部分系统问题、疑难问题、性能功耗问题进行攻关、分析、优化和解决
5 总结技术文档、经验教训，在部门内部进行培训
必备知识与技能 

1.  扎实的Java技术功底和android系统架构知识 
2.  4年以上android应用软件开发经验，拥有Android系统框架开发经验
3.  熟练掌握android开发所有工具的使用，可以独立承担部分疑难问题分析解决
4.  具备相对复杂功能的软件架构设计、代码编码实现的能力
5.  思路清晰、有很强的技术钻研精神和沟通协调能力，能承受一定的工作压力，具备带领开发小组的能力
6.  具备良好的文档编写能力，能熟练阅读英文技术文档

##职位五：软件测试工具开发工程师（Android应用开发）
18-36万
岗位描述：
1. 负责Android平台的应用设计、开发和调试；
2. 能够独立开发Android应用程序；
3、负责改善用户界面的易用性，提升用户体验度；
4、维护和优化相关的APP产品和工具的质量/性能；

任职资格：
1、计算机相关专业，大专以上学历，2年以上安卓开发经验；
2、精通基于Android SDK的应用程序开发，能独立进行应用程序开发、调试、适配和移植；
3、熟悉Android平台架构、原理、Android SDK，熟悉HTTP、HTTPS、TCP/IP通讯协议； 
4、扎实的Java语言基础，熟练使用AndroidSdk进行开发，深入了解Android系统组件，深入理解Android多线程模型； 
5、熟练掌握android各种UI布局和控件、网络框架、测试框架、能够熟练自定义UI控件 ；
6、有独立解决问题的能力，具备良好的沟通能力和优秀的团队协作能力 ；
7、有个人作品或者有github作品源码贡献者优先考虑

# 关于闻泰的招聘
##职位一：Android 软件开发工程师 (System Debug)
任职要求:
1、本科或以上学历，计算机软件、通信相关专业；
2、2年或以上相关工作经验或者Android开发经验；
3、熟练掌握C/C++/Java程序设计；
4、熟悉Android系统问题的分析和解决，常见问题包括死机/定屏/ANR/Crash/Panic/性能优化等；
5、熟悉Android Framework 基本框架，重要服务；
6、掌握Linux操作系统内存管理，进程管理/调度等基本知识；
7、有ARM基础，汇编语言基础者优先；
8、有Qualcomm 平台开发经验者优先；
9、工作认真细致,主动性强,责任心强,有较高独立工作能力, 能承受工作压力。
岗位职责：
1、技术领域：Statility(Crash/Reboot/Shutdown/Hang),Security(keystore,Selinux,SeAndroid,FRP,Boot verify,FDE,ROOT Check,TEE(QSEE) ) 需求实现/问题解决；
2、技术开发：所负责技术领域的功能/需求开发，文档撰写，评审；项目的BSP Bring up, 项目各个阶段的Debug；
3、技术攻关：参与System领域的技术攻关；
4、技术支持：负责System领域的技术培训；
5、技术积累：System领域的经验库总结，问题分析报告，问题回溯报告, 工具使用指导，SOP梳理；
6、知识产权：专利以及软件著作权申请。

##职位二：Android软件开发工程师
职要求： 
1、本科以上学历 ，计算机或通信相关专业； 
2、精通java/c ,熟悉linux操作系统； 
3、熟悉android软件架构； 
4、熟悉android framework； 
3、熟练androidui 开发以及特效处理； 
3、掌握java语言和xml解析数据； 
4、掌握android进程间通信方法； 
5、掌握socket和http网络传输，熟悉xmpp协议、json数据解析； 
6、富有团队和敬业精神，工作主动，有较强的责任感和严谨的工作作风； 
7、有良好的文档撰写能力，英文阅读能力。 
有以下任一经验者优先： 
1、熟悉图形图像算法 ；
2、熟悉常见的编码格式算法、如二维码等； 
3、熟悉数据同步协议 ；
4、熟悉android下网络通信机制，对sockdet通信、tcp/ip和http有较深刻的理解和经验，有网络编程经验 ；
5、掌握手机安全机制，熟悉攻防技术以及安全漏洞原理。 

职位描述： 
1、引入新技术：熟悉市场上出现的和应用，及时在软件中引入 ；
2、软件开发：新功能和新ui的设计和开发； 
3、软件集成：将新功能和新技术的开发成果引入项目中； 
4、软件维护：维护代码，使代码保持一定的兼容性； 
5、技术支持：负责提供软件相关问题的技术培训 ；
6、软件升级：收集软件使用反馈意见，修正缺陷或故障，设计升级版本，提高软件的使用性能； 
7、知识产权管理：协助专利以及软件著作权申请，确保公司利益。


# 关于展讯的招聘
##职位一：Android 应用软件工程师0943
岗位职责:
1、负责展讯平台 Android 应用客户问题解决处理；
2、能够对接客户完成模块相关的客户支持工作；
3、负责编写相关的技术文档以及流程梳理。
任职资格:
1、熟悉Android系统结构；
2、有Android系统应用（SystemUI/Launcher/MultiMedia/Tele/Contacts等）问题处理、功能需求实现经验；
3、对某个Android系统应用或 Android framework(AMS/PMS/WMS/Input等)有深入经验者优先；
4、有稳定性、性能问题处理经验者优先；
5、能够熟练使用 Android 和 Linux 下各种常见工具；
6、能够与团队成员或部门同事合作，清楚地交流信息、思想或观点；
7、良好的学习能力和理解能力。

##职位二：高级软件工程师0887
岗位职责:
1. 承担各芯片平台Android Security功能（FBE\FDE\FRP等）开发维护和客制化定制工作；
2. 承担各芯片平台Android Security加密框架和加密库（JCA\Boringssl等）的开发维护；
3. 承担各芯片平台指纹等生物识别驱动的开发以及配合厂商调试安全方案工作；
4. 承担各芯片平台VerifyBoot Dmverity功能开发和维护；
5.. 学习新技术，按照公司发展规划和开发新产品。
任职资格:
1. 计算机软件、通信、电子相关专业本科以上学历，硕士2年、本科3年以上相关工作经验；
2. 熟练掌握C/C++/Java语言与软件调试工具，熟练掌握Android Framework开发和调试技能；
3. 有JCA、FBE、FDE、Directboot调试和Debug经验优先，有kernel文件系统开发和调试经验优先；
4. 有Secure Boot、Dmverity、VerifyBoot开发和调试经验优先；
5. 具备TEE开发和CA\TA开发调试经验以及生物识别安全调试经验优先；
6. 具备较强的系统分析能力和产品思维，能够快速适应和深入新产品方向，思路清晰，能和客户/协作部门进行良好沟通合作；
7. 具有较强的事业心、责任感, 抗压能力和团队协作精神，良好的英文沟通表达和文档总结能力，能够适应短期出差。


##职位三：高级软件工程师(System)0902
岗位职责:
1.基于展锐芯片平台，交付车联网/智能设备新产品软件开发；
2.评估技术方案可行性，解决产品形态差异化Feature的问题；
3.编写和评审技术文档，保证设计完整性和积累产品技术经验库；
4.支持行业客户与大客户技术问题，保证客户顺利量产；
5.主要业务方向在Android/Linux平台稳定性分析和系统问题。
任职资格:
1、计算机软件、通信、电子相关专业本科以上学历，3年以上产品开发工作经验；
2、熟练掌握嵌入式编程语言与调试工具，具备软件工程与嵌入式系统软件知识；
3、具备较强的系统分析能力，能够快速适应和深入新技术，思路清晰，有良好的沟通协作能力；
4、具有较强的责任感, 抗压能力，良好的英文沟通表达和文档总结能力，能够适应出差需求；
5、 熟悉Android系统框架/Linux Kernel, 能够对Crash/Panic等定屏死机问题进行系统分析；
6、具备展锐芯片平台软件开发，OS系统移植，系统性能调优，项目技术PL经验者更佳。

##职位四：软件系统工程师0947
岗位职责:
1. 在芯片设计阶段与ASIC团队沟通，进行系统软件方案的设计工作；
2. 在产品量产阶段与研发团队，产品管理和客户支持团队完成客户需求的分析和软件方案设计；
3. 对手机等产品上出现的新技术与硬件等团队合作进行预研和方案设计验证(软件部分)。
任职资格:
1. 具有本科或以上学历，有三年或以上Android平台或嵌入式产品开发经验；
2. 有较强的自主工作能力和团队合作精神；
3. 有人工智能或音频/视频系统开发经验优先；
4. 熟悉C/C++或Java等开发工具。

-->
<h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol>
<li>集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突以及处理算法，ConcurrentHashMap</li>
</ol>
<ol start="2">
<li>进程和线程的区别</li>
</ol>
<ol start="3">
<li><p>Java的并发、多线程、线程模型</p>
</li>
<li><p>什么是线程池，如何使用<br>线程池就是事先将多个线程对象放到一个容器中，当使用额时候就不用new线程，而是直接去线程池中拿线程就可以了，节省了开辟子线程的时间，提高代码的执行效率。</p>
</li>
<li><p>数据一致性如何保证；Synchronized关键字，类锁，方法锁和重入锁</p>
</li>
<li><p>Java中实现多态的机制是什么</p>
</li>
<li><p>如何将一个Java对象序列化到文件中</p>
</li>
<li><p>说说对Java反射的理解<br>Java中的反射，首先是能够获取到Java中要反射类的字节码，获取字节码有三种方式<br>a)Class.forName(classname)<br>b)类名.class<br>c) this.getClass()<br>然后将字节码中的方法、变量、构造函数等映射成相应的Method、Filed、Constructor等<br>d)同步的方法：多进程开发以及多进程应用场景</p>
</li>
<li><p>在Java中wait和sleep方法的不同<br>最大的不同是在等待的时候wait会释放锁，而sleep一直持有锁。wait通常用于线程间的交互，sleep通常用于执行暂停</p>
</li>
<li><p>synchronized和volatile关键字的作用<br>1) 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的</p>
</li>
</ol>
<ol start="11">
<li><p>服务器只提供数据接收接口，在多线程或多线程条件下，如何保证数据的有序到达</p>
</li>
<li><p>TheadLocal原理，实现以及如何保证Local属性</p>
</li>
<li><p>String、StringBuilder、StringBuffer的对比</p>
</li>
<li><p>你所知道的设计模式</p>
</li>
<li><p>Java如何调用C、C++语言</p>
</li>
<li><p>接口和回调，回调的原理，写一个回调的demo</p>
</li>
<li><p>泛型的原理，举例说明；解析与分派</p>
</li>
<li><p>抽象类和接口的区别；应用场景，抽象类是否可以没有方法和属性</p>
</li>
<li><p>静态属性和静态方法是否可以被继承？是否可以被重写？什么原因</p>
</li>
<li><p>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法</p>
</li>
<li><p>说说对泛型的理解</p>
</li>
<li><p>Java的异常体系</p>
</li>
<li><p>如何控制某个方法运行并发访问线程的个数</p>
</li>
<li><p>动态代理的区别，分别在什么场景下使用</p>
</li>
</ol>
<h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><h2 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h2><ol>
<li><p>什么是ANR？如何避免它？<br>看《ANR机制以及问题分析》</p>
</li>
<li><p>View的绘制流程？自定义View如何考虑机型适配？ View的事件分发机制？</p>
</li>
<li><p>ART和Dalvik的对比，JVM的内存 分配和垃圾回收GC机制,虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)，JVM的内存模型以及类加载机制，内存对象的循环应用以及避免</p>
</li>
</ol>
<ol start="4">
<li>DDMS/traceView/systrace</li>
</ol>
<ol start="5">
<li>内存回收机制与GC算法(各种算法的优缺点以及应用场景)；GC的原理时机以及GC对象；内存泄漏的场景以及解决方法</li>
</ol>
<ol start="6">
<li>四大组件以及生命周期；ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)，Activity的四种启动模式的对比，Activity状态保存于恢复</li>
</ol>
<ol start="7">
<li>什么是AIDL，以及如何使用.</li>
</ol>
<ol start="8">
<li>请解释下在单线程模型中Message、Hanlder、MessageQueue、Looper之间的关系</li>
</ol>
<ol start="9">
<li>Fragment生命周期，Fragment状态保存,startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用，应该如何解耦</li>
</ol>
<ol start="10">
<li>AsyncTask 原理以及不足，IntentService的原理</li>
</ol>
<ol start="11">
<li><p>Activity怎么和Service绑定，怎么在Activity中启动对应的Service</p>
</li>
<li><p>AsyncTask + HttpClient 与 AsyncHttpClient有什么区别</p>
</li>
<li><p>请描述一下Service的生命周期</p>
</li>
</ol>
<ol start="14">
<li><p>如何保证一个后台服务不被杀死；比较省电的方式是什么？</p>
</li>
<li><p>如何通过广播拦截和abort一条短信；广播是否可以请求网络，广播引起的ANR的时间限制</p>
</li>
<li><p>进程间通信的方式有哪些？ AIDL</p>
</li>
<li><p>事件分发中的onTouch和onTouchEvent有什么区别，又该如何使用</p>
</li>
</ol>
<ol start="18">
<li><p>说说 ContentProvider/ContentResolver/ContentObservr之间的关系</p>
</li>
<li><p>请介绍一下ContentProvider是如何实现数据共享的</p>
</li>
<li><p>Handler的机制以及底层的实现</p>
</li>
<li><p>Binder机制以及底层的实现</p>
</li>
<li><p>ListView中图片错位的问题是如何产生的</p>
</li>
<li><p>在manifest和代码中是如何注册和使用广播的</p>
</li>
<li><p>说说Activity/Intent/Service是什么关系</p>
</li>
<li><p>ApplicationContext和ActivityContext的区别是什么</p>
</li>
</ol>
<ol start="26">
<li><p>一张Bitmap所占内存以及内存占用的计算方法</p>
</li>
<li><p>Serializable和Parcelable的区别</p>
</li>
<li><p>请描述一下BroadcastReceiver</p>
</li>
</ol>
<ol start="29">
<li>请描述一下Android的事件分发机制</li>
</ol>
<ol start="30">
<li><p>请介绍一下NDK</p>
</li>
<li><p>什么是NDK库，如何在JNI中注册native函数，有几种注册方式</p>
</li>
<li><p>Async如何使用</p>
</li>
</ol>
<ol start="33">
<li><p>对于应用更新这块是如何做的？(灰度？强制更新？分区域更新？)</p>
</li>
<li><p>混合开发：ReactNative/weex/H5/小程序/Flutter</p>
</li>
<li><p>什么情况下会导致内存泄漏</p>
</li>
<li><p>如何对Android应用进行性能分析以及优化</p>
</li>
<li><p>说一款你认为当前比较火的应用并设计(直播APP)</p>
</li>
<li><p>OOM的避免异常以及解决方法</p>
</li>
<li><p>屏幕适配的处理技巧有哪些</p>
</li>
<li><p>两个Activity之间跳转时必然会执行的是哪几个方法</p>
</li>
</ol>
<ol start="41">
<li><p>MVC、MVP、MVVM、常见的设计模式，写出观察者模式代码</p>
</li>
<li><p>TCP的三次握手和四次挥手，TCP与UDP的区别</p>
</li>
<li><p>HTTP协议；HTTP 1.0与2.0的区别，HTTP报文结构</p>
</li>
<li><p>都使用过哪些框架和平台</p>
</li>
<li><p>都使用过哪些自定义控件</p>
</li>
<li><p>介绍你做过的项目</p>
</li>
</ol>
<h2 id="非技术问题汇总"><a href="#非技术问题汇总" class="headerlink" title="非技术问题汇总"></a>非技术问题汇总</h2><ol>
<li><p>研究的比较深的领域有哪些</p>
</li>
<li><p>对业内信息的关注渠道有哪些</p>
</li>
<li><p>最近都读了哪些书</p>
</li>
<li><p>自己最擅长的技术点，最感兴趣的技术领域和技术点</p>
</li>
<li><p>项目中使用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题</p>
</li>
<li><p>实习过程中做了什么，有哪些产出</p>
</li>
<li><p>5枚硬币，2正3反，如何划分为两堆然后通过翻转让两堆中正面向上的硬币和反面向上的硬币个数相同</p>
</li>
<li><p>时针走一圈，时针和分针重合几次</p>
</li>
<li><p>N*N的方格纸，里面有多少个正方形</p>
</li>
<li><p>现在下载速度很慢，试从网络协议的角度分析原因，并优化，网络的5层都可以涉及</p>
</li>
</ol>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><ol>
<li><p>堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)</p>
</li>
<li><p>最快的排序算法是哪个？给阿里2万多员工按年龄排序应该选择哪个算法？堆和树的区别？写出快排代码，链表逆序代码</p>
</li>
<li><p>求1000以内的水仙花数以及40亿以内的水仙花数</p>
</li>
<li><p>子串包含问题(KMP算法)写代码实现</p>
</li>
<li><p>万亿级别的两个URL文件A和B，如何求出A和B的差集C</p>
</li>
<li><p>蚁群算法和蒙特卡洛算法</p>
</li>
<li><p>写出你所知道的排序算法以及时空复杂度，稳定性</p>
</li>
<li><p>百度POI中如何试下查找最近商家功能(坐标镜像+R树)</p>
</li>
<li><p>死锁的四个必要条件</p>
</li>
<li><p>常见的编码方式，utf-8变种中文占几个字节，int型占几个字节</p>
</li>
</ol>
<h1 id="HR问题"><a href="#HR问题" class="headerlink" title="HR问题"></a>HR问题</h1><ol>
<li><p>上家离职的原因</p>
</li>
<li><p>讲一件你印象最深的事情</p>
</li>
<li><p>介绍一个你影响最深的项目</p>
</li>
<li><p>介绍你最热爱最擅长的专业领域</p>
</li>
<li><p>公司实习最大的收获是什么</p>
</li>
<li><p>与上级意见不一致时，你怎么办</p>
</li>
<li><p>自己的优点和缺点是什么，并举例说明</p>
</li>
<li><p>你的学习方法是什么样的？实习过程中如何学习？实习过程中遇到的最大困难是什么，以及如何解决的？</p>
</li>
<li><p>说一件最能证明你能力的事情</p>
</li>
<li><p>针对你申请的这个职位，你认为你还欠缺什么</p>
</li>
<li><p>项目中遇到的最大困难时什么，如何解决</p>
</li>
<li><p>职业规划以及个人目标，未来发展路线以及求职定位</p>
</li>
</ol>
<ol start="13">
<li></li>
</ol>
<h1 id="Java-基础-必须要完全的掌握，越熟练越好"><a href="#Java-基础-必须要完全的掌握，越熟练越好" class="headerlink" title="Java 基础 (必须要完全的掌握，越熟练越好)"></a>Java 基础 (必须要完全的掌握，越熟练越好)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  本部分内容主要包含以下知识点，这些内容都是Java中的基础知识，对于Java的学习很有帮助.其中集合、反射、IO等都是面试常问的知识点，是<strong>必须掌握</strong>的。</p>
<ul>
<li>Java集合</li>
<li>Java反射</li>
<li>Java注解</li>
<li>Java I/O</li>
<li>Java泛型</li>
<li>Cloneable </li>
<li>Serializable</li>
<li>Iterator</li>
</ul>
<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>  Java集合大致可以分为Set、List、Queue和Map四种体系.</p>
<p>  其中Set 集合：代表无序，不可重复的集合;<br>  List：代表有序，重复的集合;<br>  Queue:是先进先出的队列集合;<br>  Map：代表映射关系的集合;</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>  Java集合就像一种容器，可以把多个对象(实际上是对象的引用，但习惯上都称对象)”丢进”该容器中,从Java 5 增加了泛型之后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮.</p>
<ol>
<li><p>Java集合和数组的区别：<br>a)数组长度在初始化的时候指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据，同时可以保存具有映射关系的数据(即关联数组，键值对key-value).<br>b)数组的元素既可以是基本数据类型，也可以是对象.集合中只能保存对象(实际上只是保存对象的引用变量)，基本数据类型的变量要转换成对应的包装类才能放入集合类中.</p>
</li>
<li><p>Java集合类之间的继承关系：<br>Java的集合类主要由两个接口派生而出：Collection和Map,Collection 和 Map是Java集合框架的根接口.<br>Collection的派生树 如下：<br><img src="https://camo.githubusercontent.com/b1974bdd58e78c12612907d0ad27b893f8fbdbb9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d653766656266333634643864383233352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Collection的派生树"><br>图中后面[I]表示是接口，[C]表示是类，[AC]表示是抽象类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection[I]</span><br><span class="line">└── Set[I] </span><br><span class="line">|     └── SortedSet[I]</span><br><span class="line">|     |         └── TreeSet[C]</span><br><span class="line">|     └── HashSet[C]</span><br><span class="line">|     |          └── LinkedHashSet[C]</span><br><span class="line">|     └── EnumSet[C]</span><br><span class="line">└── Queue[I]</span><br><span class="line">|      └── PriorityQueue[C]</span><br><span class="line">|      └── Deque[I]</span><br><span class="line">|              └── ArraryDeque[C]</span><br><span class="line">|              └── LinkedList[C]</span><br><span class="line">└── List[I]</span><br><span class="line">       └── LinkedList[C]</span><br><span class="line">       └── ArraryList[C]</span><br><span class="line">       |           └── AttributList[C]</span><br><span class="line">       └── Vector[C]</span><br><span class="line">               └── Stack[C]</span><br></pre></td></tr></table></figure>
<p>此图中，ArrayList，HashSet，LinkedList，TreeSet是我们经常会有用到的已实现的集合类.</p>
</li>
</ol>
<p>   Map 类实现用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，<strong>Map里面的key是不可重复的，key用于表示集合里面的每一项数据.</strong>，这是Map和Collection最大的区别.<br>   <img src="https://camo.githubusercontent.com/517258d1f1e996c7a728c8fe067c439722fc61ce/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d303630353231303738343961373630332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Map的派生树"><br>   图中后面[I]表示是接口，[C]表示是类，[AC]表示是抽象类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map</span><br><span class="line">└── SortMap</span><br><span class="line">|       └──  TreeMap</span><br><span class="line">└── WeakHashMap</span><br><span class="line">└── EnumMap</span><br><span class="line">└── HashMap </span><br><span class="line">|       └── LinkedHashMap</span><br><span class="line">└── IdentityHashMapMap</span><br><span class="line">└── HashTable</span><br><span class="line">        └── Properties</span><br></pre></td></tr></table></figure></p>
<p>   图中，HashMap、TreeMap是我们经常用到的集合类</p>
<h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>  Collection是 Set、List、Queue的父接口<br>  在接口中定义了多种方法提供给子类进行实现，以实现数据操作.<br>  Collection.java代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Collection&lt;E&gt; extends java.lang.Iterable &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean contains(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;E&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public abstract java.lang.Object[] toArray();</span><br><span class="line">  </span><br><span class="line">  public abstract &lt;T&gt; T[] toArray(T[] arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean add(E arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean containsAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean addAll(java.util.Collection&lt;? extends E&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean removeAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public  boolean removeIf(java.util.function.Predicate&lt;? super E&gt; arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean retainAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.stream.Stream&lt;E&gt; <span class="function"><span class="title">stream</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.stream.Stream&lt;E&gt; <span class="function"><span class="title">parallelStream</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a>可以查看到每个函数的具体作用.</p>
<p>可以看出Collection用法有：添加元素、删除元素，返回Collection集合个数以及清空集合等.其中重点介绍iterator()方法，该方法的返回值是Iterator.</p>
<p>从Collection的源码看到，Iterable是Collection的父接口,Iterable的源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.lang;</span><br><span class="line">public abstract interface Iterable&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;T&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public  void forEach(java.util.function.Consumer&lt;? super T&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;T&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">可以看到Iterable接口中有一个抽象方法iterator()</span><br><span class="line">``` bash</span><br><span class="line">public abstract  java.util.Iterator&lt;T&gt; iterator();</span><br></pre></td></tr></table></figure></p>
<p>iterator()方法的返回类型是Iterator型，我们再看看Iterator的源码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract boolean hasNext();</span><br><span class="line">  </span><br><span class="line">  public abstract  E next();</span><br><span class="line">  </span><br><span class="line">  public void <span class="function"><span class="title">remove</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void forEachRemaining(java.util.function.Consumer&lt;? super E&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从JDK文档中可以看到Iterator 是对 collection 进行迭代的迭代器.主要作用是遍历Collection里面的元素.</p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>  Set集合和Collection集合完全相同，没有提供额外的方法，只是行为略有不同(Set不允许包含重复元素).<br>  我们来看看Set的源码.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Set&lt;E&gt; extends java.util.Collection &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean contains(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;E&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public abstract java.lang.Object[] toArray();</span><br><span class="line">  </span><br><span class="line">  public abstract &lt;T&gt; T[] toArray(T[] arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean add(E arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean containsAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean addAll(java.util.Collection&lt;? extends E&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean retainAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean removeAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Set.java也是一个接口，从Set.java和Collection.java的代码来看，几乎一样的.</p>
<p>通过查看源码，我们发现最后Set集合的类，都是继承自AbstractSet类，实现了Set、Cloneable、Serializable接口<br>以HashSet为例，看下它的源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public class HashSet&lt;E&gt; extends java.util.AbstractSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">  static final long serialVersionUID = -5024744406713321676L;</span><br><span class="line">  </span><br><span class="line">  private transient java.util.HashMap&lt;E,java.lang.Object&gt; map;</span><br><span class="line">  </span><br><span class="line">  private static final java.lang.Object PRESENT;</span><br><span class="line">  </span><br><span class="line">  public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  HashSet(java.util.Collection&lt;? extends E&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public HashSet(int arg0, <span class="built_in">float</span> arg1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public HashSet(int arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  HashSet(int arg0, <span class="built_in">float</span> arg1, boolean arg2) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Iterator&lt;E&gt; <span class="function"><span class="title">iterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean contains(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean add(E arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean remove(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void <span class="function"><span class="title">clear</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public java.lang.Object <span class="function"><span class="title">clone</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void writeObject(java.io.ObjectOutputStream arg0) throws java.io.IOException &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void readObject(java.io.ObjectInputStream arg0) throws java.io.IOException, java.lang.ClassNotFoundException &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static &#123;&#125; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看AbstractSet这个抽象类的源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract class AbstractSet&lt;E&gt; extends java.util.AbstractCollection implements java.util.Set &#123;</span><br><span class="line">  </span><br><span class="line">  protected <span class="function"><span class="title">AbstractSet</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean equals(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean removeAll(java.util.Collection&lt;?&gt; arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查阅JDK api看到对AbstractSet类的解释是：此类提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。<br>看到这里有点懵了，</p>
<p>  Map.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Map&lt;K,V&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean containsKey(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean containsValue(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  V get(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  V put(K arg0, V arg1);</span><br><span class="line">  </span><br><span class="line">  public abstract  V remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  void putAll(java.util.Map&lt;? extends K,? extends V&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Set&lt;K&gt; keySet();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Collection&lt;V&gt; values();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Set&lt;java.util.Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  V getOrDefault(java.lang.Object arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void forEach(java.util.function.BiConsumer&lt;? super K,? super V&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void replaceAll(java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V putIfAbsent(K arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean remove(java.lang.Object arg0, java.lang.Object arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean replace(K arg0, V arg1, V arg2) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V replace(K arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V computeIfAbsent(K arg0, java.util.function.Function&lt;? super K,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V computeIfPresent(K arg0, java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V compute(K arg0, java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V merge(K arg0, V arg1, java.util.function.BiFunction&lt;? super V,? super V,? extends V&gt; arg2) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li><p>引入泛型的目的<br>了解引入泛型的动机，就先从语法糖开始了解</p>
<p><strong>语法糖</strong></p>
<p>语法糖(Synactic Sugar),也称糖衣语法，英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用.</p>
<p>Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等.虚拟机并不支持这些语法，它们在编译阶段被还原回了简单的基础语法结构，这个过程成为解语法糖.</p>
<p>泛型的目的：泛型的目的是使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常.</p>
</li>
<li><p>泛型初探<br>JDK 1.5 才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型.<br>在泛型（Generic type或Generics）出现之前，是这么写代码的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println((String)list.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这是完全允许的，因为List里面的内容是Object类型的，自然任何对象类型都可以放入、都可以取出，但是这么写会有两个问题：</p>
<p>1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。<br>2、运行时需要人为地强制转换类型到具体目标，实际的程序绝不会这么简单，一个不小心就会出现java.lang.ClassCastException。</p>
<p>所以，泛型出现之后，上面的代码就改成了大家都熟知的写法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是泛型。泛型是对Java语言类型系统的一种扩展，有点类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。引入泛型，是对Java语言一个较大的功能增强，带来了很多的好处。</p>
</li>
<li><p>泛型的好处<br>①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</p>
<p>②消除了代码中许多的强制类型转换，增强了代码的可读性。</p>
<p>③为较大的优化带来了可能。</p>
</li>
</ol>
<h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><ol>
<li><p>泛型类和泛型接口<br>下面是JDK 1.5 以后，List接口，以及ArrayList类的代码片段.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定了一个类型形参，该形参名为E</span><br><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">   //在该接口里，E可以作为类型使用</span><br><span class="line">   public E get(int index) &#123;&#125;</span><br><span class="line">   public void add(E e) &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义类时指定了一个类型形参，该形参名为E</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">   //在该类里，E可以作为类型使用</span><br><span class="line">   public void <span class="built_in">set</span>(E e) &#123;</span><br><span class="line">   .......................</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是<strong>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。</strong></p>
<p>下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。</p>
<p><strong>泛型类</strong></p>
<p>定义一个容器类，存放键值对key-value，键值对的类型不确定，可以使用泛型来定义，分别指定为K和V。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Container&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Container(K k, V v) &#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K <span class="function"><span class="title">getkey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V <span class="function"><span class="title">getValue</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">setKey</span></span>() &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">setValue</span></span>() &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Container&lt;String,String&gt;  c1=new Container&lt;String ,String&gt;(<span class="string">"name"</span>,<span class="string">"hello"</span>);</span><br><span class="line">    Container&lt;String,Integer&gt; c2=new Container&lt;String,Integer&gt;(<span class="string">"age"</span>,22);</span><br><span class="line">    Container&lt;Double,Double&gt;  c3=new Container&lt;Double,Double&gt;(1.1,1.3);</span><br><span class="line">    System.out.println(c1.getKey() + <span class="string">" : "</span> + c1.getValue());      </span><br><span class="line">    System.out.println(c2.getKey() + <span class="string">" : "</span> + c2.getValue());                                                               </span><br><span class="line">    System.out.println(c3.getKey() + <span class="string">" : "</span> + c3.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK 1.7 增加了泛型的“菱形”语法：<strong>Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。</strong><br>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;String,String&gt; c1=new Container&lt;&gt;(<span class="string">"name"</span>,<span class="string">"hello"</span>);</span><br><span class="line">Container&lt;String,Integer&gt; c2=new Container&lt;&gt;(<span class="string">"age"</span>,22);</span><br></pre></td></tr></table></figure>
<p><strong>泛型类派生子类</strong></p>
<p>当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：<strong>使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。</strong><br>错误的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&lt;K, V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>正确的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&lt;Integer, String&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以不指定具体的类型，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此时系统会把K,V形参当成Object类型处理。</p>
</li>
<li><p>泛型的方法<br>前面在介绍泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 如下面的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Container&lt;K, V&gt;</span><br><span class="line"> &#123;</span><br><span class="line">........................</span><br><span class="line">    public K <span class="function"><span class="title">getkey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">setKey</span></span>() &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">  public static &lt;T&gt; void out(T t)&#123;</span><br><span class="line">       System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">       out(<span class="string">"hansheng"</span>);</span><br><span class="line">       out(123);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T, S&gt; 返回值类型 方法名（形参列表）｛</span><br><span class="line">   方法体</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;  </span><br><span class="line">  public &lt;T&gt; T fun(T t)&#123;   // 可以接收任意类型的数据  </span><br><span class="line">   <span class="built_in">return</span> t ;     // 直接把参数返回  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">public class GenericsDemo26&#123;  </span><br><span class="line">  public static void main(String args[])&#123;  </span><br><span class="line">    Demo d = new Demo() ; // 实例化Demo对象  </span><br><span class="line">    String str = d.fun(<span class="string">"汤姆"</span>) ; // 传递字符串  </span><br><span class="line">    int i = d.fun(30) ;  // 传递数字，自动装箱  </span><br><span class="line">    System.out.println(str) ; // 输出内容  </span><br><span class="line">    System.out.println(i) ;  // 输出内容  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p>
</li>
<li><p>泛型构造器<br>正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。<br>和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public &lt;T&gt; Person(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //隐式</span><br><span class="line">        new Person(22);</span><br><span class="line">        //显示</span><br><span class="line">        new&lt;String&gt; Person(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里唯一需要特殊注明的就是，如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：<br>因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。<br>以下面这个例子为代表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person&lt;E&gt; &#123;</span><br><span class="line">    public &lt;T&gt; Person(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;String&gt; a = new &lt;Integer&gt;Person&lt;&gt;(15);</span><br></pre></td></tr></table></figure>
<p>这种语法不允许，会直接编译报错！</p>
</li>
</ol>
<h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p> 顾名思义就是匹配任意类型的类型实参.<br> 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">test</span>(List&lt;?&gt; c)&#123;</span><br><span class="line">  <span class="keyword">for</span>(int i =0;i&lt;c.size();i++)&#123;</span><br><span class="line">    System.out.println(c.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 现在可以传入任何类型的List来调用test()方法，程序依然可以访问集合c中的元素，其类型是Object。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; c = new ArrayList&lt;String&gt;();</span><br><span class="line">//编译器报错</span><br><span class="line">c.add(new Object());</span><br></pre></td></tr></table></figure></p>
<p> 但是并不能把元素加入到其中。因为程序无法确定c集合中元素的类型，所以不能向其添加对象。<br> 下面就该引入带限通配符，来确定集合元素中的类型。</p>
<p> <strong>带限通配符</strong><br> 单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。<br> 主要分为两类即：<strong>上限通配符</strong>和<strong>下限通配符</strong>。</p>
<ol>
<li><p>上限通配符<br>如果想限制使用泛型类别时，只能用某个特定类型或者是其<strong>子类型</strong>才能实例化该类型时，可以在定义类型时，<strong>使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身</strong></p>
<p>表示集合中的所有元素都是Shape类型或者其子类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Shape&gt;</span><br></pre></td></tr></table></figure>
<p>这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Circle是其子类</span><br><span class="line">List&lt;? extends Shape&gt; list = new ArrayList&lt;Circle&gt;();</span><br></pre></td></tr></table></figure>
<p>这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。</p>
</li>
<li><p>下限通配符<br>如果想限制使用泛型类别时，只能用某个特定类型或者是其<strong>父类型</strong>才能实例化该类型时，可以在定义类型时，<strong>使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。</strong></p>
<p>表示集合中的所有元素都是Circle类型或者其父类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List &lt;? super Circle&gt;</span><br></pre></td></tr></table></figure>
<p>这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Shape是其父类</span><br><span class="line">List&lt;? super Circle&gt; list = new ArrayList&lt;Shape&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1=new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">Class c2=new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">System.out.println(c1==c2);</span><br></pre></td></tr></table></figure>
<p> 程序输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p><strong>在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。</strong></p>
<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p> 要理解注解(Annotation)作用，就要先理解Java中的元数据的概念。</p>
<ol>
<li><p>元数据概念<br>元数据是关于数据的数据，在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。</p>
</li>
<li><p>元数据的作用<br>一般来说，元数据可以用于创建文档(根据程序元素上的注释创建文档),跟踪代码中的依赖性(可声明方法是重载，依赖父类的方法)，执行编译时检查(可声明是否编译期监测)，代码分析。<br>如下：<br>1) 编写文档： 通过代码里标识的元数据生成文档<br>2) 代码分析： 通过代码里标识的元数据对代码进行分析<br>3）编译检查： 通过代码里标识的元数据让编译器能实现基本的编译检查</p>
</li>
<li><p>Java平台元数据<br>注解Annotation就是Java平台的元数据，是J2SE5.0新增加的功能，该机制允许在Java代码中添加自定义注释，并允许通过反射(reflection),以编程方式访问元数据注释。通过提供为程序元素(类、方法等)附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。</p>
</li>
</ol>
<h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><ol>
<li><p>注解(Annotation)的概念<br>注解是在JDK1.5之后新增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或者编译工具解析。</p>
<p>关于注解(Annotation)的作用，其实就是上述元数据的作用。</p>
<p><strong>注意：Annotation能被用来为程序元素(类、方法、成员变量等)设置元数据。Annotation不影响程序代码的执行，无论增加、删除Annotation，代码始终如一的执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或者编译工具对Annotation中的信息进行解析和处理.</strong></p>
</li>
<li><p>内建注解<br>Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppresWarnings以及@FunctionallInterface者四个注解。内建注解主要实现呢了元数据的第二个作用：<strong>编译检查</strong>。</p>
<p><strong>@Override</strong><br>用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。</p>
<p>@Override可适用元素为方法，仅仅保留在Java源文件中。</p>
<p><strong>@Deprecated</strong><br>用途：使用这个注解，用于告知编译器吗，某一程序元素(比如方法，成员变量)不建议使用了(即过时了).<br>例如：<br>Person类中的info()方法使用@Deprecated表示该方法过时了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void <span class="function"><span class="title">info</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用info()方法会编译器会出现警告，告知该方法已过时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Person person = nre Person();</span><br><span class="line">		person.info();//info函数会有一个删除线</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解类型分析：@Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时。</p>
</li>
</ol>
<p><strong>@SuppressWarnings</strong><br> 用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。<br> 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</p>
<p> 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SupressWarning(value=&#123;<span class="string">"uncheck"</span>,<span class="string">"deprecation"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p> <img src="https://camo.githubusercontent.com/bd0738100994d5221b0ae2783ae2db6851d0591f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d323465333963646166306436326337352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="SuppressWarning参数"></p>
<p> <strong>@FunctionalInterface</strong><br> 用途：用户告知编译器，检查这个接口，保证该接口是函数式接口，即只能包含一个抽象方法，否则就会编译出错。</p>
<p> 注解类型分析： @FunctionalInterface可适合用于注解类型声明，保留时长为运行时。</p>
<ol start="3">
<li><p>元Annotation<br>JDK除了在java.lang提供了上述内建注解外，还在java.lang.annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。</p>
<p>我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。</p>
<p><strong>当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。</strong></p>
<p><strong>@Documented</strong></p>
<p>@Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。<br>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义@Deprecated时使用了@Documented，则任何元素使用@Deprecated修饰时，在生成API文档时，将会包含@Deprecated的说明<br>以下是String的一个过时的构造方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public String(byte[] ascii,int hibyte,int offset, int count)</span><br></pre></td></tr></table></figure>
<p>该注解实现了元数据的第一个功能：<strong>编写文档</strong>。</p>
<p><strong>@Inherited</strong><br>@Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表：<br><img src="https://camo.githubusercontent.com/6ed7adc069270fc38dc3975727e7c52eb0ef6f05/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383238666536386663646638333462342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Retention"></p>
<p><strong> @Target</strong><br>@Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表：<br><img src="https://camo.githubusercontent.com/9dec3ec2d382a6c13ed4f7742e9abf9b8a653c11/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d376234353764663231343366613564642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Target"></p>
</li>
</ol>
<h3 id="自定义注解（Annotation）"><a href="#自定义注解（Annotation）" class="headerlink" title="自定义注解（Annotation）"></a>自定义注解（Annotation）</h3><p> 创建自定义注解，与创建接口有几分相似，但注解需要以@开头。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotataion&#123;</span><br><span class="line">    String name();</span><br><span class="line">    String website() default <span class="string">"hello"</span>;</span><br><span class="line">    int revision() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>自定义注解中定义成员变量的规则：</strong><br> 其定义是以无形参的方法形式来声明的。即：<br> 注解方法不带参数，比如name()，website()；<br> 注解方法返回值类型：基本类型、String、Enums、Annotation以及前面这些类型的数组类型<br> 注解方法可有默认值，比如default “hello”，默认website=”hello”</p>
<p> <strong>当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationDemo &#123;</span><br><span class="line">    @MyAnnotataion(name=<span class="string">"lvr"</span>, website=<span class="string">"hello"</span>, revision=1)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I am main method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123; <span class="string">"unchecked"</span>, <span class="string">"deprecation"</span> &#125;)</span><br><span class="line">    @MyAnnotataion(name=<span class="string">"lvr"</span>, website=<span class="string">"hello"</span>, revision=2)</span><br><span class="line">    public void <span class="function"><span class="title">demo</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am demo method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  由于该注解的保留策略为RetentionPolicy.RUNTIME，故可在运行期通过反射机制来使用，否则无法通过反射机制来获取。这时候注解实现的就是元数据的第二个作用：<strong>代码分析</strong>。<br>下面来具体介绍如何通过反射机制来进行注解解析。</p>
<h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p> 接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：<br> <img src="https://camo.githubusercontent.com/9fc1c7b7bd804977ad256f8b7b8ddf7fb1eddb2a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d343037376262616566356232376134622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Reflect"></p>
<p> 因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationParser &#123;</span><br><span class="line">    public static void main(String[] args) throws SecurityException, ClassNotFoundException &#123;</span><br><span class="line">        String clazz = <span class="string">"com.lvr.annotation.AnnotationDemo"</span>;</span><br><span class="line">        Method[]  demoMethod = AnnotationParser.class</span><br><span class="line">                .getClassLoader().loadClass(clazz).getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : demoMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotataion.class)) &#123;</span><br><span class="line">                 MyAnnotataion annotationInfo = method.getAnnotation(MyAnnotataion.class);</span><br><span class="line">                 System.out.println(<span class="string">"method: "</span>+ method);</span><br><span class="line">                 System.out.println(<span class="string">"name= "</span>+ annotationInfo.name() +</span><br><span class="line">                         <span class="string">" , website= "</span>+ annotationInfo.website()</span><br><span class="line">                        + <span class="string">" , revision= "</span>+annotationInfo.revision());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上仅是一个示例，其实可以根据拿到的注解信息做更多有意义的事。</p>
<h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol>
<li><p>Java反射机制的定义<br>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
</li>
<li><p>Java反射机制的功能<br>a).在运行时判断任意一个对象所属的类。<br>b).在运行时构造任意一个类的对象。<br>c).在运行时判断任意一个类所具有的成员变量和方法。<br>d).在运行时调用任意一个对象的方法。<br>e).生成动态代理。</p>
</li>
<li><p>Java 反射机制的应用场景<br>a).逆向代码  例如反编译<br>b).与注解相结合的框架 例如Retrofit<br>c).单纯的反射机制应用框架 例如EventBus<br>d).动态生成类框架 例如Gson</p>
</li>
</ol>
<h3 id="通过Java反射查看类信息"><a href="#通过Java反射查看类信息" class="headerlink" title="通过Java反射查看类信息"></a>通过Java反射查看类信息</h3><p> 一、 获得Class对象<br> 每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。<br> 在Java程序中获得Class对象通常有如下三种方式：</p>
<ol>
<li>使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</li>
<li>调用某个类的class属性来获取该类对应的Class对象。</li>
<li><p>调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//第一种方式 通过Class类的静态方法——forName()来实现</span><br><span class="line">class1 = Class.forName(<span class="string">"com.lvr.reflection.Person"</span>);</span><br><span class="line">//第二种方式 通过类的class属性</span><br><span class="line">class1 = Person.class;</span><br><span class="line">//第三种方式 通过对象getClass方法</span><br><span class="line">Person person = new Person();</span><br><span class="line">Class&lt;?&gt; class1 = person.getClass();</span><br></pre></td></tr></table></figure>
<p>二、获取class对象的属性、方法、构造函数等</p>
</li>
<li><p>获取class对象的成员变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性</span><br><span class="line">Field[] publicFields = class1.getFields();//获取class对象的public属性</span><br><span class="line">Field ageField = class1.getDeclaredField(<span class="string">"age"</span>);//获取class指定属性</span><br><span class="line">Field desField = class1.getField(<span class="string">"des"</span>);//获取class指定的public属性</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取class对象的方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法</span><br><span class="line">Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法</span><br><span class="line">Method method = class1.getMethod(<span class="string">"info"</span>, String.class);//返回次Class对象对应类的、带指定形参列表的public方法</span><br><span class="line">Method declaredMethod = class1.getDeclaredMethod(<span class="string">"info"</span>, String.class);//返回次Class对象对应类的、带指定形参列表的方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取class对象的构造函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数</span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</span><br><span class="line">Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解</span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解</span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type</span><br><span class="line">Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的<span class="built_in">type</span>集合</span><br></pre></td></tr></table></figure>
<p>三、 获取class对象的信息<br>比较多</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型</span><br><span class="line">boolean isArray = class1.isArray();//判断是否是集合类</span><br><span class="line">boolean isAnnotation = class1.isAnnotation();//判断是否是注解类</span><br><span class="line">boolean isInterface = class1.isInterface();//判断是否是接口类</span><br><span class="line">boolean isEnum = class1.isEnum();//判断是否是枚举类</span><br><span class="line">boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类</span><br><span class="line">boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰</span><br><span class="line">String className = class1.getName();//获取class名字 包含包名路径</span><br><span class="line">Package aPackage = class1.getPackage();//获取class的包信息</span><br><span class="line">String simpleName = class1.getSimpleName();//获取class类名</span><br><span class="line">int modifiers = class1.getModifiers();//获取class访问权限</span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类</span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h3><p> 一、生成类的实例对象</p>
<ol>
<li><p>使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p>
</li>
<li><p>先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//第一种方式 Class对象调用newInstance()方法生成</span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line">//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</span><br><span class="line">obj = constructor.newInstance(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p> 二、调用类的方法</p>
<ol>
<li><p>通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。</p>
</li>
<li><p>调用Method对象中的Object invoke(Object obj, Object… args)方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 生成新的对象：用newInstance()方法</span><br><span class="line"> Object obj = class1.newInstance();</span><br><span class="line">//首先需要获得与该方法对应的Method对象</span><br><span class="line">Method method = class1.getDeclaredMethod(<span class="string">"setAge"</span>, int.class);</span><br><span class="line">//调用指定的函数并传递参数</span><br><span class="line">method.invoke(obj, 28);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。<br>setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。</strong></p>
<p> 三、访问成员变量值</p>
<ol>
<li><p>通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。</p>
</li>
<li><p>Field提供了两组方法来读取或设置成员变量的值：<br>getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。<br>setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//生成新的对象：用newInstance()方法 </span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line">//获取age成员变量</span><br><span class="line">Field field = class1.getField(<span class="string">"age"</span>);</span><br><span class="line">//将obj对象的age的值设置为10</span><br><span class="line">field.setInt(obj, 10);</span><br><span class="line">//获取obj对象的age的值</span><br><span class="line">field.getInt(obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p> 定义：<strong>给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</strong></p>
<ol>
<li><p>代理模式的理解<br>代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。<br>在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</p>
</li>
<li><p>代理模式的参与者<br>代理模式的角色分四种：<br><img src="https://camo.githubusercontent.com/1dab04df36af09afb1d73542f9ba66dccc444e8c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d663464333339613639613862396539322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Proxy"><br><strong>主题接口：</strong>Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。<br><strong>目标对象：</strong>ReaSubject 是原对象，也就是被代理的对象。<br><strong>代理对象：</strong>Proxy 是代理对象，用来封装真是主题类的代理类。<br><strong>客户端 ：</strong>使用代理类和主题接口完成一些工作。</p>
</li>
<li><p>代理模式的分类<br>代理的实现分为：</p>
<p><strong>静态代理：</strong>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。<br><strong>动态代理：</strong>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p>
</li>
<li><p>代理模式的实现思路<br>a).代理对象和目标对象均实现同一个行为接口。<br>b).代理类和目标类分别具体实现接口逻辑。<br>c).在代理类的构造函数中实例化一个目标对象。<br>d).在代理类中调用目标对象的行为接口。<br>e).客户端想要调用目标对象的行为接口，只能通过代理类来操作。</p>
</li>
<li><p>静态代理模式的简单实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyDemo &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        RealSubject subject = new RealSubject();</span><br><span class="line">        Proxy p = new Proxy(subject);</span><br><span class="line">        p.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Subject&#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealSubject implements Subject&#123;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements Subject&#123;</span><br><span class="line">    private Subject subject;</span><br><span class="line">    public Proxy(Subject subject)&#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"PreProcess"</span>);</span><br><span class="line">        subject.request();</span><br><span class="line">        System.out.println(<span class="string">"PostProcess"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。</p>
<p><strong>代理模式的好处：</strong><br>假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。</p>
<p>这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。</p>
<p>静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。</p>
</li>
</ol>
<h3 id="Java反射机制与动态代理"><a href="#Java反射机制与动态代理" class="headerlink" title="Java反射机制与动态代理"></a>Java反射机制与动态代理</h3><p> 动态代理的思路和上述思路一致，下面主要讲解如何实现。</p>
<ol>
<li><p>动态代理介绍<br>动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。</p>
<p>①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护；<br>②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。</p>
</li>
<li><p>动态代理涉及的主要类<br>主要涉及两个类，这两个类都是java.lang.reflect包下的类，内部主要通过反射来实现的。</p>
<p><strong>java.lang.reflect.Proxy:</strong>这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br>Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。</p>
<p><strong>java.lang.reflect.InvocationHandler:</strong>这里称他为”调用处理器”，它是一个接口。只有一个invoke方法。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。<br>InvocationHandler.java代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.reflect;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class="line"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class="line"> * When a method is invoked on a proxy instance, the method</span><br><span class="line"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class="line"> * method of its invocation handler.</span><br><span class="line"> *</span><br><span class="line"> * @author      Peter Jones</span><br><span class="line"> * @see         Proxy</span><br><span class="line"> * @since       1.3</span><br><span class="line"> */</span><br><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Processes a method invocation on a proxy instance and returns</span><br><span class="line">     * the result.  This method will be invoked on an invocation handler</span><br><span class="line">     * when a method is invoked on a proxy instance that it is</span><br><span class="line">     * associated with.</span><br><span class="line">     *</span><br><span class="line">     * @param   proxy the proxy instance that the method was invoked on</span><br><span class="line">     *</span><br><span class="line">     * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class="line">     * the interface method invoked on the proxy instance.  The declaring</span><br><span class="line">     * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class="line">     * the method was declared <span class="keyword">in</span>, <span class="built_in">which</span> may be a superinterface of the</span><br><span class="line">     * proxy interface that the proxy class inherits the method through.</span><br><span class="line">     *</span><br><span class="line">     * @param   args an array of objects containing the values of the</span><br><span class="line">     * arguments passed <span class="keyword">in</span> the method invocation on the proxy instance,</span><br><span class="line">     * or &#123;@code null&#125; <span class="keyword">if</span> interface method takes no arguments.</span><br><span class="line">     * Arguments of primitive types are wrapped <span class="keyword">in</span> instances of the</span><br><span class="line">     * appropriate primitive wrapper class, such as</span><br><span class="line">     * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @<span class="built_in">return</span>  the value to <span class="built_in">return</span> from the method invocation on the</span><br><span class="line">     * proxy instance.  If the declared <span class="built_in">return</span> <span class="built_in">type</span> of the interface</span><br><span class="line">     * method is a primitive <span class="built_in">type</span>, <span class="keyword">then</span> the value returned by</span><br><span class="line">     * this method must be an instance of the corresponding primitive</span><br><span class="line">     * wrapper class; otherwise, it must be a <span class="built_in">type</span> assignable to the</span><br><span class="line">     * declared <span class="built_in">return</span> <span class="built_in">type</span>.  If the value returned by this method is</span><br><span class="line">     * &#123;@code null&#125; and the interface method<span class="string">'s return type is</span></span><br><span class="line"><span class="string">     * primitive, then a &#123;@code NullPointerException&#125; will be</span></span><br><span class="line"><span class="string">     * thrown by the method invocation on the proxy instance.  If the</span></span><br><span class="line"><span class="string">     * value returned by this method is otherwise not compatible with</span></span><br><span class="line"><span class="string">     * the interface method'</span>s declared <span class="built_in">return</span> <span class="built_in">type</span> as described above,</span><br><span class="line">     * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class="line">     * invocation on the proxy instance.</span><br><span class="line">     *</span><br><span class="line">     * @throws  Throwable the exception to throw from the method</span><br><span class="line">     * invocation on the proxy instance.  The exception<span class="string">'s type must be</span></span><br><span class="line"><span class="string">     * assignable either to any of the exception types declared in the</span></span><br><span class="line"><span class="string">     * &#123;@code throws&#125; clause of the interface method or to the</span></span><br><span class="line"><span class="string">     * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span></span><br><span class="line"><span class="string">     * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span></span><br><span class="line"><span class="string">     * thrown by this method that is not assignable to any of the</span></span><br><span class="line"><span class="string">     * exception types declared in the &#123;@code throws&#125; clause of</span></span><br><span class="line"><span class="string">     * the interface method, then an</span></span><br><span class="line"><span class="string">     * &#123;@link UndeclaredThrowableException&#125; containing the</span></span><br><span class="line"><span class="string">     * exception that was thrown by this method will be thrown by the</span></span><br><span class="line"><span class="string">     * method invocation on the proxy instance.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @see     UndeclaredThrowableException</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    public Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="string">        throws Throwable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Proxy提供了如下两个方法来创建动态代理类和动态代理实例。</p>
<blockquote>
<p>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。</p>
</blockquote>
<p> 对应上述两种方法创建动态代理对象的方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建一个InvocationHandler对象</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(.args..);</span><br><span class="line">//使用Proxy生成一个动态代理类</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler);</span><br><span class="line">//获取proxyClass类中一个带InvocationHandler参数的构造器</span><br><span class="line">Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line">//调用constructor的newInstance方法来创建动态实例</span><br><span class="line">RealSubject real = (RealSubject)constructor.newInstance(handler);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建一个InvocationHandler对象</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(.args..);</span><br><span class="line">//使用Proxy直接生成一个动态代理对象</span><br><span class="line">RealSubject real =Proxy.newProxyInstance(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler);</span><br></pre></td></tr></table></figure>
<p> <strong>newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字 节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。</strong></p>
<p> Proxy 类还有一些静态方法，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。</span><br><span class="line"></span><br><span class="line">Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。</span><br></pre></td></tr></table></figure></p>
<p>InvocationHandler 接口中有方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure></p>
<p> 这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p>
<ol start="3">
<li><p>动态代理模式的简单实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建目标对象</span><br><span class="line">        RealSubject realSubject = new RealSubject();    </span><br><span class="line">        //2.创建调用处理器对象</span><br><span class="line">        ProxyHandler handler = new ProxyHandler(realSubject);    </span><br><span class="line">       //3.动态生成代理对象</span><br><span class="line">        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(),</span><br><span class="line">                                                        RealSubject.class.getInterfaces(), handler);   </span><br><span class="line">        //4.通过代理对象调用方法   </span><br><span class="line">        proxySubject.request();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主题接口</span><br><span class="line"> */</span><br><span class="line">interface Subject&#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 目标对象类</span><br><span class="line"> */</span><br><span class="line">class RealSubject implements Subject&#123;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"====RealSubject Request===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 代理类的调用处理器</span><br><span class="line"> */</span><br><span class="line">class ProxyHandler implements InvocationHandler&#123;</span><br><span class="line">    private Subject subject;</span><br><span class="line">    public ProxyHandler(Subject subject)&#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</span><br><span class="line">        System.out.println(<span class="string">"====before===="</span>);</span><br><span class="line">       //调用RealSubject中的方法</span><br><span class="line">        Object result = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">"====after===="</span>);</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。</p>
</li>
</ol>
<h3 id="泛型和Class类"><a href="#泛型和Class类" class="headerlink" title="泛型和Class类"></a>泛型和Class类</h3><p> 从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class<string>。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。</string></p>
<p> 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectFactory &#123;</span><br><span class="line">    public static Object getInstance(String name)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建指定类对应的Class对象</span><br><span class="line">            Class cls = Class.forName(name);</span><br><span class="line">            //返回使用该Class对象创建的实例</span><br><span class="line">            <span class="built_in">return</span> cls.newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。<br> 如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = (Date) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure></p>
<p> 又或者如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String string = (String) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure></p>
<p> 上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。<br> 但是泛型的出现后，就可以避免这种情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectFactory &#123;</span><br><span class="line">    public static &lt;T&gt; T getInstance(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 返回使用该Class对象创建的实例</span><br><span class="line">            <span class="built_in">return</span> cls.newInstance();</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 在上面程序的getInstance()方法中传入一个Class<t>参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String instance = ObjectFactory.getInstance(String.class);</span><br></pre></td></tr></table></figure></t></p>
<p> 通过传入String.class便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。<br> 当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。</p>
<h3 id="使用反射来获取泛型信息"><a href="#使用反射来获取泛型信息" class="headerlink" title="使用反射来获取泛型信息"></a>使用反射来获取泛型信息</h3><p> 通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Field 对象 f 的类型</span><br><span class="line">Class&lt;?&gt; a = f.getType();</span><br></pre></td></tr></table></figure></p>
<p> 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。<br> 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获得 Field 实例的泛型类型</span><br><span class="line">Type <span class="built_in">type</span> = f.getGenericType();</span><br></pre></td></tr></table></figure></p>
<p> 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。<br> <strong>getRawType()：</strong>返回没有泛型信息的原始类型。<br> <strong>getActualTypeArguments()：</strong>返回泛型参数的类型。<br> 下面是一个获取泛型类型的完整程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest</span><br><span class="line">&#123;</span><br><span class="line">    private Map&lt;String , Integer&gt; score;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">        throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;GenericTest&gt; clazz = GenericTest.class;</span><br><span class="line">        Field f = clazz.getDeclaredField(<span class="string">"score"</span>);</span><br><span class="line">        // 直接使用getType()取出Field类型只对普通类型的Field有效</span><br><span class="line">        Class&lt;?&gt; a = f.getType();</span><br><span class="line">        // 下面将看到仅输出java.util.Map</span><br><span class="line">        System.out.println(<span class="string">"score的类型是:"</span> + a);</span><br><span class="line">        // 获得Field实例f的泛型类型</span><br><span class="line">        Type gType = f.getGenericType();</span><br><span class="line">        // 如果gType类型是ParameterizedType对象</span><br><span class="line">        <span class="keyword">if</span>(gType instanceof ParameterizedType)</span><br><span class="line">        &#123;</span><br><span class="line">            // 强制类型转换</span><br><span class="line">            ParameterizedType pType = (ParameterizedType)gType;</span><br><span class="line">            // 获取原始类型</span><br><span class="line">            Type rType = pType.getRawType();</span><br><span class="line">            System.out.println(<span class="string">"原始类型是："</span> + rType);</span><br><span class="line">            // 取得泛型类型的泛型参数</span><br><span class="line">            Type[] tArgs = pType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"泛型类型是:"</span>);</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; tArgs.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"个泛型类型是："</span> + tArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"获取泛型类型出错！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 输出结果：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score 的类型是: interface java.util.Map</span><br><span class="line">原始类型是: interface java.util.Map</span><br><span class="line">泛型类型是:</span><br><span class="line">第 0 个泛型类型是: class java.lang.String</span><br><span class="line">第 1 个泛型类型是：class java.lang.Integer</span><br></pre></td></tr></table></figure></p>
<p> 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。</p>
<p> Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。</p>
<h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><h3 id="字符和字节"><a href="#字符和字节" class="headerlink" title="字符和字节"></a>字符和字节</h3><p> 在Java中有输入、输出两种I/O流，每种输入、输出流又分为字节流和字符流。关于字节，我们在学习8大基本数据类型中都有了解，每个字节(byte)有8bit组成，每种数据类型又有几个字节组成等，关于字符，我们知道代表一个汉字或者英文字母。</p>
<p> <strong>但是字节和字符之间的关系是怎么样的呢？</strong></p>
<p> Java采用Unicode编码，2个字节来表示一个字符，这点与C语言不同，C语言采用ASCII码，在大多数系统中，一个字符通常占一个字节，但是在0~127整数之间的字符映射，Unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节。但如果采用其他编码方式，一个字符占用的字节数则各不相同。可能有点晕，举个例子解释下。</p>
<p> 例如：Java中的String类是按照unicode进行编码的，当使用String(byte[] bytes, String encoding)构造字符串时，encoding所指的是bytes中的数据是按照那种方式编码的，而不是最后产生的String是什么编码方式，换句话说，是让系统把bytes中的数据由encoding编码方式转换成unicode编码。如果不指明，bytes的编码方式将由jdk根据操作系统决定。</p>
<p> getBytes(String charsetName)使用指定的编码方式将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。如果不指定将使用操作系统默认的编码方式，我的电脑默认的是GBK编码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Hel &#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        String str = <span class="string">"你好hello"</span>;  </span><br><span class="line">            int byte_len = str.getBytes().length;  </span><br><span class="line">            int len = str.length();  </span><br><span class="line">            System.out.println(<span class="string">"字节长度为："</span> + byte_len);  </span><br><span class="line">        System.out.println(<span class="string">"字符长度为："</span> + len);  </span><br><span class="line">        System.out.println(<span class="string">"系统默认编码方式："</span> + System.getProperty(<span class="string">"file.encoding"</span>));  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字节长度为：9</span><br><span class="line">字符长度为：7</span><br><span class="line">系统默认编码方式：GBK</span><br></pre></td></tr></table></figure></p>
<p> 这是因为：在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p>
<p> <strong>简单来讲，一个字符表示一个汉字或英文字母，具体字符与字节之间的大小比例视编码情况而定。有时候读取的数据是乱码，就是因为编码方式不一致，需要进行转换，然后再按照unicode进行编码。</strong></p>
<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p> File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件或者目录，都可以通过File类来完成。</p>
<ol>
<li><p>构造函数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//构造函数File(String pathname)</span><br><span class="line">File f1 =new File(<span class="string">"c:\\abc\\1.txt"</span>);</span><br><span class="line">//File(String parent,String child)</span><br><span class="line">File f2 =new File(<span class="string">"c:\\abc"</span>,<span class="string">"2.txt"</span>);</span><br><span class="line">//File(File parent,String child)</span><br><span class="line">File f3 =new File(<span class="string">"c:"</span>+File.separator+<span class="string">"abc"</span>);//separator 跨平台分隔符</span><br><span class="line">File f4 =new File(f3,<span class="string">"3.txt"</span>);</span><br><span class="line">System.out.println(f1);//c:\abc\1.txt</span><br></pre></td></tr></table></figure>
<p><strong>路径分隔符：</strong><br>windows： “/“ “” 都可以<br>linux/unix： “/“<br>注意:如果windows选择用””做分割符的话,那么请记得替换成”\”,因为Java中””代表转义字符<br>所以推荐都使用”/“，也可以直接使用代码File.separator，表示跨平台分隔符。<br><strong>路径：</strong><br>相对路径：<br>./表示当前路径<br>../表示上一级路径<br>其中当前路径：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。”</p>
<p>绝对路径：<br>绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件</p>
</li>
<li><p>创建与删除方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如果文件存在返回<span class="literal">false</span>，否则返回<span class="literal">true</span>并且创建文件 </span><br><span class="line">boolean createNewFile();</span><br><span class="line">//创建一个File对象所对应的目录，成功返回<span class="literal">true</span>，否则<span class="literal">false</span>。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。</span><br><span class="line">boolean mkdir();</span><br><span class="line">//创建一个File对象所对应的目录，成功返回<span class="literal">true</span>，否则<span class="literal">false</span>。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录</span><br><span class="line">boolean mkdirs()    ;</span><br><span class="line">//如果文件存在返回<span class="literal">true</span>并且删除文件，否则返回<span class="literal">false</span></span><br><span class="line">boolean delete();</span><br><span class="line">//在虚拟机终止时，删除File对象所表示的文件或目录。</span><br><span class="line">void deleteOnExit();</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean canExecute()    ;//判断文件是否可执行</span><br><span class="line">boolean canRead();//判断文件是否可读</span><br><span class="line">boolean canWrite();//判断文件是否可写</span><br><span class="line">boolean exists();//判断文件是否存在</span><br><span class="line">boolean isDirectory();//判断是否是目录</span><br><span class="line">boolean isFile();//判断是否是文件</span><br><span class="line">boolean isHidden();//判断是否是隐藏文件或隐藏目录</span><br><span class="line">boolean isAbsolute();//判断是否是绝对路径 文件不存在也能判断</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String getName();//返回文件或者是目录的名称</span><br><span class="line">String getPath();//返回路径</span><br><span class="line">String getAbsolutePath();//返回绝对路径</span><br><span class="line">String getParent();//返回父目录，如果没有父目录则返回null</span><br><span class="line">long lastModified();//返回最后一次修改的时间</span><br><span class="line">long length();//返回文件的长度</span><br><span class="line">File[] listRoots();// 列出所有的根目录（Window中就是所有系统的盘符）</span><br><span class="line">String[] list() ;//返回一个字符串数组，给定路径下的文件或目录名称字符串</span><br><span class="line">String[] list(FilenameFilter filter);//返回满足过滤器要求的一个字符串数组</span><br><span class="line">File[]  listFiles();//返回一个文件对象数组，给定路径下文件或目录</span><br><span class="line">File[] listFiles(FilenameFilter filter);//返回满足过滤器要求的一个文件对象数组</span><br></pre></td></tr></table></figure>
<p>其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 文件过滤</span><br><span class="line">    File[] files = file.listFiles(new <span class="function"><span class="title">FilenameFilter</span></span>() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean accept(File file, String filename) &#123;</span><br><span class="line">            <span class="built_in">return</span> filename.endsWith(<span class="string">".mp3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p> file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。</p>
<h3 id="IO流的概念"><a href="#IO流的概念" class="headerlink" title="IO流的概念"></a>IO流的概念</h3><p> Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源抽象表述为”流”。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。<br> <strong>流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。</strong></p>
<p> IO流的分类:</p>
<ol>
<li><p>输入流和输出流<br>根据数据流向不同分为：输入流和输出流。</p>
<blockquote>
<p>输入流:只能从中读取数据，而不能向其写入数据。<br>输出流：只能向其写入数据，而不能从中读取数据。</p>
</blockquote>
</li>
<li><p>字节流和字符流<br>字节流和字符流和用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同。<br>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：<br>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。<br>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p>
<p>只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
</li>
<li><p>节点流和处理流<br>按照流的角色来分，可以分为节点流和处理流。<br>可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被成为低级流。<br>处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，处理流也被称为高级流。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//节点流，直接传入的参数是IO设备</span><br><span class="line">FileInputStream fis = new FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">//处理流，直接传入的参数是流对象</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fis);</span><br></pre></td></tr></table></figure>
<p>当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。<br>实际上，Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。</p>
</li>
</ol>
<h3 id="IO流的四大基类"><a href="#IO流的四大基类" class="headerlink" title="IO流的四大基类"></a>IO流的四大基类</h3><p> 根据流的流向以及操作的数据单元不同，将流分为了四种类型，每种类型对应一种抽象基类。这四种抽象基类分别为：InputStream,Reader,OutputStream以及Writer。四种基类下，对应不同的实现类，具有不同的特性。在这些实现类中，又可以分为节点流和处理流。下面就是整个由着四大基类支撑下，整个IO流的框架图。<br> <img src="https://camo.githubusercontent.com/fdb7d34b4c62c0dde7adca91c766e224ee3e11f3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333863336561343536326436646265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="IO流"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">I/O流</span><br><span class="line">└── 字符流</span><br><span class="line">|       └── Reader</span><br><span class="line">|       |      └── BufferReader</span><br><span class="line">|       |      └── InputStreamReader - FileReader</span><br><span class="line">|       |      └── StringReader</span><br><span class="line">|       |      └── PipedReader</span><br><span class="line">|       |      └── ByteArrayReader</span><br><span class="line">|       |      └── FilterReader - PushBackReader</span><br><span class="line">|       └── Writer</span><br><span class="line">|              └── BufferWriter</span><br><span class="line">|              └── OutputStreamWriter - FileWriter</span><br><span class="line">|              └── StringWriter</span><br><span class="line">|              └── PipedWriter</span><br><span class="line">|              └── CharWriter</span><br><span class="line">|              └── FilterWriter</span><br><span class="line">└── 字节流</span><br><span class="line">        └── InputStream </span><br><span class="line">        |      └── FileInputStream</span><br><span class="line">        |      └── FilterInputStream</span><br><span class="line">        |      |          └── BufferInputStream</span><br><span class="line">        |      |          └── DataInputStream</span><br><span class="line">        |      |          └── PushBackInputStream</span><br><span class="line">        |      └── ObjectInputStream</span><br><span class="line">        |      └── PipedInputStream</span><br><span class="line">        |      └── SequenceInputStream</span><br><span class="line">        |      └── StringBufferInputStream</span><br><span class="line">        |      └── ByteArrayInputStream</span><br><span class="line">        └── OutputStream</span><br><span class="line">               └── FileOutputStream</span><br><span class="line">               └── FilterOutputStream</span><br><span class="line">               |          └── BufferOutputStream</span><br><span class="line">               |          └── DataOutputStream</span><br><span class="line">               |          └── PrintOutputStream</span><br><span class="line">               └── ObjectOutputStream</span><br><span class="line">               └── PipedOutputStream</span><br><span class="line">               └── ByteArrayOutputStream</span><br></pre></td></tr></table></figure></p>
<p> InputStream,Reader,OutputStream以及Writer，这四大抽象基类，本身并不能创建实例来执行输入/输出，但它们将成为所有输入/输出流的模版，所以它们的方法是所有输入/输出流都可以使用的方法。类似于集合中的Collection接口。</p>
<ol>
<li><p>InputStream<br>InputStream 是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class="line">int <span class="built_in">read</span>() ； </span><br><span class="line">//读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(byte[] buffer) ； </span><br><span class="line">//读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(byte[] buffer, int off, int len) ；</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reader<br>Reader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class="line">int <span class="built_in">read</span>() ； </span><br><span class="line">//读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(char[] cbuf) ； </span><br><span class="line">//读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(char[] cbuf, int off, int len)</span><br></pre></td></tr></table></figure>
<p>对比InputStream和Reader所提供的方法，就不难发现两个基类的功能基本一样的，只不过读取的数据单元不同。</p>
<p><strong>在执行完流操作后，要调用close()方法来关系输入流，因为程序里打开的IO资源不属于内存资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</strong></p>
<p>除此之外，InputStream和Reader还支持如下方法来移动流中的指针位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在此输入流中标记当前的位置</span><br><span class="line">//readlimit - 在标记位置失效前可以读取字节的最大限制。</span><br><span class="line">void mark(int readlimit)</span><br><span class="line">// 测试此输入流是否支持 mark 方法</span><br><span class="line">boolean markSupported()</span><br><span class="line">// 跳过和丢弃此输入流中数据的 n 个字节/字符</span><br><span class="line">long skip(long n)</span><br><span class="line">//将此流重新定位到最后一次对此输入流调用 mark 方法时的位置</span><br><span class="line">void reset()</span><br></pre></td></tr></table></figure>
</li>
<li><p>OutputStream<br>OutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向输出流中写入一个字节数据,该字节数据为参数b的低8位。 </span><br><span class="line">void write(int b) ; </span><br><span class="line">//将一个字节类型的数组中的数据写入输出流。 </span><br><span class="line">void write(byte[] b); </span><br><span class="line">//将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 </span><br><span class="line">void write(byte[] b, int off, int len); </span><br><span class="line">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class="line">void flush();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Writer<br>Writer 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//向输出流中写入一个字符数据,该字节数据为参数b的低16位。 </span><br><span class="line">void write(int c); </span><br><span class="line">//将一个字符类型的数组中的数据写入输出流， </span><br><span class="line">void write(char[] cbuf) </span><br><span class="line">//将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 </span><br><span class="line">void write(char[] cbuf, int offset, int length); </span><br><span class="line">//将一个字符串中的字符写入到输出流。 </span><br><span class="line">void write(String string); </span><br><span class="line">//将一个字符串从offset开始的length个字符写入到输出流。 </span><br><span class="line">void write(String string, int offset, int length); </span><br><span class="line">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class="line">void flush();</span><br></pre></td></tr></table></figure>
<p>可以看出，Writer比OutputStream多出两个方法，主要是支持写入字符和字符串类型的数据。</p>
<p><strong>使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，还能将输出流缓冲区的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法）</strong></p>
<p>以上内容就是整个IO流的框架介绍。</p>
</li>
</ol>
<h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><h3 id="RandomAccessFile概述"><a href="#RandomAccessFile概述" class="headerlink" title="RandomAccessFile概述"></a>RandomAccessFile概述</h3><p> RandomAccessFile既可以读取文件内容，也可以向文件输出数据。同时，RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。</p>
<p> 由于RandomAccessFile可以自由访问文件的任意位置，<strong>所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。</strong></p>
<p> 与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定义文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。<strong>如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。</strong></p>
<p> RandomAccessFile的方法虽然多，但它有一个最大的局限，<strong>就是只能读写文件，不能读写其他IO节点。</strong></p>
<p> RandomAccessFile的一个<strong>重要使用场景就是网络请求中的多线程下载及断点续传。</strong></p>
<h3 id="RandomAccessFile中的方法"><a href="#RandomAccessFile中的方法" class="headerlink" title="RandomAccessFile中的方法"></a>RandomAccessFile中的方法</h3><ol>
<li><p>RandomAccessFile的构造函数<br>RandomAccessFile类有两个构造函数，其实这两个构造函数基本相同，只不过是指定文件的形式不同——一个需要使用String参数来指定文件名，一个使用File参数来指定文件本身。除此之外，创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，一共有4种模式。</p>
<blockquote>
<p>“r”: 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。<br>“rw”: 打开以便读取和写入。<br>“rws”: 打开以便读取和写入。相对于 “rw”，”rws” 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。<br>“rwd” : 打开以便读取和写入，相对于 “rw”，”rwd” 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。</p>
</blockquote>
</li>
<li><p>RandomAccessFile的重要方法</p>
<p>RandomAccessFile既可以读文件，也可以写文件，所以类似于InputStream的read()方法，以及类似于OutputStream的write()方法，RandomAccessFile都具备。除此之外，RandomAccessFile具备两个特有的方法，来支持其随机访问的特性。</p>
<p>RandomAccessFile对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件指针记录位于文件头（也就是0处），当读/写了n个字节后，文件记录指针将会后移n个字节。除此之外，RandomAccessFile还可以自由移动该记录指针。下面就是RandomAccessFile具有的两个特殊方法，来操作记录指针，实现随机访问：</p>
<blockquote>
<p>long getFilePointer( )：返回文件记录指针的当前位置<br>void seek(long pos )：将文件指针定位到pos位置</p>
</blockquote>
</li>
</ol>
<h3 id="RandomAccessFile的使用"><a href="#RandomAccessFile的使用" class="headerlink" title="RandomAccessFile的使用"></a>RandomAccessFile的使用</h3><p> 利用RandomAccessFile实现文件的多线程下载，即多线程下载一个文件时，将文件分成几块，每块用不同的线程进行下载。下面是一个利用多线程在写文件时的例子，其中预先分配文件所需要的空间，然后在所分配的空间中进行分块，然后写入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 测试利用多线程进行文件的写操作 </span><br><span class="line"> */  </span><br><span class="line">public class Test &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        // 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件  </span><br><span class="line">        RandomAccessFile raf = new RandomAccessFile(<span class="string">"D://abc.txt"</span>, <span class="string">"rw"</span>);  </span><br><span class="line">        raf.setLength(1024*1024); // 预分配 1M 的文件空间  </span><br><span class="line">        raf.close();  </span><br><span class="line"></span><br><span class="line">        // 所要写入的文件内容  </span><br><span class="line">        String s1 = <span class="string">"第一个字符串"</span>;  </span><br><span class="line">        String s2 = <span class="string">"第二个字符串"</span>;  </span><br><span class="line">        String s3 = <span class="string">"第三个字符串"</span>;  </span><br><span class="line">        String s4 = <span class="string">"第四个字符串"</span>;  </span><br><span class="line">        String s5 = <span class="string">"第五个字符串"</span>;  </span><br><span class="line"></span><br><span class="line">        // 利用多线程同时写入一个文件  </span><br><span class="line">        new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 利用线程在文件的指定位置写入指定数据  </span><br><span class="line">    static class FileWriteThread extends Thread&#123;  </span><br><span class="line">        private int skip;  </span><br><span class="line">        private byte[] content;  </span><br><span class="line"></span><br><span class="line">        public FileWriteThread(int skip,byte[] content)&#123;  </span><br><span class="line">            this.skip = skip;  </span><br><span class="line">            this.content = content;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>()&#123;  </span><br><span class="line">            RandomAccessFile raf = null;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                raf = new RandomAccessFile(<span class="string">"D://abc.txt"</span>, <span class="string">"rw"</span>);  </span><br><span class="line">                raf.seek(skip);  </span><br><span class="line">                raf.write(content);  </span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; catch (IOException e) &#123;  </span><br><span class="line">                // TODO Auto-generated catch block  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    raf.close();  </span><br><span class="line">                &#125; catch (Exception e) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>当RandomAccessFile向指定文件中插入内容时，将会覆盖掉原有内容。如果不想覆盖掉，则需要将原有内容先读取出来，然后先把插入内容插入后再把原有内容追加到插入内容后。</strong></p>
<h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="NIO-概述"><a href="#NIO-概述" class="headerlink" title="NIO 概述"></a>NIO 概述</h3><p> Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<p> 所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</p>
<p> <strong>由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO（非阻塞IO）。</strong></p>
<p> Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Buffer</li>
<li>Channel</li>
<li>Selector<br>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</li>
</ul>
<h3 id="Buffer的使用"><a href="#Buffer的使用" class="headerlink" title="Buffer的使用"></a>Buffer的使用</h3><p> 利用Buffer读写数据，通常遵循四个步骤：</p>
<ul>
<li>把数据写入buffer；</li>
<li>调用flip；</li>
<li>从Buffer中读取数据；</li>
<li>调用buffer.clear()</li>
</ul>
<p>未完待续</p>
<h2 id="Java-异常详解"><a href="#Java-异常详解" class="headerlink" title="Java 异常详解"></a>Java 异常详解</h2><h3 id="Java异常概述"><a href="#Java异常概述" class="headerlink" title="Java异常概述"></a>Java异常概述</h3><p> Java异常是Java提供的一种识别及响应错误的一致性机制。</p>
<p> Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。</p>
<p> Java异常机制用到的几个关键字：try、catch、finally、throw、throws。</p>
<p>  • try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p>
<p>  • catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p>
<p>  • finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p>
<p>  • throw – 用于抛出异常。</p>
<p>  • throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p>
<p> 下面通过几个示例对这几个关键字进行简单了解。<br> 示例一: 了解try和catch基本用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </span><br><span class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </span><br><span class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </span><br><span class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caught Exception</span><br><span class="line">e.getMessage(): / by zero</span><br><span class="line">e.toString(): java.lang.ArithmeticException: / by zero</span><br><span class="line">e.printStackTrace():</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Demo1.main(Demo1.java:6)</span><br></pre></td></tr></table></figure></p>
<p> 结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。</p>
<p> 观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。</p>
<p> 示例二: 了解finally的基本用法,在”示例一”的基础上，我们添加finally语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </span><br><span class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </span><br><span class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </span><br><span class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">"run finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Caught Exception</span><br><span class="line">e.getMessage(): / by zero</span><br><span class="line">e.toString(): java.lang.ArithmeticException: / by zero</span><br><span class="line">e.printStackTrace():</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Demo2.main(Demo2.java:6)</span><br><span class="line">run finally</span><br><span class="line">``` </span><br><span class="line"> 结果说明：最终执行了finally语句块。</span><br><span class="line"></span><br><span class="line"> 示例三: 了解throws和throw的基本用法</span><br><span class="line"> **throws**是**用于声明抛出的异常**，而**throw**是**用于抛出异常**。</span><br><span class="line">``` bash</span><br><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public <span class="function"><span class="title">MyException</span></span>() &#123;&#125;</span><br><span class="line">    public MyException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">test</span>();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Catch My Exception"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void <span class="built_in">test</span>() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            throw new MyException(<span class="string">"This is MyException"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Catch My Exception</span><br><span class="line">MyException: This is MyException</span><br><span class="line">    at Demo3.test(Demo3.java:24)</span><br><span class="line">    at Demo3.main(Demo3.java:13)</span><br></pre></td></tr></table></figure></p>
<p> 运行结果说明：MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。</p>
<h3 id="Java异常框架"><a href="#Java异常框架" class="headerlink" title="Java异常框架"></a>Java异常框架</h3><p>未完待续</p>
<h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p> 未完待续</p>
<h2 id="Java深拷贝和浅拷贝"><a href="#Java深拷贝和浅拷贝" class="headerlink" title="Java深拷贝和浅拷贝"></a>Java深拷贝和浅拷贝</h2><p>未完待续</p>
<h2 id="Java中transient关键字"><a href="#Java中transient关键字" class="headerlink" title="Java中transient关键字"></a>Java中transient关键字</h2><p>未完待续</p>
<h2 id="Java中finally和return的执行顺序"><a href="#Java中finally和return的执行顺序" class="headerlink" title="Java中finally和return的执行顺序"></a>Java中finally和return的执行顺序</h2><p>未完代码</p>
<h2 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h2><h2 id="Java-8-源码"><a href="#Java-8-源码" class="headerlink" title="Java 8 源码"></a>Java 8 源码</h2><p><a href="https://github.com/EricChows/JDK-1.8-sourcecode" target="_blank" rel="noopener">JDk 1.8 Source Code</a></p>
<h1 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h1><p> 本部分内容是关于Java并发的一些知识总结，既是学习的难点，同时也是面试中几乎必问的知识点。</p>
<p> 面试中可能会问的一些问题：<br> • 创建线程的方式<br> • Synchronized/ReentrantLock<br> • 生产者/消费者模式<br> • volatile关键字<br> • 乐观锁/悲观锁<br> • 死锁<br> • 了解的并发集合</p>
<h2 id="Java创建线程的三种方式"><a href="#Java创建线程的三种方式" class="headerlink" title="Java创建线程的三种方式"></a>Java创建线程的三种方式</h2><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="Synchronize-Reentrantlock"><a href="#Synchronize-Reentrantlock" class="headerlink" title="Synchronize/Reentrantlock"></a>Synchronize/Reentrantlock</h2><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><hr>
<h1 id="Android基础-1"><a href="#Android基础-1" class="headerlink" title="Android基础"></a>Android基础</h1><p> 主要复习Android的一些个基础知识点</p>
<ul>
<li>四大组件</li>
<li>事件分发机制</li>
<li>消息机制</li>
<li>binder机制</li>
<li>线程和进程</li>
</ul>
<h2 id="Activity全方位解析"><a href="#Activity全方位解析" class="headerlink" title="Activity全方位解析"></a>Activity全方位解析</h2><p> 先从Activity的功能上复习</p>
<p> MyQuestion:</p>
<ol>
<li>能否从Framework的层面来分析一下，Activity这样设计的原理和机制是什么？</li>
</ol>
<ol start="2">
<li>如何从Framework代码中看出Activity的设计逻辑</li>
</ol>
<h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><ol>
<li><p>Activity生命周期<br>典型的生命周期<br>onCreate -&gt; onRestart -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory<br>onCreate:加载布局资源，初始化Activity所需要的数据，<br>onRestart:从不可见变为可见<br>onStart:表示Activity正在被启动，此时Activity已经出现，但是还没有出现在前台，无法与用户交互，这个时候可以理解为Activity已经显示出来，但是我们看不到。<br>onResume:表示Activity已经可见，且出现在前台<br>onPause:表示Activity正在停止，但是仍可见，正常情况下，紧接着onStop就会被调用。特殊情况下，如果这个时候快速的返回当前Activity，那么onResume就会被调用(极端情况)<br>onStop:表示Activity即将停止，不可见，位于后台，可以做稍微重量级的回收工作，同样不能太耗时。<br>onDestory:表示Activity即将被销毁，这是Activity的最后一个回调，可以做一些回收工作和最终的资源回收。、</p>
</li>
<li><p>特殊情况下的生命周期<br>a) 横竖屏切换<br>横竖屏切换的过程中，会发生Activity被销毁和重建的过程。<br>onSaveInstanceState和onRestoreInstanceState</p>
<p>onSaveInstanceState在onStop之前被调用<br>onRestoreInstanceState在onStart之后调用</p>
<p>b)资源不足导致优先级低的Activity被杀死</p>
</li>
</ol>
<h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><p> 从Framework中Activity相关代码可以看到，Activity的管理是通过ActivityStack任务栈的形式来管理。<br> Activity的LaunchMode主要有四种：</p>
<ol>
<li>Standard 标准模式：每次启动Activity，都会new一个新的Activity放在栈顶</li>
<li>SingleTop 栈顶复用：栈顶存在，则直接使用，不用new</li>
<li>SingleTask 栈内复用</li>
<li><p>SingleInstance 单例模式</p>
<p>特殊情况：前台栈和后台栈交互</p>
</li>
</ol>
<h3 id="Activity的Flag"><a href="#Activity的Flag" class="headerlink" title="Activity的Flag"></a>Activity的Flag</h3><p> FLAG_ACTIVITY_NEW_TASK</p>
<p> FLAG_ACTIVITY_SINGLE_TOP</p>
<p> FLAG_ACTIVITY_CLEAR_TOP</p>
<h2 id="Service-全方位解析"><a href="#Service-全方位解析" class="headerlink" title="Service 全方位解析"></a>Service 全方位解析</h2><p> Service是ANdroid中实现程序后台运行的解决方案，它非常适用于执行那些不需要和用户交互而且还要求长期运行的任务。Servcie默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建子线程来完成耗时操作。</p>
<p> MyQuestion：</p>
<ol>
<li>在Android Framework代码中，Service的机制是什么?</li>
</ol>
<ol>
<li><p>Service种类<br>按运行类型分类：</p>
<pre><code>区别                                    应用
</code></pre><p>前台服务   会在通知栏显示onGoing的Notification     服务被终止时，通知栏Notification也会消失，如：音乐播放服务<br>后台服务   默认的服务即为后台服务，不会在通知栏显示  服务被终止时，用户看不到，如：天气更新、日期同步、邮件同步</p>
<p>按使用方式分类：<br>  类别                          区别<br>startServcie启动的服务       主要用于启动一个服务咨询后台任务，不进行通讯，停止服务，使用stopService<br>bindService启动的服务        可以进行进程通讯.停止服务，使用unbindService<br>同时使用StartServcie和bindService启动的服务    停止服务使用stopService和unbindServcie</p>
</li>
<li><p>Service生命周期<br>onCreate -&gt; onStartCommand -&gt; onDestory<br>onCreate -&gt; onBind -&gt; onUnbind -&gt; onDestory<br>onCreate:系统在Service第一次创建时执行此方法，如果service已经运行，此方法不会调用<br>onStartCommand:每次客户端调用startService方法启动该service，都会回调该方法<br>onBind:当调用bindService时，执行该方法，一次调用</p>
</li>
</ol>
<h2 id="BroadcastReceiver全方位解析"><a href="#BroadcastReceiver全方位解析" class="headerlink" title="BroadcastReceiver全方位解析"></a>BroadcastReceiver全方位解析</h2><p> BroadcastReceiver广播接收器，使用了观察者模式来实现。<br> 模型中有三个角色：<br> a)消息订阅者 –广播接收者<br> b)消息发布者 –广播发送者<br> c)消息中心(AMS,即ActivityManagerService)</p>
<p> 原理描述：<br> i) 广播接受者通过Binder机制在AMS注册<br> ii)广播发送者通过Binder机制向AMS发送广播<br> iii)AMS根据广播发送者要求，在已注册列表中，寻求合适的广播接收者</p>
<ul>
<li><p>寻找依据：IntenFilter/Permission<br>iv)AMS将广播发送到合适的广播接收者相应的消息循环队列中<br>v)广播接收者通过消息循环 拿到此广播，并回调onReceive()</p>
<p>特别注意：广播发送者和广播接收者执行的是 异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底何时才能接收到。</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/broadcastreceiver.md" target="_blank" rel="noopener">参考文章</a></p>
<p>My Question:<br>需要拿出AMS的源码来详细的分析原理</p>
</li>
</ul>
<h2 id="ContenProvider全方位解析"><a href="#ContenProvider全方位解析" class="headerlink" title="ContenProvider全方位解析"></a>ContenProvider全方位解析</h2><ol>
<li><p>作用：进程间 数据交互和共享，跨进程通讯<br>ContentProvider只是中间者角色，真正存储&amp;操作数据的数据源还是原来存储数据的方式(数据库、文件、xml、网络)</p>
</li>
<li><p>原理：ContentProvider 采用的是Android中Binder机制来实现</p>
</li>
<li><p>使用</p>
</li>
</ol>
<ul>
<li>URL 统一资源标识符</li>
<li>MIME 数据类型</li>
<li>ContentProvider类的 使用方法和数据组织方式</li>
<li><p>辅助工具类：a)ContentResolver类  b)ContentUris 类 c)UriMatcher类  d) ContentObserver类</p>
<p>3.1 统一资源标识符<br>Uniform Resource Identifier<br>作用：唯一标识ContentProvider 其中的数据<br>具体使用，分两类，系统预制和自定义</p>
<p>自定义URI = content://com.carson.provider/User/1<br>主题(Schema):URI的前缀，由Android规定<br>授权信息(Authority):唯一标识符，一般是包名<br>表名(Path):指向数据库中的某个表<br>记录(ID):表中的某个记录(若无指定，则返回全部记录)</p>
<p>3.2 MIME数据类型</p>
<p>3.3 ContentProvider 类</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/ContentProvider.md" target="_blank" rel="noopener">参考文章</a></p>
</li>
</ul>
<h2 id="Fragment-详解"><a href="#Fragment-详解" class="headerlink" title="Fragment 详解"></a>Fragment 详解</h2><ol>
<li><p>什么是Fragment<br>简单来说，就是显示在Activity中的Activity</p>
</li>
<li><p>Fragment的生命周期<br>由于Fragment是依附于Activity存在的，因此，它的生命周期受到Activity的生命周期的影响<br>onCreate(){ onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() }<br>onStart(){ onStart() }<br>onResume(){ onResume() }<br>onPause(){ onPause() }<br>onStop(){ onStop() }<br>onDestory(){ onDestoryView() -&gt; onDestory() -&gt; onDetach() }</p>
<p>PS： 注意：除了onCreateView,其他的所有方法如果重写了，必须调用父类对于该方法的实现</p>
</li>
<li><p>Fragment的使用方式<br>静态使用Fragment</p>
<p>动态使用Fragment</p>
</li>
<li><p>什么是Fragment的回退栈？<br>Fragment的回退栈是用来保存每一次Fragment事务发生的变化，如果你将Fragment任务添加到回退栈，当用户点击回退按钮时，将看到上一次保存的Fragment。一旦Fragment完全从回退栈弹出，用户再次点击后退键，则退出当前Activity</p>
<p>FragmentTransaction.addToBackStack(String)</p>
</li>
<li><p>Fragment和Activity之间的通信</p>
</li>
<li><p>Fragment与Activity通信的优化</p>
</li>
<li><p>如何处理运行时配置发生变化</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/Fragment.md" target="_blank" rel="noopener">参考文章</a></p>
</li>
</ol>
<h2 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h2><p>  Android中的消息机制，即Handler.</p>
<ol>
<li><p>消息机制的模型<br>消息机制主要包含：MessageQueue/Handler/Looper/Message四个模块，现在来一一介绍</p>
<p><strong>Message:</strong> 需要传递的消息，可以装载数据<br><strong>MessageQueue:</strong> 消息队列，它的内部实现并不是用的队列，实际是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能是向消息池投递消息<br>(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next). <a href="/home/zds/Code/Junior/frameworks/base/core/java/android/os/MessageQueue.java">MessageQueue</a><br><strong>Handler:</strong> 消息辅助类，主要功能是向信息池发送各种消息事件(Handler.sendMessage)和取走处理相应消息事件(Handler.handleMessage).<br><strong>Looper：</strong>不断循环执行(Looper.loop),从MessageQueue中读取消息，按分发机制将消息分发给目标处理.</p>
</li>
<li><p>消息机制的架构</p>
</li>
</ol>
<ol start="3">
<li><p>消息机制原理<br>frameworks/base/core/java/android/os/MessageQueue.java<br>frameworks/base/core/java/android/os/Message.java<br>frameworks/base/core/java/android/os/Message.aidl<br>frameworks/base/core/java/android/os/Looper.java<br>frameworks/base/core/java/android/os/Handler.java</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/message-mechanism.md" target="_blank" rel="noopener">参考文章</a></p>
</li>
</ol>
<h2 id="Android事件分发机制"><a href="#Android事件分发机制" class="headerlink" title="Android事件分发机制"></a>Android事件分发机制</h2><ol>
<li><p>事件在哪些对象间进行传递<br>Activity、ViewGroup、View，事件产生后，传递顺序：Activity &gt; ViewGroup &gt; View</p>
</li>
<li><p>事件分发的本质，就是Activity/ViewGroup/View三者的事件分发<br>参考资料2中有对源码进行分析</p>
<p>参考资料[1]:Myblog中的 《Android编程下Touch事件的分发和消费机制》</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/Event-Dispatch.md" target="_blank" rel="noopener">参考资料2</a> </p>
</li>
<li><p>onTouch和onTouchEvent的区别</p>
</li>
<li><p>Touch事件的后续(Move、up)事件的层级传递</p>
</li>
</ol>
<h2 id="AsyncTask详解"><a href="#AsyncTask详解" class="headerlink" title="AsyncTask详解"></a>AsyncTask详解</h2><ol>
<li><p>AsyncTask是一个抽象类，是由Android封装的一个轻量级异步类，它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程并在主线程中更新UI<br>AsyncTask的内部封装了两个线程池(SerialExecutor和THREAD_POOL_EXECUTOR)和一个Handler(InternalHandler).</p>
</li>
<li><p>AsyncTask的使用和源码分析见参考资料1</p>
</li>
<li><p>AsyncTask使用不当的后果<br>a) 生命周期<br>AsyncTask 不与任何组件绑定生命周期，所以在Activity或者Fragment中创建执行AsyncTask时，最好在Activity/Fragment的onDestory调用cancel方法</p>
<p>b)内存泄漏<br>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用.<br>如果Activity已经被销毁，AsyncTask的后台线程还在执行，将继续保留这个引用，导致Activity无法被回收，引起内存泄漏</p>
<p>c)结果丢失<br>屏幕旋转或者Activity在后台被系统杀掉等情况导致的Activity重建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这是调用onPOSTExecute()再去更新界面将不再生效.</p>
<p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/asynctask.md" target="_blank" rel="noopener">参考资料1</a></p>
</li>
</ol>
<h2 id="HandlerThread详解"><a href="#HandlerThread详解" class="headerlink" title="HandlerThread详解"></a>HandlerThread详解</h2><p>   在Android中执行耗时的操作都需要另外开启子线程来执行，执行完线程以后会自动销毁，如果项目中经常需要执行耗时操作，如果经常开启线程，接着又销毁线程，无疑会消耗性能，解决方法是：<br>   a)使用线程池<br>   b)使用HandlerThread</p>
<p>   HandlerThread的代码以及在Framework中封装好：/frameworks/base/core/java/android/os/HandlerThread.java，采用的是Handler和Looper来实现</p>
<p>   HandlerThread的使用，见参考资料1</p>
<p>   <a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/HandlerThread.md" target="_blank" rel="noopener">参考资料1</a></p>
<h2 id="IntentServcie详解"><a href="#IntentServcie详解" class="headerlink" title="IntentServcie详解"></a>IntentServcie详解</h2><p>  IntentService是Android里面的一个封装类，继承自四大组件之一的Service.<br>  作用：处理异步请求，实现多线程.</p>
<h2 id="LruCache详解"><a href="#LruCache详解" class="headerlink" title="LruCache详解"></a>LruCache详解</h2><p>  Android中缓存策略，一般来说，缓存策略主要包含缓存的添加、获取和删除者三类操作.<br>  不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的，当缓存满了之后，再向其添加缓存，这时就需要删除一些旧的缓存并添加新的缓存.</p>
<p>  LRU(Least Recently Used)是最近最少使用算法，采用LRU算法的缓存有两种：LruCache和DisLruCache，分别是内存缓存和硬盘缓存.</p>
<ol>
<li><p>LruCache的使用<br>LruCache是Android3.1提供的一个缓存类.</p>
</li>
<li><p>LruCache源码<br>看LruCache源码，发现在Android的framework层的代码，大部分实现都用到Java的基础知识.所以还是要好好掌握下Java的基础知识.</p>
</li>
</ol>
<h2 id="Window、Activity、DecorView以及ViewRoot之间的关系"><a href="#Window、Activity、DecorView以及ViewRoot之间的关系" class="headerlink" title="Window、Activity、DecorView以及ViewRoot之间的关系"></a>Window、Activity、DecorView以及ViewRoot之间的关系</h2><h2 id="View的测量、布局以及绘制原理"><a href="#View的测量、布局以及绘制原理" class="headerlink" title="View的测量、布局以及绘制原理"></a>View的测量、布局以及绘制原理</h2><h2 id="Android虚拟机以及编译过程"><a href="#Android虚拟机以及编译过程" class="headerlink" title="Android虚拟机以及编译过程"></a>Android虚拟机以及编译过程</h2><h2 id="Android进程间通信方式"><a href="#Android进程间通信方式" class="headerlink" title="Android进程间通信方式"></a>Android进程间通信方式</h2><h2 id="Android-Bitmap压缩策略"><a href="#Android-Bitmap压缩策略" class="headerlink" title="Android Bitmap压缩策略"></a>Android Bitmap压缩策略</h2><h2 id="Android-动画总结"><a href="#Android-动画总结" class="headerlink" title="Android 动画总结"></a>Android 动画总结</h2><h2 id="Android-进程优先级"><a href="#Android-进程优先级" class="headerlink" title="Android 进程优先级"></a>Android 进程优先级</h2><h2 id="Android-Contex-详解"><a href="#Android-Contex-详解" class="headerlink" title="Android Contex 详解"></a>Android Contex 详解</h2><h1 id="Android进阶"><a href="#Android进阶" class="headerlink" title="Android进阶"></a>Android进阶</h1><h2 id="Android-多线程断点续传"><a href="#Android-多线程断点续传" class="headerlink" title="Android 多线程断点续传"></a>Android 多线程断点续传</h2><h2 id="Android全局异常处理"><a href="#Android全局异常处理" class="headerlink" title="Android全局异常处理"></a>Android全局异常处理</h2><h2 id="Android-MVP模式详解"><a href="#Android-MVP模式详解" class="headerlink" title="Android MVP模式详解"></a>Android MVP模式详解</h2><h2 id="Android-Binder机制以及AIDL使用"><a href="#Android-Binder机制以及AIDL使用" class="headerlink" title="Android Binder机制以及AIDL使用"></a>Android Binder机制以及AIDL使用</h2><h2 id="Android-Parcelable和Serializable的区别"><a href="#Android-Parcelable和Serializable的区别" class="headerlink" title="Android Parcelable和Serializable的区别"></a>Android Parcelable和Serializable的区别</h2><h2 id="一个APP从启动到主页面显示经历了哪些过程"><a href="#一个APP从启动到主页面显示经历了哪些过程" class="headerlink" title="一个APP从启动到主页面显示经历了哪些过程?"></a>一个APP从启动到主页面显示经历了哪些过程?</h2><h2 id="Android-性能优化总结"><a href="#Android-性能优化总结" class="headerlink" title="Android 性能优化总结"></a>Android 性能优化总结</h2><h2 id="Android-内存泄漏总结"><a href="#Android-内存泄漏总结" class="headerlink" title="Android 内存泄漏总结"></a>Android 内存泄漏总结</h2><h2 id="Android-布局优化之include-merge-ViewStub的使用"><a href="#Android-布局优化之include-merge-ViewStub的使用" class="headerlink" title="Android 布局优化之include/merge/ViewStub的使用"></a>Android 布局优化之include/merge/ViewStub的使用</h2><h2 id="Android-权限处理"><a href="#Android-权限处理" class="headerlink" title="Android 权限处理"></a>Android 权限处理</h2><h2 id="Android热修复原理"><a href="#Android热修复原理" class="headerlink" title="Android热修复原理"></a>Android热修复原理</h2><h2 id="Android-插件化入门指南"><a href="#Android-插件化入门指南" class="headerlink" title="Android 插件化入门指南"></a>Android 插件化入门指南</h2><h2 id="VirtualAPK解析"><a href="#VirtualAPK解析" class="headerlink" title="VirtualAPK解析"></a>VirtualAPK解析</h2><h2 id="Android-推送技术解析"><a href="#Android-推送技术解析" class="headerlink" title="Android 推送技术解析"></a>Android 推送技术解析</h2><h2 id="Android-APK安装过程"><a href="#Android-APK安装过程" class="headerlink" title="Android APK安装过程"></a>Android APK安装过程</h2><h2 id="PopupWindow和Dialog区别"><a href="#PopupWindow和Dialog区别" class="headerlink" title="PopupWindow和Dialog区别"></a>PopupWindow和Dialog区别</h2><h1 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h1><p>《深入理解Java虚拟机》–JVM高级特性与最佳实践<br>      周志明-机械工业出版社</p>
<p>关于Java虚拟机，重点考察以下三个方面：</p>
<ul>
<li>内存区域/内存模型</li>
<li>类加载机制</li>
<li>垃圾收集算法/收集器</li>
</ul>
<p>MyQuestion：</p>
<ol>
<li><p>JVM 开源么？ JVM是包含在JDK里面的么？</p>
</li>
<li><p>Dalvik对JVM 做了哪些改进？ </p>
</li>
<li><p>ART又对Dalvik做了哪些改进？</p>
</li>
</ol>
<p>虚拟机相关的关键字：<br>JVM：<br>HotSpot：<br>JIT<br>AOT:<br>Heap(堆):<br>Stack(栈):</p>
<h2 id="对象的创建、内存布局和访问定位"><a href="#对象的创建、内存布局和访问定位" class="headerlink" title="对象的创建、内存布局和访问定位"></a>对象的创建、内存布局和访问定位</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol>
<li><p>虚拟机遇到一个New指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用；</p>
</li>
<li><p>检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行相应的类的加载过程;</p>
</li>
<li><p>在类加载检查功能通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。</p>
</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>分为三个区域：  对象头，实例数据，对齐填充。</p>
<ol>
<li><p>对象头<br>包含两部分信息，第一部分：对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。着不放数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为”Mark Word”.</p>
<p>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据 。</p>
</li>
<li><p>实例数据<br>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
</li>
<li><p>对齐填充<br>对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐是，就需要通过对齐补充来补全了。</p>
</li>
</ol>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p> Java程序需要通过栈上的reference数据来操作堆上的具体对象</p>
<p> 目前主流的访问方式有使用句柄和直接使用指针两种。</p>
<ol>
<li><p>句柄访问<br>Java堆中会划分出一块内存来作为句柄池，reference中存储的事就对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。<br><img src="/Android-InterView/" alt="句柄访问"></p>
</li>
<li><p>直接指针访问<br>reference中存储的直接就是对象地址<br><img src="/Android-InterView/" alt="直接指针访问"></p>
</li>
</ol>
<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><ol>
<li><p>方法区(公有)</p>
</li>
<li><p>堆(公有)</p>
</li>
<li><p>虚拟机栈(线程私有)</p>
</li>
<li><p>本地方法栈(线程私有)</p>
</li>
<li><p>程序计数器(线程私有)</p>
</li>
</ol>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p> Java内存模型的目的： 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p>
<p> 主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p> 了解Java内存模型之前需要了解：主内存和工作内存。</p>
<p> Java内存模型规定了所有的变量都存储在主内存中，每个线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量(这些变量是从主内存中拷贝而来)。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
<h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><ol>
<li><p>定义： 把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p>
<p>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点来实现的。</p>
</li>
<li><p>类的生命周期：  加载、验证、准备、解析、初始化、使用和卸载。其中验证，准备，解析3个部分统称为链接。<br>Loading -&gt; Verification -&gt; Preparation -&gt; Resolution -&gt; Initalization -&gt; Using -&gt; Unloading</p>
</li>
</ol>
<h2 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h2><p> 通过上述的了解，我们已经知道了类加载机制的大概流程以及各个部分的功能，其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p>
<ol>
<li><p>类加载器分类<br>不同的类加载器负责加载不同的类。主要分为两类：<br>启动类加载器(Bootstrap ClassLoader):由C++语言实现(针对Hotspot),负责将存放在&lt;JAVA_HOME&gt;/lib目录或者-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类</p>
<p>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：</p>
<p>扩展类加载器(Extension ClassLoader)：负责将存放在&lt;JAVA_HOME&gt;/lib/ext目录或者java.ext.dirs系统变量指定的路径中的类库加载到内存中，即负责加载Java扩展的核心类之外的类</p>
<p>应用程序类加载器(Application ClassLoader): </p>
</li>
<li><p>双亲委派模型<br>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有父加载器在它的搜索范围内没有找到所需的类时，即无法完成该加载，子加载才会尝试自己去加载该类。</p>
</li>
</ol>
<ol start="3">
<li>双亲委派模型的代码实现<br>ClassLoader中loadClass方法实现了双亲委派模型</li>
</ol>
<h2 id="JVM中垃圾收集算法"><a href="#JVM中垃圾收集算法" class="headerlink" title="JVM中垃圾收集算法"></a>JVM中垃圾收集算法</h2><ol>
<li><p>标记-清除算法<br>最基础的收集算法是”标记-清除”(Mark-Sweep)算法，分为标记和清除两个阶段<br>a)首先标记出所需要回收的对象<br>b)在标记完成之后，统一回收所有被标记的对象</p>
<p>不足：<br>效率问题： 标记和清除两个过程的效率都不高<br>空间问题：标记清除后产生大量的不连续的内存碎片，空间碎片太多，可能会导致分配大对象时，无法找到足够连续的内存而不得不提前触发另一次垃圾收集动作</p>
</li>
<li><p>复制算法<br>目的：为了解决效率问题</p>
<p>将可用内存按照容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。</p>
<p>缺点：将内存缩小为了原来的一半</p>
<p>现代的商业虚拟机都是采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是”朝生夕死”，所以不需要按照1:1来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8:1</p>
</li>
<li><p>标记-整理算法<br>复制算法在对象存活率较高的时候，就要进行较多的复制操作，效率就会变低。</p>
<p>标记过程和标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。</p>
</li>
<li><p>分代收集算法<br>一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p>对新生代，采用复制算法</p>
<p>对老年代，采用标记整理算法或者标记清除算法</p>
</li>
</ol>
<p>##垃圾收集器详解</p>
<h2 id="JVM怎么判断对象是否已死"><a href="#JVM怎么判断对象是否已死" class="headerlink" title="JVM怎么判断对象是否已死"></a>JVM怎么判断对象是否已死</h2><ol>
<li><p>引用计数法<br>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1.任何时刻计数器为0的对象就是不可能被在使用的。</p>
<p>主流的JVM里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象间的互相循环引用问题。</p>
</li>
<li><p>可达性分析算法</p>
</li>
<li><p>判断对象是否存活与”引用”相关<br>Strong Reference 强引用<br>Soft Reference 软引用<br>Weak Reference 弱引用<br>Phantom Reference 虚引用<br>引用强度依次减弱</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">Android校招面试指南</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/读书笔记/" rel="next" title="读书笔记">
                <i class="fa fa-chevron-left"></i> 读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/year-06-23-Android/" rel="prev" title="Android">
                Android <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div id="gitalk-container"></div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myapple.jpg"
                alt="Eric Chows" />
            
              <p class="site-author-name" itemprop="name">Eric Chows</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">89</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ericchows" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xnzds2008@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plus.google.com" target="_blank" title="Google">
                    
                      <i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="/images/wechat.jpg" target="_blank" title="Wechat">
                    
                      <i class="fa fa-fw fa-globe"></i>Wechat</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java面试题"><span class="nav-number">1.</span> <span class="nav-text">Java面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java基础"><span class="nav-number">1.1.</span> <span class="nav-text">Java基础</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android面试题"><span class="nav-number">2.</span> <span class="nav-text">Android面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android基础"><span class="nav-number">2.1.</span> <span class="nav-text">Android基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非技术问题汇总"><span class="nav-number">2.2.</span> <span class="nav-text">非技术问题汇总</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构和算法"><span class="nav-number">3.</span> <span class="nav-text">数据结构和算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HR问题"><span class="nav-number">4.</span> <span class="nav-text">HR问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-基础-必须要完全的掌握，越熟练越好"><span class="nav-number">5.</span> <span class="nav-text">Java 基础 (必须要完全的掌握，越熟练越好)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java集合框架"><span class="nav-number">5.2.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-接口"><span class="nav-number">5.2.2.</span> <span class="nav-text">Collection 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-集合"><span class="nav-number">5.2.3.</span> <span class="nav-text">Set 集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java泛型"><span class="nav-number">5.3.</span> <span class="nav-text">Java泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">5.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型的使用"><span class="nav-number">5.3.2.</span> <span class="nav-text">泛型的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型通配符"><span class="nav-number">5.3.3.</span> <span class="nav-text">类型通配符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型擦除"><span class="nav-number">5.3.4.</span> <span class="nav-text">类型擦除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-注解"><span class="nav-number">5.4.</span> <span class="nav-text">Java 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元数据"><span class="nav-number">5.4.1.</span> <span class="nav-text">元数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解-Annotation"><span class="nav-number">5.4.2.</span> <span class="nav-text">注解(Annotation)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义注解（Annotation）"><span class="nav-number">5.4.3.</span> <span class="nav-text">自定义注解（Annotation）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注解解析"><span class="nav-number">5.4.4.</span> <span class="nav-text">注解解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-反射"><span class="nav-number">5.5.</span> <span class="nav-text">Java 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">5.5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Java反射查看类信息"><span class="nav-number">5.5.2.</span> <span class="nav-text">通过Java反射查看类信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Java反射生成并操作对象"><span class="nav-number">5.5.3.</span> <span class="nav-text">通过Java反射生成并操作对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理模式"><span class="nav-number">5.5.4.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java反射机制与动态代理"><span class="nav-number">5.5.5.</span> <span class="nav-text">Java反射机制与动态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型和Class类"><span class="nav-number">5.5.6.</span> <span class="nav-text">泛型和Class类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用反射来获取泛型信息"><span class="nav-number">5.5.7.</span> <span class="nav-text">使用反射来获取泛型信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-I-O"><span class="nav-number">5.6.</span> <span class="nav-text">Java I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符和字节"><span class="nav-number">5.6.1.</span> <span class="nav-text">字符和字节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File类"><span class="nav-number">5.6.2.</span> <span class="nav-text">File类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO流的概念"><span class="nav-number">5.6.3.</span> <span class="nav-text">IO流的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO流的四大基类"><span class="nav-number">5.6.4.</span> <span class="nav-text">IO流的四大基类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RandomAccessFile"><span class="nav-number">5.7.</span> <span class="nav-text">RandomAccessFile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile概述"><span class="nav-number">5.7.1.</span> <span class="nav-text">RandomAccessFile概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile中的方法"><span class="nav-number">5.7.2.</span> <span class="nav-text">RandomAccessFile中的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RandomAccessFile的使用"><span class="nav-number">5.7.3.</span> <span class="nav-text">RandomAccessFile的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO"><span class="nav-number">5.8.</span> <span class="nav-text">Java NIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-概述"><span class="nav-number">5.8.1.</span> <span class="nav-text">NIO 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer的使用"><span class="nav-number">5.8.2.</span> <span class="nav-text">Buffer的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-异常详解"><span class="nav-number">5.9.</span> <span class="nav-text">Java 异常详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java异常概述"><span class="nav-number">5.9.1.</span> <span class="nav-text">Java异常概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java异常框架"><span class="nav-number">5.9.2.</span> <span class="nav-text">Java异常框架</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java抽象类和接口的区别"><span class="nav-number">5.10.</span> <span class="nav-text">Java抽象类和接口的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java深拷贝和浅拷贝"><span class="nav-number">5.11.</span> <span class="nav-text">Java深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中transient关键字"><span class="nav-number">5.12.</span> <span class="nav-text">Java中transient关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中finally和return的执行顺序"><span class="nav-number">5.13.</span> <span class="nav-text">Java中finally和return的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-8-新特性"><span class="nav-number">5.14.</span> <span class="nav-text">Java 8 新特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-8-源码"><span class="nav-number">5.15.</span> <span class="nav-text">Java 8 源码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-并发"><span class="nav-number">6.</span> <span class="nav-text">Java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java创建线程的三种方式"><span class="nav-number">6.1.</span> <span class="nav-text">Java创建线程的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java线程池"><span class="nav-number">6.2.</span> <span class="nav-text">Java线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-number">6.3.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronize-Reentrantlock"><span class="nav-number">6.4.</span> <span class="nav-text">Synchronize/Reentrantlock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者消费者模式"><span class="nav-number">6.5.</span> <span class="nav-text">生产者消费者模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android基础-1"><span class="nav-number">7.</span> <span class="nav-text">Android基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity全方位解析"><span class="nav-number">7.1.</span> <span class="nav-text">Activity全方位解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity生命周期"><span class="nav-number">7.1.1.</span> <span class="nav-text">Activity生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity的启动模式"><span class="nav-number">7.1.2.</span> <span class="nav-text">Activity的启动模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity的Flag"><span class="nav-number">7.1.3.</span> <span class="nav-text">Activity的Flag</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service-全方位解析"><span class="nav-number">7.2.</span> <span class="nav-text">Service 全方位解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BroadcastReceiver全方位解析"><span class="nav-number">7.3.</span> <span class="nav-text">BroadcastReceiver全方位解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ContenProvider全方位解析"><span class="nav-number">7.4.</span> <span class="nav-text">ContenProvider全方位解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fragment-详解"><span class="nav-number">7.5.</span> <span class="nav-text">Fragment 详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android消息机制"><span class="nav-number">7.6.</span> <span class="nav-text">Android消息机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android事件分发机制"><span class="nav-number">7.7.</span> <span class="nav-text">Android事件分发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncTask详解"><span class="nav-number">7.8.</span> <span class="nav-text">AsyncTask详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HandlerThread详解"><span class="nav-number">7.9.</span> <span class="nav-text">HandlerThread详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IntentServcie详解"><span class="nav-number">7.10.</span> <span class="nav-text">IntentServcie详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LruCache详解"><span class="nav-number">7.11.</span> <span class="nav-text">LruCache详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window、Activity、DecorView以及ViewRoot之间的关系"><span class="nav-number">7.12.</span> <span class="nav-text">Window、Activity、DecorView以及ViewRoot之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View的测量、布局以及绘制原理"><span class="nav-number">7.13.</span> <span class="nav-text">View的测量、布局以及绘制原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android虚拟机以及编译过程"><span class="nav-number">7.14.</span> <span class="nav-text">Android虚拟机以及编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android进程间通信方式"><span class="nav-number">7.15.</span> <span class="nav-text">Android进程间通信方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Bitmap压缩策略"><span class="nav-number">7.16.</span> <span class="nav-text">Android Bitmap压缩策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-动画总结"><span class="nav-number">7.17.</span> <span class="nav-text">Android 动画总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-进程优先级"><span class="nav-number">7.18.</span> <span class="nav-text">Android 进程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Contex-详解"><span class="nav-number">7.19.</span> <span class="nav-text">Android Contex 详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Android进阶"><span class="nav-number">8.</span> <span class="nav-text">Android进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-多线程断点续传"><span class="nav-number">8.1.</span> <span class="nav-text">Android 多线程断点续传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android全局异常处理"><span class="nav-number">8.2.</span> <span class="nav-text">Android全局异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-MVP模式详解"><span class="nav-number">8.3.</span> <span class="nav-text">Android MVP模式详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Binder机制以及AIDL使用"><span class="nav-number">8.4.</span> <span class="nav-text">Android Binder机制以及AIDL使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-Parcelable和Serializable的区别"><span class="nav-number">8.5.</span> <span class="nav-text">Android Parcelable和Serializable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个APP从启动到主页面显示经历了哪些过程"><span class="nav-number">8.6.</span> <span class="nav-text">一个APP从启动到主页面显示经历了哪些过程?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-性能优化总结"><span class="nav-number">8.7.</span> <span class="nav-text">Android 性能优化总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-内存泄漏总结"><span class="nav-number">8.8.</span> <span class="nav-text">Android 内存泄漏总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-布局优化之include-merge-ViewStub的使用"><span class="nav-number">8.9.</span> <span class="nav-text">Android 布局优化之include/merge/ViewStub的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-权限处理"><span class="nav-number">8.10.</span> <span class="nav-text">Android 权限处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android热修复原理"><span class="nav-number">8.11.</span> <span class="nav-text">Android热修复原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-插件化入门指南"><span class="nav-number">8.12.</span> <span class="nav-text">Android 插件化入门指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VirtualAPK解析"><span class="nav-number">8.13.</span> <span class="nav-text">VirtualAPK解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-推送技术解析"><span class="nav-number">8.14.</span> <span class="nav-text">Android 推送技术解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android-APK安装过程"><span class="nav-number">8.15.</span> <span class="nav-text">Android APK安装过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PopupWindow和Dialog区别"><span class="nav-number">8.16.</span> <span class="nav-text">PopupWindow和Dialog区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-虚拟机"><span class="nav-number">9.</span> <span class="nav-text">Java 虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建、内存布局和访问定位"><span class="nav-number">9.1.</span> <span class="nav-text">对象的创建、内存布局和访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的创建"><span class="nav-number">9.1.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">9.1.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的访问定位"><span class="nav-number">9.1.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存区域"><span class="nav-number">9.2.</span> <span class="nav-text">Java内存区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型"><span class="nav-number">9.3.</span> <span class="nav-text">Java内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java类加载机制"><span class="nav-number">9.4.</span> <span class="nav-text">Java类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器详解"><span class="nav-number">9.5.</span> <span class="nav-text">类加载器详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM中垃圾收集算法"><span class="nav-number">9.6.</span> <span class="nav-text">JVM中垃圾收集算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM怎么判断对象是否已死"><span class="nav-number">9.7.</span> <span class="nav-text">JVM怎么判断对象是否已死</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">10.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricChows</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1274018749&web_id=1274018749" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
		var gitalk = new Gitalk({
		  clientID: '2f039a8ed54186479946',
		  clientSecret: 'bc88282455b50fbc8c5d9502d17621a4f9e48d18',
		  repo: 'myblog-comment',
		  owner: 'EricChows',
		  admin: ['EricChows'],
		  id: location.pathname,
		  distractionFreeMode: 'true'
		})
		gitalk.render('gitalk-container')           
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ANlC6pJEdxOLHAcDbFuHuXrF-gzGzoHsz", "tNpAWjkmbhhKnsB3bcDooRrl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  

</body>
</html>
