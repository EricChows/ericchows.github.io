<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android ANR," />





  <link rel="alternate" href="/atom.xml" title="EricChows" type="application/atom+xml" />






<meta name="description" content="本文目标讲解Android中的ANR原理以及如何分析ANR问题 概览   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。    首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问">
<meta name="keywords" content="Android ANR">
<meta property="og:type" content="article">
<meta property="og:title" content="ANR 机制以及问题分析">
<meta property="og:url" content="http://yoursite.com/2018/06/21/ANR-机制以及问题分析/index.html">
<meta property="og:site_name" content="EricChows">
<meta property="og:description" content="本文目标讲解Android中的ANR原理以及如何分析ANR问题 概览   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。    首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-29T09:44:26.762Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ANR 机制以及问题分析">
<meta name="twitter:description" content="本文目标讲解Android中的ANR原理以及如何分析ANR问题 概览   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。    首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/21/ANR-机制以及问题分析/"/>





  <title>ANR 机制以及问题分析 | EricChows</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">EricChows</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Android Developer</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/ANR-机制以及问题分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric Chows">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myapple.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EricChows">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">ANR 机制以及问题分析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T19:06:22+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/06/21/ANR-机制以及问题分析/" class="leancloud_visitors" data-flag-title="ANR 机制以及问题分析">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文目标讲解Android中的ANR原理以及如何分析ANR问题</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。</p>
<p>   首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问题圈定在应用程序。SNR是有Watchdog机制保证，具体可查阅<strong>Watchdog机制以及问题分析</strong>;ANR由消息处理机制保证，Android在系统层实现了一套机制来发现ANR,核心原理是消息调度和超时处理。</p>
<p>   其次，ANR机制的主体实现在系统层。所有与ANR相关的消息，都会经过系统进程(system_server)调度，然后派发发哦应用进程完成对消息的实际处理，同时，系统进程设计了不同的超时限制来跟踪消息的处理。一旦应用程序处理消息不当，超时限制就起了作用了，它收集一些系统状态，比如CPU/IO使用情况、进程函数调用栈，并报告用户进程无响应(弹出ANR对话框).</p>
<p>   然后，ANR问题本质是一个性能问题和稳定性的问题。ANR机制实际上对应用程序主线程的限制，要求主线程在限定的时间内处理完一些常见的操作(启动服务、处理广播、处理输入)，如果超时，则任务主线程已经失去了响应其他操作的能力。主线程中的耗时操作，比如密集CPU运算、大量IO、复杂界面布局等，都会降低应用程序的响应能力。当系统中的ANR问题太多的时候，就影响到了系统的稳定性。</p>
<p>   最后，部分ANR问题时很难分析的，有时候由于系统底层的一些影响，导致消息调度失败，比如说Binder资源耗尽，nativepollonce等，出现问题的场景又难以复现。这类ANR问题往往需要花费大量的事件去了解系统的一些行为，超出了ANR机制本省的范畴。</p>
<p>   出现ANR的场景主要有以下几种：</p>
<blockquote>
<ul>
<li><strong>Service Timeout:</strong>服务在20s内未执行完成；</li>
<li><strong>BroadcastQueue Timeout：</strong>比如前台广播在10s内执行完成</li>
<li><strong>ContentProvider Timeout：</strong>内容提供者执行超时</li>
<li><strong>inputDispatching Timeout:</strong> 输入事件分发超时5s，包括按键分发事件的超时</li>
</ul>
</blockquote>
<h2 id="Google-官方关于ANR的介绍"><a href="#Google-官方关于ANR的介绍" class="headerlink" title="Google 官方关于ANR的介绍"></a>Google 官方关于ANR的介绍</h2><p>   Google官方关于ANR的介绍是在介绍使用Android Vitals工具时提到：<a href="https://developer.android.com/topic/performance/vitals/anr" target="_blank" rel="noopener">https://developer.android.com/topic/performance/vitals/anr</a></p>
<h3 id="查找ANR根因"><a href="#查找ANR根因" class="headerlink" title="查找ANR根因"></a>查找ANR根因</h3><p>查找ANR根因的方法有</p>
<ol>
<li><p>使用StrictMode<br>具体请参照： StrictMode 机制以及性能调优</p>
</li>
<li><p>启动ANR 背景对话框<br>Enable background ANR dialogs</p>
<p>Android shows ANR dialogs for apps that take too long to process the broadcast message only if Show all ANRs is enabled in the device’s Developer options. For this reason, background ANR dialogs are not always displayed to the user, but the app could still be experiencing performance issues.</p>
<p> 打开 开发者模式 –&gt; 打开 Show All ANR</p>
</li>
<li><p>使用TraceView</p>
</li>
<li><p>adb pull data/anr</p>
</li>
</ol>
<h3 id="解决ANR问题的方式"><a href="#解决ANR问题的方式" class="headerlink" title="解决ANR问题的方式"></a>解决ANR问题的方式</h3><pre><code>There are some common patterns to look for when diagnosing ANRs:
1. The app is doing slow operations involving I/O on the main thread.
2. The app is doing a long calculation on the main thread.
3. The main thread is doing a synchronous binder call to another process, and that other process is taking a long time to return.
4. The main thread is blocked waiting for a synchronized block for a long operation that is happening on another thread.
5. The main thread is in a deadlock with another thread, either in your process or via a binder call. The main thread is not just waiting for a long operation to finish, but is in a deadlock situation. For more information, see Deadlock on Wikipedia.
</code></pre><p>翻译如下:<br>    在诊断ANR时有一些常见的模式需要查找：</p>
<pre><code>1. 该应用程序在主线程上执行涉及I / O的缓慢操作。
2. 该应用程序正在对主线程进行长时间计算。
3. 主线程正在对另一个进程执行同步绑定程序调用，而其他进程需要很长时间才能返回。
4. 主线程被阻塞，等待正在另一个线程上发生的长操作的同步块。
5. 主线程与另一个线程处于死锁状态，无论是在您的进程中还是通过联编程序调用。主线不仅仅是等待长时间的操作才能完成，而是处于死锁状态。有关更多信息，请参阅 维基百科上的死锁。
</code></pre><ol>
<li><p>主线程执行超时<br>定位到是主线程超时时，需要找到对应的代码，将超时操作移到<a href="https://developer.android.com/topic/performance/threads#helper" target="_blank" rel="noopener">Handler</a>里面去处理，或者使用AsyncTask(<a href="https://developer.android.com/reference/android/os/AsyncTask" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/AsyncTask</a>) 异步任务的方式来处理。</p>
</li>
<li><p>主线程I/O超时<br>I/O超时，将超时操作移动到线程中处理,使用Handler或者AsyncTask.如果I/O是网络操作的或者存储操作的话，<a href="https://developer.android.com/training/basics/network-ops/" target="_blank" rel="noopener">网络操作</a>使用<a href="https://developer.android.com/training/volley/" target="_blank" rel="noopener">Volly</a>的方式来实现,数据存储的话，参照Android提供的几种存储方式<a href="https://developer.android.com/guide/topics/data/data-storage" target="_blank" rel="noopener">https://developer.android.com/guide/topics/data/data-storage</a></p>
</li>
<li><p>互斥锁<br>当前工作线程持有了UI线程所需要的资源太长时间，导致UI线程一直处于Wait状态.UI线程被阻塞住。可以使用<a href="https://developer.android.com/reference/java/util/concurrent/Semaphore" target="_blank" rel="noopener">Semaphore</a>(计数信号量)或者线程<a href="https://developer.android.com/reference/java/util/concurrent/locks/Lock" target="_blank" rel="noopener">锁</a>等其他的互斥机制来解决。 </p>
</li>
<li><p>死锁<br>UI线程和其他线程互相持有对方所需要的资源，导致死锁。双方都在等待对方释放资源。<br>解决死锁的方式：</p>
</li>
<li><p>广播超时<br>广播OnReceiver方法中耗时太久，比如前台广播超过10s未完成等<br>如果广播中需要执行复杂的操作，可以通过<a href="">IntenService</a>来实现。</p>
</li>
<li><p>服务超时/内容提供者超时/输入事件超时<br>都是用Handler或者AsyncTask来处理</p>
</li>
<li><p>CPU负载过高<br>一般CPU负载过高，只有在进行压力测试的时候才能出现，出现CPU负载过高之后，会使得很多事件得不到响应。一般CPU负载过高的ANR问题都不解。   </p>
</li>
</ol>
<h2 id="ANR-机制"><a href="#ANR-机制" class="headerlink" title="ANR 机制"></a>ANR 机制</h2><p>   分析一些初级的ANR问题，只需要简单理解最终输出的日志即可，但对于一些系统问题(比如CPU负载过高、进程卡死) 发的ANR，就需要对整个ANR机制有所了解，才能定位出问题的原因。</p>
<p>   ANR机制可以分为两部分：</p>
<blockquote>
<ul>
<li><strong>ANR的监测。</strong> Android对不同的ANR类型(Broadcase/Service/InputEvent)都有一套监测机制。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>ANR的报告。</strong> 在监测到ANR以后，需要显示ANR对话框、输出日志(发生ANR时的进程函数调用栈、CPU使用情况等)。</li>
</ul>
</blockquote>
<p>   整个ANR机制的代码也是横跨了Android的几个层：</p>
<blockquote>
<ul>
<li><strong>App层：</strong>应用主线程的处理逻辑</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>Framework层：</strong>  ANR机制的核心</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</li>
<li>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</li>
<li>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</li>
<li>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</li>
<li>frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java</li>
<li>frameworks/base/core/java/android/view/InputChannel</li>
<li>frameworks/base/services/core/java/com/android/internal/os/ProcessCpuTracker</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>Native层：</strong> 输入事件派发机制。针对InputEvent类型的ANR</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>frameworks/base//services/core/jni/com_android_server_input_InputManagerService.cpp</li>
<li>frameworks/native/services/inputflinger/InputDispatcher.cpp</li>
</ul>
</blockquote>
<p>   下面我们会深入源码，分析ANR的监测和报告过程。</p>
<h3 id="ANR检测机制"><a href="#ANR检测机制" class="headerlink" title="ANR检测机制"></a>ANR检测机制</h3><h4 id="Service-处理超时"><a href="#Service-处理超时" class="headerlink" title="Service 处理超时"></a>Service 处理超时</h4><p>   Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。</p>
<p>   当发生Service ANR时，一般可以先排查一下在Service的生命周期函数中(onCreate(), onStartCommand()等)有没有做耗时的操作，譬如复杂的运算、IO操作等。如果应用程序的代码逻辑查不出问题，就需要深入检查当前系统的状态：CPU的使用情况、系统服务的状态等，判断当时发生ANR进程是否受到系统运行异常的影响。</p>
<p>   如何检测Service超时呢？Android是通过设置定时消息实现的。定时消息是由AMS的消息队列处理的(system_server的ActivityManager线程)。 AMS有Service运行的上下文信息，所以在AMS中设置一套超时检测机制也是合情合理的。</p>
<p>   Service ANR机制相对最为简单，简单说就是AMS中的mHandler收到SERVICE_TIMEOUT_MSG消息时触发。<br>   主体实现在<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActiveServices.java" target="_blank" rel="noopener">ActiveServices.java</a>中。 当Service的生命周期开始时，bumpServiceExecutingLocked()会被调用，紧接着会调用scheduleServiceTimeoutLocked()：</p>
<p>   StartService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread == null) &#123;</span><br><span class="line">            throw new RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">        r.app = app;</span><br><span class="line">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        final boolean newService = app.services.add(r);</span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);//执行bumpServiceExecutingLocked</span><br><span class="line">        mAm.updateLruProcessLocked(app, <span class="literal">false</span>, null);</span><br><span class="line">        updateServiceForegroundLocked(r.app, /* oomAdj= */ <span class="literal">false</span>);</span><br><span class="line">        mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        boolean created = <span class="literal">false</span>;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">                String nameTerm;</span><br><span class="line">                int lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">                EventLogTags.writeAmCreateService(</span><br><span class="line">                        r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">            &#125;</span><br><span class="line">            ........</span><br></pre></td></tr></table></figure></p>
<p>   BindService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">            // If service is not currently running, can<span class="string">'t yet bind.</span></span><br><span class="line"><span class="string">            return false;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, "requestBind " + i + ": requested=" + i.requested</span></span><br><span class="line"><span class="string">                + " rebind=" + rebind);</span></span><br><span class="line"><span class="string">        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                bumpServiceExecutingLocked(r, execInFg, "bind");//执行bumpServiceExecutingLocked</span></span><br><span class="line"><span class="string">                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span></span><br><span class="line"><span class="string">                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span></span><br><span class="line"><span class="string">                        r.app.repProcState);</span></span><br><span class="line"><span class="string">                if (!rebind) &#123;</span></span><br><span class="line"><span class="string">                    i.requested = true;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                i.hasBound = true;</span></span><br><span class="line"><span class="string">                i.doRebind = false;</span></span><br><span class="line"><span class="string">            &#125; catch (TransactionTooLargeException e) &#123;</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r, e);</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                throw e;</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r);</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>调用bumpServiceExecutingLocked</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void bumpServiceExecutingLocked(ServiceRecord r, boolean <span class="built_in">fg</span>, String why) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r + <span class="string">" in app "</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r.shortName);</span><br><span class="line">    long now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == 0) &#123;</span><br><span class="line">        r.executeFg = <span class="built_in">fg</span>;</span><br><span class="line">        ServiceState stracker = r.getTracker();</span><br><span class="line">        <span class="keyword">if</span> (stracker != null) &#123;</span><br><span class="line">            stracker.setExecuting(<span class="literal">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |= <span class="built_in">fg</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == 1) &#123;</span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != null &amp;&amp; <span class="built_in">fg</span> &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">        r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">    &#125;</span><br><span class="line">    r.executeFg |= <span class="built_in">fg</span>;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    r.executingStart = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着调用scheduleServiceTimeoutLocked<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方法通过AMS.MainHandler抛出一个定时消息SERVICE_TIMEOUT_MSG：</p>
<blockquote>
<ul>
<li><strong>前台进程中执行Service</strong>，超时时间是SERVICE_TIMEOUT(20秒)</li>
<li><strong>后台进程中执行Service</strong>，超时时间是SERVICE_BACKGROUND_TIMEOUT(200秒)</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_TIMEOUT = 20*1000;</span><br><span class="line"></span><br><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;</span><br><span class="line"></span><br><span class="line">// How long the startForegroundService() grace period is to get around to</span><br><span class="line">// calling startForeground() before we ANR + stop it.</span><br><span class="line">static final int SERVICE_START_FOREGROUND_TIMEOUT = 5*1000;</span><br></pre></td></tr></table></figure>
<p>当Service的生命周期结束时，会调用serviceDoneExecutingLocked()方法，之前抛出的SERVICE_TIMEOUT_MSG消息在这个方法中会被清除。 如果在超时时间内，SERVICE_TIMEOUT_MSG没有被清除，那么，AMS.MainHandler就会响应这个消息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,</span><br><span class="line">            boolean finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">                + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">                + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line">        r.executeNesting--;</span><br><span class="line">        <span class="keyword">if</span> (r.executeNesting &lt;= 0) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">                r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">                r.app.executingServices.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.app.executingServices.size() == 0) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                            <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);//清除SERVICE_TIMEOUT_MSG消息</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                    // Need to re-evaluate whether the app still needs to be <span class="keyword">in</span> the foreground.</span><br><span class="line">                    <span class="keyword">for</span> (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                            r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .....</span><br></pre></td></tr></table></figure>
<p>AMS.MainHandler就会响应这个消息:<br>见<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">ActivityManagerService</a><br>本文是基于Android8.0的代码分析，与<a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a> 这篇文章这里的代码不一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final class MainHandler extends Handler &#123;</span><br><span class="line">       public MainHandler(Looper looper) &#123;</span><br><span class="line">           super(looper, null, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE_CONFIGURATION_MSG: &#123;</span><br><span class="line">               final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">               Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj,</span><br><span class="line">                       msg.arg1);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> GC_BACKGROUND_PROCESSES_MSG: &#123;</span><br><span class="line">               synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                   performAppGcsIfAppropriateLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;  </span><br><span class="line">               mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_TIMEOUT_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundTimeout((ServiceRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_CRASH_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundCrash((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> DISPATCH_PENDING_INTENT_CANCEL_MSG: &#123;</span><br><span class="line">               RemoteCallbackList&lt;IResultReceiver&gt; callbacks</span><br><span class="line">                       = (RemoteCallbackList&lt;IResultReceiver&gt;)msg.obj;</span><br><span class="line">               int N = callbacks.beginBroadcast();</span><br><span class="line">               <span class="keyword">for</span> (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               callbacks.finishBroadcast();</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           ......</span><br></pre></td></tr></table></figure></p>
<p>mServices是ActiveServices，又返回到ActiveService中进行处理:<br>serviceTimeout 的处理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void serviceTimeout(ProcessRecord proc) &#123;</span><br><span class="line">    String anrMessage = null;</span><br><span class="line">    synchronized(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        final long now = SystemClock.uptimeMillis();</span><br><span class="line">        final long maxTime =  now -</span><br><span class="line">                (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        ServiceRecord timeout = null;</span><br><span class="line">        long nextTime = 0;</span><br><span class="line">        <span class="keyword">for</span> (int i=proc.executingServices.size()-1; i&gt;=0; i--) &#123;// 寻找运行超时的Service</span><br><span class="line">            ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123; // 判断执行Service超时的进程是否在最近运行进程列表，如果在，则输出<span class="built_in">log</span>到logcat和dumplog中，并记录anrMessage供弹框使用</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timeout executing service: "</span> + timeout);</span><br><span class="line">            StringWriter sw = new StringWriter();</span><br><span class="line">            PrintWriter pw = new FastPrintWriter(sw, <span class="literal">false</span>, 1024);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">"    "</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  //其他的三种情况分别如下，则继续等待监测20s或者200s</span><br><span class="line">        	//a)如果Service超时，但是不在最近运行进程列表中</span><br><span class="line">        	//b)如果Service不超时，且不在最近运行进程列表中</span><br><span class="line">        	//c)如果Service不超时，且在最近运进程列表中</span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">        mAm.mAppErrors.appNotResponding(proc, null, null, <span class="literal">false</span>, anrMessage);//ANR的弹框处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述方法会找到当前进程已经超时的Service，经过一些判定后，决定要报告ANR，最终调用AMS.appNotResponding()方法。 走到这一步，ANR机制已经完成了监测报告任务，剩下的任务就是ANR结果的输出，我们称之为ANR的报告机制。 ANR的报告机制是通过AMS.appNotResponding()完成的，Broadcast和InputEvent类型的ANR最终也都会调用这个方法，我们后文再详细展开。</p>
<p>至此，我们分析了Service的ANR机制：</p>
<p>通过定时消息跟踪Service的运行，当定时消息被响应时，说明Service还没有运行完成，这就意味着Service ANR。</p>
<h4 id="Broadcast处理超时"><a href="#Broadcast处理超时" class="headerlink" title="Broadcast处理超时"></a>Broadcast处理超时</h4><p>应用程序可以注册广播接收器，实现BroadcastReceiver.onReceive()方法来完成对广播的处理。通常，这个方法是在主线程执行的，Android限定它执行时间不能超过10秒，否则，就会引发ANR。</p>
<p>onReceive()也可以调度在其他线程执行，通过Context.registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)这个方法注册广播接收器， 可以指定一个处理的Handler，将onReceive()调度在非主线程执行。</p>
<p>这里先把问题抛出来了：</p>
<blockquote>
<p>Android如何将广播投递给各个应用程序？<br>Android如何检测广播处理超时？</p>
</blockquote>
<p>广播消息的调度<br>AMS维护了两个广播队列BroadcastQueue:</p>
<blockquote>
<p> foreground queue，前台队列的超时时间是10秒<br> background queue，后台队列的超时时间是60秒</p>
</blockquote>
<p>之所以有两个，就是因为要区分的不同超时时间。所有发送的广播都会进入到队列中等待调度，在发送广播时，可以通过Intent.FLAG_RECEIVER_FOREGROUND参数将广播投递到前台队列。 AMS线程会不断地从队列中取出广播消息派发到各个接收器(BroadcastReceiver)。当要派发广播时，AMS会调用BroadcastQueue.scheduleBroadcastsLocked()方法：</p>
<p><strong> 参见 Android中广播注册和发送机制分析 </strong></p>
<p>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">scheduleBroadcastsLocked</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法中，往AMS线程的消息队列发送BROADCAST_INTENT_MSG消息，由此也可以看到真正派发广播的是AMS线程(system_server进程中的ActivityManager线程)。 由于上述方法可能被并发调用，所以通过mBroadcastsScheduled这个变量来标识BROADCAST_INTENT_MSG是不是已经被AMS线程接收了，当已经抛出的消息还未被接受时，不需要重新抛出。 该消息被接收后的处理逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static final int BROADCAST_INTENT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG;</span><br><span class="line">static final int BROADCAST_TIMEOUT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG + 1;</span><br><span class="line"></span><br><span class="line">final BroadcastHandler mHandler;</span><br><span class="line"></span><br><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">    public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        super(looper, null, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                processNextBroadcast(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 直接调用BroadcastQueue.processNextBroadcast()方法，fromMsg参数为true表示这是一次来自BROADCAST_INTENT_MSG消息的派发请求。 BroadcastQueue.processNextBroadcast()是派发广播消息最为核心的函数，代码量自然也不小，我们分成几个部分来分析：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分1：处理非串行广播消息</span><br><span class="line">final ActivityManagerService mService;//mService是ActivityManagerService</span><br><span class="line">   .....</span><br><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">       synchronized(mService) &#123;</span><br><span class="line">           BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                   + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                   + mParallelBroadcasts.size() + <span class="string">" parallel broadcasts, "</span></span><br><span class="line">                   + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">           mService.updateCpuStats();//更新CPU状态信息</span><br><span class="line"></span><br><span class="line">           //1. 更新mBroadcastsScheduled 标志状态</span><br><span class="line">           <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">               mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">           //2. 处理并行广播</span><br><span class="line">           <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">               r = mParallelBroadcasts.remove(0);</span><br><span class="line">               r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">               r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                   Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">                   Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int N = r.receivers.size();</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">               <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                   Object target = r.receivers.get(i);</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                           <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                           + target + <span class="string">": "</span> + r);</span><br><span class="line">                   deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="literal">false</span>, i);</span><br><span class="line">               &#125;</span><br><span class="line">               addBroadcastToHistoryLocked(r);</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Now take care of the next serialized one...</span><br><span class="line"></span><br><span class="line">           // If we are waiting <span class="keyword">for</span> a process to come up to handle the next</span><br><span class="line">           // broadcast, <span class="keyword">then</span> <span class="keyword">do</span> nothing at this point.  Just <span class="keyword">in</span> <span class="keyword">case</span>, we</span><br><span class="line">           // check that the process we<span class="string">'re waiting for still exists.</span></span><br><span class="line"><span class="string">           //3. 处理阻塞广播</span></span><br><span class="line"><span class="string">           if (mPendingBroadcast != null) &#123;</span></span><br><span class="line"><span class="string">               if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                       "processNextBroadcast [" + mQueueName + "]: waiting for "</span></span><br><span class="line"><span class="string">                       + mPendingBroadcast.curApp);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               boolean isDead; // isDead表示当前广播消息的进程的存活状态</span></span><br><span class="line"><span class="string">               synchronized (mService.mPidsSelfLocked) &#123;</span></span><br><span class="line"><span class="string">                   ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span></span><br><span class="line"><span class="string">                   isDead = proc == null || proc.crashing;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               if (!isDead) &#123;</span></span><br><span class="line"><span class="string">                   // It'</span>s still alive, so keep waiting// 如果还活着，则返回该函数，继续等待下次派发</span><br><span class="line">                   <span class="built_in">return</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                           + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                           + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                   mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                   mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                   mPendingBroadcast = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //未完待续</span><br></pre></td></tr></table></figure></p>
<p>第一个部分是处理非”串行广播消息”，有以下几个步骤：</p>
<ol>
<li><p>设置mBroadcastsScheduled。该变量在前文说过，是对BROADCAST_INTENT_MSG进行控制。 如果是响应BROADCAST_INTENT_MSG 的派发调用，则将mBroadcastsScheduled设为false， 表示本次 BROADCAST_INTENT_MSG 已经处理完毕，可以继续抛出下一次 BROADCAST_INTENT_MSG消息了</p>
</li>
<li><p>处理”并行广播消息”。广播接受器有”动态”和”静态”之分，通过Context.registerReceiver()注册的广播接收器为”动态”的，通过AndroidManifest.xml注册的广播接收器为”静态”的。 广播消息有”并行”和”串行”之分，”并行广播消息”都会派发到”动态”接收器，”串行广播消息”则会根据实际情况派发到两种接收器。 我们先不去探究Android为什么这么设计，只关注这两种广播消息派发的区别。在BroadcastQueue维护着两个队列：</p>
</li>
</ol>
<blockquote>
<p> mParallelBroadcasts，”并行广播消息”都会进入到此队列中排队。”并行广播消息”可以一次性派发完毕，即在一个循环中将广播派发到所有的”动态”接收器</p>
</blockquote>
<blockquote>
<p> mOrderedBroadcasts，”串行广播消息”都会进入到此队列中排队。”串行广播消息”需要轮侯派发，当一个接收器处理完毕后，会再抛出BROADCAST_INTENT_MSG消息， 再次进入BroadcastQueue.processNextBroadcast()处理下一个</p>
</blockquote>
<ol start="3">
<li>处理阻塞的广播消息。有时候会存在一个广播消息派发不出去的情况，这个广播消息会保存在mPendingBroadcast变量中。新一轮的派发启动时，会判断接收该消息的进程是否还活着， 如果接收进程还活着，那么就继续等待。否则，就放弃这个广播消息</li>
</ol>
<p>接下来是最为复杂的一部分，处理”串行广播消息”，ANR监测机制只在这一类广播消息中才发挥作用，也就是说”并行广播消息”是不会发生ANR的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分2：从队列中取出“串行广播消息”</span><br><span class="line">            boolean looped = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span> &#123;//处理有序广播</span><br><span class="line">                <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;//有序广播都处理完了时</span><br><span class="line">                    // No more broadcasts pending, so all <span class="keyword">done</span>!</span><br><span class="line">                    mService.scheduleAppGcsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                        // If we had finished the last ordered broadcast, <span class="keyword">then</span></span><br><span class="line">                        // make sure all processes have correct oom and <span class="built_in">sched</span></span><br><span class="line">                        // adjustments.</span><br><span class="line">                        mService.updateOomAdjLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                r = mOrderedBroadcasts.get(0);</span><br><span class="line">                boolean forceReceive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                // 1. 广播消息的第一个ANR监测机制</span><br><span class="line">                // Ensure that even <span class="keyword">if</span> something goes awry with the timeout</span><br><span class="line">                // detection, we catch <span class="string">"hung"</span> broadcasts here, discard them,</span><br><span class="line">                // and <span class="built_in">continue</span> to make progress.</span><br><span class="line">                //</span><br><span class="line">                // This is only <span class="keyword">done</span> <span class="keyword">if</span> the system is ready so that PRE_BOOT_COMPLETED</span><br><span class="line">                // receivers don<span class="string">'t get executed with timeouts. They'</span>re intended <span class="keyword">for</span></span><br><span class="line">                // one time heavy lifting after system upgrades and can take</span><br><span class="line">                // significant amounts of time.</span><br><span class="line">                int numReceivers = (r.receivers != null) ? r.receivers.size() : 0;</span><br><span class="line">                <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">                    long now = SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                            (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                                + <span class="string">" now="</span> + now</span><br><span class="line">                                + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                                + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                                + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                                + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                                + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                                + <span class="string">" state="</span> + r.state);</span><br><span class="line">                        broadcastTimeoutLocked(<span class="literal">false</span>); // forcibly finish this broadcast</span><br><span class="line">                        forceReceive = <span class="literal">true</span>;</span><br><span class="line">                        r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"processNextBroadcast("</span></span><br><span class="line">                            + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                            + r.state + <span class="string">")"</span>);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 2. 判断该广播消息是否处理完毕</span><br><span class="line">                <span class="keyword">if</span> (r.receivers == null || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                        || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                    // No more receivers <span class="keyword">for</span> this broadcast!  Send the final</span><br><span class="line">                    // result <span class="keyword">if</span> requested...</span><br><span class="line">                    <span class="keyword">if</span> (r.resultTo != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                    <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                    + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                            performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                                new Intent(r.intent), r.resultCode,</span><br><span class="line">                                r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                            // Set this to null so that the reference</span><br><span class="line">                            // (<span class="built_in">local</span> and remote) isn<span class="string">'t kept in the mBroadcastHistory.</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                            Slog.w(TAG, "Failure ["</span></span><br><span class="line"><span class="string">                                    + mQueueName + "] sending broadcast result of "</span></span><br><span class="line"><span class="string">                                    + r.intent, e);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Cancelling BROADCAST_TIMEOUT_MSG");</span></span><br><span class="line"><span class="string">                    cancelBroadcastTimeoutLocked();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                            "Finished with ordered broadcast " + r);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    // ... and on to the next...</span></span><br><span class="line"><span class="string">                    addBroadcastToHistoryLocked(r);</span></span><br><span class="line"><span class="string">                    if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null</span></span><br><span class="line"><span class="string">                            &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span></span><br><span class="line"><span class="string">                        // This was an implicit broadcast... let'</span>s record it <span class="keyword">for</span> posterity.</span><br><span class="line">                        mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                                r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mOrderedBroadcasts.remove(0);</span><br><span class="line">                    r = null;</span><br><span class="line">                    looped = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (r == null);</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure>
<p>这部分是一个do-while循环，每次都从mOrderedBroadcasts队列中取出第一条广播消息进行处理。第一个Broadcast ANR监测机制千呼万唤总算是出现了：</p>
<p>判定当前时间是否已经超过了r.dispatchTime + 2×mTimeoutPeriod×numReceivers:</p>
<p>dispatchTime表示这一系列广播消息开始派发的时间。“串行广播消息”是逐个接收器派发的，一个接收器处理完毕后，才开始处理下一个消息派发。 开始派发到第一个接收器的时间就是dispatchTime。dispatchTime需要开始等广播消息派发以后才会设定，也就是说，第一次进入processNextBroadcast()时， dispatchTime=0,并不会进入该条件判断</p>
<p>mTimeoutPeriod由当前BroadcastQueue的类型决定(forground为10秒，background为60秒)。这个时间在初始化BroadcastQueue的时候就设置好了， 本意是限定每一个Receiver处理广播的时间，这里利用它做了一个超时计算</p>
<p>假设一个广播消息有2个接受器，mTimeoutPeriod是10秒，当2×10×2=40秒后，该广播消息还未处理完毕，就调用broadcastTimeoutLocked()方法， 这个方法会判断当前是不是发生了ANR，我们后文再分析。</p>
<p>如果广播消息是否已经处理完毕，则从mOrderedBroadcasts中移除，重新循环，处理下一条;否则，就会跳出循环。</p>
<p>以上代码块完成的主要任务是从队列中取一条“串行广播消息”，接下来就准备派发了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分3：串行广播消息的第二个ANR监测机制</span><br><span class="line">            // Get the next receiver...</span><br><span class="line">            int recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">            // Keep track of when this receiver started, and make sure there</span><br><span class="line">            // is a timeout message pending to <span class="built_in">kill</span> it <span class="keyword">if</span> need be.</span><br><span class="line">            r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (recIdx == 0) &#123;</span><br><span class="line">                r.dispatchTime = r.receiverTime;</span><br><span class="line">                r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                    Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">                long timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">                setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p>
<p>取出“串行广播消息”后，一旦要开始派发，第二个ANR检测机制就出现了。mPendingBroadcastTimeoutMessage变量用于标识当前是否有阻塞的超时消息， 如果没有则调用BroadcastQueue.setBroadcastTimeoutLocked()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void setBroadcastTimeoutLocked(long timeoutTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过设置一个定时消息BROADCAST_TIMEOUT_MSG来跟踪当前广播消息的执行情况，这种超时监测机制跟Service ANR很类似，也是抛到AMS线程的消息队列。 如果所有的接收器都处理完毕了，则会调用cancelBroadcastTimeoutLocked()清除该消息;否则，该消息就会响应，并调用broadcastTimeoutLocked()， 这个方法在第一种ANR监测机制的时候调用过，第二种ANR监测机制也会调用，我们留到后文分析。</p>
<p>继续分析processNextBroadcast函数<br>设置完定时消息后，就开始派发广播消息了，首先是“动态”接收器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分4： 向“动态”接收器派发广播消息</span><br><span class="line">            final BroadcastOptions brOptions = r.options;</span><br><span class="line">            final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">            // 动态接收器的类型都是BroadcastFilter</span><br><span class="line">            <span class="keyword">if</span> (nextReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">                // Simple <span class="keyword">case</span>: this is a registered receiver who gets</span><br><span class="line">                // a direct call.</span><br><span class="line">                BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering ordered ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + filter + <span class="string">": "</span> + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">                <span class="keyword">if</span> (r.receiver == null || !r.ordered) &#123;</span><br><span class="line">                    // The receiver has already finished, so schedule to</span><br><span class="line">                    // process the next one.</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                            + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                        scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                                brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p>
<p>“动态”接收器的载体进程一般是处于运行状态的，所以向这种类型的接收器派发消息相对简单，调用BroadcastQueue.deliverToRegisteredReceiverLocked()完成接下来的工作。 但“静态”接收器是在AndroidManifest.xml中注册的，派发的时候，可能广播接收器的载体进程还没有启动，所以，这种场景会复杂很多。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分5： 向“静态”接收器派发广播消息</span><br><span class="line">            // Hard <span class="keyword">case</span>: need to instantiate the receiver, possibly</span><br><span class="line">            // starting its application process to host it.</span><br><span class="line">            //// 静态接收器的类型都是 ResolveInfo</span><br><span class="line">            ResolveInfo info =</span><br><span class="line">                (ResolveInfo)nextReceiver;</span><br><span class="line">            ComponentName component = new ComponentName(</span><br><span class="line">                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                    info.activityInfo.name);</span><br><span class="line"></span><br><span class="line">            boolean skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp;</span><br><span class="line">                    (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">                    info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1. 权限检查</span><br><span class="line">            int perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                    r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                    info.activityInfo.exported);</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.permission != null) &#123;</span><br><span class="line">                final int opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line">                <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                                r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                            + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                    info.activityInfo.permission)</span><br><span class="line">                            + <span class="string">" due to registered receiver "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">                r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                    String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                    try &#123;</span><br><span class="line">                        perm = AppGlobals.getPackageManager().</span><br><span class="line">                                checkPermission(requiredPermission,</span><br><span class="line">                                        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                        UserHandle</span><br><span class="line">                                                .getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                    <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                            &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                requiredPermission)</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent + <span class="string">" to "</span></span><br><span class="line">                        + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                        r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isSingleton = <span class="literal">false</span>;</span><br><span class="line">            try &#123;</span><br><span class="line">                isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                        info.activityInfo.applicationInfo,</span><br><span class="line">                        info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Slog.w(TAG, e.getMessage());</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                        android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid)</span><br><span class="line">                                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                            + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.isInstantApp()</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" Instant Apps do not support manifest receivers"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.callerInstantApp</span><br><span class="line">                    &amp;&amp; (info.activityInfo.flags &amp; ActivityInfo.FLAG_VISIBLE_TO_INSTANT_APP) == 0</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires receiver have visibleToInstantApps set"</span></span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                r.manifestCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.manifestSkipCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.curApp != null &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">                // If the target process is crashing, just skip it.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                        + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                boolean isAvailable = <span class="literal">false</span>;</span><br><span class="line">                try &#123;</span><br><span class="line">                    isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                            info.activityInfo.packageName,</span><br><span class="line">                            UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // all such failures mean we skip this receiver</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                            + info.activityInfo.packageName, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!isAvailable) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                            + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If permissions need a review before any of the app components can run, we drop</span><br><span class="line">            // the broadcast and <span class="keyword">if</span> the calling app is <span class="keyword">in</span> the foreground and the broadcast is</span><br><span class="line">            // explicit we launch the review UI passing it a pending intent to send the skipped</span><br><span class="line">            // broadcast.</span><br><span class="line">            <span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; !skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">                        info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                                info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This is safe to <span class="keyword">do</span> even <span class="keyword">if</span> we are skipping the broadcast, and we need</span><br><span class="line">            // this information now to evaluate whether it is going to be allowed to run.</span><br><span class="line">            final int receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line">            // If it<span class="string">'s a singleton, it needs to be the same app or a special app</span></span><br><span class="line"><span class="string">            if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span></span><br><span class="line"><span class="string">                    &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span></span><br><span class="line"><span class="string">                info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 2. 获取接收器所在的进程</span></span><br><span class="line"><span class="string">            String targetProcess = info.activityInfo.processName;</span></span><br><span class="line"><span class="string">            ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span></span><br><span class="line"><span class="string">                    info.activityInfo.applicationInfo.uid, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if (!skip) &#123;</span></span><br><span class="line"><span class="string">                final int allowed = mService.getAppStartModeLocked(</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false);</span></span><br><span class="line"><span class="string">                if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span></span><br><span class="line"><span class="string">                    // We won'</span>t allow this receiver to be launched <span class="keyword">if</span> the app has been</span><br><span class="line">                    // completely disabled from launches, or it was not explicitly sent</span><br><span class="line">                    // to it and the app is <span class="keyword">in</span> a state that should not receive it</span><br><span class="line">                    // (depending on how getAppStartModeLocked has determined that).</span><br><span class="line">                    <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)</span><br><span class="line">                            || (r.intent.getComponent() == null</span><br><span class="line">                                &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                                &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                                        &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)</span><br><span class="line">                                &amp;&amp; !isSignaturePerm(r.requiredPermissions))) &#123;</span><br><span class="line">                        mService.addBackgroundCheckViolationLocked(r.intent.getAction(),</span><br><span class="line">                                component.getPackageName());</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.isAutoStartAllowed(info.activityInfo.applicationInfo.uid, info.activityInfo.applicationInfo.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                        + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line">                r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">                r.receiver = null;</span><br><span class="line">                r.curFilter = null;</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">            r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">            r.curComponent = component;</span><br><span class="line">            r.curReceiver = info.activityInfo;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">                Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                        + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                        brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Broadcast is being executed, its package can<span class="string">'t be stopped.</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                AppGlobals.getPackageManager().setPackageStoppedState(</span></span><br><span class="line"><span class="string">                        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            &#125; catch (IllegalArgumentException e) &#123;</span></span><br><span class="line"><span class="string">                Slog.w(TAG, "Failed trying to unstop package "</span></span><br><span class="line"><span class="string">                        + r.curComponent.getPackageName() + ": " + e);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 3. 进程已经启动</span></span><br><span class="line"><span class="string">            // Is this receiver'</span>s application already running?</span><br><span class="line">            <span class="keyword">if</span> (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                            info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                    processCurBroadcastLocked(r, app);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                          + r.curComponent, e);</span><br><span class="line">                &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                    Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                            + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line">                    // If some unexpected exception happened, just skip</span><br><span class="line">                    // this broadcast.  At this point we are not <span class="keyword">in</span> the call</span><br><span class="line">                    // from a client, so throwing an exception out from here</span><br><span class="line">                    // will crash the entire system instead of just whoever</span><br><span class="line">                    // sent the broadcast.</span><br><span class="line">                    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                            r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                    // We need to reset the state <span class="keyword">if</span> we failed to start the receiver.</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If a dead object exception was thrown -- fall through to</span><br><span class="line">                // restart the application.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 进程还未启动</span><br><span class="line">            // Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Need to start app ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                    info.activityInfo.applicationInfo, <span class="literal">true</span>,</span><br><span class="line">                    r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                    <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                    (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, <span class="literal">false</span>, <span class="literal">false</span>))</span><br><span class="line">                            == null) &#123;</span><br><span class="line">                // Ah, this recipient is unavailable.  Finish it <span class="keyword">if</span> necessary,</span><br><span class="line">                // and mark the broadcast record as ready <span class="keyword">for</span> the next.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                        + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 5. 进程启动失败</span><br><span class="line">            mPendingBroadcast = r;</span><br><span class="line">            mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // processNextBroadcast完</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.“静态”接收器是ResolveInfo，需要通过PackageManager获取包信息，进行权限检查。权限检查的内容非常庞大，此处不表。</p>
</blockquote>
<blockquote>
<p>2.经过一系列复杂的权限检查后，终于可以向目标接收器派发了。通过AMS.getProcessRecordLocked()获取广播接收器的进程信息</p>
</blockquote>
<blockquote>
<p>3.如果app.thread ！= null，则进程已经启动，就可以调用BroadcastQueue.processCurBroadcastLocked()进行接下来的派发处理了</p>
</blockquote>
<blockquote>
<p>4.如果进程还没有启动，则需要通过AMS.startProcessLocked()来启动进程，当前消息并未派发，调用BroadcastQueue.scheduleBroadcastsLocked()进入下一次的调度</p>
</blockquote>
<blockquote>
<p>5.如果进程启动失败了，则当前消息记录成mPendingBroadcast，即阻塞的广播消息，等待下一次调度时处理</p>
</blockquote>
<p>庞大的processNextBroadcast()终于完结了，它的功能就是对广播消息进行调度，该方法被设计得十分复杂而精巧，用于应对不同的广播消息和接收器的处理。</p>
<p>广播消息的跨进程传递调度是完成了，接下来，我们就来分析被调度广播消息如何到达应用程序。上文的分析中，最终有两个方法将广播消息派发出去： BroadcastQueue.deliverToRegisteredReceiverLocked() 和BroadcastQueue.processCurBroadcastLocked()。</p>
<p>我们先不展开这两个函数的逻辑，试想要将广播消息的从AMS线程所在的system_server进程传递到应用程序的进程，该怎么实现？ 自然需要用到跨进程调用，Android中最常规的手段就是Binder机制。没错，广播消息派发到应用进程就是这么玩的。</p>
<p>对于应用程序已经启动(app.thread != null)的情况，会通过IApplicationThread发起跨进程调用， 调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.ApplicationThread.scheduleReceiver()</span><br><span class="line">└── ActivityThread.handleReceiver()</span><br><span class="line">    └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure></p>
<pre><code>对于应用程序还未启动的情况，会调用IIntentReceiver发起跨进程调用，应用进程的实现在LoadedApk.ReceiverDispatcher.IntentReceiver 中， 调用关系如下：
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadedApk.ReceiverDispatcher.IntentReceiver.performReceive()</span><br><span class="line">└── LoadedApk.ReceiverDispatcher.performReceiver()</span><br><span class="line">    └── LoadedApk.ReceiverDispatcher.Args.run()</span><br><span class="line">        └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure>
<p>最终，都会调用到BroadcastReceiver.onReceive()，在应用进程执行接收广播消息的具体动作。 对于“串行广播消息”而言，执行完了以后，还需要通知system_server进程，才能继续将广播消息派发到下一个接收器，这又需要跨进程调用了。 应用进程在处理完广播消息后，即在BroadcastReceiver.onReceive()执行完毕后，会调用BroadcastReceiver.PendingResult.finish()， 接下来的调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver.PendingResult.finish()</span><br><span class="line">└── BroadcastReceiver.PendingResult.sendFinished()</span><br><span class="line">    └── IActivityManager.finishReceiver()</span><br><span class="line">        └── ActivityManagerService.finishReceiver()</span><br><span class="line">            └── BroadcastQueue.processNextBroadcat()</span><br></pre></td></tr></table></figure></p>
<p>通过IActivityManager发起了一个从应用进程到system_server进程的调用，最终在AMS线程中，又走到了BroadcastQueue.processNextBroadcat(), 开始下一轮的调度。</p>
<p>broadcastTimeoutLocked()方法<br>前文说过，两种ANR机制最终都会调用BroadcastQueue.broadcastTimeoutLocked()方法， 第一种ANR监测生效时，会将fromMsg设置为false;第二种ANR监测生效时，会将fromMsg参数为True时，表示当前正在响应BROADCAST_TIMEOUT_MSG消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">final void broadcastTimeoutLocked(boolean fromMsg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;// 1. 设置mPendingBroadcastTimeoutMessage</span><br><span class="line">            mPendingBroadcastTimeoutMessage = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 判断第二种ANR机制是否超时</span><br><span class="line">        long now = SystemClock.uptimeMillis();</span><br><span class="line">        BroadcastRecord r = mOrderedBroadcasts.get(0);</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">                // Only process broadcast timeouts <span class="keyword">if</span> the system is ready. That way</span><br><span class="line">                // PRE_BOOT_COMPLETED broadcasts can<span class="string">'t timeout as they are intended</span></span><br><span class="line"><span class="string">                // to do heavy lifting for system up.</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            long timeoutTime = r.receiverTime + mTimeoutPeriod;</span></span><br><span class="line"><span class="string">            if (timeoutTime &gt; now) &#123;</span></span><br><span class="line"><span class="string">                // We can observe premature timeouts because we do not cancel and reset the</span></span><br><span class="line"><span class="string">                // broadcast timeout message after each receiver finishes.  Instead, we set up</span></span><br><span class="line"><span class="string">                // an initial timeout then kick it down the road a little further as needed</span></span><br><span class="line"><span class="string">                // when it expires.</span></span><br><span class="line"><span class="string">                if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                        "Premature timeout ["</span></span><br><span class="line"><span class="string">                        + mQueueName + "] @ " + now + ": resetting BROADCAST_TIMEOUT_MSG for "</span></span><br><span class="line"><span class="string">                        + timeoutTime);</span></span><br><span class="line"><span class="string">                setBroadcastTimeoutLocked(timeoutTime);</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BroadcastRecord br = mOrderedBroadcasts.get(0);</span></span><br><span class="line"><span class="string">        if (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span></span><br><span class="line"><span class="string">            // In this case the broadcast had already finished, but we had decided to wait</span></span><br><span class="line"><span class="string">            // for started services to finish as well before going on.  So if we have actually</span></span><br><span class="line"><span class="string">            // waited long enough time timeout the broadcast, let'</span>s give up on the whole thing</span><br><span class="line">            // and just move on to the next.</span><br><span class="line">            Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + (br.curComponent != null</span><br><span class="line">                    ? br.curComponent.flattenToShortString() : <span class="string">"(null)"</span>));</span><br><span class="line">            br.curComponent = null;</span><br><span class="line">            br.state = BroadcastRecord.IDLE;</span><br><span class="line">            processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Timeout of broadcast "</span> + r + <span class="string">" - receiver="</span> + r. receiver</span><br><span class="line">                + <span class="string">", started "</span> + (now - r.receiverTime) + <span class="string">"ms ago"</span>);</span><br><span class="line">        r.receiverTime = now;</span><br><span class="line">        r.anrCount++;</span><br><span class="line"></span><br><span class="line">        ProcessRecord app = null;</span><br><span class="line">        String anrMessage = null;</span><br><span class="line"></span><br><span class="line">        Object curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &gt; 0) &#123;</span><br><span class="line">            curReceiver = r.receivers.get(r.nextReceiver-1);</span><br><span class="line">            r.delivery[r.nextReceiver-1] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curReceiver = r.curReceiver;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Receiver during timeout of "</span> + r + <span class="string">" : "</span> + curReceiver);</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (curReceiver != null &amp;&amp; curReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">            BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">            <span class="keyword">if</span> (bf.receiverList.pid != 0</span><br><span class="line">                    &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">                synchronized (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                    app = mService.mPidsSelfLocked.get(</span><br><span class="line">                            bf.receiverList.pid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = r.curApp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != null) &#123;</span><br><span class="line">            anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast == r) &#123;</span><br><span class="line">            mPendingBroadcast = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 已经超时，则结束对当前接收器，开始新一轮调度</span><br><span class="line">        // Move on to the next receiver.</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">        // 4. 抛出绘制ANR对话框的消息</span><br><span class="line">        <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">            // Post the ANR to the handler since we <span class="keyword">do</span> not want to process ANRs <span class="keyword">while</span></span><br><span class="line">            // potentially holding our lock.</span><br><span class="line">            mHandler.post(new AppNotResponding(app, anrMessage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 1.mPendingBroadcastTimeoutMessage 标识是否存在未处理的BROADCAST_TIMEOUT_MSG 消息， 将其设置成false，允许继续抛出BROADCAST_TIMEOUT_MSG 消息</p>
</blockquote>
<blockquote>
<p> 2.每次将广播派发到接收器，都会将r.receiverTime 更新，如果判断当前还未超时，则又抛出一个 BROADCAST_TIMEOUT_MSG 息。正常情况下，所有接收器处理完毕后，才会清除 BROADCAST_TIMEOUT_MSG ;否则，每进行一次广播消息的调度，都会抛出 BROADCAST_TIMEOUT_MSG 消息</p>
</blockquote>
<blockquote>
<p> 3.判断已经超时了，说明当前的广播接收器还未处理完毕，则结束掉当前的接收器，开始新一轮广播调度</p>
</blockquote>
<blockquote>
<p> 4.最终，发出绘制ANR对话框的消息</p>
</blockquote>
<p>至此，我们回答了前文提出的两个问题:</p>
<p>AMS维护着广播队列BroadcastQueue，AMS线程不断从队列中取出消息进行调度，完成广播消息的派发。 在派发“串行广播消息”时，会抛出一个定时消息 BROADCAST_TIMEOUT_MSG ，在广播接收器处理完毕后，AMS会将定时消息清除。 如果BROADCAST_TIMEOUT_MSG得到了响应，就会判断是否广播消息处理超时，最终通知ANR的发生。</p>
<h4 id="Input处理超时"><a href="#Input处理超时" class="headerlink" title="Input处理超时"></a>Input处理超时</h4><p>应用程序可以接收输入事件(按键、触屏、轨迹球等)，当5秒内没有处理完毕时，则会引发ANR。</p>
<p>如果Broadcast ANR一样，我们抛出Input ANR的几个问题：</p>
<blockquote>
<ol>
<li>输入事件经历了一些什么工序才能被派发到应用的界面？</li>
<li>如何检测到输入时间处理超时</li>
</ol>
</blockquote>
<p>输入事件最开始由硬件设备(譬如按键或触摸屏幕)发起，Android有一套输入子系统来发现各种输入事件， 这些事件最终都会被<a href="https://android.googlesource.com/platform/frameworks/native/+/master/services/inputflinger/InputDispatcher.cpp" target="_blank" rel="noopener">InputDispatcher</a>分发到各个需要接收事件的窗口。 那么，窗口如何告之InputDispatcher自己需要处理输入事件呢？Android通过InputChannel 连接InputDispatcher和窗口，InputChannel其实是封装后的Linux管道(Pipe)。 每一个窗口都会有一个独立的InputChannel，窗口需要将这个InputChannel注册到InputDispatcher中:</p>
<blockquote>
<p>frameworks/native/services/inputflinger/InputDispatcher.cpp</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_REGISTRATION</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ registerInputChannel - monitor=%s"</span>, inputChannel-&gt;getName().string(),</span><br><span class="line">            toString(monitor));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Attempted to register already registered input channel '%s'"</span>,</span><br><span class="line">                    inputChannel-&gt;getName().string());</span><br><span class="line">            <span class="built_in">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        int fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</span><br><span class="line">    &#125; // release lock</span><br><span class="line"></span><br><span class="line">    // Wake the looper because some connections have changed.</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于InputDispatcher而言，每注册一个InputChannel都被视为一个Connection，通过文件描述符来区别。InputDispatcher是一个消息处理循环，当有新的Connection时，就需要唤醒消息循环队列进行处理。</p>
<p>输入事件的类型有很多，按键、轨迹球、触屏等，Android对这些事件进行了分类，处理这些事件的窗口也被赋予了一个类型 (targetType)：Foucused或Touched ，如果当前输入事件是按键类型，则寻找 Focused类型的窗口;如果当前输入事件类型是触摸类型，则寻找Touched类型的窗口。 InputDispatcher需要经过以下复杂的调用关系，才能把一个输入事件派发出去(调用关系以按键事件为例，触屏事件的调用关系类似)：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcherThread::threadLoop()</span><br><span class="line">└── InputDispatcher::dispatchOnce()</span><br><span class="line">    └── InputDispatcher::dispatchOnceInnerLocked()</span><br><span class="line">        └── InputDispatcher::dispatchKeyLocked()</span><br><span class="line">            └── InputDispatcher::dispatchEventLocked()</span><br><span class="line">                └── InputDispatcher::prepareDispatchCycleLocked()</span><br><span class="line">                    └── InputDispatcher::enqueueDispatchEntriesLocked()</span><br><span class="line">                        └── InputDispatcher::startDispatchCycleLocked()</span><br><span class="line">                            └── InputPublisher::publishKeyEvent()</span><br></pre></td></tr></table></figure>
<p>具体每个函数的实现逻辑此处不表。我们提炼出几个关键点：</p>
<blockquote>
<ol>
<li>InputDispatcherThread是一个线程，它处理一次消息的派发</li>
<li>输入事件作为一个消息，需要排队等待派发，每一个Connection都维护两个队列：<br>outboundQueue: 等待发送给窗口的事件。每一个新消息到来，都会先进入到此队列<br>waitQueue: 已经发送给窗口的事件</li>
<li>publishKeyEvent完成后，表示事件已经派发了，就将事件从outboundQueue挪到了waitQueue</li>
</ol>
</blockquote>
<p>事件经过这么一轮处理，就算是从InputDispatcher派发出去了，但事件是不是被窗口收到了，还需要等待接收方的“finished”通知。 在向InputDispatcher 注册InputChannel 的时候，同时会注册一个回调函数handleReceiveCallback():</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) &#123;</span><br><span class="line">    InputDispatcher* d = static_cast&lt;InputDispatcher*&gt;(data);</span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(d-&gt;mLock);</span><br><span class="line"></span><br><span class="line">        ssize_t connectionIndex = d-&gt;mConnectionsByFd.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &lt; 0) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Received spurious receive callback for unknown input channel.  "</span></span><br><span class="line">                    <span class="string">"fd=%d, events=0x%x"</span>, fd, events);</span><br><span class="line">            <span class="built_in">return</span> 0; // remove the callback</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool notify;</span><br><span class="line">        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(events &amp; ALOOPER_EVENT_INPUT)) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName(), events);</span><br><span class="line">                <span class="built_in">return</span> 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nsecs_t currentTime = now();</span><br><span class="line">            bool gotOne = <span class="literal">false</span>;</span><br><span class="line">            status_t status;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                uint32_t seq;</span><br><span class="line">                bool handled;</span><br><span class="line">                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);</span><br><span class="line">                <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);</span><br><span class="line">                gotOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotOne) &#123;</span><br><span class="line">                d-&gt;runCommandsLockedInterruptible();</span><br><span class="line">                <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                    <span class="built_in">return</span> 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notify = status != DEAD_OBJECT || !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Failed to receive finished signal.  status=%d"</span>,</span><br><span class="line">                        connection-&gt;getInputChannelName(), status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // Monitor channels are never explicitly unregistered.</span><br><span class="line">            // We <span class="keyword">do</span> it automatically when the remote endpoint is closed so don<span class="string">'t warn</span></span><br><span class="line"><span class="string">            // about them.</span></span><br><span class="line"><span class="string">            notify = !connection-&gt;monitor;</span></span><br><span class="line"><span class="string">            if (notify) &#123;</span></span><br><span class="line"><span class="string">                ALOGW("channel '</span>%s<span class="string">' ~ Consumer closed input channel or an error occurred.  "</span></span><br><span class="line"><span class="string">                        "events=0x%x", connection-&gt;getInputChannelName(), events);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Unregister the channel.</span></span><br><span class="line"><span class="string">        d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);</span></span><br><span class="line"><span class="string">        return 0; // remove the callback</span></span><br><span class="line"><span class="string">    &#125; // release lock</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>当收到的status为OK时，会调用finishDispatchCycleLocked()来完成一个消息的处理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::finishDispatchCycleLocked()</span><br><span class="line">└── InputDispatcher::onDispatchCycleFinishedLocked()</span><br><span class="line">    └── InputDispatcher::doDispatchCycleFinishedLockedInterruptible()</span><br><span class="line">        └── InputDispatcher::startDispatchCycleLocked()</span><br></pre></td></tr></table></figure>
<p>调用到doDispatchCycleFinishedLockedInterruptible() 方法时，会将已经成功派发的消息从waitQueue中移除， 进一步调用会 startDispatchCycleLocked开始派发新的事件。</p>
<p>至此，我们回答了第一个问题：</p>
<p>一个正常的输入事件会经过从outboundQueue挪到waitQueue的过程，表示消息已经派发出去;再经过从waitQueue中移除的过程，表示消息已经被窗口接收。InputDispatcher作为中枢，不停地在递送着输入事件，当一个事件无法得到处理的时候，InputDispatcher不能就此死掉啊，否则系统也太容易崩溃了。 InputDispatcher 的策略是放弃掉处理不过来的事件， 并发出通知(这个通知机制就是ANR)，继续进行下一轮消息的处理。</p>
<blockquote>
<p>理解输入事件分发模型，我们可以举一个生活中的例子：<br>每一个输入事件可以比做一个快递，InputDispatcher就像一个快递中转站，窗口就像是收件人，InputChannel就像是快递员。 所有快递都会经过中转站中处理，中转站需要知道每一个快递的收件人是谁，通过快递员将快递发送到具体的收件人。 这其中有很多场景导致快递不能及时送到：譬如联系不到收件人;快递很多，快递员会忙不过来;快递员受伤休假了等等… 这时候快递员就需要告知中转站：有快递无法及时送到了。中转站在收到快递员的通知后，一边继续派发其他快递，一边报告上级。</p>
</blockquote>
<p>在了解输入事件分发模型之后，我们可以见识一下ANR机制了。在派发事件时，dispatchKeyLocked()和dispatchMotionLocked()， 需要找到当前的焦点窗口 ,焦点窗口才是最终接收事 件的地方，找窗口的过程就会判断是否已经发生了ANR：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::findFocusedWindowTargetsLocked()</span><br><span class="line">InputDispatcher::findTouchedWindowTargetsLocked()</span><br><span class="line">└── InputDispatcher::handleTargetsNotReadyLocked()</span><br><span class="line">    └── InputDispatcher::onANRLocked()</span><br><span class="line">        └── InputDispatcher::doNotifyANRLockedInterruptible()</span><br><span class="line">            └── NativeInputManager::notifyANR()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先，会调用findFocusedWindowTargetsLocked()或findTouchedWindowTargetsLocked()寻找接收输入事件的窗口。在找到窗口以后，会调用checkWindowReadyForMoreInputLocked() 检查窗口是否有能力再接收新的输入事件，会有一系列的场景阻碍事件的继续派发：</p>
<ul>
<li><p><strong>场景1:</strong> 窗口处于paused状态，不能处理输入事件“Waiting because the [targetType] window is paused.”</p>
</li>
<li><p><strong>场景2:</strong> 窗口还未向InputDispatcher注册，无法将事件派发到窗口“Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.”</p>
</li>
<li><p><strong>场景3:</strong> 窗口和InputDispatcher的连接已经中断，即InputChannel不能正常工作“Waiting because the [targetType] window’s input connection is [status]. The window may be in the process of being removed.”</p>
</li>
<li><p><strong>场景4:</strong> InputChannel已经饱和，不能再处理新的事件“Waiting because the [targetType] window’s input channel is full. Outbound queue length: %d. Wait queue length: %d.”</p>
</li>
<li><p><strong>场景5:</strong> 对于按键类型(KeyEvent)的输入事件，需要等待上一个事件处理完毕“Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: %d. Wait queue length: %d.”</p>
</li>
<li><p><strong>场景6:</strong> 对于触摸类型(TouchEvent)的输入事件，可以立即派发到当前的窗口，因为TouchEvent都是发生在用户当前可见的窗口。但有一种情况，如果当前应用由于队列有太多的输入事件等待派发，导致发生了ANR，那TouchEvent事件就需要排队等待派发。“Waiting to send non-key event because the %s window has not finished processing certain input events that were delivered to it over %0.1fms ago. Wait queue length: %d. Wait queue head age: %0.1fms.”</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">String8 InputDispatcher::checkWindowReadyForMoreInputLocked(nsecs_t currentTime,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle, const EventEntry* eventEntry,</span><br><span class="line">        const char* targetType) &#123;</span><br><span class="line">    // If the window is paused <span class="keyword">then</span> keep waiting.</span><br><span class="line">    <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;paused) &#123;</span><br><span class="line">        <span class="built_in">return</span> String8::format(<span class="string">"Waiting because the %s window is paused."</span>, targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the window<span class="string">'s connection is not registered then keep waiting.</span></span><br><span class="line"><span class="string">    ssize_t connectionIndex = getConnectionIndexLocked(windowHandle-&gt;getInputChannel());</span></span><br><span class="line"><span class="string">    if (connectionIndex &lt; 0) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is not <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>registered with the input dispatcher.  The window may be <span class="keyword">in</span> the process <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>of being removed.<span class="string">", targetType);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is dead then keep waiting.</span></span><br><span class="line"><span class="string">    sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span></span><br><span class="line"><span class="string">    if (connection-&gt;status != Connection::STATUS_NORMAL) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("</span>Waiting because the %s window<span class="string">'s input connection is %s."</span></span><br><span class="line"><span class="string">                "The window may be in the process of being removed.", targetType,</span></span><br><span class="line"><span class="string">                connection-&gt;getStatusLabel());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is backed up then keep waiting.</span></span><br><span class="line"><span class="string">    if (connection-&gt;inputPublisherBlocked) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is full.  <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Ensure that the dispatch queues aren't too far backed up for this event.</span></span><br><span class="line"><span class="string">    if (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;</span></span><br><span class="line"><span class="string">        // If the event is a key event, then we must wait for all previous events to</span></span><br><span class="line"><span class="string">        // complete before delivering it because previous events may have the</span></span><br><span class="line"><span class="string">        // side-effect of transferring focus to a different window and we want to</span></span><br><span class="line"><span class="string">        // ensure that the following keys are sent to the new window.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Suppose the user touches a button in a window then immediately presses "</span>A<span class="string">".</span></span><br><span class="line"><span class="string">        // If the button causes a pop-up window to appear then we want to ensure that</span></span><br><span class="line"><span class="string">        // the "</span>A<span class="string">" key is delivered to the new pop-up window.  This is because users</span></span><br><span class="line"><span class="string">        // often anticipate pending UI changes when typing on a keyboard.</span></span><br><span class="line"><span class="string">        // To obtain this behavior, we must serialize key events with respect to all</span></span><br><span class="line"><span class="string">        // prior input events.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;outboundQueue.isEmpty() || !connection-&gt;waitQueue.isEmpty()) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing all of the input events that were previously <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>delivered to it.  Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Touch events can always be sent to a window immediately because the user intended</span></span><br><span class="line"><span class="string">        // to touch whatever was visible at the time.  Even if focus changes or a new</span></span><br><span class="line"><span class="string">        // window appears moments later, the touch event was meant to be delivered to</span></span><br><span class="line"><span class="string">        // whatever window happened to be on screen at the time.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Generic motion events, such as trackball or joystick events are a little trickier.</span></span><br><span class="line"><span class="string">        // Like key events, generic motion events are delivered to the focused window.</span></span><br><span class="line"><span class="string">        // Unlike key events, generic motion events don't tend to transfer focus to other</span></span><br><span class="line"><span class="string">        // windows and it is not important for them to be serialized.  So we prefer to deliver</span></span><br><span class="line"><span class="string">        // generic motion events as soon as possible to improve efficiency and reduce lag</span></span><br><span class="line"><span class="string">        // through batching.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // The one case where we pause input event delivery is when the wait queue is piling</span></span><br><span class="line"><span class="string">        // up with lots of events because the application is not responding.</span></span><br><span class="line"><span class="string">        // This condition ensures that ANRs are detected reliably.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;waitQueue.isEmpty()</span></span><br><span class="line"><span class="string">                &amp;&amp; currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime</span></span><br><span class="line"><span class="string">                        + STREAM_AHEAD_EVENT_TIMEOUT) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send non-key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing certain input events that were delivered to it over <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>%0.1fms ago.  Wait queue length: %d.  Wait queue head age: %0.1fms.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, STREAM_AHEAD_EVENT_TIMEOUT * 0.000001f,</span></span><br><span class="line"><span class="string">                    connection-&gt;waitQueue.count(),</span></span><br><span class="line"><span class="string">                    (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) * 0.000001f);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return String8::empty();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后，上述有任何一个场景发生了，则输入事件需要继续等待，紧接着就会调用handleTargetsNotReadyLocked()来判断是不是已经的等待超时了：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime,</span><br><span class="line">        const EventEntry* entry,</span><br><span class="line">        const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t* nextWakeupTime, const char* reason) &#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationHandle == NULL &amp;&amp; windowHandle == NULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for system to become ready for input.  Reason: %s"</span>, reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = LONG_LONG_MAX;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for application to become ready for input: %s.  Reason: %s"</span>,</span><br><span class="line">                    getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">                    reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            nsecs_t timeout;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationHandle != NULL) &#123;</span><br><span class="line">                timeout = applicationHandle-&gt;getDispatchingTimeout(</span><br><span class="line">                        DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = currentTime + timeout;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitApplicationHandle == NULL &amp;&amp; applicationHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = applicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputTargetWaitTimeoutExpired) &#123;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;</span><br><span class="line">        onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                entry-&gt;eventTime, mInputTargetWaitStartTime, reason);</span><br><span class="line"></span><br><span class="line">        // Force poll loop to wake up immediately on next iteration once we get the</span><br><span class="line">        // ANR response back from the policy.</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // Force poll loop to wake up when timeout is due.</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitTimeoutTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">            *nextWakeupTime = mInputTargetWaitTimeoutTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后，如果当前事件派发已经超时，则说明已经检测到了ANR，调用onANRLocked()方法，然后将nextWakeupTime设置为最小值，马上开始下一轮调度。 在onANRLocked()方法中， 会保存ANR的一些状态信息，调用doNotifyANRLockedInterruptible()，进一步会调用到JNI层的 NativeInputManager::notifyANR()方法， 它的主要功能就是衔接Native层和  Java层，直接调用Java层的InputManagerService.notifyANR()方法。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::onANRLocked(</span><br><span class="line">        nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) &#123;</span><br><span class="line">    <span class="built_in">float</span> dispatchLatency = (currentTime - eventTime) * 0.000001f;</span><br><span class="line">    <span class="built_in">float</span> waitDuration = (currentTime - waitStartTime) * 0.000001f;</span><br><span class="line">    ALOGI(<span class="string">"Application is not responding: %s.  "</span></span><br><span class="line">            <span class="string">"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">            dispatchLatency, waitDuration, reason);</span><br><span class="line"></span><br><span class="line">    // Capture a record of the InputDispatcher state at the time of the ANR.</span><br><span class="line">    time_t t = time(NULL);</span><br><span class="line">    struct tm tm;</span><br><span class="line">    localtime_r(&amp;t, &amp;tm);</span><br><span class="line">    char timestr[64];</span><br><span class="line">    strftime(timestr, sizeof(timestr), <span class="string">"%F %T"</span>, &amp;tm);</span><br><span class="line">    mLastANRState.clear();</span><br><span class="line">    mLastANRState.append(INDENT <span class="string">"ANR:\n"</span>);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Time: %s\n"</span>, timestr);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Window: %s\n"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string());</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"DispatchLatency: %0.1fms\n"</span>, dispatchLatency);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"WaitDuration: %0.1fms\n"</span>, waitDuration);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Reason: %s\n"</span>, reason);</span><br><span class="line">    dumpDispatchStateLocked(mLastANRState);</span><br><span class="line"></span><br><span class="line">    CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">            &amp; InputDispatcher::doNotifyANRLockedInterruptible);</span><br><span class="line">    commandEntry-&gt;inputApplicationHandle = applicationHandle;</span><br><span class="line">    commandEntry-&gt;inputWindowHandle = windowHandle;</span><br><span class="line">    commandEntry-&gt;reason = reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::doNotifyANRLockedInterruptible(</span><br><span class="line">        CommandEntry* commandEntry) &#123;</span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    nsecs_t newTimeout = mPolicy-&gt;notifyANR(</span><br><span class="line">            commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle,</span><br><span class="line">            commandEntry-&gt;reason);</span><br><span class="line"></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    resumeAfterTargetsNotReadyTimeoutLocked(newTimeout,</span><br><span class="line">            commandEntry-&gt;inputWindowHandle != NULL</span><br><span class="line">                    ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(NULL), mLastDropReason(DROP_REASON_NOT_DROPPED),</span><br><span class="line">    mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(NULL),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    mLooper = new Looper(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = NULL;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到mPolicy是InputDispatcherPolicyInterface,对应的在JNI层frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class NativeInputManager : public virtual RefBase,</span><br><span class="line">    public virtual InputReaderPolicyInterface,</span><br><span class="line">    public virtual InputDispatcherPolicyInterface,</span><br><span class="line">    public virtual PointerControllerPolicyInterface &#123;</span><br><span class="line">protected:</span><br><span class="line">    virtual ~NativeInputManager();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</span><br><span class="line"></span><br><span class="line">    inline sp&lt;InputManager&gt; getInputManager() const &#123; <span class="built_in">return</span> mInputManager; &#125;</span><br><span class="line"></span><br><span class="line">    void dump(String8&amp; dump);</span><br><span class="line"></span><br><span class="line">    void setVirtualDisplayViewports(JNIEnv* env, jobjectArray viewportObjArray);</span><br><span class="line">    void setDisplayViewport(int32_t viewportType, const DisplayViewport&amp; viewport);</span><br><span class="line"></span><br><span class="line">    status_t registerInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor);</span><br><span class="line">    status_t unregisterInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel);</span><br><span class="line"></span><br><span class="line">    void setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray);</span><br><span class="line">    void setFocusedApplication(JNIEnv* env, jobject applicationHandleObj);</span><br><span class="line">    void setInputDispatchMode(bool enabled, bool frozen);</span><br><span class="line">    void setSystemUiVisibility(int32_t visibility);</span><br><span class="line">    void setPointerSpeed(int32_t speed);</span><br><span class="line">    void setInputDeviceEnabled(uint32_t deviceId, bool enabled);</span><br><span class="line">    void setShowTouches(bool enabled);</span><br><span class="line">    void setInteractive(bool interactive);</span><br><span class="line">    void reloadCalibration();</span><br><span class="line">    void setPointerIconType(int32_t iconId);</span><br><span class="line">    void reloadPointerIcons();</span><br><span class="line">    void setCustomPointerIcon(const SpriteIcon&amp; icon);</span><br><span class="line">    void setPointerCapture(bool enabled);</span><br><span class="line"></span><br><span class="line">    /* --- InputReaderPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void getReaderConfiguration(InputReaderConfiguration* outConfig);</span><br><span class="line">    virtual sp&lt;PointerControllerInterface&gt; obtainPointerController(int32_t deviceId);</span><br><span class="line">    virtual void notifyInputDevicesChanged(const Vector&lt;InputDeviceInfo&gt;&amp; inputDevices);</span><br><span class="line">    virtual sp&lt;KeyCharacterMap&gt; getKeyboardLayoutOverlay(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual String8 getDeviceAlias(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(JNIEnv *env,</span><br><span class="line">            jfloatArray matrixArr);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(</span><br><span class="line">            const String8&amp; inputDeviceDescriptor, int32_t surfaceRotation);</span><br><span class="line"></span><br><span class="line">    /* --- InputDispatcherPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void notifySwitch(nsecs_t when, uint32_t switchValues, uint32_t switchMask,</span><br><span class="line">            uint32_t policyFlags);</span><br><span class="line">    virtual void notifyConfigurationChanged(nsecs_t when);</span><br><span class="line">    virtual nsecs_t notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const String8&amp; reason);</span><br><span class="line">    virtual void notifyInputChannelBroken(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle);</span><br><span class="line">    virtual bool filterInputEvent(const InputEvent* inputEvent, uint32_t policyFlags);</span><br><span class="line">    virtual void getDispatcherConfiguration(InputDispatcherConfiguration* outConfig);</span><br><span class="line">    virtual void interceptKeyBeforeQueueing(const KeyEvent* keyEvent, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual void interceptMotionBeforeQueueing(nsecs_t when, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual nsecs_t interceptKeyBeforeDispatching(</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags);</span><br><span class="line">    virtual bool dispatchUnhandledKey(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags, KeyEvent* outFallbackKeyEvent);</span><br><span class="line">    virtual void pokeUserActivity(nsecs_t eventTime, int32_t eventType);</span><br><span class="line">    virtual bool checkInjectEventsPermissionNonReentrant(</span><br><span class="line">            int32_t injectorPid, int32_t injectorUid);</span><br><span class="line"></span><br><span class="line">    /* --- PointerControllerPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void loadPointerIcon(SpriteIcon* icon);</span><br><span class="line">    virtual void loadPointerResources(PointerResources* outResources);</span><br><span class="line">    virtual void loadAdditionalMouseResources(std::map&lt;int32_t, SpriteIcon&gt;* outResources,</span><br><span class="line">            std::map&lt;int32_t, PointerAnimation&gt;* outAnimationResources);</span><br><span class="line">    virtual int32_t getDefaultPointerIconId();</span><br><span class="line">    virtual int32_t getCustomPointerIconId();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>JNI层中notifyANR的实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">nsecs_t NativeInputManager::notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, const String8&amp; reason) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_INPUT_DISPATCHER_POLICY</span></span><br><span class="line">    ALOGD(<span class="string">"notifyANR"</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    // 将应用程序句柄、窗口句柄、ANR原因字符串，转化为Java层的对象</span><br><span class="line">    jobject inputApplicationHandleObj =</span><br><span class="line">            getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);</span><br><span class="line">    jobject inputWindowHandleObj =</span><br><span class="line">            getInputWindowHandleObjLocalRef(env, inputWindowHandle);</span><br><span class="line">    jstring reasonObj = env-&gt;NewStringUTF(reason.string());</span><br><span class="line"></span><br><span class="line">    // 调用Java层的InputManagerService.notifyANR()方法</span><br><span class="line">    jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,</span><br><span class="line">                gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,</span><br><span class="line">                reasonObj);</span><br><span class="line">    <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"notifyANR"</span>)) &#123;</span><br><span class="line">        newTimeout = 0; // abort dispatch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(newTimeout &gt;= 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(reasonObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputWindowHandleObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputApplicationHandleObj);</span><br><span class="line">    <span class="built_in">return</span> newTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，ANR的处理逻辑转交到了Java层。底层(Native)发现一旦有输入事件派发超时，就会通知上层(Java)，上层收到ANR通知后，决定是否终止当前输入事件的派发。</p>
<p>发生ANR时，Java层最开始的入口是InputManagerService.notifyANR()，它是直接被Native层调用的。我们先把ANR的Java层调用关系列出来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputManagerService.notifyANR()</span><br><span class="line">└── InputMonitor.notifyANR()</span><br><span class="line">    ├── IApplicationToken.keyDispatchingTimedOut()</span><br><span class="line">    │   └── ActivityRecord.keyDispatchingTimedOut()</span><br><span class="line">    │       └── AMS.inputDispatchingTimedOut()</span><br><span class="line">    │           └── AMS.appNotResponding()</span><br><span class="line">    │</span><br><span class="line">    └── AMS.inputDispatchingTimedOut()</span><br><span class="line">        └── AMS.appNotResponding()</span><br></pre></td></tr></table></figure>
<p>在Java层的InputManagerService代码: frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private WindowManagerCallbacks mWindowManagerCallbacks;</span><br><span class="line">....</span><br><span class="line"> // Native callback.</span><br><span class="line"> private long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">         InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">     <span class="built_in">return</span> mWindowManagerCallbacks.notifyANR(</span><br><span class="line">             inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>WindowManagerCallbacks由 InputMonitor.java实现： frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java<br>InputManagerService.notifyANR()只是为Native层定义了一个接口，它直接调用InputMonitor.notifyANR()。 如果该方法的返回值等于0, 则放弃本次输入事件;如果大于0, 则表示 需要继续等待的时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">final class InputMonitor implements InputManagerService.WindowManagerCallbacks &#123;</span><br><span class="line">    private final WindowManagerService mService;</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">    /* Notifies the window manager about an application that is not responding.</span><br><span class="line">     * Returns a new timeout to <span class="built_in">continue</span> waiting <span class="keyword">in</span> nanoseconds, or 0 to abort dispatch.</span><br><span class="line">     *</span><br><span class="line">     * Called by the InputManager.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">            InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">        AppWindowToken appWindowToken = null;</span><br><span class="line">        WindowState windowState = null;</span><br><span class="line">        boolean aboveSystem = <span class="literal">false</span>;</span><br><span class="line">        synchronized (mService.mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputWindowHandle != null) &#123;</span><br><span class="line">                windowState = (WindowState) inputWindowHandle.windowState;</span><br><span class="line">                <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                    appWindowToken = windowState.mAppToken;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (appWindowToken == null &amp;&amp; inputApplicationHandle != null) &#123;</span><br><span class="line">                appWindowToken = (AppWindowToken)inputApplicationHandle.appWindowToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to "</span> + windowState.mAttrs.getTitle()</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">                // Figure out whether this window is layered above system windows.</span><br><span class="line">                // We need to <span class="keyword">do</span> this here to <span class="built_in">help</span> the activity manager know how to</span><br><span class="line">                // layer its ANR dialog.</span><br><span class="line">                int systemAlertLayer = mService.mPolicy.getWindowLayerFromTypeLw(</span><br><span class="line">                        TYPE_APPLICATION_OVERLAY, windowState.mOwnerCanAddInternalSystemWindow);</span><br><span class="line">                aboveSystem = windowState.mBaseLayer &gt; systemAlertLayer;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appWindowToken != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to application "</span> + appWindowToken.stringName</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mService.saveANRStateLocked(appWindowToken, windowState, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // All the calls below need to happen without the WM lock held since they call into AM.</span><br><span class="line">        mService.mAmInternal.saveANRState(reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) &#123;</span><br><span class="line">        	// appToken实际上就是当前的ActivityRecord。</span><br><span class="line">            // 如果发生ANR的Activity还存在，则直接通过ActivityRecord通知事件派发超时</span><br><span class="line">            // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">            // to abort dispatching or keep waiting.</span><br><span class="line">            final AppWindowContainerController controller = appWindowToken.getController();</span><br><span class="line">            final boolean abort = controller != null</span><br><span class="line">                    &amp;&amp; controller.keyDispatchingTimedOut(reason,</span><br><span class="line">                            (windowState != null) ? windowState.mSession.mPid : -1);</span><br><span class="line">            <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">                // The activity manager declined to abort dispatching.</span><br><span class="line">                // Wait a bit longer and timeout again later.</span><br><span class="line">                <span class="built_in">return</span> appWindowToken.mInputDispatchingTimeoutNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">        	// 如果发生ANR的Activity已经销毁了，则通过AMS通知事件派发超时</span><br><span class="line">            try &#123;</span><br><span class="line">                // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">                // to abort dispatching or keep waiting.</span><br><span class="line">                long timeout = ActivityManager.getService().inputDispatchingTimedOut(</span><br><span class="line">                        windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt;= 0) &#123;</span><br><span class="line">                    // The activity manager declined to abort dispatching.</span><br><span class="line">                    // Wait a bit longer and timeout again later.</span><br><span class="line">                    <span class="built_in">return</span> timeout * 1000000L; // nanoseconds</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> 0; // abort dispatching</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述方法中有两种不同的调用方式，但最终都会交由AMS.inputDispatchingTimedOut()处理。AMS有重载的inputDispatchingTimedOut()方法，他们的参数不一样。 ActivityRecord 调用时，可以传入的信息更多一点(当前发生ANR的界面是哪一个)。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord proc;</span><br><span class="line">        long timeout;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                proc = mPidsSelfLocked.get(pid);// 1. 根据进程号获取到ProcessRecord</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 获取超时时间</span><br><span class="line">            // 测试环境下的超时时间是INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT(60秒)，</span><br><span class="line">            // 正常环境下的超时时间是KEY_DISPATCHING_TIMEOUT(5秒)</span><br><span class="line">            timeout = getInputDispatchingTimeoutLocked(proc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用重载的函数，如果返回True，则表示需要中断当前的事件派发;</span><br><span class="line">        <span class="keyword">if</span> (inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 返回继续等待的时间，这个值会传递到Native层</span><br><span class="line">        <span class="built_in">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Handle input dispatching timeouts.</span><br><span class="line">     * Returns whether input dispatching should be aborted or not.</span><br><span class="line">     */</span><br><span class="line">    public boolean inputDispatchingTimedOut(final ProcessRecord proc,</span><br><span class="line">            final ActivityRecord activity, final ActivityRecord parent,</span><br><span class="line">            final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String annotation;</span><br><span class="line">        <span class="keyword">if</span> (reason == null) &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out ("</span> + reason + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proc != null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                <span class="keyword">if</span> (proc.debugging) &#123;// 1. 发生ANR进程正处于调试状态，不需要中断事件</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2. 发生ANR的进程是测试进程，需要中断，但不在UI界面显示ANR信息判断</span><br><span class="line">                <span class="keyword">if</span> (proc.instr != null) &#123;</span><br><span class="line">                    Bundle info = new Bundle();</span><br><span class="line">                    info.putString(<span class="string">"shortMsg"</span>, <span class="string">"keyDispatchingTimedOut"</span>);</span><br><span class="line">                    info.putString(<span class="string">"longMsg"</span>, annotation);</span><br><span class="line">                    finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3. 通知UI界面显示ANR信息</span><br><span class="line">            mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                    mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们回答了第二个问题：</p>
<p>在InputDispatcher派发输入事件时，会寻找接收事件的窗口，如果无法正常派发，则可能会导致当前需要派发的事件超时(默认是5秒)。 Native层发现超时了，会通知Java层，Java层经过一些处理后，会反馈给Native层，是继续等待还是丢弃当前派发的事件。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ANR监测机制包含三种：</p>
<blockquote>
<ul>
<li>Service ANR，前台进程中Service生命周期不能超过20秒，后台进程中Service的生命周期不能超过200秒。 在启动Service时，抛出定时消息SERVICE_TIMEOUT_MSG或SERVICE_BACKGOURND_TIMEOUT_MSG，如果定时消息响应了，则说明发生了ANR</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Broadcast ANR，前台的“串行广播消息”必须在10秒内处理完毕，后台的“串行广播消息”必须在60秒处理完毕， 每派发串行广播消息到一个接收器时，都会抛出一个定时消息BROADCAST_TIMEOUT_MSG，如果定时消息响应，则判断是否广播消息处理超时，超时就说明发生了ANR</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Input ANR，输入事件必须在5秒内处理完毕。在派发一个输入事件时，会判断当前输入事件是否需要等待，如果需要等待，则判断是否等待已经超时，超时就说明发生了ANR</li>
</ul>
</blockquote>
<p>ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对几种操作的响应;否则，就可以认为应用程序主线程失去响应能力。</p>
<p>从ANR的三种监测机制中，我们看到不同超时机制的设计：</p>
<p>Service和Broadcast都是由AMS调度，利用Handler和Looper，设计了一个TIMEOUT消息交由AMS线程来处理，整个超时机制的实现都是在Java层； InputEvent由InputDispatcher调度，待处理的输入事件都会进入队列中等待，设计了一个等待超时的判断，超时机制的实现在Native层。</p>
<h3 id="ANR的报告机制"><a href="#ANR的报告机制" class="headerlink" title="ANR的报告机制"></a>ANR的报告机制</h3><p>无论哪种类型的ANR发生以后，最终都会调用 AMS.appNotResponding() 方法，所谓“殊途同归”。这个方法的职能就是向用户或开发者报告ANR发生了。 最终的表现形式是：弹出一个对话框，告诉用户当前某个程序无响应;输入一大堆与ANR相关的日志，便于开发者解决问题。</p>
<p>最终形式我们见过很多，但输出日志的原理是什么，未必所有人都了解，下面我们就来认识一下是如何输出ANR日志的。</p>
<p>在  <a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/AppErrors.java" target="_blank" rel="noopener">AppErrors.java</a>  frameworks/base/services/core/java/com/android/server/am/AppErrors.java中处理ANR的弹框<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">final void appNotResponding(ProcessRecord app, ActivityRecord activity,</span><br><span class="line">        ActivityRecord parent, boolean aboveSystem, final String annotation) &#123;</span><br><span class="line">        // app: 当前发生ANR的进程</span><br><span class="line">		// activity: 发生ANR的界面</span><br><span class="line">		// parent: 发生ANR的界面的上一级界面</span><br><span class="line">		// aboveSystem:</span><br><span class="line">		// annotation: 发生ANR的原因</span><br><span class="line">    ArrayList&lt;Integer&gt; firstPids = new ArrayList&lt;Integer&gt;(5);</span><br><span class="line">    SparseArray&lt;Boolean&gt; lastPids = new SparseArray&lt;Boolean&gt;(20);</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 0 == <span class="built_in">continue</span>, -1 = <span class="built_in">kill</span> process immediately</span><br><span class="line">            int res = mService.mController.appEarlyNotResponding(</span><br><span class="line">                    app.processName, app.pid, annotation);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">                app.kill(<span class="string">"anr"</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            mService.mController = null;</span><br><span class="line">            Watchdog.getInstance().setActivityController(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long anrTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;// 1. 更新CPU使用信息。ANR的第一次CPU信息采样</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">    &#125;</span><br><span class="line">    // Unless configured otherwise, swallow ANRs <span class="keyword">in</span> background processes &amp; <span class="built_in">kill</span> the process.</span><br><span class="line">    boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">            Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;</span><br><span class="line">    boolean isSilentANR;</span><br><span class="line">    synchronized (mService) &#123;</span><br><span class="line">        // PowerManager.reboot() can block <span class="keyword">for</span> a long time, so ignore ANRs <span class="keyword">while</span> shutting down.</span><br><span class="line">        <span class="keyword">if</span> (mService.mShuttingDown) &#123;//正在关机过程中的ANR，直接忽视掉</span><br><span class="line">            Slog.i(TAG, <span class="string">"During shutdown skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.notResponding) &#123;//重复的ANR，直接忽略掉，不重复弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping duplicate ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.crashing) &#123;//APP crash 引起的ANR，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Crashing app skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killedByAm) &#123;// APP 已经被 AM <span class="built_in">kill</span>掉的，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"App already killed by AM skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killed) &#123;//APP 已经挂掉了，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping died app ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // In <span class="keyword">case</span> we come through here <span class="keyword">for</span> the same app before completing</span><br><span class="line">        // this one, mark as anring now so we will bail out.</span><br><span class="line">        app.notResponding = <span class="literal">true</span>;</span><br><span class="line">        // Log the ANR to the event <span class="built_in">log</span>.</span><br><span class="line">        //2.将ANR 信息写入event <span class="built_in">log</span>中</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,</span><br><span class="line">                app.processName, app.info.flags, annotation);</span><br><span class="line">        // Dump thread traces as quickly as we can, starting with <span class="string">"interesting"</span> processes.</span><br><span class="line">        // 3. 填充firstPids和lastPids数组。从最近运行进程(Last Recently Used)中挑选：</span><br><span class="line">		//    firstPids用于保存ANR进程及其父进程，system_server进程和persistent的进程(譬如Phone进程)</span><br><span class="line">		//    lastPids用于保存除firstPids外的其他进程</span><br><span class="line">        firstPids.add(app.pid);</span><br><span class="line">        // Don<span class="string">'t dump other PIDs if it'</span>s a background ANR</span><br><span class="line">        isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);</span><br><span class="line">        <span class="keyword">if</span> (!isSilentANR) &#123;</span><br><span class="line">            int parentPid = app.pid;</span><br><span class="line">            <span class="keyword">if</span> (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) &#123;</span><br><span class="line">                parentPid = parent.app.pid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid != app.pid) firstPids.add(parentPid);</span><br><span class="line">            <span class="keyword">if</span> (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</span><br><span class="line">            <span class="keyword">for</span> (int i = mService.mLruProcesses.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                ProcessRecord r = mService.mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (r != null &amp;&amp; r.thread != null) &#123;</span><br><span class="line">                    int pid = r.pid;</span><br><span class="line">                    <span class="keyword">if</span> (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.persistent) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding persistent proc: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.treatLikeActivity) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding likely IME: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastPids.put(pid, Boolean.TRUE);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding ANR proc: "</span> + r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Log the ANR to the main <span class="built_in">log</span>. </span><br><span class="line">    //4. 将ANR信息输出到 main <span class="built_in">log</span>中</span><br><span class="line">    StringBuilder info = new StringBuilder();</span><br><span class="line">    info.setLength(0);</span><br><span class="line">    info.append(<span class="string">"ANR in "</span>).append(app.processName);</span><br><span class="line">    <span class="keyword">if</span> (activity != null &amp;&amp; activity.shortComponentName != null) &#123;</span><br><span class="line">        info.append(<span class="string">" ("</span>).append(activity.shortComponentName).append(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(<span class="string">"\n"</span>);</span><br><span class="line">    info.append(<span class="string">"PID: "</span>).append(app.pid).append(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (annotation != null) &#123;</span><br><span class="line">        info.append(<span class="string">"Reason: "</span>).append(annotation).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != null &amp;&amp; parent != activity) &#123;</span><br><span class="line">        info.append(<span class="string">"Parent: "</span>).append(parent.shortComponentName).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(<span class="literal">true</span>);</span><br><span class="line">    // don<span class="string">'t dump native PIDs for background ANRs unless it is the process of interest</span></span><br><span class="line"><span class="string">    String[] nativeProcs = null;</span></span><br><span class="line"><span class="string">    if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">        for (int i = 0; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;</span></span><br><span class="line"><span class="string">            if (NATIVE_STACKS_OF_INTEREST[i].equals(app.processName)) &#123;</span></span><br><span class="line"><span class="string">                nativeProcs = new String[] &#123; app.processName &#125;;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        nativeProcs = NATIVE_STACKS_OF_INTEREST;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int[] pids = nativeProcs == null ? null : Process.getPidsForCommands(nativeProcs);</span></span><br><span class="line"><span class="string">    ArrayList&lt;Integer&gt; nativePids = null;</span></span><br><span class="line"><span class="string">    if (pids != null) &#123;</span></span><br><span class="line"><span class="string">        nativePids = new ArrayList&lt;Integer&gt;(pids.length);</span></span><br><span class="line"><span class="string">        for (int i : pids) &#123;</span></span><br><span class="line"><span class="string">            nativePids.add(i);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // For background ANRs, don'</span>t pass the ProcessCpuTracker to</span><br><span class="line">    // avoid spending 1/2 second collecting stats to rank lastPids.</span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="literal">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? null : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? null : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line">    String cpuInfo = null;</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">        synchronized (mService.mProcessCpuTracker) &#123;</span><br><span class="line">            cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);</span><br><span class="line">        &#125;</span><br><span class="line">        info.append(processCpuTracker.printCurrentLoad());</span><br><span class="line">        info.append(cpuInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(processCpuTracker.printCurrentState(anrTime));</span><br><span class="line">    Slog.e(TAG, info.toString());//将上面拿到的所有信息，打印到main <span class="built_in">log</span>中</span><br><span class="line">    <span class="keyword">if</span> (tracesFile == null) &#123;//5.将<span class="built_in">log</span>打印到 traces.txt中</span><br><span class="line">        // There is no trace file, so dump (only) the alleged culprit<span class="string">'s threads to the log</span></span><br><span class="line"><span class="string">        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation,</span></span><br><span class="line"><span class="string">            cpuInfo, tracesFile, null);// 6.将log打印到dropbox</span></span><br><span class="line"><span class="string">    if (mService.mController != null) &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately</span></span><br><span class="line"><span class="string">            int res = mService.mController.appNotResponding(</span></span><br><span class="line"><span class="string">                    app.processName, app.pid, info.toString());</span></span><br><span class="line"><span class="string">            if (res != 0) &#123;</span></span><br><span class="line"><span class="string">                if (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span></span><br><span class="line"><span class="string">                    app.kill("anr", true);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">                        mService.mServices.scheduleServiceTimeoutLocked(app);</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            mService.mController = null;</span></span><br><span class="line"><span class="string">            Watchdog.getInstance().setActivityController(null);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // 弹框处理</span></span><br><span class="line"><span class="string">    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);</span></span><br><span class="line"><span class="string">        if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">            app.kill("bg anr", true);</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // Set the app'</span>s notResponding state, and look up the errorReportReceiver</span><br><span class="line">        makeAppNotRespondingLocked(app,</span><br><span class="line">                activity != null ? activity.shortComponentName : null,</span><br><span class="line">                annotation != null ? <span class="string">"ANR "</span> + annotation : <span class="string">"ANR"</span>,</span><br><span class="line">                info.toString());</span><br><span class="line">        // Bring up the infamous App Not Responding dialog</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = map;</span><br><span class="line">        msg.arg1 = aboveSystem ? 1 : 0;</span><br><span class="line">        map.put(<span class="string">"app"</span>, app);</span><br><span class="line">        <span class="keyword">if</span> (activity != null) &#123;</span><br><span class="line">            map.put(<span class="string">"activity"</span>, activity);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主体逻辑可以分成五个部分来看：</p>
<ol>
<li>更新CPU的统计信息。这是发生ANR时，第一次CPU使用信息的采样，采样数据会保存在mProcessStats这个变量中</li>
<li>将Log信息，写入Event log中</li>
<li>填充firstPids和lastPids数组。当前发生ANR的应用会首先被添加到firstPids中，这样打印函数栈的时候，当前进程总是在trace文件的最前面打印函数调用栈(StackTrace)。具体实现由dumpStackTraces()函数完成更新CPU的统计信息。这是发生ANR时，第二次CPU使用信息的采样，两次采样的数据分别对应ANR发生前后的CPU使用情况</li>
<li>准备main log需要的参数，将ANR信息输出到main log中</li>
<li>将log打印到trace.txt文件中</li>
<li>将log打印到dropbox中</li>
<li>弹框处理，显示ANR对话框。抛出SHOW_NOT_RESPONDING_MSG消息，AMS.MainHandler会处理这条消息，显示AppNotRespondingDialog</li>
</ol>
<p>当然，除了主体逻辑，发生ANR时还会输出各种类别的日志：</p>
<blockquote>
<p>event log，通过检索”am_anr”关键字，可以找到发生ANR的应用<br>main log，通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况<br>dropbox，通过检索”anr”类型，可以找到ANR的信息,log位于/data/system/dropbox<br>traces, 发生ANR时，各进程的函数调用栈信息，log位于/data/anr<br>我们分析ANR问题，往往是从main log中的CPU使用情况和traces中的函数调用栈开始。所以，更新CPU的使用信息updateCpuStatsNow()方法和打印函数栈dumpStackTraces()方法，是系统报告ANR问题关键所在。</p>
</blockquote>
<h4 id="CPU的使用情况"><a href="#CPU的使用情况" class="headerlink" title="CPU的使用情况"></a>CPU的使用情况</h4><p>AMS.updateCpuStatsNow()方法的实现见下面的代码，更新CPU使用信息的间隔最小是5秒，即如果5秒内连续调用updateCpuStatsNow()方法，其实是没有更新CPU使用信息的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">updateCpuStatsNow</span></span>() &#123;</span><br><span class="line">        synchronized (mProcessCpuTracker) &#123;</span><br><span class="line">            mProcessCpuMutexFree.set(<span class="literal">false</span>);</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            boolean haveNewCpuStats = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE &amp;&amp;</span><br><span class="line">                    mLastCpuTime.get() &lt; (now-MONITOR_CPU_MIN_TIME)) &#123;</span><br><span class="line">                mLastCpuTime.set(now);</span><br><span class="line">                mProcessCpuTracker.update();</span><br><span class="line">                <span class="keyword">if</span> (mProcessCpuTracker.hasGoodLastStats()) &#123;</span><br><span class="line">                    haveNewCpuStats = <span class="literal">true</span>;</span><br><span class="line">                    //Slog.i(TAG, mProcessCpu.printCurrentState());</span><br><span class="line">                    //Slog.i(TAG, <span class="string">"Total CPU usage: "</span></span><br><span class="line">                    //        + mProcessCpu.getTotalCpuPercent() + <span class="string">"%"</span>);</span><br><span class="line"></span><br><span class="line">                    // Slog the cpu usage <span class="keyword">if</span> the property is <span class="built_in">set</span>.</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(SystemProperties.get(<span class="string">"events.cpu"</span>))) &#123;</span><br><span class="line">                        int user = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                        int system = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                        int iowait = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                        int irq = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                        int softIrq = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                        int idle = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line"></span><br><span class="line">                        int total = user + system + iowait + irq + softIrq + idle;</span><br><span class="line">                        <span class="keyword">if</span> (total == 0) total = 1;</span><br><span class="line"></span><br><span class="line">                        EventLog.writeEvent(EventLogTags.CPU,</span><br><span class="line">                                ((user+system+iowait+irq+softIrq) * 100) / total,</span><br><span class="line">                                (user * 100) / total,</span><br><span class="line">                                (system * 100) / total,</span><br><span class="line">                                (iowait * 100) / total,</span><br><span class="line">                                (irq * 100) / total,</span><br><span class="line">                                (softIrq * 100) / total);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final BatteryStatsImpl bstats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">            synchronized(bstats) &#123;</span><br><span class="line">                synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (haveNewCpuStats) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bstats.startAddingCpuLocked()) &#123;</span><br><span class="line">                            int totalUTime = 0;</span><br><span class="line">                            int totalSTime = 0;</span><br><span class="line">                            final int N = mProcessCpuTracker.countStats();</span><br><span class="line">                            <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                                ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);</span><br><span class="line">                                <span class="keyword">if</span> (!st.working) &#123;</span><br><span class="line">                                    <span class="built_in">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                ProcessRecord pr = mPidsSelfLocked.get(st.pid);</span><br><span class="line">                                totalUTime += st.rel_utime;</span><br><span class="line">                                totalSTime += st.rel_stime;</span><br><span class="line">                                <span class="keyword">if</span> (pr != null) &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = pr.curProcBatteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        pr.curProcBatteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                pr.info.uid, pr.processName);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                    pr.curCpuTime += st.rel_utime + st.rel_stime;</span><br><span class="line">                                    <span class="keyword">if</span> (pr.lastCpuTime == 0) &#123;</span><br><span class="line">                                        pr.lastCpuTime = pr.curCpuTime;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = st.batteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        st.batteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                bstats.mapUid(st.uid), st.name);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            final int userTime = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                            final int systemTime = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                            final int iowaitTime = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                            final int irqTime = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                            final int softIrqTime = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                            final int idleTime = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line">                            bstats.finishAddingCpuLocked(totalUTime, totalSTime, userTime,</span><br><span class="line">                                    systemTime, iowaitTime, irqTime, softIrqTime, idleTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mLastWriteTime &lt; (now-BATTERY_STATS_TIME)) &#123;</span><br><span class="line">                    mLastWriteTime = now;</span><br><span class="line">                    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>CPU使用信息由ProcessCpuTracker这个类维护， 每次调用ProcessCpuTracker.update()方法，就会读取设备节点 /proc 下的文件，来更新CPU使用信息，具体有以下几个维度：</p>
<blockquote>
<p>CPU的使用时间: 读取 /proc/stat</p>
<blockquote>
<p>user： 用户进程的CPU使用时间<br>nice： 降低过优先级进程的CPU使用时间。Linux进程都有优先级，这个优先级可以进行动态调整，譬如进程初始优先级的值设为10,运行时降低为8,那么，修正值-2就定义为nice。 Android将user和nice这两个时间归类成user<br>sys： 内核进程的CPU使用时间<br>idle： CPU空闲的时间<br>wait： CPU等待IO的时间<br>hw irq： 硬件中断的时间。如果外设（譬如硬盘）出现故障，需要通过硬件终端通知CPU保存现场，发生上下文切换的时间就是CPU的硬件中断时间<br>sw irg： 软件中断的时间。同硬件中断一样，如果软件要求CPU中断，则上下文切换的时间就是CPU的软件中断时间</p>
</blockquote>
</blockquote>
<blockquote>
<p>CPU负载: 读取 /proc/loadavg, 统计最近1分钟，5分钟，15分钟内，CPU的平均活动进程数。 CPU的负载可以比喻成超市收银员负载，如果有1个人正在买单，有2个人在排队，那么该收银员的负载就是3。 在收银员工作时，不断会有人买单完成，也不断会有人排队，可以在固定的时间间隔内(譬如，每隔5秒)统计一次负载，那么，就可以统计出一段时间内的平均负载。</p>
</blockquote>
<blockquote>
<p>页错误信息： 进程的CPU使用率最后输出的“faults: xxx minor/major”部分表示的是页错误次数，当次数为0时不显示。 major是指Major Page Fault(主要页错误，简称MPF)，内核在读取数据时会先后查找CPU的高速缓存和物理内存，如果找不到会发出一个MPF信息，请求将数据加载到内存。 minor是指Minor Page Fault(次要页错误，简称MnPF)，磁盘数据被加载到内存后，内核再次读取时，会发出一个MnPF信息。 一个文件第一次被读写时会有很多的MPF，被缓存到内存后再次访问MPF就会很少，MnPF反而变多，这是内核为减少效率低下的磁盘I/O操作采用的缓存技术的结果。</p>
</blockquote>
<h4 id="堆栈调用"><a href="#堆栈调用" class="headerlink" title="堆栈调用"></a>堆栈调用</h4><p>AMS.dumpStackTraces()方法用于打印进程的函数调用栈，该方法的主体逻辑如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * If a stack trace dump file is configured, dump process stack traces.</span><br><span class="line"> * @param clearTraces causes the dump file to be erased prior to the new</span><br><span class="line"> *    traces being written, <span class="keyword">if</span> <span class="literal">true</span>; when <span class="literal">false</span>, the new traces will be</span><br><span class="line"> *    appended to any existing file content.</span><br><span class="line"> * @param firstPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> first</span><br><span class="line"> * @param lastPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> last</span><br><span class="line"> * @param nativePids optional list of native pids to dump stack crawls</span><br><span class="line"> */</span><br><span class="line">public static File dumpStackTraces(boolean clearTraces, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; extraPids = null;</span><br><span class="line"></span><br><span class="line">    // Measure CPU usage as soon as we<span class="string">'re called in order to get a realistic sampling</span></span><br><span class="line"><span class="string">    // of the top users at the time of the request.</span></span><br><span class="line"><span class="string">    if (processCpuTracker != null) &#123;</span></span><br><span class="line"><span class="string">        processCpuTracker.init();</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            Thread.sleep(200);</span></span><br><span class="line"><span class="string">        &#125; catch (InterruptedException ignored) &#123;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        processCpuTracker.update();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // We'</span>ll take the stack crawls of just the top apps using CPU.</span><br><span class="line">        final int N = processCpuTracker.countWorkingStats();</span><br><span class="line">        extraPids = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; N &amp;&amp; extraPids.size() &lt; 5; i++) &#123;</span><br><span class="line">            ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);</span><br><span class="line">            <span class="keyword">if</span> (lastPids.indexOfKey(stats.pid) &gt;= 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_ANR) Slog.d(TAG, <span class="string">"Collecting stacks for extra pid "</span> + stats.pid);</span><br><span class="line"></span><br><span class="line">                extraPids.add(stats.pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_ANR) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Skipping next CPU consuming process, not a java proc: "</span></span><br><span class="line">                        + stats.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean useTombstonedForJavaTraces = <span class="literal">false</span>;</span><br><span class="line">    File tracesFile;</span><br><span class="line"></span><br><span class="line">    final String tracesDirProp = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-dir"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (tracesDirProp.isEmpty()) &#123;</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is not <span class="built_in">set</span>, we are using the <span class="string">"old"</span> trace</span><br><span class="line">        // dumping scheme. All traces are written to a global trace file (usually</span><br><span class="line">        // <span class="string">"/data/anr/traces.txt"</span>) so the code below must take care to unlink and recreate</span><br><span class="line">        // the file <span class="keyword">if</span> requested.</span><br><span class="line">        //</span><br><span class="line">        // This mode of operation will be removed <span class="keyword">in</span> the near future.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String globalTracesPath = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-file"</span>, null);</span><br><span class="line">        <span class="keyword">if</span> (globalTracesPath.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"dumpStackTraces: no trace path configured"</span>);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tracesFile = new File(globalTracesPath);</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (clearTraces &amp;&amp; tracesFile.exists()) &#123;</span><br><span class="line">                tracesFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tracesFile.createNewFile();</span><br><span class="line">            FileUtils.setPermissions(globalTracesPath, 0666, -1, -1); // -rw-rw-rw-</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to prepare ANR traces file: "</span> + tracesFile, e);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        File tracesDir = new File(tracesDirProp);</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is <span class="built_in">set</span>, we use the <span class="string">"new"</span> trace dumping scheme.</span><br><span class="line">        // Each <span class="built_in">set</span> of ANR traces is written to a separate file and dumpstate will process</span><br><span class="line">        // all such files and add them to a captured bug report <span class="keyword">if</span> they<span class="string">'re recent enough.</span></span><br><span class="line"><span class="string">        maybePruneOldTraces(tracesDir);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // NOTE: We should consider creating the file in native code atomically once we'</span>ve</span><br><span class="line">        // gotten rid of the old scheme of dumping and lot of the code that deals with paths</span><br><span class="line">        // can be removed.</span><br><span class="line">        tracesFile = createAnrDumpFile(tracesDir);</span><br><span class="line">        <span class="keyword">if</span> (tracesFile == null) &#123;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        useTombstonedForJavaTraces = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids,</span><br><span class="line">            useTombstonedForJavaTraces);</span><br><span class="line">    <span class="built_in">return</span> tracesFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void dumpStackTraces(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids,</span><br><span class="line">        boolean useTombstonedForJavaTraces) &#123;</span><br><span class="line"></span><br><span class="line">    // We don<span class="string">'t need any sort of inotify based monitoring when we'</span>re dumping traces via</span><br><span class="line">    // tombstoned. Data is piped to an <span class="string">"intercept"</span> FD installed <span class="keyword">in</span> tombstoned so we<span class="string">'re in full</span></span><br><span class="line"><span class="string">    // control of all writes to the file in question.</span></span><br><span class="line"><span class="string">    final DumpStackFileObserver observer;</span></span><br><span class="line"><span class="string">    if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">        observer = null;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Use a FileObserver to detect when traces finish writing.</span></span><br><span class="line"><span class="string">        // The order of traces is considered important to maintain for legibility.</span></span><br><span class="line"><span class="string">        observer = new DumpStackFileObserver(tracesFile);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // We must complete all stack dumps within 20 seconds.</span></span><br><span class="line"><span class="string">    long remainingTime = 20 * 1000;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.startWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // First collect all of the stacks of the most important pids.</span></span><br><span class="line"><span class="string">        if (firstPids != null) &#123;</span></span><br><span class="line"><span class="string">            int num = firstPids.size();</span></span><br><span class="line"><span class="string">            for (int i = 0; i &lt; num; i++) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for pid "</span></span><br><span class="line"><span class="string">                        + firstPids.get(i));</span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(firstPids.get(i), tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(firstPids.get(i), remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current firstPid=" + firstPids.get(i) +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Next collect the stacks of the native pids</span></span><br><span class="line"><span class="string">        if (nativePids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : nativePids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for native pid " + pid);</span></span><br><span class="line"><span class="string">                final long nativeDumpTimeoutMs = Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long start = SystemClock.elapsedRealtime();</span></span><br><span class="line"><span class="string">                Debug.dumpNativeBacktraceToFileTimeout(</span></span><br><span class="line"><span class="string">                        pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));</span></span><br><span class="line"><span class="string">                final long timeTaken = SystemClock.elapsedRealtime() - start;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current native pid=" + pid +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with native pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Lastly, dump stacks for all extra PIDs from the CPU tracker.</span></span><br><span class="line"><span class="string">        if (extraPids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : extraPids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for extra pid " + pid);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(pid, remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current extra pid=" + pid +</span></span><br><span class="line"><span class="string">                            "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with extra pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.stopWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="问题分析方法"><a href="#问题分析方法" class="headerlink" title="问题分析方法"></a>问题分析方法</h2><p>分析ANR问题，有三大利器：Logcat，traces和StrictMode。 在StrictMode机制一文中，有介绍StrictMode的实现机制以及用途，本文中不讨论利用StrictMode来解决ANR问题，但各位读者需要有这个意识。 在Watchdog机制以及问题分析一文中，我们介绍过logcat和traces这两种日志的用途。 分析ANR问题同Watchdog问题一样，都需要经过日志获取、问题定位和场景还原三个步骤。</p>
<h3 id="日志的获取"><a href="#日志的获取" class="headerlink" title="日志的获取"></a>日志的获取</h3><p>分析ANR问题最主要的途径就是通过log来分析。Android中log的获取见，Android的log机制分析一问中log的存储位置章节。</p>
<h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>通过在event log中检索 am_anr 关键字，就可以找到发生ANR的进程，譬如以下日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:27 820 907 I am_anr: [0,29533,com.android.systemui,1082670605,Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;]</span><br></pre></td></tr></table></figure></p>
<p>表示在 10-16 00:48:27 这个时刻，PID为 29533 进程发生了ANR，进程名是 com.android.systemui<br>接下来可以在system log检索 ANR in 关键字，找到发生ANR前后的CPU使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:50:10 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.systemui, time=130090695</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Load: 30.4 / 22.34 / 19.94</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Android time :[2015-10-16 00:50:05.76] [130191,266]</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: CPU usage from 6753ms to -4ms ago:</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   47% 320/netd: 3.1% user + 44% kernel / faults: 14886 minor 3 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   15% 10007/com.sohu.sohuvideo: 2.8% user + 12% kernel / faults: 1144 minor</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   13% 10654/hif_thread: 0% user + 13% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   11% 175/mmcqd/0: 0% user + 11% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   5.1% 12165/app_process: 1.6% user + 3.5% kernel / faults: 9703 minor 540 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.3% 29533/com.android.systemui: 2.6% user + 0.7% kernel / faults: 8402 minor 343 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.2% 820/system_server: 0.8% user + 2.3% kernel / faults: 5120 minor 523 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   2.5% 11817/com.netease.pomelo.push.l.messageservice_V2: 0.7% user + 1.7% kernel / faults: 7728 minor 687 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.6% 11887/com.android.email: 0.5% user + 1% kernel / faults: 6259 minor 587 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11854/com.android.settings: 0.7% user + 0.7% kernel / faults: 5404 minor 471 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11869/android.process.acore: 0.7% user + 0.7% kernel / faults: 6131 minor 561 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.3% 11860/com.tencent.mobileqq: 0.1% user + 1.1% kernel / faults: 5542 minor 470 major</span><br><span class="line">...</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 12832/cat: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 13211/zygote64: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: 87% TOTAL: 3% user + 18% kernel + 64% iowait + 0.5% softirq</span><br></pre></td></tr></table></figure></p>
<p>这一段日志对于Android开发人员而言，实在太熟悉不过了，它包含的信息量巨大：</p>
<ul>
<li><strong>发生ANR的时间。</strong>event log中，ANR的时间是 00：48：27，因为AMS.appNotResponding()首先会打印event log，然后再打印system log， 所以，在system log中，找到ANR的时间是 00:50:10。可以从这个时间点之前的日志中，还原ANR出现时系统的运行状态</li>
<li><strong>打印ANR日志的进程。</strong>ANR日志都是在system_server进程的AMS线程打印的，在event log和system log中，都能看到 820 和 907， 所以system_server的PID是 802，AMS线程的TID是 907。ANR的监测机制实现在AMS线程，分析一些受系统影响的ANR，需要知道system_server进程的运行状态</li>
<li><strong>发生ANR的进程。</strong>ANR in关键字就表明了当前ANR的进程是com.android.system.ui，通过event log，知道进程的PID是 29533</li>
<li><strong>发生ANR的原因。</strong>Reason关键字表明了当前发生ANR的原因是，处理TIME_TICK广播消息超时。 隐含的意思是TIME_TICK是一个串行广播消息，在 29533 的主线程中，执行BroadcastReceiver.onReceive()方法已经超过10秒</li>
<li><strong>CPU负载。</strong>Load关键字表明了最近1分钟、5分钟、15分钟内的CPU负载分别是30.4、22.3、19.94。CPU最近1分钟的负载最具参考价值，因为ANR的超时限制基本都是1分钟以内， 这可以近似的理解为CPU最近1分钟平均有30.4个任务要处理，这个负载值是比较高的</li>
<li><strong>CPU使用统计时间段。</strong>CPU usage from XX to XX ago关键字表明了这是在ANR发生之前一段时间内的CPU统计。 类似的还有CPU usage from XX to XX after关键字，表明是ANR发生之后一段时间内的CPU统计</li>
<li><strong>各进程的CPU使用率。</strong>我们以com.android.systemui进程的CPU使用率为例，它包含以下信息：<br>  1）<strong>总的CPU使用率:</strong> 3.3%，其中systemui进程在用户态的CPU使用率是2.6%，在内核态的使用率是0.7%<br>  2) <strong>缺页次数fault：</strong>8402 minor表示高速缓存中的缺页次数，343 major表示内存的缺页次数。minor可以理解为进程在做内存访问，major可以理解为进程在做IO操作。 当前minor和major值都是比较高的，从侧面反映了发生ANR之前，systemui进程有有较多的内存访问操作，引发的IO次数也会较多<br>  3) <strong>CPU使用率前面的 “+”。</strong>部分进程的CPU使用率前面有 “+” 号，譬如cat和zygote64，表示在上一次CPU统计的时间片段内，还没有这些进程，而这一次CPU统计的时间片段内，运行了这些进程。 类似的还有 “-” 号，表示两次CPU统计时间片段时，这些进程消亡了</li>
<li><strong>CPU使用汇总。</strong>TOTAL关键字表明了CPU使用的汇总，87%是总的CPU使用率，其中有一项iowait表明CPU在等待IO的时间，占到64%，说明发生ANR以前，有大量的IO操作。app_process、 system_server, com.android.systemui这几个进程的major值都比较大，说明这些进程的IO操作较为频繁，从而拉升了整个iowait的时间</li>
</ul>
<p>信息量是如此的庞大，以致于我们都要下结论了：CPU大量的时间都在等待IO，导致systemui进程分配不到CPU时间，从而主线程处理广播消息超时，发生了ANR。<br>对于一个严谨的开发人员而言，这种结论下得有点早，因为还有太多的疑问：</p>
<ul>
<li>systemui进程也分到了一些CPU时间(3.3%)，难道BroadcastReceiver.onReceive()方法就一直无法执行吗？</li>
<li>为什么iowait的时间会这么多，而且多个进程的major值都很高？<br>接下来还是需要从其他日志中还原ANR出现的场景。</li>
</ul>
<h3 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h3><h4 id="第一个假设和验证"><a href="#第一个假设和验证" class="headerlink" title="第一个假设和验证"></a>第一个假设和验证</h4><p>带着上文提出来的第一个疑问，我们先来做一个假设：如果systemui进程正在执行BroadcatReceiver.onReceive()方法，那么从traces.txt文件中，应该可以看到主线程的函数调用栈正在执行这个方法。<br>接下来，我们首先从traces文件中，找到发生ANR时(00:48:27)，sysemtui进程的函数调用栈信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">----- pid 29533 at 2015-10-16 00:48:06 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (53):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 288625433917 93454573244 903419 ) utm=20570 stm=8292 core=3 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00060b0c  /system/lib64/libc.so (__epoll_pwait+8)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0001bb54  /system/lib64/libc.so (epoll_pwait+32)</span></span><br><span class="line">  native: <span class="comment">#02 pc 0001b3d8  /system/lib64/libutils.so (android::Looper::pollInner(int)+144)</span></span><br><span class="line">  native: <span class="comment">#03 pc 0001b75c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+76)</span></span><br><span class="line">  native: <span class="comment">#04 pc 000d7194  /system/lib64/libandroid_runtime.so (android::NativeMessageQueue::pollOnce(_JNIEnv*, int)+48)</span></span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:148)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:151)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line"></span><br><span class="line">----- pid 29533 at 2015-10-16 00:48:29 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (54):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 289080040422 93461978317 904874 ) utm=20599 stm=8309 core=0 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.println(SourceFile:77)</span><br><span class="line">  - waiting to lock &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger) held by thread 49</span><br><span class="line">  at android.os.Looper.loop(Looper.java:195)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line">...</span><br><span class="line"><span class="string">"Binder_5"</span> prio=5 tid=49 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x136760a0 self=0x7f7e453000</span><br><span class="line">  | sysTid=6945 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f6e3ce000</span><br><span class="line">  | state=S schedstat=( 5505571091 4567508913 30743 ) utm=264 stm=286 core=4 HZ=100</span><br><span class="line">  | stack=0x7f6b83f000-0x7f6b841000 stackSize=1008KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00019d14  /system/lib64/libc.so (syscall+28)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0005b5d8  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#02 pc 002c6f18  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#03 pc 00032c40  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  at libcore.io.Posix.getpid(Native method)</span><br><span class="line">  at libcore.io.ForwardingOs.getpid(ForwardingOs.java:83)</span><br><span class="line">  at android.system.Os.getpid(Os.java:176)</span><br><span class="line">  at android.os.Process.myPid(Process.java:754)</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.dump(SourceFile:219)</span><br><span class="line">  - locked &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger)</span><br><span class="line">  at com.mediatek.anrappmanager.ANRAppManager.dumpMessageHistory(SourceFile:65)</span><br><span class="line">  at android.app.ActivityThread<span class="variable">$ApplicationThread</span>.dumpMessageHistory(ActivityThread.java:1302)</span><br><span class="line">  at android.app.ApplicationThreadNative.onTransact(ApplicationThreadNative.java:682)</span><br><span class="line">  at android.os.Binder.execTransact(Binder.java:451)</span><br></pre></td></tr></table></figure>
<p>最终，我们找到systemui进程ANR时刻(00:48:27)附近的两个函数调用栈:</p>
<ul>
<li>在ANR发生之前(00:48:06)，主线程的函数调用栈处于正常状态：消息队列中，循环中处理消息</li>
<li>在ANR发生之后2秒(00:48:29)，主线程处于Blocked状态，在等待一个被49号线程持有的锁。而49号线程是一个Binder线程，anrappmanager正在做dump操作。</li>
</ul>
<blockquote>
<p>笔者分析的日志是MTK平台产生的，所以从函数调用栈中看到com.mediatek.anrappmanager.MessageLogger这样的类，它是MTK在AOSP上的扩展，用于打印ANR日志。</p>
</blockquote>
<p>至此，systemui进程发生ANR的直接原因我们已经找到了，systemui进程正在打印traces，存在较长时间的IO操作，导致主线程阻塞，从而无法处理TIME_TICK广播消息，所以发生了ANR。</p>
<p>要避免这种场景下的ANR，我们就需要打破主线程中Blocked的逻辑。其实本例是由于MTK在AOSP的android.os.Looper.loop()扩展了打印消息队列的功能，该功能存在设计缺陷，会导致锁等待的情况。</p>
<h4 id="第二个假设和验证"><a href="#第二个假设和验证" class="headerlink" title="第二个假设和验证"></a>第二个假设和验证</h4><p>我们进一步挖掘在systemui还没有发生ANR时，就在打印traces的原因。带着上文提出的第二个疑问，我们来做另一个假设： iowait较高，而且多个进程的major都很高，可能是由于当前正在调用AMS.dumpStackTraces()方法，很多进程都需要将自己的函数调用栈写到traces文件，所以IO就会较高。 如果当前正在调用AMS.dumpStackTraces()方法，那说明当时系统已经发生了异常，要么已经有ANR发生，要么有SNR发生</p>
<p>从event log中，我们检索到了另一个ANR：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:47:58 820 907 I am_anr  : [0,10464,com.android.settings,1086864965,Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)]</span><br></pre></td></tr></table></figure></p>
<p>在 00:47:58 这个时刻，com.android.settings进程发生了ANR，而且ANR的时间在systemui之前(00:48:27)。这一下，我们就找到佐证了，正是因为settings进程先发生了ANR，调用AMS.dumpStackTraces()， 从而很多进程都开始了打印traces的操作，所以系统的整个iowait比较高，大量进程的major值也比较高，systemui就在其列。在MTK逻辑的影响下，打印ANR日志会导致主线程阻塞，从而就连带引发了其他应用的ANR。</p>
<p>在system log中，我们检索到了settings进程ANR的CPU使用信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:12 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.settings (com.android.settings/.SubSettings), time=130063718</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Load: 21.37 / 19.25 / 18.84</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Android time :[2015-10-16 00:48:12.24] [130077,742]</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: CPU usage from 0ms to 7676ms later:</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   91% 820/system_server: 16% user + 75% kernel / faults: 13192 minor 167 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   3.2% 175/mmcqd/0: 0% user + 3.2% kernel</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.9% 29533/com.android.systemui: 2.3% user + 0.6% kernel / faults: 1352 minor 10 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 1736/com.android.phone: 0.9% user + 1.3% kernel / faults: 1225 minor 1 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 10464/com.android.settings: 0.7% user + 1.4% kernel / faults: 2801 minor 105 major</span><br></pre></td></tr></table></figure></p>
<p>具体的涵义我们不再赘述了，只关注一下ANR的原因:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.</span><br><span class="line">Outbound queue length: 0. Wait queue length: 1.)</span><br></pre></td></tr></table></figure></p>
<p>之前对Input ANR机制的分析派上用长了，我们轻松知道这种ANR的原因是什么。 Wait queue length： 1表示之前的输入事件已经派发到Settings进程了，但Settings进程还没有处理完毕，新来的KeyEvent事件已经等待超过了5秒，所以ANR产生了。<br>接下来，又需要找到Settings的traces，分析Settings主线程处理输入事件超时的原因，我们点到为止。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Android ANR机制进行了深入的分析：</p>
<ul>
<li><strong>ANR的监测机制</strong>，从Service，Broadcast，InputEvent三种不同的ANR监测机制的源码实现开始，分析了Android如何发现各类ANR。在启动服务、派发广播消息和输入事件时，植入超时检测，用于发现ANR</li>
<li><strong>ANR的报告机制</strong>，分析Android如何输出ANR日志。当ANR被发现后，两个很重要的日志输出是：CPU使用情况和进程的函数调用栈，这两类日志是我们解决ANR问题的利器</li>
</ul>
<p>ANR的解决方法，通过一个案例，对ANR日志进行了深入解读，梳理了分析ANR问题的思路和途径<br>最后，致各位读者，从日志出发解决ANR问题，理解ANR机制背后的实现原理，碰到再难的ANR问题也无需惊慌。</p>
<p> <strong>Android中的各种log机制以及分析。</strong></p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li>ANR机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a></li>
<li>ANR问题分析流程  <a href="https://blog.csdn.net/mathcompfrac/article/details/53862441" target="_blank" rel="noopener">https://blog.csdn.net/mathcompfrac/article/details/53862441</a></li>
<li>StrictMode 机制以及使用场景 <a href="http://duanqz.github.io/2015-11-04-StrictMode-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-11-04-StrictMode-Analysis</a></li>
<li>Watchdog机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android-ANR/" rel="tag"># Android ANR</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/20/Android8-1-0-DeskClock横屏滑动冲突/" rel="next" title="Android8.1.0 DeskClock横屏滑动冲突">
                <i class="fa fa-chevron-left"></i> Android8.1.0 DeskClock横屏滑动冲突
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/23/year-06-23-Android/" rel="prev" title="Android">
                Android <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  
    <div id="gitalk-container"></div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myapple.jpg"
                alt="Eric Chows" />
            
              <p class="site-author-name" itemprop="name">Eric Chows</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/ericchows" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xnzds2008@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://plus.google.com" target="_blank" title="Google">
                    
                      <i class="fa fa-fw fa-google"></i>Google</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com" target="_blank" title="Twitter">
                    
                      <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.facebook.com" target="_blank" title="FB Page">
                    
                      <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://vk.com" target="_blank" title="VK Group">
                    
                      <i class="fa fa-fw fa-vk"></i>VK Group</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/8872810/eric" target="_blank" title="StackOverflow">
                    
                      <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://youtube.com" target="_blank" title="YouTube">
                    
                      <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://instagram.com" target="_blank" title="Instagram">
                    
                      <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="skype" target="_blank" title="Skype">
                    
                      <i class="fa fa-fw fa-skype"></i>Skype</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="/images/wechat.jpg" target="_blank" title="Wechat">
                    
                      <i class="fa fa-fw fa-globe"></i>Wechat</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://blog.csdn.net/Cxiaolinxiaozi" target="_blank" title="CSDN">
                    
                      <i class="fa fa-fw fa-globe"></i>CSDN</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Google-官方关于ANR的介绍"><span class="nav-number">2.</span> <span class="nav-text">Google 官方关于ANR的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找ANR根因"><span class="nav-number">2.1.</span> <span class="nav-text">查找ANR根因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决ANR问题的方式"><span class="nav-number">2.2.</span> <span class="nav-text">解决ANR问题的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ANR-机制"><span class="nav-number">3.</span> <span class="nav-text">ANR 机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ANR检测机制"><span class="nav-number">3.1.</span> <span class="nav-text">ANR检测机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-处理超时"><span class="nav-number">3.1.1.</span> <span class="nav-text">Service 处理超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Broadcast处理超时"><span class="nav-number">3.1.2.</span> <span class="nav-text">Broadcast处理超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Input处理超时"><span class="nav-number">3.1.3.</span> <span class="nav-text">Input处理超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">3.1.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ANR的报告机制"><span class="nav-number">3.2.</span> <span class="nav-text">ANR的报告机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU的使用情况"><span class="nav-number">3.2.1.</span> <span class="nav-text">CPU的使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆栈调用"><span class="nav-number">3.2.2.</span> <span class="nav-text">堆栈调用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题分析方法"><span class="nav-number">4.</span> <span class="nav-text">问题分析方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#日志的获取"><span class="nav-number">4.1.</span> <span class="nav-text">日志的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题定位"><span class="nav-number">4.2.</span> <span class="nav-text">问题定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#场景还原"><span class="nav-number">4.3.</span> <span class="nav-text">场景还原</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一个假设和验证"><span class="nav-number">4.3.1.</span> <span class="nav-text">第一个假设和验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二个假设和验证"><span class="nav-number">4.3.2.</span> <span class="nav-text">第二个假设和验证</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料："><span class="nav-number">6.</span> <span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EricChows</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1274018749&web_id=1274018749" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
		var gitalk = new Gitalk({
		  clientID: '2f039a8ed54186479946',
		  clientSecret: 'bc88282455b50fbc8c5d9502d17621a4f9e48d18',
		  repo: 'myblog-comment',
		  owner: 'EricChows',
		  admin: ['EricChows'],
		  id: location.pathname,
		  distractionFreeMode: 'true'
		})
		gitalk.render('gitalk-container')           
       </script>


  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ANlC6pJEdxOLHAcDbFuHuXrF-gzGzoHsz", "tNpAWjkmbhhKnsB3bcDooRrl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  

</body>
</html>
