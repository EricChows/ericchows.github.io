<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EricChows</title>
  
  <subtitle>Android Developer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-04T07:18:35.710Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Eric Chows</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读书笔记</title>
    <link href="http://yoursite.com/2023/11/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2023/11/01/读书笔记/</id>
    <published>2023-10-31T16:00:00.000Z</published>
    <updated>2018-07-04T07:18:35.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文目的是记录阅读一些书籍过程中的知识点</p><h1 id="JVM-源码分析"><a href="#JVM-源码分析" class="headerlink" title="JVM 源码分析"></a>JVM 源码分析</h1><p> 下载JVM源码 <a href="https://download.java.net/openjdk/jdk7/" target="_blank" rel="noopener">https://download.java.net/openjdk/jdk7/</a><br> openjdk-7-ea-src-b31-17_jul_2008.zip中有hotspot目录,里面是vm的代码</p><h1 id="《剑指Offer-名企面试官精讲典型编程题》"><a href="#《剑指Offer-名企面试官精讲典型编程题》" class="headerlink" title="《剑指Offer:名企面试官精讲典型编程题》"></a>《剑指Offer:名企面试官精讲典型编程题》</h1><p>   2012年电子工业出版社,何海涛</p><p><a href="https://blog.csdn.net/Together_CZ/article/details/74906427" target="_blank" rel="noopener">剑指Offer学习</a><br><a href="https://blog.csdn.net/panda_AJ/article/details/69420293" target="_blank" rel="noopener">剑指offer题目及答案</a></p><p>#《Android应用安全防护和逆向分析》—姜维</p><ol><li>Android中锁屏密码加密算法分析<br>以Android 5.1版本，分析了密码算法 和手势密码算法</li><li>Android中NDK开发<br>写了简单的实例，实现Java调用C，C调用Java</li><li>Android 开发和逆向常用命令<br>介绍了一些常用的adb 命令</li><li>so文件格式解析<br>so文件是Android中C/C++模块编译出来的库，有静态库和动态库两种。Android中的so文件就是ELF文件。<br>文中介绍了阅读ELF文件的工具readelf的常用命令。</li><li><p>AndroidManifest.xml文件格式解析</p></li><li><p>resource.arsc文件格式解析<br>Resource.arsc文件对应的数据结构 frameworks/base/include/androidfw/ResourceTypes.h</p></li><li><p>dex 文件格式解析</p><p>防护篇</p></li><li><p>Android 应用安全防护的基本策略<br>1) 混淆机制.混淆不仅是为了安全防护，也是为了减小应用安装包的大小。混淆机制有两种:<br> a)代码混淆：混淆后的代码类名和方法名都变了<br> b)资源混淆： 微信已经开源资源混淆 <a href="http://github.com/shwenzhang/AndResGuard" target="_blank" rel="noopener">http://github.com/shwenzhang/AndResGuard</a><br>2) 签名保护<br>3）手动注册native方法<br>4）反调试监测</p></li><li>Android中常用权限分析</li></ol><p><a href="https://github.com/Juude/droidReverse" target="_blank" rel="noopener">逆向工程工具集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文目的是记录阅读一些书籍过程中的知识点&lt;/p&gt;
&lt;h1 id=&quot;JVM-源码分析&quot;&gt;&lt;a href=&quot;#JVM-源码分析&quot; class=&quot;
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="逆向分析" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android中广播注册和发送机制分</title>
    <link href="http://yoursite.com/2018/06/28/Android%E4%B8%AD%E5%B9%BF%E6%92%AD%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/28/Android中广播注册和发送机制分析/</id>
    <published>2018-06-28T01:07:59.398Z</published>
    <updated>2018-06-28T01:13:16.204Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li>Android Broadcast广播注册和发布方式以及机制流程 <a href="https://blog.csdn.net/liu_3262296/article/details/51935316" target="_blank" rel="noopener">https://blog.csdn.net/liu_3262296/article/details/51935316</a></li><li>Android广播之发送广播的源码分析 <a href="https://blog.csdn.net/zhangyongfeiyong/article/details/52022935" target="_blank" rel="noopener">https://blog.csdn.net/zhangyongfeiyong/article/details/52022935</a></li><li>Android广播机制实现源码浅析（一） <a href="https://blog.csdn.net/hehui1860/article/details/30726609" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30726609</a></li><li>Android广播机制实现源码浅析（二） <a href="https://blog.csdn.net/hehui1860/article/details/30727075" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30727075</a></li><li>Android广播机制实现源码浅析（三）<a href="https://blog.csdn.net/hehui1860/article/details/30727537" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30727537</a></li><li>BroadcastReceiver源码解析(一)  <a href="https://blog.csdn.net/tiefeng0606/article/details/51354381" target="_blank" rel="noopener">https://blog.csdn.net/tiefeng0606/article/details/51354381</a></li><li>BroadcastReceiver源码解析（二） <a href="https://blog.csdn.net/tiefeng0606/article/details/51381221" target="_blank" rel="noopener">https://blog.csdn.net/tiefeng0606/article/details/51381221</a></li></ol><p>Android 解读main log和event log日志信息<br><a href="https://blog.csdn.net/yelangjueqi/article/details/52621903" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52621903</a></p><p>Log中’main’, ‘system’, ‘radio’, ‘events’以及android log分析<br><a href="https://www.cnblogs.com/zhengtu2015/p/5134012.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengtu2015/p/5134012.html</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android Broadcast" scheme="http://yoursite.com/tags/Android-Broadcast/"/>
    
  </entry>
  
  <entry>
    <title>Android的Log机制分析</title>
    <link href="http://yoursite.com/2018/06/27/A-Ongoing-Android%E7%9A%84Log%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/27/A-Ongoing-Android的Log机制分析/</id>
    <published>2018-06-27T15:45:18.115Z</published>
    <updated>2018-07-05T01:15:19.892Z</updated>
    
    <content type="html"><![CDATA[<p>Android 解读main log和event log日志信息<br><a href="https://blog.csdn.net/yelangjueqi/article/details/52621903" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52621903</a></p><p>Log中’main’, ‘system’, ‘radio’, ‘events’以及android log分析<br><a href="https://www.cnblogs.com/zhengtu2015/p/5134012.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengtu2015/p/5134012.html</a></p><p>关于Android Log的一些思考<br><a href="https://droidyue.com/blog/2015/11/01/thinking-about-android-log/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/11/01/thinking-about-android-log/</a></p><p><a href="https://blog.csdn.net/fishmai/article/details/52398537" target="_blank" rel="noopener">https://blog.csdn.net/fishmai/article/details/52398537</a></p><p>手机的默认的日志目录：</p><p> /data/local/tmp/*</p><p>/data/tmp/*</p><p>/data/system/usagestats/*</p><p>/data/system/appusagestates/*</p><p>/data/system/dropbox/*</p><p>/data/tombstones/*</p><p>/data/anr/*</p><p>logcat的日志在</p><p>/dev/log/main</p><p>有/data/local/log目录的，可以保存3-4天的log。</p><h1 id="需要对Android的log机制有深入的研究"><a href="#需要对Android的log机制有深入的研究" class="headerlink" title="需要对Android的log机制有深入的研究"></a>需要对Android的log机制有深入的研究</h1><h1 id="logcat源码分析"><a href="#logcat源码分析" class="headerlink" title="logcat源码分析"></a>logcat源码分析</h1><p>logcat源码位置:<a href="">system/core/logcat/logcat.cpp</a><br>代码结构以及各个文件功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">logcat</span><br><span class="line">└── Android.mk</span><br><span class="line">    event.logtags  //</span><br><span class="line">    logcat.cpp     //主文件</span><br><span class="line">    logcatd.rc     //logcat相关的一些rc属性</span><br><span class="line">    logpersist     //持久化的存储一些<span class="built_in">log</span>相关的属性值</span><br><span class="line"> ```  </span><br><span class="line">event.logtags 文件的作用是：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># logd源码分析</span></span><br><span class="line"></span><br><span class="line">logd源码位置:[system/core/logd]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># logwraper 源码分析</span></span><br><span class="line">logwraper源码位置：[system/core/logwrapper/logwrap.c]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 概述</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log的使用</span></span><br><span class="line"></span><br><span class="line"> 介绍Kernel中内核态的printk和用户态的Log使用</span><br><span class="line"></span><br><span class="line"> printk提供了8种日志级别</span><br><span class="line"> kernel/include/linux/kern_levels.h</span><br><span class="line">``` bash</span><br><span class="line"><span class="comment">#ifndef __KERN_LEVELS_H__</span></span><br><span class="line"><span class="comment">#define __KERN_LEVELS_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define KERN_SOH"\001"/* ASCII Start Of Header */</span></span><br><span class="line"><span class="comment">#define KERN_SOH_ASCII'\001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define KERN_EMERGKERN_SOH "0"/* system is unusable */</span></span><br><span class="line"><span class="comment">#define KERN_ALERTKERN_SOH "1"/* action must be taken immediately */</span></span><br><span class="line"><span class="comment">#define KERN_CRITKERN_SOH "2"/* critical conditions */</span></span><br><span class="line"><span class="comment">#define KERN_ERRKERN_SOH "3"/* error conditions */</span></span><br><span class="line"><span class="comment">#define KERN_WARNINGKERN_SOH "4"/* warning conditions */</span></span><br><span class="line"><span class="comment">#define KERN_NOTICEKERN_SOH "5"/* normal but significant condition */</span></span><br><span class="line"><span class="comment">#define KERN_INFOKERN_SOH "6"/* informational */</span></span><br><span class="line"><span class="comment">#define KERN_DEBUGKERN_SOH "7"/* debug-level messages */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define KERN_DEFAULTKERN_SOH "d"/* the default kernel loglevel */</span></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Annotation <span class="keyword">for</span> a <span class="string">"continued"</span> line of <span class="built_in">log</span> printout (only <span class="keyword">done</span> after a</span><br><span class="line"> * line that had no enclosing \n). Only to be used by core/arch code</span><br><span class="line"> * during early bootup (a continued line is not SMP-safe otherwise).</span><br><span class="line"> */</span><br><span class="line"><span class="comment">#define KERN_CONT""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">``` </span><br><span class="line"> 在Android系统中，printk输出的日志信息保存在/proc/kmsg中，要查看/proc/kmsg的内容,cat  /proc/kmsg</span><br><span class="line"></span><br><span class="line"> 如何调整Kernel <span class="built_in">log</span>的日志级别</span><br><span class="line"></span><br><span class="line"> Android系统中的C/C++日志接口是通过宏来使用的。在system/core/include/android/log.h定义了日志的级别：</span><br><span class="line"></span><br><span class="line"> 在system/core/include/cutils/log.h中，定义了对应的宏，如对应于ANDROID_LOG_VERBOSE的宏LOGV：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 再来看Android系统中的Java日志接口。Android系统在Frameworks层中定义了Log接口（frameworks/base/core/java/android/util/Log.java）：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Logger驱动程序源码分析</span></span><br><span class="line"> Logger驱动程序主要由两个文件构成，分别是：</span><br><span class="line"> kernel/drivers/staging/android/logger.c</span><br><span class="line"> kernel/drivers/staging/android/logger.h</span><br><span class="line"></span><br><span class="line"><span class="comment">## 日志系统数据结构</span></span><br><span class="line"></span><br><span class="line"> 先来看一下logger.h头文件的内容：</span><br><span class="line">``` bash</span><br><span class="line"><span class="comment">#ifndef _LINUX_LOGGER_H</span></span><br><span class="line"><span class="comment">#define _LINUX_LOGGER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;linux/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/ioctl.h&gt;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * struct user_logger_entry_compat - defines a single entry that is given to a logger</span><br><span class="line"> * @len:The length of the payload  //有效负载长度</span><br><span class="line"> * @__pad:Two bytes of padding that appear to be required //两个字节的空格</span><br><span class="line"> * @pid:The generating process<span class="string">' process ID  //进程ID</span></span><br><span class="line"><span class="string"> * @tid:The generating process'</span> thread ID   //线程ID</span><br><span class="line"> * @sec:The number of seconds that have elapsed since the Epoch  //秒数</span><br><span class="line"> * @nsec:The number of nanoseconds that have elapsed since @sec   //纳秒数</span><br><span class="line"> * @msg:The message that is to be logged  //<span class="built_in">log</span>的内容</span><br><span class="line"> *</span><br><span class="line"> * The userspace structure <span class="keyword">for</span> version 1 of the logger_entry ABI.</span><br><span class="line"> * This structure is returned to userspace unless the <span class="built_in">caller</span> requests</span><br><span class="line"> * an upgrade to a newer ABI version.</span><br><span class="line"> */</span><br><span class="line">struct user_logger_entry_compat &#123;</span><br><span class="line">__u16len;</span><br><span class="line">__u16__pad;</span><br><span class="line">__s32pid;</span><br><span class="line">__s32tid;</span><br><span class="line">__s32sec;</span><br><span class="line">__s32nsec;</span><br><span class="line">charmsg[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * struct logger_entry - defines a single entry that is given to a logger</span><br><span class="line"> * @len:The length of the payload  //有效负载长度</span><br><span class="line"> * @hdr_size:sizeof(struct logger_entry_v2) //</span><br><span class="line"> * @pid:The generating process<span class="string">' process ID</span></span><br><span class="line"><span class="string"> * @tid:The generating process'</span> thread ID</span><br><span class="line"> * @sec:The number of seconds that have elapsed since the Epoch</span><br><span class="line"> * @nsec:The number of nanoseconds that have elapsed since @sec</span><br><span class="line"> * @euid:Effective UID of logger //User Identifier 用户ID</span><br><span class="line"> * @msg:The message that is to be logged</span><br><span class="line"> *</span><br><span class="line"> * The structure <span class="keyword">for</span> version 2 of the logger_entry ABI.</span><br><span class="line"> * This structure is returned to userspace <span class="keyword">if</span> ioctl(LOGGER_SET_VERSION)</span><br><span class="line"> * is called with version &gt;= 2</span><br><span class="line"> */</span><br><span class="line">struct logger_entry &#123;</span><br><span class="line">__u16len;</span><br><span class="line">__u16hdr_size;</span><br><span class="line">__s32pid;</span><br><span class="line">__s32tid;</span><br><span class="line">__s32sec;</span><br><span class="line">__s32nsec;</span><br><span class="line">kuid_teuid;</span><br><span class="line">charmsg[0];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGGER_LOG_RADIO"log_radio"/* radio-related messages */</span></span><br><span class="line"><span class="comment">#define LOGGER_LOG_EVENTS"log_events"/* system/hardware events */</span></span><br><span class="line"><span class="comment">#define LOGGER_LOG_SYSTEM"log_system"/* system/framework messages */</span></span><br><span class="line"><span class="comment">#define LOGGER_LOG_MAIN"log_main"/* everything else */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGGER_ENTRY_MAX_PAYLOAD4076 //每条日志记录最大长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define __LOGGERIO0xAE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOGGER_GET_LOG_BUF_SIZE_IO(__LOGGERIO, 1) /* size of log */</span></span><br><span class="line"><span class="comment">#define LOGGER_GET_LOG_LEN_IO(__LOGGERIO, 2) /* used log len */</span></span><br><span class="line"><span class="comment">#define LOGGER_GET_NEXT_ENTRY_LEN_IO(__LOGGERIO, 3) /* next entry len */</span></span><br><span class="line"><span class="comment">#define LOGGER_FLUSH_LOG_IO(__LOGGERIO, 4) /* flush log */</span></span><br><span class="line"><span class="comment">#define LOGGER_GET_VERSION_IO(__LOGGERIO, 5) /* abi version */</span></span><br><span class="line"><span class="comment">#define LOGGER_SET_VERSION_IO(__LOGGERIO, 6) /* abi version */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#endif /* _LINUX_LOGGER_H */</span></span><br></pre></td></tr></table></figure></p><p> 我们看到有两个结构体user_logger_entry_compat 和 logger_entry，均用来描述一条Log记录.</p><p> struct logger_entry是一个用于描述一条Log记录的结构体。len成员变量记录了这条记录的有效负载的长度，有效负载指定的日志记录本身的长度，但是不包括用于描述这个记录的struct logger_entry结构体。回忆一下我们调用android.util.Log接口来使用日志系统时，会指定日志的优先级别Priority、Tag字符串以及Msg字符串，Priority + Tag + Msg三者内容的长度加起来就是记录的有效负载长度了。__pad成员变量是用来对齐结构体的。pid和tid成员变量分别用来记录是哪条进程和线程写入了这条记录。sec和nsec成员变量记录日志写的时间。msg成员变量记录的就有效负载的内容了，它的大小由len成员变量来确定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct logger_log - represents a specific <span class="built_in">log</span>, such as <span class="string">'main'</span> or <span class="string">'radio'</span></span><br><span class="line"> * @buffer:The actual ring buffer</span><br><span class="line"> * @misc:The <span class="string">"misc"</span> device representing the <span class="built_in">log</span></span><br><span class="line"> * @wq:The <span class="built_in">wait</span> queue <span class="keyword">for</span> @readers</span><br><span class="line"> * @readers:This <span class="built_in">log</span><span class="string">'s readers</span></span><br><span class="line"><span class="string"> * @mutex:The mutex that protects the @buffer</span></span><br><span class="line"><span class="string"> * @w_off:The current write head offset</span></span><br><span class="line"><span class="string"> * @head:The head, or location that readers start reading at.</span></span><br><span class="line"><span class="string"> * @size:The size of the log</span></span><br><span class="line"><span class="string"> * @logs:The list of log channels</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * This structure lives from module insertion until module removal, so it does</span></span><br><span class="line"><span class="string"> * not need additional reference counting. The structure is protected by the</span></span><br><span class="line"><span class="string"> * mutex '</span>mutex<span class="string">'.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct logger_log &#123;</span></span><br><span class="line"><span class="string">unsigned char*buffer;</span></span><br><span class="line"><span class="string">struct miscdevicemisc;</span></span><br><span class="line"><span class="string">wait_queue_head_twq;</span></span><br><span class="line"><span class="string">struct list_headreaders;</span></span><br><span class="line"><span class="string">struct mutexmutex;</span></span><br><span class="line"><span class="string">size_tw_off;</span></span><br><span class="line"><span class="string">size_thead;</span></span><br><span class="line"><span class="string">size_tsize;</span></span><br><span class="line"><span class="string">struct list_headlogs;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static LIST_HEAD(log_list);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * struct logger_reader - a logging device open for reading</span></span><br><span class="line"><span class="string"> * @log:The associated log</span></span><br><span class="line"><span class="string"> * @list:The associated entry in @logger_log'</span>s list</span><br><span class="line"> * @r_off:The current <span class="built_in">read</span> head offset.</span><br><span class="line"> * @r_all:Reader can <span class="built_in">read</span> all entries</span><br><span class="line"> * @r_ver:Reader ABI version</span><br><span class="line"> *</span><br><span class="line"> * This object lives from open to release, so we don<span class="string">'t need additional</span></span><br><span class="line"><span class="string"> * reference counting. The structure is protected by log-&gt;mutex.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">struct logger_reader &#123;</span></span><br><span class="line"><span class="string">struct logger_log*log;</span></span><br><span class="line"><span class="string">struct list_headlist;</span></span><br><span class="line"><span class="string">size_tr_off;</span></span><br><span class="line"><span class="string">boolr_all;</span></span><br><span class="line"><span class="string">intr_ver;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>   结构体struct logger_log就是真正用来保存日志的地方了。buffer成员变量变是用保存日志信息的内存缓冲区，它的大小由size成员变量确定。从misc成员变量可以看出，logger驱动程序使用的设备属于misc类型的设备，通过在Android模拟器上执行cat /proc/devices命令（可参考在Ubuntu上下载、编译和安装Android最新内核源代码（Linux Kernel）一文），可以看出，misc类型设备的主设备号是10。关于主设备号的相关知识，可以参考Android学习启动篇一文中提到的Linux Driver Development一书。wq成员变量是一个等待队列，用于保存正在等待读取日志的进程。readers成员变量用来保存当前正在读取日志的进程，正在读取日志的进程由结构体logger_reader来描述。mutex成员变量是一个互斥量，用来保护log的并发访问。可以看出，这里的日志系统的读写问题，其实是一个生产者-消费者的问题，因此，需要互斥量来保护log的并发访问。 w_off成员变量用来记录下一条日志应该从哪里开始写。head成员变量用来表示打开日志文件中，应该从哪一个位置开始读取日志</p><p>   结构体struct logger_reader用来表示一个读取日志的进程，log成员变量指向要读取的日志缓冲区。list成员变量用来连接其它读者进程。r_off成员变量表示当前要读取的日志在缓冲区中的位置。</p><p>   struct logger_log结构体中用于保存日志信息的内存缓冲区buffer是一个循环使用的环形缓冲区，缓冲区中保存的内容是以struct logger_entry为单位的，每个单位的组成为：</p><pre><code>struct logger_entry | priority | tag | msg由于是内存缓冲区buffer是一个循环使用的环形缓冲区，给定一个偏移值，它在buffer中的位置由下logger_offset来确定：#define logger_offset(n)          ((n) &amp; (log-&gt;size - 1))</code></pre><h2 id="Logger驱动程序模块的初始化过程分析"><a href="#Logger驱动程序模块的初始化过程分析" class="headerlink" title="Logger驱动程序模块的初始化过程分析"></a>Logger驱动程序模块的初始化过程分析</h2><p> 继续看logger.c文件，定义了三个日志设备：</p><h2 id="日志系统读取"><a href="#日志系统读取" class="headerlink" title="日志系统读取"></a>日志系统读取</h2><h2 id="日志系统写入"><a href="#日志系统写入" class="headerlink" title="日志系统写入"></a>日志系统写入</h2><h1 id="AP侧Log调用流程解析"><a href="#AP侧Log调用流程解析" class="headerlink" title="AP侧Log调用流程解析"></a>AP侧Log调用流程解析</h1><h1 id="Logcat源码简析"><a href="#Logcat源码简析" class="headerlink" title="Logcat源码简析"></a>Logcat源码简析</h1><h1 id="Android中其他log分析"><a href="#Android中其他log分析" class="headerlink" title="Android中其他log分析"></a>Android中其他log分析</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6581828" target="_blank" rel="noopener">浅谈Android系统开发中LOG的使用</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6595744" target="_blank" rel="noopener">Android日志系统驱动程序Logger源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6598703" target="_blank" rel="noopener">Android应用程序框架层和系统运行库层日志系统源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6606957" target="_blank" rel="noopener">Android日志系统Logcat源代码简要分析</a></p><p><a href="https://blog.csdn.net/armwind/article/details/52166139" target="_blank" rel="noopener">misc设备</a> 杂项设备<br>[mutex互斥锁]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 解读main log和event log日志信息&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/yelangjueqi/article/details/52621903&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;h
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android Log" scheme="http://yoursite.com/tags/Android-Log/"/>
    
  </entry>
  
  <entry>
    <title>Android8.0充电图标不显示</title>
    <link href="http://yoursite.com/2018/06/25/Android8-0%E5%85%85%E7%94%B5%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/06/25/Android8-0充电图标不显示/</id>
    <published>2018-06-25T09:06:20.000Z</published>
    <updated>2018-06-26T08:00:26.991Z</updated>
    
    <content type="html"><![CDATA[<p>1.充电图标不显示，问题分析步骤<br>a)找到充电图标的UI，frameworks/base/packages/SystemUI/res/layout/system_icons.xml<br>中找到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.android.systemui.BatteryMeterView android:id=<span class="string">"@+id/battery"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>确定充电图标UI文件，BatteryMeterView.java<br>frameworks/base/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java<br>中充电图标绘制在BatteryMeterDrawableBase.java,查看<br>frameworks/base/packages/SettingsLib/src/com/android/settingslib/graph/BatteryMeterDrawableBase.java可以看到充电的闪电图标的绘制过程。<br>在BatteryMeterView.java中可以看到充电图标的显示与否是由下面决定的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) &#123;</span><br><span class="line">        mDrawable.setBatteryLevel(level);</span><br><span class="line">        mDrawable.setCharging(pluggedIn);//pluggedIn为<span class="literal">true</span>，显示闪电图标，为<span class="literal">false</span>则不显示</span><br><span class="line">        mLevel = level;</span><br><span class="line">        updatePercentText();</span><br><span class="line">        setContentDescription(</span><br><span class="line">                getContext().getString(charging ? R.string.accessibility_battery_level_charging</span><br><span class="line">                        : R.string.accessibility_battery_level, level));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到是由pluggedIn来决定是否显示，这里有个疑问，为何不用charging的值来判断，而要用pluggedIn的值来判断。原因在下面这个代码,<br>onBatteryLevelChanged这个函数，是在<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java里面addCallback回调过去的。<br>mCharging的值是由 mCharged和 BATTERY_STATUS_CHARGING两个值一起判断的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onReceive(final Context context, Intent intent) &#123;</span><br><span class="line">        final String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(Intent.ACTION_BATTERY_CHANGED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTestmode &amp;&amp; !intent.getBooleanExtra(<span class="string">"testmode"</span>, <span class="literal">false</span>)) <span class="built_in">return</span>;</span><br><span class="line">            mHasReceivedBattery = <span class="literal">true</span>;</span><br><span class="line">            mLevel = (int)(100f</span><br><span class="line">                    * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0)</span><br><span class="line">                    / intent.getIntExtra(BatteryManager.EXTRA_SCALE, 100));</span><br><span class="line">            mPluggedIn = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;</span><br><span class="line"></span><br><span class="line">            final int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS,</span><br><span class="line">                    BatteryManager.BATTERY_STATUS_UNKNOWN);</span><br><span class="line">            mCharged = status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line">            mCharging = mCharged || status == BatteryManager.BATTERY_STATUS_CHARGING;</span><br><span class="line"></span><br><span class="line">            fireBatteryLevelChanged();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>为了查看手机中当前的pluggedIn和charging这两个值的状态，从<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java文件中看到了一个Dump 的log打印，刚好打印了这几个值的状态，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123;</span><br><span class="line">        pw.println(<span class="string">"BatteryController state:"</span>);</span><br><span class="line">        pw.print(<span class="string">"  mLevel="</span>); pw.println(mLevel);</span><br><span class="line">        pw.print(<span class="string">"  mPluggedIn="</span>); pw.println(mPluggedIn);</span><br><span class="line">        pw.print(<span class="string">"  mCharging="</span>); pw.println(mCharging);</span><br><span class="line">        pw.print(<span class="string">"  mCharged="</span>); pw.println(mCharged);</span><br><span class="line">        pw.print(<span class="string">"  mPowerSave="</span>); pw.println(mPowerSave);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><pre><code>所以，不需要另外打任何的log，直接连接手机，使用adb shell bugreport &gt; bugreport.txt抓出所有的dump log即可。BatteryController state:  mLevel=86  mPluggedIn=false  mCharging=true  mCharged=false  mPowerSave=false01-01 10:23:19.490  1000  1098  1110 D BatteryService: Sending ACTION_BATTERY_CHANGED.  level:71, scale:100, status:3, health:2, present:true, voltage: 3962, temperature: 375, technology: Li-ion, AC powered:false, USB powered:false, Wireless powered:false, icon:17303429, invalid charger:0, maxChargingCurrent:0, maxChargingVoltage:0, chargeCounter:1714883-------------------------------------------------------------------------------DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57这里有个问题，adb shell bugreport的log在User版本和Userdebug的版本里面抓出来的结果不一样，具体原因，可能是日志的级别限制的，需要查证一下。</code></pre><p>2.mPluggedIn的值是在收到ACTION_BATTERY_CHANGED广播里面带的参数得到的，那么这个广播是哪里发出来的呢？<br>通过使用<a href="http://androidxref.com" target="_blank" rel="noopener">http://androidxref.com</a> 进行全局搜索，找到是在<br>/frameworks/base/services/core/java/com/android/server/BatteryService.java的sendIntentLocked()函数里面发出来的。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="function"><span class="title">sendIntentLocked</span></span>() &#123;</span><br><span class="line">        //  Pack up the values and broadcast them to everyone</span><br><span class="line">        final Intent intent = new Intent(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line"></span><br><span class="line">        int icon = getIconLocked(mBatteryProps.batteryLevel);</span><br><span class="line"></span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_STATUS, mBatteryProps.batteryStatus);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_HEALTH, mBatteryProps.batteryHealth);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PRESENT, mBatteryProps.batteryPresent);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_LEVEL, mBatteryProps.batteryLevel);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_SCALE);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_ICON_SMALL, icon);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PLUGGED, mPlugType);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_VOLTAGE, mBatteryProps.batteryVoltage);    </span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_TEMPERATURE, mBatteryProps.batteryTemperature);  </span><br><span class="line"></span><br><span class="line">        EXTRA_PLUGGED的值是由mPlugType得到的，而mPlugType的值在BatteryService.java中得到方式如下：</span><br><span class="line">    private void processValuesLocked(boolean force) &#123;</span><br><span class="line">        boolean logOutlier = <span class="literal">false</span>;</span><br><span class="line">        long dischargeDuration = 0;</span><br><span class="line"></span><br><span class="line">        mBatteryLevelCritical = (mBatteryProps.batteryLevel &lt;= mCriticalBatteryLevel);</span><br><span class="line">        <span class="keyword">if</span> (mBatteryProps.chargerAcOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_AC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerUsbOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_USB;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerWirelessOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlugType = BATTERY_PLUGGED_NONE;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><pre><code>从中可以看出是根据mBatteryProps.chargerAcOnline或者mBatteryProps.chargerUsbOnline或者mBatteryProps.chargerWirelessOnline的值来判断，在frameworks/base/core/java/android/os/BatteryProperties.java中，可以看到这三个值是通过序列化的方式得到：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private BatteryProperties(Parcel p) &#123;</span><br><span class="line">    chargerAcOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerUsbOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerWirelessOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    maxChargingCurrent = p.readInt();</span><br><span class="line">    maxChargingVoltage = p.readInt();</span><br><span class="line">    batteryStatus = p.readInt();</span><br><span class="line">    batteryHealth = p.readInt();</span><br><span class="line">    batteryPresent = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    batteryLevel = p.readInt();</span><br><span class="line">    batteryVoltage = p.readInt();</span><br><span class="line">    batteryTemperature = p.readInt();</span><br><span class="line">    batteryFullCharge = p.readInt();</span><br><span class="line">    batteryChargeCounter = p.readInt();</span><br><span class="line">    batteryTechnology = p.readString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void writeToParcel(Parcel p, int flags) &#123;</span><br><span class="line">    p.writeInt(chargerAcOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerUsbOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerWirelessOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(maxChargingCurrent);</span><br><span class="line">    p.writeInt(maxChargingVoltage);</span><br><span class="line">    p.writeInt(batteryStatus);</span><br><span class="line">    p.writeInt(batteryHealth);</span><br><span class="line">    p.writeInt(batteryPresent ? 1 : 0);</span><br><span class="line">    p.writeInt(batteryLevel);</span><br><span class="line">    p.writeInt(batteryVoltage);</span><br><span class="line">    p.writeInt(batteryTemperature);</span><br><span class="line">    p.writeInt(batteryFullCharge);</span><br><span class="line">    p.writeInt(batteryChargeCounter);</span><br><span class="line">    p.writeString(batteryTechnology);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final Parcelable.Creator&lt;BatteryProperties&gt; CREATOR</span><br><span class="line">    = new Parcelable.Creator&lt;BatteryProperties&gt;() &#123;</span><br><span class="line">    public BatteryProperties createFromParcel(Parcel p) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BatteryProperties[] newArray(int size) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>再来看看mBatteryProps的赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void update(BatteryProperties props) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mUpdatesStopped) &#123;</span><br><span class="line">            mBatteryProps = props;</span><br><span class="line">            // Process the new values.</span><br><span class="line">            processValuesLocked(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastBatteryProps.set(props);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接着看update()函数的调用，如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class BatteryListener extends IBatteryPropertiesListener.Stub &#123;</span><br><span class="line">    @Override public void batteryPropertiesChanged(BatteryProperties props) &#123;</span><br><span class="line">        final long identity = Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            BatteryService.this.update(props);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(identity);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>可以看到BatteryProperties是在由batteryPropertiesChanged赋值，是通过AIDL实现对C++侧的监听，这个AIDL实现了JAVA侧与C++侧的通讯。这一块关于电池的共有三个AIDL文件,作为客户端和服务端的媒介，具体代码，以及作用分析如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/BatteryProperties.aidl</span><br><span class="line">package android.os;</span><br><span class="line">    parcelable BatteryProperties;</span><br></pre></td></tr></table></figure><pre><code>BatteryProperties.aidl主要用户AIDL跨进程通讯时的数据序列化和反序列化frameworks/base/core/java/android/os/BatteryProperties.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesListener.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.BatteryProperties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* &#123;@hide&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">oneway interface IBatteryPropertiesListener &#123;</span><br><span class="line">    void batteryPropertiesChanged(<span class="keyword">in</span> BatteryProperties props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesListener.aidl主要用于监听</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesRegistrar.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.IBatteryPropertiesListener;</span><br><span class="line">import android.os.BatteryProperty;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@hide&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">interface IBatteryPropertiesRegistrar &#123;</span><br><span class="line">    void registerListener(IBatteryPropertiesListener listener);</span><br><span class="line">    void unregisterListener(IBatteryPropertiesListener listener);</span><br><span class="line">    int getProperty(<span class="keyword">in</span> int id, out BatteryProperty prop);</span><br><span class="line">    oneway void scheduleUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesRegistrar.aidl主要用于注册服务端在BatteryService.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">onStart</span></span>() &#123;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"batteryproperties"</span>);</span><br><span class="line">    final IBatteryPropertiesRegistrar batteryPropertiesRegistrar =</span><br><span class="line">            IBatteryPropertiesRegistrar.Stub.asInterface(b);</span><br><span class="line">    try &#123;</span><br><span class="line">        batteryPropertiesRegistrar.registerListener(new BatteryListener());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Should never happen.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBinderService = new BinderService();</span><br><span class="line">    publishBinderService(<span class="string">"battery"</span>, mBinderService);</span><br><span class="line">    publishLocalService(BatteryManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>对应的native层的代码在frameworks/native/services/batteryservice/编译出libbatteryservice.so库Java侧与C++侧通过AIDL通讯，两边都要写AIDL文件，且两边都要有Parcel序列化。通过查找batteryPropertiesChanged函数system/core/healthd/BatteryPropertiesRegistrar.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "BatteryPropertiesRegistrar.h"</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/BatteryService.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesListener.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesRegistrar.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IPCThreadState.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IServiceManager.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/PermissionCache.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;private/android_filesystem_config.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Errors.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Mutex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/String16.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;healthd/healthd.h&gt;</span></span><br><span class="line"></span><br><span class="line">namespace android &#123;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::publish(</span><br><span class="line">    const sp&lt;BatteryPropertiesRegistrar&gt;&amp; service) &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(String16(<span class="string">"batteryproperties"</span>), service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::notifyListeners(const struct BatteryProperties&amp; props) &#123;</span><br><span class="line">    Vector&lt;sp&lt;IBatteryPropertiesListener&gt; &gt; listenersCopy;</span><br><span class="line"></span><br><span class="line">    // Binder currently may service an incoming oneway transaction whenever an</span><br><span class="line">    // outbound oneway call is made (<span class="keyword">if</span> there is already a pending incoming</span><br><span class="line">    // oneway call waiting).  This is considered a bug and may change <span class="keyword">in</span> the</span><br><span class="line">    // future.  For now, avoid recursive mutex lock <span class="keyword">while</span> making outbound</span><br><span class="line">    // calls by making a <span class="built_in">local</span> copy of the current list of listeners.</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        listenersCopy = mListeners;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; listenersCopy.size(); i++) &#123;</span><br><span class="line">        listenersCopy[i]-&gt;batteryPropertiesChanged(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::registerListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        // check whether this is a duplicate</span><br><span class="line">        <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mListeners.add(listener);</span><br><span class="line">        IInterface::asBinder(listener)-&gt;linkToDeath(this);</span><br><span class="line">    &#125;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::unregisterListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">            IInterface::asBinder(mListeners[i])-&gt;unlinkToDeath(this);</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::getProperty(int id, struct BatteryProperty *val) &#123;</span><br><span class="line">    <span class="built_in">return</span> healthd_get_property(id, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::<span class="function"><span class="title">scheduleUpdate</span></span>() &#123;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::dump(int fd, const Vector&lt;String16&gt;&amp; /*args*/) &#123;</span><br><span class="line">    IPCThreadState* self = IPCThreadState::self();</span><br><span class="line">    const int pid = self-&gt;getCallingPid();</span><br><span class="line">    const int uid = self-&gt;getCallingUid();</span><br><span class="line">    <span class="keyword">if</span> ((uid != AID_SHELL) &amp;&amp;</span><br><span class="line">        !PermissionCache::checkPermission(</span><br><span class="line">                String16(<span class="string">"android.permission.DUMP"</span>), pid, uid))</span><br><span class="line">        <span class="built_in">return</span> PERMISSION_DENIED;</span><br><span class="line"></span><br><span class="line">    healthd_dump_battery_state(fd);</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == who) &#123;</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace android</span><br></pre></td></tr></table></figure><pre><code>再查找notifyListeners函数，在 system/core/healthd/healthd_mode_android.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void healthd_mode_android_battery_update(</span><br><span class="line">    struct android::BatteryProperties *props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gBatteryPropertiesRegistrar != NULL)</span><br><span class="line">        gBatteryPropertiesRegistrar-&gt;notifyListeners(*props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>Healthd是一种中介模型，向下监听来自kernel层的电池事件，向上将电池数据信息传递给Framework层的BatteryService.主要代码在 system/core/healthd 中，对Healthd模块的代码分析如下：参考：Healthd模块编译出来的文件有system/bin/healthd通过在system/core/healthd里面查找chargerUsbOnline，在system/core/healthd/BatteryMonitor.cpp中update函数可以看到赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">bool BatteryMonitor::update(void) &#123;</span><br><span class="line">    bool logthis;</span><br><span class="line"></span><br><span class="line">    initBatteryProperties(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryPresentPath.isEmpty())</span><br><span class="line">        props.batteryPresent = getBooleanField(mHealthdConfig-&gt;batteryPresentPath);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        props.batteryPresent = mBatteryDevicePresent;</span><br><span class="line"></span><br><span class="line">    props.batteryLevel = mBatteryFixedCapacity ?</span><br><span class="line">        mBatteryFixedCapacity :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryCapacityPath);</span><br><span class="line">    props.batteryVoltage = getIntField(mHealthdConfig-&gt;batteryVoltagePath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty())</span><br><span class="line">        props.batteryCurrent = getIntField(mHealthdConfig-&gt;batteryCurrentNowPath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty())</span><br><span class="line">        props.batteryFullCharge = getIntField(mHealthdConfig-&gt;batteryFullChargePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty())</span><br><span class="line">        props.batteryCycleCount = getIntField(mHealthdConfig-&gt;batteryCycleCountPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryChargeCounterPath.isEmpty())</span><br><span class="line">        props.batteryChargeCounter = getIntField(mHealthdConfig-&gt;batteryChargeCounterPath);</span><br><span class="line"></span><br><span class="line">    props.batteryTemperature = mBatteryFixedTemperature ?</span><br><span class="line">        mBatteryFixedTemperature :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryTemperaturePath);</span><br><span class="line"></span><br><span class="line">    // For devices <span class="built_in">which</span> <span class="keyword">do</span> not have battery and are always plugged</span><br><span class="line">    // into power souce.</span><br><span class="line">    <span class="keyword">if</span> (mAlwaysPluggedDevice) &#123;</span><br><span class="line">        props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">        props.batteryPresent = <span class="literal">true</span>;</span><br><span class="line">        props.batteryStatus = BATTERY_STATUS_CHARGING;</span><br><span class="line">        props.batteryHealth = BATTERY_HEALTH_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryStatusPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryStatus = getBatteryStatus(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryHealthPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryHealth = getBatteryHealth(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryTechnologyPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryTechnology = String8(buf.c_str());</span><br><span class="line"></span><br><span class="line">    unsigned int i;</span><br><span class="line">    double MaxPower = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; mChargerNames.size(); i++) &#123;</span><br><span class="line">        String8 path;</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/online"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          mChargerNames[i].string());</span><br><span class="line">        <span class="keyword">if</span> (getIntField(path)) &#123;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/type"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            switch(readPowerSupplyType(path)) &#123;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_AC:</span><br><span class="line">                props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_USB:</span><br><span class="line">                props.chargerUsbOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_WIRELESS:</span><br><span class="line">                props.chargerWirelessOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                KLOG_WARNING(LOG_TAG, <span class="string">"%s: Unknown power supply type\n"</span>,</span><br><span class="line">                             mChargerNames[i].string());</span><br><span class="line">            &#125;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/current_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            int ChargingCurrent =</span><br><span class="line">                    (access(path.string(), R_OK) == 0) ? getIntField(path) : 0;</span><br><span class="line"></span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/voltage_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line"></span><br><span class="line">            int ChargingVoltage =</span><br><span class="line">                (access(path.string(), R_OK) == 0) ? getIntField(path) :</span><br><span class="line">                DEFAULT_VBUS_VOLTAGE;</span><br><span class="line"></span><br><span class="line">            double power = ((double)ChargingCurrent / MILLION) *</span><br><span class="line">                           ((double)ChargingVoltage / MILLION);</span><br><span class="line">            <span class="keyword">if</span> (MaxPower &lt; power) &#123;</span><br><span class="line">                props.maxChargingCurrent = ChargingCurrent;</span><br><span class="line">                props.maxChargingVoltage = ChargingVoltage;</span><br><span class="line">                MaxPower = power;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logthis = !healthd_board_battery_update(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        char dmesgline[256];</span><br><span class="line">        size_t len;</span><br><span class="line">        <span class="keyword">if</span> (props.batteryPresent) &#123;</span><br><span class="line">            snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery l=%d v=%d t=%s%d.%d h=%d st=%d"</span>,</span><br><span class="line">                 props.batteryLevel, props.batteryVoltage,</span><br><span class="line">                 props.batteryTemperature &lt; 0 ? <span class="string">"-"</span> : <span class="string">""</span>,</span><br><span class="line">                 abs(props.batteryTemperature / 10),</span><br><span class="line">                 abs(props.batteryTemperature % 10), props.batteryHealth,</span><br><span class="line">                 props.batteryStatus);</span><br><span class="line"></span><br><span class="line">            len = strlen(dmesgline);</span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" c=%d"</span>, props.batteryCurrent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" fc=%d"</span>, props.batteryFullCharge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" cc=%d"</span>, props.batteryCycleCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery none"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        snprintf(dmesgline + len, sizeof(dmesgline) - len, <span class="string">" chg=%s%s%s"</span>,</span><br><span class="line">                 props.chargerAcOnline ? <span class="string">"a"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerUsbOnline ? <span class="string">"u"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerWirelessOnline ? <span class="string">"w"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        KLOG_WARNING(LOG_TAG, <span class="string">"%s\n"</span>, dmesgline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    healthd_mode_ops-&gt;battery_update(&amp;props);</span><br><span class="line">    <span class="built_in">return</span> props.chargerAcOnline | props.chargerUsbOnline |</span><br><span class="line">            props.chargerWirelessOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   从上面代码可以看到chargerUsbOnline的值是通过读取 sys/class/power_supply文件夹下的USB文件夹下的type里面的值来判断。</p><p>   adb shell进入手机后，cd sys/class/power_supply/USB,cat type发现是USB。<br>   这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump log来看如下：的确没有正确的读取到</p><pre><code>-------------------------------------------------------------------------------DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57现在怀疑是SeAndroid的AVC权限导致的。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.充电图标不显示，问题分析步骤&lt;br&gt;a)找到充电图标的UI，frameworks/base/packages/SystemUI/res/layout/system_icons.xml&lt;br&gt;中找到&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android PMS" scheme="http://yoursite.com/tags/Android-PMS/"/>
    
  </entry>
  
  <entry>
    <title>Android</title>
    <link href="http://yoursite.com/2018/06/23/year-06-23-Android/"/>
    <id>http://yoursite.com/2018/06/23/year-06-23-Android/</id>
    <published>2018-06-23T12:26:02.000Z</published>
    <updated>2018-06-24T12:27:49.481Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>ANR 机制以及问题分析</title>
    <link href="http://yoursite.com/2018/06/21/ANR-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/21/ANR-机制以及问题分析/</id>
    <published>2018-06-21T11:06:22.000Z</published>
    <updated>2018-06-29T09:44:26.762Z</updated>
    
    <content type="html"><![CDATA[<p>本文目标讲解Android中的ANR原理以及如何分析ANR问题</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。</p><p>   首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问题圈定在应用程序。SNR是有Watchdog机制保证，具体可查阅<strong>Watchdog机制以及问题分析</strong>;ANR由消息处理机制保证，Android在系统层实现了一套机制来发现ANR,核心原理是消息调度和超时处理。</p><p>   其次，ANR机制的主体实现在系统层。所有与ANR相关的消息，都会经过系统进程(system_server)调度，然后派发发哦应用进程完成对消息的实际处理，同时，系统进程设计了不同的超时限制来跟踪消息的处理。一旦应用程序处理消息不当，超时限制就起了作用了，它收集一些系统状态，比如CPU/IO使用情况、进程函数调用栈，并报告用户进程无响应(弹出ANR对话框).</p><p>   然后，ANR问题本质是一个性能问题和稳定性的问题。ANR机制实际上对应用程序主线程的限制，要求主线程在限定的时间内处理完一些常见的操作(启动服务、处理广播、处理输入)，如果超时，则任务主线程已经失去了响应其他操作的能力。主线程中的耗时操作，比如密集CPU运算、大量IO、复杂界面布局等，都会降低应用程序的响应能力。当系统中的ANR问题太多的时候，就影响到了系统的稳定性。</p><p>   最后，部分ANR问题时很难分析的，有时候由于系统底层的一些影响，导致消息调度失败，比如说Binder资源耗尽，nativepollonce等，出现问题的场景又难以复现。这类ANR问题往往需要花费大量的事件去了解系统的一些行为，超出了ANR机制本省的范畴。</p><p>   出现ANR的场景主要有以下几种：</p><blockquote><ul><li><strong>Service Timeout:</strong>服务在20s内未执行完成；</li><li><strong>BroadcastQueue Timeout：</strong>比如前台广播在10s内执行完成</li><li><strong>ContentProvider Timeout：</strong>内容提供者执行超时</li><li><strong>inputDispatching Timeout:</strong> 输入事件分发超时5s，包括按键分发事件的超时</li></ul></blockquote><h2 id="Google-官方关于ANR的介绍"><a href="#Google-官方关于ANR的介绍" class="headerlink" title="Google 官方关于ANR的介绍"></a>Google 官方关于ANR的介绍</h2><p>   Google官方关于ANR的介绍是在介绍使用Android Vitals工具时提到：<a href="https://developer.android.com/topic/performance/vitals/anr" target="_blank" rel="noopener">https://developer.android.com/topic/performance/vitals/anr</a></p><h3 id="查找ANR根因"><a href="#查找ANR根因" class="headerlink" title="查找ANR根因"></a>查找ANR根因</h3><p>查找ANR根因的方法有</p><ol><li><p>使用StrictMode<br>具体请参照： StrictMode 机制以及性能调优</p></li><li><p>启动ANR 背景对话框<br>Enable background ANR dialogs</p><p>Android shows ANR dialogs for apps that take too long to process the broadcast message only if Show all ANRs is enabled in the device’s Developer options. For this reason, background ANR dialogs are not always displayed to the user, but the app could still be experiencing performance issues.</p><p> 打开 开发者模式 –&gt; 打开 Show All ANR</p></li><li><p>使用TraceView</p></li><li><p>adb pull data/anr</p></li></ol><h3 id="解决ANR问题的方式"><a href="#解决ANR问题的方式" class="headerlink" title="解决ANR问题的方式"></a>解决ANR问题的方式</h3><pre><code>There are some common patterns to look for when diagnosing ANRs:1. The app is doing slow operations involving I/O on the main thread.2. The app is doing a long calculation on the main thread.3. The main thread is doing a synchronous binder call to another process, and that other process is taking a long time to return.4. The main thread is blocked waiting for a synchronized block for a long operation that is happening on another thread.5. The main thread is in a deadlock with another thread, either in your process or via a binder call. The main thread is not just waiting for a long operation to finish, but is in a deadlock situation. For more information, see Deadlock on Wikipedia.</code></pre><p>翻译如下:<br>    在诊断ANR时有一些常见的模式需要查找：</p><pre><code>1. 该应用程序在主线程上执行涉及I / O的缓慢操作。2. 该应用程序正在对主线程进行长时间计算。3. 主线程正在对另一个进程执行同步绑定程序调用，而其他进程需要很长时间才能返回。4. 主线程被阻塞，等待正在另一个线程上发生的长操作的同步块。5. 主线程与另一个线程处于死锁状态，无论是在您的进程中还是通过联编程序调用。主线不仅仅是等待长时间的操作才能完成，而是处于死锁状态。有关更多信息，请参阅 维基百科上的死锁。</code></pre><ol><li><p>主线程执行超时<br>定位到是主线程超时时，需要找到对应的代码，将超时操作移到<a href="https://developer.android.com/topic/performance/threads#helper" target="_blank" rel="noopener">Handler</a>里面去处理，或者使用AsyncTask(<a href="https://developer.android.com/reference/android/os/AsyncTask" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/AsyncTask</a>) 异步任务的方式来处理。</p></li><li><p>主线程I/O超时<br>I/O超时，将超时操作移动到线程中处理,使用Handler或者AsyncTask.如果I/O是网络操作的或者存储操作的话，<a href="https://developer.android.com/training/basics/network-ops/" target="_blank" rel="noopener">网络操作</a>使用<a href="https://developer.android.com/training/volley/" target="_blank" rel="noopener">Volly</a>的方式来实现,数据存储的话，参照Android提供的几种存储方式<a href="https://developer.android.com/guide/topics/data/data-storage" target="_blank" rel="noopener">https://developer.android.com/guide/topics/data/data-storage</a></p></li><li><p>互斥锁<br>当前工作线程持有了UI线程所需要的资源太长时间，导致UI线程一直处于Wait状态.UI线程被阻塞住。可以使用<a href="https://developer.android.com/reference/java/util/concurrent/Semaphore" target="_blank" rel="noopener">Semaphore</a>(计数信号量)或者线程<a href="https://developer.android.com/reference/java/util/concurrent/locks/Lock" target="_blank" rel="noopener">锁</a>等其他的互斥机制来解决。 </p></li><li><p>死锁<br>UI线程和其他线程互相持有对方所需要的资源，导致死锁。双方都在等待对方释放资源。<br>解决死锁的方式：</p></li><li><p>广播超时<br>广播OnReceiver方法中耗时太久，比如前台广播超过10s未完成等<br>如果广播中需要执行复杂的操作，可以通过<a href="">IntenService</a>来实现。</p></li><li><p>服务超时/内容提供者超时/输入事件超时<br>都是用Handler或者AsyncTask来处理</p></li><li><p>CPU负载过高<br>一般CPU负载过高，只有在进行压力测试的时候才能出现，出现CPU负载过高之后，会使得很多事件得不到响应。一般CPU负载过高的ANR问题都不解。   </p></li></ol><h2 id="ANR-机制"><a href="#ANR-机制" class="headerlink" title="ANR 机制"></a>ANR 机制</h2><p>   分析一些初级的ANR问题，只需要简单理解最终输出的日志即可，但对于一些系统问题(比如CPU负载过高、进程卡死) 发的ANR，就需要对整个ANR机制有所了解，才能定位出问题的原因。</p><p>   ANR机制可以分为两部分：</p><blockquote><ul><li><strong>ANR的监测。</strong> Android对不同的ANR类型(Broadcase/Service/InputEvent)都有一套监测机制。</li></ul></blockquote><blockquote><ul><li><strong>ANR的报告。</strong> 在监测到ANR以后，需要显示ANR对话框、输出日志(发生ANR时的进程函数调用栈、CPU使用情况等)。</li></ul></blockquote><p>   整个ANR机制的代码也是横跨了Android的几个层：</p><blockquote><ul><li><strong>App层：</strong>应用主线程的处理逻辑</li></ul></blockquote><blockquote><ul><li><strong>Framework层：</strong>  ANR机制的核心</li></ul></blockquote><blockquote><ul><li>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</li><li>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</li><li>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</li><li>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</li><li>frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java</li><li>frameworks/base/core/java/android/view/InputChannel</li><li>frameworks/base/services/core/java/com/android/internal/os/ProcessCpuTracker</li></ul></blockquote><blockquote><ul><li><strong>Native层：</strong> 输入事件派发机制。针对InputEvent类型的ANR</li></ul></blockquote><blockquote><ul><li>frameworks/base//services/core/jni/com_android_server_input_InputManagerService.cpp</li><li>frameworks/native/services/inputflinger/InputDispatcher.cpp</li></ul></blockquote><p>   下面我们会深入源码，分析ANR的监测和报告过程。</p><h3 id="ANR检测机制"><a href="#ANR检测机制" class="headerlink" title="ANR检测机制"></a>ANR检测机制</h3><h4 id="Service-处理超时"><a href="#Service-处理超时" class="headerlink" title="Service 处理超时"></a>Service 处理超时</h4><p>   Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。</p><p>   当发生Service ANR时，一般可以先排查一下在Service的生命周期函数中(onCreate(), onStartCommand()等)有没有做耗时的操作，譬如复杂的运算、IO操作等。如果应用程序的代码逻辑查不出问题，就需要深入检查当前系统的状态：CPU的使用情况、系统服务的状态等，判断当时发生ANR进程是否受到系统运行异常的影响。</p><p>   如何检测Service超时呢？Android是通过设置定时消息实现的。定时消息是由AMS的消息队列处理的(system_server的ActivityManager线程)。 AMS有Service运行的上下文信息，所以在AMS中设置一套超时检测机制也是合情合理的。</p><p>   Service ANR机制相对最为简单，简单说就是AMS中的mHandler收到SERVICE_TIMEOUT_MSG消息时触发。<br>   主体实现在<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActiveServices.java" target="_blank" rel="noopener">ActiveServices.java</a>中。 当Service的生命周期开始时，bumpServiceExecutingLocked()会被调用，紧接着会调用scheduleServiceTimeoutLocked()：</p><p>   StartService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread == null) &#123;</span><br><span class="line">            throw new RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">        r.app = app;</span><br><span class="line">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        final boolean newService = app.services.add(r);</span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);//执行bumpServiceExecutingLocked</span><br><span class="line">        mAm.updateLruProcessLocked(app, <span class="literal">false</span>, null);</span><br><span class="line">        updateServiceForegroundLocked(r.app, /* oomAdj= */ <span class="literal">false</span>);</span><br><span class="line">        mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        boolean created = <span class="literal">false</span>;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">                String nameTerm;</span><br><span class="line">                int lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">                EventLogTags.writeAmCreateService(</span><br><span class="line">                        r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">            &#125;</span><br><span class="line">            ........</span><br></pre></td></tr></table></figure></p><p>   BindService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">            // If service is not currently running, can<span class="string">'t yet bind.</span></span><br><span class="line"><span class="string">            return false;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, "requestBind " + i + ": requested=" + i.requested</span></span><br><span class="line"><span class="string">                + " rebind=" + rebind);</span></span><br><span class="line"><span class="string">        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                bumpServiceExecutingLocked(r, execInFg, "bind");//执行bumpServiceExecutingLocked</span></span><br><span class="line"><span class="string">                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span></span><br><span class="line"><span class="string">                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span></span><br><span class="line"><span class="string">                        r.app.repProcState);</span></span><br><span class="line"><span class="string">                if (!rebind) &#123;</span></span><br><span class="line"><span class="string">                    i.requested = true;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                i.hasBound = true;</span></span><br><span class="line"><span class="string">                i.doRebind = false;</span></span><br><span class="line"><span class="string">            &#125; catch (TransactionTooLargeException e) &#123;</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r, e);</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                throw e;</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r);</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>调用bumpServiceExecutingLocked</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void bumpServiceExecutingLocked(ServiceRecord r, boolean <span class="built_in">fg</span>, String why) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r + <span class="string">" in app "</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r.shortName);</span><br><span class="line">    long now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == 0) &#123;</span><br><span class="line">        r.executeFg = <span class="built_in">fg</span>;</span><br><span class="line">        ServiceState stracker = r.getTracker();</span><br><span class="line">        <span class="keyword">if</span> (stracker != null) &#123;</span><br><span class="line">            stracker.setExecuting(<span class="literal">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |= <span class="built_in">fg</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == 1) &#123;</span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != null &amp;&amp; <span class="built_in">fg</span> &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">        r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">    &#125;</span><br><span class="line">    r.executeFg |= <span class="built_in">fg</span>;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    r.executingStart = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着调用scheduleServiceTimeoutLocked<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法通过AMS.MainHandler抛出一个定时消息SERVICE_TIMEOUT_MSG：</p><blockquote><ul><li><strong>前台进程中执行Service</strong>，超时时间是SERVICE_TIMEOUT(20秒)</li><li><strong>后台进程中执行Service</strong>，超时时间是SERVICE_BACKGROUND_TIMEOUT(200秒)</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_TIMEOUT = 20*1000;</span><br><span class="line"></span><br><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;</span><br><span class="line"></span><br><span class="line">// How long the startForegroundService() grace period is to get around to</span><br><span class="line">// calling startForeground() before we ANR + stop it.</span><br><span class="line">static final int SERVICE_START_FOREGROUND_TIMEOUT = 5*1000;</span><br></pre></td></tr></table></figure><p>当Service的生命周期结束时，会调用serviceDoneExecutingLocked()方法，之前抛出的SERVICE_TIMEOUT_MSG消息在这个方法中会被清除。 如果在超时时间内，SERVICE_TIMEOUT_MSG没有被清除，那么，AMS.MainHandler就会响应这个消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,</span><br><span class="line">            boolean finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">                + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">                + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line">        r.executeNesting--;</span><br><span class="line">        <span class="keyword">if</span> (r.executeNesting &lt;= 0) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">                r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">                r.app.executingServices.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.app.executingServices.size() == 0) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                            <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);//清除SERVICE_TIMEOUT_MSG消息</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                    // Need to re-evaluate whether the app still needs to be <span class="keyword">in</span> the foreground.</span><br><span class="line">                    <span class="keyword">for</span> (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                            r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .....</span><br></pre></td></tr></table></figure><p>AMS.MainHandler就会响应这个消息:<br>见<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">ActivityManagerService</a><br>本文是基于Android8.0的代码分析，与<a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a> 这篇文章这里的代码不一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final class MainHandler extends Handler &#123;</span><br><span class="line">       public MainHandler(Looper looper) &#123;</span><br><span class="line">           super(looper, null, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE_CONFIGURATION_MSG: &#123;</span><br><span class="line">               final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">               Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj,</span><br><span class="line">                       msg.arg1);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> GC_BACKGROUND_PROCESSES_MSG: &#123;</span><br><span class="line">               synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                   performAppGcsIfAppropriateLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;  </span><br><span class="line">               mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_TIMEOUT_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundTimeout((ServiceRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_CRASH_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundCrash((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> DISPATCH_PENDING_INTENT_CANCEL_MSG: &#123;</span><br><span class="line">               RemoteCallbackList&lt;IResultReceiver&gt; callbacks</span><br><span class="line">                       = (RemoteCallbackList&lt;IResultReceiver&gt;)msg.obj;</span><br><span class="line">               int N = callbacks.beginBroadcast();</span><br><span class="line">               <span class="keyword">for</span> (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               callbacks.finishBroadcast();</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           ......</span><br></pre></td></tr></table></figure></p><p>mServices是ActiveServices，又返回到ActiveService中进行处理:<br>serviceTimeout 的处理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void serviceTimeout(ProcessRecord proc) &#123;</span><br><span class="line">    String anrMessage = null;</span><br><span class="line">    synchronized(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        final long now = SystemClock.uptimeMillis();</span><br><span class="line">        final long maxTime =  now -</span><br><span class="line">                (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        ServiceRecord timeout = null;</span><br><span class="line">        long nextTime = 0;</span><br><span class="line">        <span class="keyword">for</span> (int i=proc.executingServices.size()-1; i&gt;=0; i--) &#123;// 寻找运行超时的Service</span><br><span class="line">            ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123; // 判断执行Service超时的进程是否在最近运行进程列表，如果在，则输出<span class="built_in">log</span>到logcat和dumplog中，并记录anrMessage供弹框使用</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timeout executing service: "</span> + timeout);</span><br><span class="line">            StringWriter sw = new StringWriter();</span><br><span class="line">            PrintWriter pw = new FastPrintWriter(sw, <span class="literal">false</span>, 1024);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">"    "</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  //其他的三种情况分别如下，则继续等待监测20s或者200s</span><br><span class="line">        //a)如果Service超时，但是不在最近运行进程列表中</span><br><span class="line">        //b)如果Service不超时，且不在最近运行进程列表中</span><br><span class="line">        //c)如果Service不超时，且在最近运进程列表中</span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">        mAm.mAppErrors.appNotResponding(proc, null, null, <span class="literal">false</span>, anrMessage);//ANR的弹框处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法会找到当前进程已经超时的Service，经过一些判定后，决定要报告ANR，最终调用AMS.appNotResponding()方法。 走到这一步，ANR机制已经完成了监测报告任务，剩下的任务就是ANR结果的输出，我们称之为ANR的报告机制。 ANR的报告机制是通过AMS.appNotResponding()完成的，Broadcast和InputEvent类型的ANR最终也都会调用这个方法，我们后文再详细展开。</p><p>至此，我们分析了Service的ANR机制：</p><p>通过定时消息跟踪Service的运行，当定时消息被响应时，说明Service还没有运行完成，这就意味着Service ANR。</p><h4 id="Broadcast处理超时"><a href="#Broadcast处理超时" class="headerlink" title="Broadcast处理超时"></a>Broadcast处理超时</h4><p>应用程序可以注册广播接收器，实现BroadcastReceiver.onReceive()方法来完成对广播的处理。通常，这个方法是在主线程执行的，Android限定它执行时间不能超过10秒，否则，就会引发ANR。</p><p>onReceive()也可以调度在其他线程执行，通过Context.registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)这个方法注册广播接收器， 可以指定一个处理的Handler，将onReceive()调度在非主线程执行。</p><p>这里先把问题抛出来了：</p><blockquote><p>Android如何将广播投递给各个应用程序？<br>Android如何检测广播处理超时？</p></blockquote><p>广播消息的调度<br>AMS维护了两个广播队列BroadcastQueue:</p><blockquote><p> foreground queue，前台队列的超时时间是10秒<br> background queue，后台队列的超时时间是60秒</p></blockquote><p>之所以有两个，就是因为要区分的不同超时时间。所有发送的广播都会进入到队列中等待调度，在发送广播时，可以通过Intent.FLAG_RECEIVER_FOREGROUND参数将广播投递到前台队列。 AMS线程会不断地从队列中取出广播消息派发到各个接收器(BroadcastReceiver)。当要派发广播时，AMS会调用BroadcastQueue.scheduleBroadcastsLocked()方法：</p><p><strong> 参见 Android中广播注册和发送机制分析 </strong></p><p>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">scheduleBroadcastsLocked</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，往AMS线程的消息队列发送BROADCAST_INTENT_MSG消息，由此也可以看到真正派发广播的是AMS线程(system_server进程中的ActivityManager线程)。 由于上述方法可能被并发调用，所以通过mBroadcastsScheduled这个变量来标识BROADCAST_INTENT_MSG是不是已经被AMS线程接收了，当已经抛出的消息还未被接受时，不需要重新抛出。 该消息被接收后的处理逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static final int BROADCAST_INTENT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG;</span><br><span class="line">static final int BROADCAST_TIMEOUT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG + 1;</span><br><span class="line"></span><br><span class="line">final BroadcastHandler mHandler;</span><br><span class="line"></span><br><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">    public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        super(looper, null, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                processNextBroadcast(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 直接调用BroadcastQueue.processNextBroadcast()方法，fromMsg参数为true表示这是一次来自BROADCAST_INTENT_MSG消息的派发请求。 BroadcastQueue.processNextBroadcast()是派发广播消息最为核心的函数，代码量自然也不小，我们分成几个部分来分析：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分1：处理非串行广播消息</span><br><span class="line">final ActivityManagerService mService;//mService是ActivityManagerService</span><br><span class="line">   .....</span><br><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">       synchronized(mService) &#123;</span><br><span class="line">           BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                   + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                   + mParallelBroadcasts.size() + <span class="string">" parallel broadcasts, "</span></span><br><span class="line">                   + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">           mService.updateCpuStats();//更新CPU状态信息</span><br><span class="line"></span><br><span class="line">           //1. 更新mBroadcastsScheduled 标志状态</span><br><span class="line">           <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">               mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">           //2. 处理并行广播</span><br><span class="line">           <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">               r = mParallelBroadcasts.remove(0);</span><br><span class="line">               r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">               r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                   Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">                   Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int N = r.receivers.size();</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">               <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                   Object target = r.receivers.get(i);</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                           <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                           + target + <span class="string">": "</span> + r);</span><br><span class="line">                   deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="literal">false</span>, i);</span><br><span class="line">               &#125;</span><br><span class="line">               addBroadcastToHistoryLocked(r);</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Now take care of the next serialized one...</span><br><span class="line"></span><br><span class="line">           // If we are waiting <span class="keyword">for</span> a process to come up to handle the next</span><br><span class="line">           // broadcast, <span class="keyword">then</span> <span class="keyword">do</span> nothing at this point.  Just <span class="keyword">in</span> <span class="keyword">case</span>, we</span><br><span class="line">           // check that the process we<span class="string">'re waiting for still exists.</span></span><br><span class="line"><span class="string">           //3. 处理阻塞广播</span></span><br><span class="line"><span class="string">           if (mPendingBroadcast != null) &#123;</span></span><br><span class="line"><span class="string">               if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                       "processNextBroadcast [" + mQueueName + "]: waiting for "</span></span><br><span class="line"><span class="string">                       + mPendingBroadcast.curApp);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               boolean isDead; // isDead表示当前广播消息的进程的存活状态</span></span><br><span class="line"><span class="string">               synchronized (mService.mPidsSelfLocked) &#123;</span></span><br><span class="line"><span class="string">                   ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span></span><br><span class="line"><span class="string">                   isDead = proc == null || proc.crashing;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               if (!isDead) &#123;</span></span><br><span class="line"><span class="string">                   // It'</span>s still alive, so keep waiting// 如果还活着，则返回该函数，继续等待下次派发</span><br><span class="line">                   <span class="built_in">return</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                           + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                           + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                   mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                   mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                   mPendingBroadcast = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //未完待续</span><br></pre></td></tr></table></figure></p><p>第一个部分是处理非”串行广播消息”，有以下几个步骤：</p><ol><li><p>设置mBroadcastsScheduled。该变量在前文说过，是对BROADCAST_INTENT_MSG进行控制。 如果是响应BROADCAST_INTENT_MSG 的派发调用，则将mBroadcastsScheduled设为false， 表示本次 BROADCAST_INTENT_MSG 已经处理完毕，可以继续抛出下一次 BROADCAST_INTENT_MSG消息了</p></li><li><p>处理”并行广播消息”。广播接受器有”动态”和”静态”之分，通过Context.registerReceiver()注册的广播接收器为”动态”的，通过AndroidManifest.xml注册的广播接收器为”静态”的。 广播消息有”并行”和”串行”之分，”并行广播消息”都会派发到”动态”接收器，”串行广播消息”则会根据实际情况派发到两种接收器。 我们先不去探究Android为什么这么设计，只关注这两种广播消息派发的区别。在BroadcastQueue维护着两个队列：</p></li></ol><blockquote><p> mParallelBroadcasts，”并行广播消息”都会进入到此队列中排队。”并行广播消息”可以一次性派发完毕，即在一个循环中将广播派发到所有的”动态”接收器</p></blockquote><blockquote><p> mOrderedBroadcasts，”串行广播消息”都会进入到此队列中排队。”串行广播消息”需要轮侯派发，当一个接收器处理完毕后，会再抛出BROADCAST_INTENT_MSG消息， 再次进入BroadcastQueue.processNextBroadcast()处理下一个</p></blockquote><ol start="3"><li>处理阻塞的广播消息。有时候会存在一个广播消息派发不出去的情况，这个广播消息会保存在mPendingBroadcast变量中。新一轮的派发启动时，会判断接收该消息的进程是否还活着， 如果接收进程还活着，那么就继续等待。否则，就放弃这个广播消息</li></ol><p>接下来是最为复杂的一部分，处理”串行广播消息”，ANR监测机制只在这一类广播消息中才发挥作用，也就是说”并行广播消息”是不会发生ANR的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分2：从队列中取出“串行广播消息”</span><br><span class="line">            boolean looped = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span> &#123;//处理有序广播</span><br><span class="line">                <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;//有序广播都处理完了时</span><br><span class="line">                    // No more broadcasts pending, so all <span class="keyword">done</span>!</span><br><span class="line">                    mService.scheduleAppGcsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                        // If we had finished the last ordered broadcast, <span class="keyword">then</span></span><br><span class="line">                        // make sure all processes have correct oom and <span class="built_in">sched</span></span><br><span class="line">                        // adjustments.</span><br><span class="line">                        mService.updateOomAdjLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                r = mOrderedBroadcasts.get(0);</span><br><span class="line">                boolean forceReceive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                // 1. 广播消息的第一个ANR监测机制</span><br><span class="line">                // Ensure that even <span class="keyword">if</span> something goes awry with the timeout</span><br><span class="line">                // detection, we catch <span class="string">"hung"</span> broadcasts here, discard them,</span><br><span class="line">                // and <span class="built_in">continue</span> to make progress.</span><br><span class="line">                //</span><br><span class="line">                // This is only <span class="keyword">done</span> <span class="keyword">if</span> the system is ready so that PRE_BOOT_COMPLETED</span><br><span class="line">                // receivers don<span class="string">'t get executed with timeouts. They'</span>re intended <span class="keyword">for</span></span><br><span class="line">                // one time heavy lifting after system upgrades and can take</span><br><span class="line">                // significant amounts of time.</span><br><span class="line">                int numReceivers = (r.receivers != null) ? r.receivers.size() : 0;</span><br><span class="line">                <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">                    long now = SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                            (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                                + <span class="string">" now="</span> + now</span><br><span class="line">                                + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                                + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                                + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                                + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                                + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                                + <span class="string">" state="</span> + r.state);</span><br><span class="line">                        broadcastTimeoutLocked(<span class="literal">false</span>); // forcibly finish this broadcast</span><br><span class="line">                        forceReceive = <span class="literal">true</span>;</span><br><span class="line">                        r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"processNextBroadcast("</span></span><br><span class="line">                            + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                            + r.state + <span class="string">")"</span>);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 2. 判断该广播消息是否处理完毕</span><br><span class="line">                <span class="keyword">if</span> (r.receivers == null || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                        || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                    // No more receivers <span class="keyword">for</span> this broadcast!  Send the final</span><br><span class="line">                    // result <span class="keyword">if</span> requested...</span><br><span class="line">                    <span class="keyword">if</span> (r.resultTo != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                    <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                    + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                            performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                                new Intent(r.intent), r.resultCode,</span><br><span class="line">                                r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                            // Set this to null so that the reference</span><br><span class="line">                            // (<span class="built_in">local</span> and remote) isn<span class="string">'t kept in the mBroadcastHistory.</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                            Slog.w(TAG, "Failure ["</span></span><br><span class="line"><span class="string">                                    + mQueueName + "] sending broadcast result of "</span></span><br><span class="line"><span class="string">                                    + r.intent, e);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Cancelling BROADCAST_TIMEOUT_MSG");</span></span><br><span class="line"><span class="string">                    cancelBroadcastTimeoutLocked();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                            "Finished with ordered broadcast " + r);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    // ... and on to the next...</span></span><br><span class="line"><span class="string">                    addBroadcastToHistoryLocked(r);</span></span><br><span class="line"><span class="string">                    if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null</span></span><br><span class="line"><span class="string">                            &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span></span><br><span class="line"><span class="string">                        // This was an implicit broadcast... let'</span>s record it <span class="keyword">for</span> posterity.</span><br><span class="line">                        mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                                r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mOrderedBroadcasts.remove(0);</span><br><span class="line">                    r = null;</span><br><span class="line">                    looped = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (r == null);</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure><p>这部分是一个do-while循环，每次都从mOrderedBroadcasts队列中取出第一条广播消息进行处理。第一个Broadcast ANR监测机制千呼万唤总算是出现了：</p><p>判定当前时间是否已经超过了r.dispatchTime + 2×mTimeoutPeriod×numReceivers:</p><p>dispatchTime表示这一系列广播消息开始派发的时间。“串行广播消息”是逐个接收器派发的，一个接收器处理完毕后，才开始处理下一个消息派发。 开始派发到第一个接收器的时间就是dispatchTime。dispatchTime需要开始等广播消息派发以后才会设定，也就是说，第一次进入processNextBroadcast()时， dispatchTime=0,并不会进入该条件判断</p><p>mTimeoutPeriod由当前BroadcastQueue的类型决定(forground为10秒，background为60秒)。这个时间在初始化BroadcastQueue的时候就设置好了， 本意是限定每一个Receiver处理广播的时间，这里利用它做了一个超时计算</p><p>假设一个广播消息有2个接受器，mTimeoutPeriod是10秒，当2×10×2=40秒后，该广播消息还未处理完毕，就调用broadcastTimeoutLocked()方法， 这个方法会判断当前是不是发生了ANR，我们后文再分析。</p><p>如果广播消息是否已经处理完毕，则从mOrderedBroadcasts中移除，重新循环，处理下一条;否则，就会跳出循环。</p><p>以上代码块完成的主要任务是从队列中取一条“串行广播消息”，接下来就准备派发了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分3：串行广播消息的第二个ANR监测机制</span><br><span class="line">            // Get the next receiver...</span><br><span class="line">            int recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">            // Keep track of when this receiver started, and make sure there</span><br><span class="line">            // is a timeout message pending to <span class="built_in">kill</span> it <span class="keyword">if</span> need be.</span><br><span class="line">            r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (recIdx == 0) &#123;</span><br><span class="line">                r.dispatchTime = r.receiverTime;</span><br><span class="line">                r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                    Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">                long timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">                setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p><p>取出“串行广播消息”后，一旦要开始派发，第二个ANR检测机制就出现了。mPendingBroadcastTimeoutMessage变量用于标识当前是否有阻塞的超时消息， 如果没有则调用BroadcastQueue.setBroadcastTimeoutLocked()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void setBroadcastTimeoutLocked(long timeoutTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过设置一个定时消息BROADCAST_TIMEOUT_MSG来跟踪当前广播消息的执行情况，这种超时监测机制跟Service ANR很类似，也是抛到AMS线程的消息队列。 如果所有的接收器都处理完毕了，则会调用cancelBroadcastTimeoutLocked()清除该消息;否则，该消息就会响应，并调用broadcastTimeoutLocked()， 这个方法在第一种ANR监测机制的时候调用过，第二种ANR监测机制也会调用，我们留到后文分析。</p><p>继续分析processNextBroadcast函数<br>设置完定时消息后，就开始派发广播消息了，首先是“动态”接收器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分4： 向“动态”接收器派发广播消息</span><br><span class="line">            final BroadcastOptions brOptions = r.options;</span><br><span class="line">            final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">            // 动态接收器的类型都是BroadcastFilter</span><br><span class="line">            <span class="keyword">if</span> (nextReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">                // Simple <span class="keyword">case</span>: this is a registered receiver who gets</span><br><span class="line">                // a direct call.</span><br><span class="line">                BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering ordered ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + filter + <span class="string">": "</span> + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">                <span class="keyword">if</span> (r.receiver == null || !r.ordered) &#123;</span><br><span class="line">                    // The receiver has already finished, so schedule to</span><br><span class="line">                    // process the next one.</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                            + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                        scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                                brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p><p>“动态”接收器的载体进程一般是处于运行状态的，所以向这种类型的接收器派发消息相对简单，调用BroadcastQueue.deliverToRegisteredReceiverLocked()完成接下来的工作。 但“静态”接收器是在AndroidManifest.xml中注册的，派发的时候，可能广播接收器的载体进程还没有启动，所以，这种场景会复杂很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分5： 向“静态”接收器派发广播消息</span><br><span class="line">            // Hard <span class="keyword">case</span>: need to instantiate the receiver, possibly</span><br><span class="line">            // starting its application process to host it.</span><br><span class="line">            //// 静态接收器的类型都是 ResolveInfo</span><br><span class="line">            ResolveInfo info =</span><br><span class="line">                (ResolveInfo)nextReceiver;</span><br><span class="line">            ComponentName component = new ComponentName(</span><br><span class="line">                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                    info.activityInfo.name);</span><br><span class="line"></span><br><span class="line">            boolean skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp;</span><br><span class="line">                    (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">                    info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1. 权限检查</span><br><span class="line">            int perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                    r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                    info.activityInfo.exported);</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.permission != null) &#123;</span><br><span class="line">                final int opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line">                <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                                r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                            + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                    info.activityInfo.permission)</span><br><span class="line">                            + <span class="string">" due to registered receiver "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">                r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                    String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                    try &#123;</span><br><span class="line">                        perm = AppGlobals.getPackageManager().</span><br><span class="line">                                checkPermission(requiredPermission,</span><br><span class="line">                                        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                        UserHandle</span><br><span class="line">                                                .getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                    <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                            &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                requiredPermission)</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent + <span class="string">" to "</span></span><br><span class="line">                        + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                        r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isSingleton = <span class="literal">false</span>;</span><br><span class="line">            try &#123;</span><br><span class="line">                isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                        info.activityInfo.applicationInfo,</span><br><span class="line">                        info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Slog.w(TAG, e.getMessage());</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                        android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid)</span><br><span class="line">                                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                            + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.isInstantApp()</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" Instant Apps do not support manifest receivers"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.callerInstantApp</span><br><span class="line">                    &amp;&amp; (info.activityInfo.flags &amp; ActivityInfo.FLAG_VISIBLE_TO_INSTANT_APP) == 0</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires receiver have visibleToInstantApps set"</span></span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                r.manifestCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.manifestSkipCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.curApp != null &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">                // If the target process is crashing, just skip it.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                        + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                boolean isAvailable = <span class="literal">false</span>;</span><br><span class="line">                try &#123;</span><br><span class="line">                    isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                            info.activityInfo.packageName,</span><br><span class="line">                            UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // all such failures mean we skip this receiver</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                            + info.activityInfo.packageName, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!isAvailable) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                            + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If permissions need a review before any of the app components can run, we drop</span><br><span class="line">            // the broadcast and <span class="keyword">if</span> the calling app is <span class="keyword">in</span> the foreground and the broadcast is</span><br><span class="line">            // explicit we launch the review UI passing it a pending intent to send the skipped</span><br><span class="line">            // broadcast.</span><br><span class="line">            <span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; !skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">                        info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                                info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This is safe to <span class="keyword">do</span> even <span class="keyword">if</span> we are skipping the broadcast, and we need</span><br><span class="line">            // this information now to evaluate whether it is going to be allowed to run.</span><br><span class="line">            final int receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line">            // If it<span class="string">'s a singleton, it needs to be the same app or a special app</span></span><br><span class="line"><span class="string">            if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span></span><br><span class="line"><span class="string">                    &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span></span><br><span class="line"><span class="string">                info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 2. 获取接收器所在的进程</span></span><br><span class="line"><span class="string">            String targetProcess = info.activityInfo.processName;</span></span><br><span class="line"><span class="string">            ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span></span><br><span class="line"><span class="string">                    info.activityInfo.applicationInfo.uid, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if (!skip) &#123;</span></span><br><span class="line"><span class="string">                final int allowed = mService.getAppStartModeLocked(</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false);</span></span><br><span class="line"><span class="string">                if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span></span><br><span class="line"><span class="string">                    // We won'</span>t allow this receiver to be launched <span class="keyword">if</span> the app has been</span><br><span class="line">                    // completely disabled from launches, or it was not explicitly sent</span><br><span class="line">                    // to it and the app is <span class="keyword">in</span> a state that should not receive it</span><br><span class="line">                    // (depending on how getAppStartModeLocked has determined that).</span><br><span class="line">                    <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)</span><br><span class="line">                            || (r.intent.getComponent() == null</span><br><span class="line">                                &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                                &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                                        &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)</span><br><span class="line">                                &amp;&amp; !isSignaturePerm(r.requiredPermissions))) &#123;</span><br><span class="line">                        mService.addBackgroundCheckViolationLocked(r.intent.getAction(),</span><br><span class="line">                                component.getPackageName());</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.isAutoStartAllowed(info.activityInfo.applicationInfo.uid, info.activityInfo.applicationInfo.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                        + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line">                r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">                r.receiver = null;</span><br><span class="line">                r.curFilter = null;</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">            r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">            r.curComponent = component;</span><br><span class="line">            r.curReceiver = info.activityInfo;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">                Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                        + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                        brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Broadcast is being executed, its package can<span class="string">'t be stopped.</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                AppGlobals.getPackageManager().setPackageStoppedState(</span></span><br><span class="line"><span class="string">                        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            &#125; catch (IllegalArgumentException e) &#123;</span></span><br><span class="line"><span class="string">                Slog.w(TAG, "Failed trying to unstop package "</span></span><br><span class="line"><span class="string">                        + r.curComponent.getPackageName() + ": " + e);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 3. 进程已经启动</span></span><br><span class="line"><span class="string">            // Is this receiver'</span>s application already running?</span><br><span class="line">            <span class="keyword">if</span> (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                            info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                    processCurBroadcastLocked(r, app);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                          + r.curComponent, e);</span><br><span class="line">                &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                    Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                            + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line">                    // If some unexpected exception happened, just skip</span><br><span class="line">                    // this broadcast.  At this point we are not <span class="keyword">in</span> the call</span><br><span class="line">                    // from a client, so throwing an exception out from here</span><br><span class="line">                    // will crash the entire system instead of just whoever</span><br><span class="line">                    // sent the broadcast.</span><br><span class="line">                    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                            r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                    // We need to reset the state <span class="keyword">if</span> we failed to start the receiver.</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If a dead object exception was thrown -- fall through to</span><br><span class="line">                // restart the application.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 进程还未启动</span><br><span class="line">            // Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Need to start app ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                    info.activityInfo.applicationInfo, <span class="literal">true</span>,</span><br><span class="line">                    r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                    <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                    (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, <span class="literal">false</span>, <span class="literal">false</span>))</span><br><span class="line">                            == null) &#123;</span><br><span class="line">                // Ah, this recipient is unavailable.  Finish it <span class="keyword">if</span> necessary,</span><br><span class="line">                // and mark the broadcast record as ready <span class="keyword">for</span> the next.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                        + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 5. 进程启动失败</span><br><span class="line">            mPendingBroadcast = r;</span><br><span class="line">            mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // processNextBroadcast完</span><br></pre></td></tr></table></figure><blockquote><p>1.“静态”接收器是ResolveInfo，需要通过PackageManager获取包信息，进行权限检查。权限检查的内容非常庞大，此处不表。</p></blockquote><blockquote><p>2.经过一系列复杂的权限检查后，终于可以向目标接收器派发了。通过AMS.getProcessRecordLocked()获取广播接收器的进程信息</p></blockquote><blockquote><p>3.如果app.thread ！= null，则进程已经启动，就可以调用BroadcastQueue.processCurBroadcastLocked()进行接下来的派发处理了</p></blockquote><blockquote><p>4.如果进程还没有启动，则需要通过AMS.startProcessLocked()来启动进程，当前消息并未派发，调用BroadcastQueue.scheduleBroadcastsLocked()进入下一次的调度</p></blockquote><blockquote><p>5.如果进程启动失败了，则当前消息记录成mPendingBroadcast，即阻塞的广播消息，等待下一次调度时处理</p></blockquote><p>庞大的processNextBroadcast()终于完结了，它的功能就是对广播消息进行调度，该方法被设计得十分复杂而精巧，用于应对不同的广播消息和接收器的处理。</p><p>广播消息的跨进程传递调度是完成了，接下来，我们就来分析被调度广播消息如何到达应用程序。上文的分析中，最终有两个方法将广播消息派发出去： BroadcastQueue.deliverToRegisteredReceiverLocked() 和BroadcastQueue.processCurBroadcastLocked()。</p><p>我们先不展开这两个函数的逻辑，试想要将广播消息的从AMS线程所在的system_server进程传递到应用程序的进程，该怎么实现？ 自然需要用到跨进程调用，Android中最常规的手段就是Binder机制。没错，广播消息派发到应用进程就是这么玩的。</p><p>对于应用程序已经启动(app.thread != null)的情况，会通过IApplicationThread发起跨进程调用， 调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.ApplicationThread.scheduleReceiver()</span><br><span class="line">└── ActivityThread.handleReceiver()</span><br><span class="line">    └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure></p><pre><code>对于应用程序还未启动的情况，会调用IIntentReceiver发起跨进程调用，应用进程的实现在LoadedApk.ReceiverDispatcher.IntentReceiver 中， 调用关系如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadedApk.ReceiverDispatcher.IntentReceiver.performReceive()</span><br><span class="line">└── LoadedApk.ReceiverDispatcher.performReceiver()</span><br><span class="line">    └── LoadedApk.ReceiverDispatcher.Args.run()</span><br><span class="line">        └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure><p>最终，都会调用到BroadcastReceiver.onReceive()，在应用进程执行接收广播消息的具体动作。 对于“串行广播消息”而言，执行完了以后，还需要通知system_server进程，才能继续将广播消息派发到下一个接收器，这又需要跨进程调用了。 应用进程在处理完广播消息后，即在BroadcastReceiver.onReceive()执行完毕后，会调用BroadcastReceiver.PendingResult.finish()， 接下来的调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver.PendingResult.finish()</span><br><span class="line">└── BroadcastReceiver.PendingResult.sendFinished()</span><br><span class="line">    └── IActivityManager.finishReceiver()</span><br><span class="line">        └── ActivityManagerService.finishReceiver()</span><br><span class="line">            └── BroadcastQueue.processNextBroadcat()</span><br></pre></td></tr></table></figure></p><p>通过IActivityManager发起了一个从应用进程到system_server进程的调用，最终在AMS线程中，又走到了BroadcastQueue.processNextBroadcat(), 开始下一轮的调度。</p><p>broadcastTimeoutLocked()方法<br>前文说过，两种ANR机制最终都会调用BroadcastQueue.broadcastTimeoutLocked()方法， 第一种ANR监测生效时，会将fromMsg设置为false;第二种ANR监测生效时，会将fromMsg参数为True时，表示当前正在响应BROADCAST_TIMEOUT_MSG消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">final void broadcastTimeoutLocked(boolean fromMsg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;// 1. 设置mPendingBroadcastTimeoutMessage</span><br><span class="line">            mPendingBroadcastTimeoutMessage = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 判断第二种ANR机制是否超时</span><br><span class="line">        long now = SystemClock.uptimeMillis();</span><br><span class="line">        BroadcastRecord r = mOrderedBroadcasts.get(0);</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">                // Only process broadcast timeouts <span class="keyword">if</span> the system is ready. That way</span><br><span class="line">                // PRE_BOOT_COMPLETED broadcasts can<span class="string">'t timeout as they are intended</span></span><br><span class="line"><span class="string">                // to do heavy lifting for system up.</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            long timeoutTime = r.receiverTime + mTimeoutPeriod;</span></span><br><span class="line"><span class="string">            if (timeoutTime &gt; now) &#123;</span></span><br><span class="line"><span class="string">                // We can observe premature timeouts because we do not cancel and reset the</span></span><br><span class="line"><span class="string">                // broadcast timeout message after each receiver finishes.  Instead, we set up</span></span><br><span class="line"><span class="string">                // an initial timeout then kick it down the road a little further as needed</span></span><br><span class="line"><span class="string">                // when it expires.</span></span><br><span class="line"><span class="string">                if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                        "Premature timeout ["</span></span><br><span class="line"><span class="string">                        + mQueueName + "] @ " + now + ": resetting BROADCAST_TIMEOUT_MSG for "</span></span><br><span class="line"><span class="string">                        + timeoutTime);</span></span><br><span class="line"><span class="string">                setBroadcastTimeoutLocked(timeoutTime);</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BroadcastRecord br = mOrderedBroadcasts.get(0);</span></span><br><span class="line"><span class="string">        if (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span></span><br><span class="line"><span class="string">            // In this case the broadcast had already finished, but we had decided to wait</span></span><br><span class="line"><span class="string">            // for started services to finish as well before going on.  So if we have actually</span></span><br><span class="line"><span class="string">            // waited long enough time timeout the broadcast, let'</span>s give up on the whole thing</span><br><span class="line">            // and just move on to the next.</span><br><span class="line">            Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + (br.curComponent != null</span><br><span class="line">                    ? br.curComponent.flattenToShortString() : <span class="string">"(null)"</span>));</span><br><span class="line">            br.curComponent = null;</span><br><span class="line">            br.state = BroadcastRecord.IDLE;</span><br><span class="line">            processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Timeout of broadcast "</span> + r + <span class="string">" - receiver="</span> + r. receiver</span><br><span class="line">                + <span class="string">", started "</span> + (now - r.receiverTime) + <span class="string">"ms ago"</span>);</span><br><span class="line">        r.receiverTime = now;</span><br><span class="line">        r.anrCount++;</span><br><span class="line"></span><br><span class="line">        ProcessRecord app = null;</span><br><span class="line">        String anrMessage = null;</span><br><span class="line"></span><br><span class="line">        Object curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &gt; 0) &#123;</span><br><span class="line">            curReceiver = r.receivers.get(r.nextReceiver-1);</span><br><span class="line">            r.delivery[r.nextReceiver-1] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curReceiver = r.curReceiver;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Receiver during timeout of "</span> + r + <span class="string">" : "</span> + curReceiver);</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (curReceiver != null &amp;&amp; curReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">            BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">            <span class="keyword">if</span> (bf.receiverList.pid != 0</span><br><span class="line">                    &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">                synchronized (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                    app = mService.mPidsSelfLocked.get(</span><br><span class="line">                            bf.receiverList.pid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = r.curApp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != null) &#123;</span><br><span class="line">            anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast == r) &#123;</span><br><span class="line">            mPendingBroadcast = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 已经超时，则结束对当前接收器，开始新一轮调度</span><br><span class="line">        // Move on to the next receiver.</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">        // 4. 抛出绘制ANR对话框的消息</span><br><span class="line">        <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">            // Post the ANR to the handler since we <span class="keyword">do</span> not want to process ANRs <span class="keyword">while</span></span><br><span class="line">            // potentially holding our lock.</span><br><span class="line">            mHandler.post(new AppNotResponding(app, anrMessage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 1.mPendingBroadcastTimeoutMessage 标识是否存在未处理的BROADCAST_TIMEOUT_MSG 消息， 将其设置成false，允许继续抛出BROADCAST_TIMEOUT_MSG 消息</p></blockquote><blockquote><p> 2.每次将广播派发到接收器，都会将r.receiverTime 更新，如果判断当前还未超时，则又抛出一个 BROADCAST_TIMEOUT_MSG 息。正常情况下，所有接收器处理完毕后，才会清除 BROADCAST_TIMEOUT_MSG ;否则，每进行一次广播消息的调度，都会抛出 BROADCAST_TIMEOUT_MSG 消息</p></blockquote><blockquote><p> 3.判断已经超时了，说明当前的广播接收器还未处理完毕，则结束掉当前的接收器，开始新一轮广播调度</p></blockquote><blockquote><p> 4.最终，发出绘制ANR对话框的消息</p></blockquote><p>至此，我们回答了前文提出的两个问题:</p><p>AMS维护着广播队列BroadcastQueue，AMS线程不断从队列中取出消息进行调度，完成广播消息的派发。 在派发“串行广播消息”时，会抛出一个定时消息 BROADCAST_TIMEOUT_MSG ，在广播接收器处理完毕后，AMS会将定时消息清除。 如果BROADCAST_TIMEOUT_MSG得到了响应，就会判断是否广播消息处理超时，最终通知ANR的发生。</p><h4 id="Input处理超时"><a href="#Input处理超时" class="headerlink" title="Input处理超时"></a>Input处理超时</h4><p>应用程序可以接收输入事件(按键、触屏、轨迹球等)，当5秒内没有处理完毕时，则会引发ANR。</p><p>如果Broadcast ANR一样，我们抛出Input ANR的几个问题：</p><blockquote><ol><li>输入事件经历了一些什么工序才能被派发到应用的界面？</li><li>如何检测到输入时间处理超时</li></ol></blockquote><p>输入事件最开始由硬件设备(譬如按键或触摸屏幕)发起，Android有一套输入子系统来发现各种输入事件， 这些事件最终都会被<a href="https://android.googlesource.com/platform/frameworks/native/+/master/services/inputflinger/InputDispatcher.cpp" target="_blank" rel="noopener">InputDispatcher</a>分发到各个需要接收事件的窗口。 那么，窗口如何告之InputDispatcher自己需要处理输入事件呢？Android通过InputChannel 连接InputDispatcher和窗口，InputChannel其实是封装后的Linux管道(Pipe)。 每一个窗口都会有一个独立的InputChannel，窗口需要将这个InputChannel注册到InputDispatcher中:</p><blockquote><p>frameworks/native/services/inputflinger/InputDispatcher.cpp</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_REGISTRATION</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ registerInputChannel - monitor=%s"</span>, inputChannel-&gt;getName().string(),</span><br><span class="line">            toString(monitor));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Attempted to register already registered input channel '%s'"</span>,</span><br><span class="line">                    inputChannel-&gt;getName().string());</span><br><span class="line">            <span class="built_in">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        int fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</span><br><span class="line">    &#125; // release lock</span><br><span class="line"></span><br><span class="line">    // Wake the looper because some connections have changed.</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于InputDispatcher而言，每注册一个InputChannel都被视为一个Connection，通过文件描述符来区别。InputDispatcher是一个消息处理循环，当有新的Connection时，就需要唤醒消息循环队列进行处理。</p><p>输入事件的类型有很多，按键、轨迹球、触屏等，Android对这些事件进行了分类，处理这些事件的窗口也被赋予了一个类型 (targetType)：Foucused或Touched ，如果当前输入事件是按键类型，则寻找 Focused类型的窗口;如果当前输入事件类型是触摸类型，则寻找Touched类型的窗口。 InputDispatcher需要经过以下复杂的调用关系，才能把一个输入事件派发出去(调用关系以按键事件为例，触屏事件的调用关系类似)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcherThread::threadLoop()</span><br><span class="line">└── InputDispatcher::dispatchOnce()</span><br><span class="line">    └── InputDispatcher::dispatchOnceInnerLocked()</span><br><span class="line">        └── InputDispatcher::dispatchKeyLocked()</span><br><span class="line">            └── InputDispatcher::dispatchEventLocked()</span><br><span class="line">                └── InputDispatcher::prepareDispatchCycleLocked()</span><br><span class="line">                    └── InputDispatcher::enqueueDispatchEntriesLocked()</span><br><span class="line">                        └── InputDispatcher::startDispatchCycleLocked()</span><br><span class="line">                            └── InputPublisher::publishKeyEvent()</span><br></pre></td></tr></table></figure><p>具体每个函数的实现逻辑此处不表。我们提炼出几个关键点：</p><blockquote><ol><li>InputDispatcherThread是一个线程，它处理一次消息的派发</li><li>输入事件作为一个消息，需要排队等待派发，每一个Connection都维护两个队列：<br>outboundQueue: 等待发送给窗口的事件。每一个新消息到来，都会先进入到此队列<br>waitQueue: 已经发送给窗口的事件</li><li>publishKeyEvent完成后，表示事件已经派发了，就将事件从outboundQueue挪到了waitQueue</li></ol></blockquote><p>事件经过这么一轮处理，就算是从InputDispatcher派发出去了，但事件是不是被窗口收到了，还需要等待接收方的“finished”通知。 在向InputDispatcher 注册InputChannel 的时候，同时会注册一个回调函数handleReceiveCallback():</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) &#123;</span><br><span class="line">    InputDispatcher* d = static_cast&lt;InputDispatcher*&gt;(data);</span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(d-&gt;mLock);</span><br><span class="line"></span><br><span class="line">        ssize_t connectionIndex = d-&gt;mConnectionsByFd.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &lt; 0) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Received spurious receive callback for unknown input channel.  "</span></span><br><span class="line">                    <span class="string">"fd=%d, events=0x%x"</span>, fd, events);</span><br><span class="line">            <span class="built_in">return</span> 0; // remove the callback</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool notify;</span><br><span class="line">        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(events &amp; ALOOPER_EVENT_INPUT)) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName(), events);</span><br><span class="line">                <span class="built_in">return</span> 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nsecs_t currentTime = now();</span><br><span class="line">            bool gotOne = <span class="literal">false</span>;</span><br><span class="line">            status_t status;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                uint32_t seq;</span><br><span class="line">                bool handled;</span><br><span class="line">                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);</span><br><span class="line">                <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);</span><br><span class="line">                gotOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotOne) &#123;</span><br><span class="line">                d-&gt;runCommandsLockedInterruptible();</span><br><span class="line">                <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                    <span class="built_in">return</span> 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notify = status != DEAD_OBJECT || !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Failed to receive finished signal.  status=%d"</span>,</span><br><span class="line">                        connection-&gt;getInputChannelName(), status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // Monitor channels are never explicitly unregistered.</span><br><span class="line">            // We <span class="keyword">do</span> it automatically when the remote endpoint is closed so don<span class="string">'t warn</span></span><br><span class="line"><span class="string">            // about them.</span></span><br><span class="line"><span class="string">            notify = !connection-&gt;monitor;</span></span><br><span class="line"><span class="string">            if (notify) &#123;</span></span><br><span class="line"><span class="string">                ALOGW("channel '</span>%s<span class="string">' ~ Consumer closed input channel or an error occurred.  "</span></span><br><span class="line"><span class="string">                        "events=0x%x", connection-&gt;getInputChannelName(), events);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Unregister the channel.</span></span><br><span class="line"><span class="string">        d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);</span></span><br><span class="line"><span class="string">        return 0; // remove the callback</span></span><br><span class="line"><span class="string">    &#125; // release lock</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>当收到的status为OK时，会调用finishDispatchCycleLocked()来完成一个消息的处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::finishDispatchCycleLocked()</span><br><span class="line">└── InputDispatcher::onDispatchCycleFinishedLocked()</span><br><span class="line">    └── InputDispatcher::doDispatchCycleFinishedLockedInterruptible()</span><br><span class="line">        └── InputDispatcher::startDispatchCycleLocked()</span><br></pre></td></tr></table></figure><p>调用到doDispatchCycleFinishedLockedInterruptible() 方法时，会将已经成功派发的消息从waitQueue中移除， 进一步调用会 startDispatchCycleLocked开始派发新的事件。</p><p>至此，我们回答了第一个问题：</p><p>一个正常的输入事件会经过从outboundQueue挪到waitQueue的过程，表示消息已经派发出去;再经过从waitQueue中移除的过程，表示消息已经被窗口接收。InputDispatcher作为中枢，不停地在递送着输入事件，当一个事件无法得到处理的时候，InputDispatcher不能就此死掉啊，否则系统也太容易崩溃了。 InputDispatcher 的策略是放弃掉处理不过来的事件， 并发出通知(这个通知机制就是ANR)，继续进行下一轮消息的处理。</p><blockquote><p>理解输入事件分发模型，我们可以举一个生活中的例子：<br>每一个输入事件可以比做一个快递，InputDispatcher就像一个快递中转站，窗口就像是收件人，InputChannel就像是快递员。 所有快递都会经过中转站中处理，中转站需要知道每一个快递的收件人是谁，通过快递员将快递发送到具体的收件人。 这其中有很多场景导致快递不能及时送到：譬如联系不到收件人;快递很多，快递员会忙不过来;快递员受伤休假了等等… 这时候快递员就需要告知中转站：有快递无法及时送到了。中转站在收到快递员的通知后，一边继续派发其他快递，一边报告上级。</p></blockquote><p>在了解输入事件分发模型之后，我们可以见识一下ANR机制了。在派发事件时，dispatchKeyLocked()和dispatchMotionLocked()， 需要找到当前的焦点窗口 ,焦点窗口才是最终接收事 件的地方，找窗口的过程就会判断是否已经发生了ANR：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::findFocusedWindowTargetsLocked()</span><br><span class="line">InputDispatcher::findTouchedWindowTargetsLocked()</span><br><span class="line">└── InputDispatcher::handleTargetsNotReadyLocked()</span><br><span class="line">    └── InputDispatcher::onANRLocked()</span><br><span class="line">        └── InputDispatcher::doNotifyANRLockedInterruptible()</span><br><span class="line">            └── NativeInputManager::notifyANR()</span><br></pre></td></tr></table></figure><ul><li><p>首先，会调用findFocusedWindowTargetsLocked()或findTouchedWindowTargetsLocked()寻找接收输入事件的窗口。在找到窗口以后，会调用checkWindowReadyForMoreInputLocked() 检查窗口是否有能力再接收新的输入事件，会有一系列的场景阻碍事件的继续派发：</p><ul><li><p><strong>场景1:</strong> 窗口处于paused状态，不能处理输入事件“Waiting because the [targetType] window is paused.”</p></li><li><p><strong>场景2:</strong> 窗口还未向InputDispatcher注册，无法将事件派发到窗口“Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.”</p></li><li><p><strong>场景3:</strong> 窗口和InputDispatcher的连接已经中断，即InputChannel不能正常工作“Waiting because the [targetType] window’s input connection is [status]. The window may be in the process of being removed.”</p></li><li><p><strong>场景4:</strong> InputChannel已经饱和，不能再处理新的事件“Waiting because the [targetType] window’s input channel is full. Outbound queue length: %d. Wait queue length: %d.”</p></li><li><p><strong>场景5:</strong> 对于按键类型(KeyEvent)的输入事件，需要等待上一个事件处理完毕“Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: %d. Wait queue length: %d.”</p></li><li><p><strong>场景6:</strong> 对于触摸类型(TouchEvent)的输入事件，可以立即派发到当前的窗口，因为TouchEvent都是发生在用户当前可见的窗口。但有一种情况，如果当前应用由于队列有太多的输入事件等待派发，导致发生了ANR，那TouchEvent事件就需要排队等待派发。“Waiting to send non-key event because the %s window has not finished processing certain input events that were delivered to it over %0.1fms ago. Wait queue length: %d. Wait queue head age: %0.1fms.”</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">String8 InputDispatcher::checkWindowReadyForMoreInputLocked(nsecs_t currentTime,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle, const EventEntry* eventEntry,</span><br><span class="line">        const char* targetType) &#123;</span><br><span class="line">    // If the window is paused <span class="keyword">then</span> keep waiting.</span><br><span class="line">    <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;paused) &#123;</span><br><span class="line">        <span class="built_in">return</span> String8::format(<span class="string">"Waiting because the %s window is paused."</span>, targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the window<span class="string">'s connection is not registered then keep waiting.</span></span><br><span class="line"><span class="string">    ssize_t connectionIndex = getConnectionIndexLocked(windowHandle-&gt;getInputChannel());</span></span><br><span class="line"><span class="string">    if (connectionIndex &lt; 0) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is not <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>registered with the input dispatcher.  The window may be <span class="keyword">in</span> the process <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>of being removed.<span class="string">", targetType);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is dead then keep waiting.</span></span><br><span class="line"><span class="string">    sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span></span><br><span class="line"><span class="string">    if (connection-&gt;status != Connection::STATUS_NORMAL) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("</span>Waiting because the %s window<span class="string">'s input connection is %s."</span></span><br><span class="line"><span class="string">                "The window may be in the process of being removed.", targetType,</span></span><br><span class="line"><span class="string">                connection-&gt;getStatusLabel());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is backed up then keep waiting.</span></span><br><span class="line"><span class="string">    if (connection-&gt;inputPublisherBlocked) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is full.  <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Ensure that the dispatch queues aren't too far backed up for this event.</span></span><br><span class="line"><span class="string">    if (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;</span></span><br><span class="line"><span class="string">        // If the event is a key event, then we must wait for all previous events to</span></span><br><span class="line"><span class="string">        // complete before delivering it because previous events may have the</span></span><br><span class="line"><span class="string">        // side-effect of transferring focus to a different window and we want to</span></span><br><span class="line"><span class="string">        // ensure that the following keys are sent to the new window.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Suppose the user touches a button in a window then immediately presses "</span>A<span class="string">".</span></span><br><span class="line"><span class="string">        // If the button causes a pop-up window to appear then we want to ensure that</span></span><br><span class="line"><span class="string">        // the "</span>A<span class="string">" key is delivered to the new pop-up window.  This is because users</span></span><br><span class="line"><span class="string">        // often anticipate pending UI changes when typing on a keyboard.</span></span><br><span class="line"><span class="string">        // To obtain this behavior, we must serialize key events with respect to all</span></span><br><span class="line"><span class="string">        // prior input events.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;outboundQueue.isEmpty() || !connection-&gt;waitQueue.isEmpty()) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing all of the input events that were previously <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>delivered to it.  Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Touch events can always be sent to a window immediately because the user intended</span></span><br><span class="line"><span class="string">        // to touch whatever was visible at the time.  Even if focus changes or a new</span></span><br><span class="line"><span class="string">        // window appears moments later, the touch event was meant to be delivered to</span></span><br><span class="line"><span class="string">        // whatever window happened to be on screen at the time.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Generic motion events, such as trackball or joystick events are a little trickier.</span></span><br><span class="line"><span class="string">        // Like key events, generic motion events are delivered to the focused window.</span></span><br><span class="line"><span class="string">        // Unlike key events, generic motion events don't tend to transfer focus to other</span></span><br><span class="line"><span class="string">        // windows and it is not important for them to be serialized.  So we prefer to deliver</span></span><br><span class="line"><span class="string">        // generic motion events as soon as possible to improve efficiency and reduce lag</span></span><br><span class="line"><span class="string">        // through batching.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // The one case where we pause input event delivery is when the wait queue is piling</span></span><br><span class="line"><span class="string">        // up with lots of events because the application is not responding.</span></span><br><span class="line"><span class="string">        // This condition ensures that ANRs are detected reliably.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;waitQueue.isEmpty()</span></span><br><span class="line"><span class="string">                &amp;&amp; currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime</span></span><br><span class="line"><span class="string">                        + STREAM_AHEAD_EVENT_TIMEOUT) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send non-key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing certain input events that were delivered to it over <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>%0.1fms ago.  Wait queue length: %d.  Wait queue head age: %0.1fms.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, STREAM_AHEAD_EVENT_TIMEOUT * 0.000001f,</span></span><br><span class="line"><span class="string">                    connection-&gt;waitQueue.count(),</span></span><br><span class="line"><span class="string">                    (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) * 0.000001f);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return String8::empty();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>然后，上述有任何一个场景发生了，则输入事件需要继续等待，紧接着就会调用handleTargetsNotReadyLocked()来判断是不是已经的等待超时了：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime,</span><br><span class="line">        const EventEntry* entry,</span><br><span class="line">        const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t* nextWakeupTime, const char* reason) &#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationHandle == NULL &amp;&amp; windowHandle == NULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for system to become ready for input.  Reason: %s"</span>, reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = LONG_LONG_MAX;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for application to become ready for input: %s.  Reason: %s"</span>,</span><br><span class="line">                    getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">                    reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            nsecs_t timeout;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationHandle != NULL) &#123;</span><br><span class="line">                timeout = applicationHandle-&gt;getDispatchingTimeout(</span><br><span class="line">                        DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = currentTime + timeout;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitApplicationHandle == NULL &amp;&amp; applicationHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = applicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputTargetWaitTimeoutExpired) &#123;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;</span><br><span class="line">        onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                entry-&gt;eventTime, mInputTargetWaitStartTime, reason);</span><br><span class="line"></span><br><span class="line">        // Force poll loop to wake up immediately on next iteration once we get the</span><br><span class="line">        // ANR response back from the policy.</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // Force poll loop to wake up when timeout is due.</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitTimeoutTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">            *nextWakeupTime = mInputTargetWaitTimeoutTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，如果当前事件派发已经超时，则说明已经检测到了ANR，调用onANRLocked()方法，然后将nextWakeupTime设置为最小值，马上开始下一轮调度。 在onANRLocked()方法中， 会保存ANR的一些状态信息，调用doNotifyANRLockedInterruptible()，进一步会调用到JNI层的 NativeInputManager::notifyANR()方法， 它的主要功能就是衔接Native层和  Java层，直接调用Java层的InputManagerService.notifyANR()方法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::onANRLocked(</span><br><span class="line">        nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) &#123;</span><br><span class="line">    <span class="built_in">float</span> dispatchLatency = (currentTime - eventTime) * 0.000001f;</span><br><span class="line">    <span class="built_in">float</span> waitDuration = (currentTime - waitStartTime) * 0.000001f;</span><br><span class="line">    ALOGI(<span class="string">"Application is not responding: %s.  "</span></span><br><span class="line">            <span class="string">"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">            dispatchLatency, waitDuration, reason);</span><br><span class="line"></span><br><span class="line">    // Capture a record of the InputDispatcher state at the time of the ANR.</span><br><span class="line">    time_t t = time(NULL);</span><br><span class="line">    struct tm tm;</span><br><span class="line">    localtime_r(&amp;t, &amp;tm);</span><br><span class="line">    char timestr[64];</span><br><span class="line">    strftime(timestr, sizeof(timestr), <span class="string">"%F %T"</span>, &amp;tm);</span><br><span class="line">    mLastANRState.clear();</span><br><span class="line">    mLastANRState.append(INDENT <span class="string">"ANR:\n"</span>);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Time: %s\n"</span>, timestr);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Window: %s\n"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string());</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"DispatchLatency: %0.1fms\n"</span>, dispatchLatency);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"WaitDuration: %0.1fms\n"</span>, waitDuration);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Reason: %s\n"</span>, reason);</span><br><span class="line">    dumpDispatchStateLocked(mLastANRState);</span><br><span class="line"></span><br><span class="line">    CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">            &amp; InputDispatcher::doNotifyANRLockedInterruptible);</span><br><span class="line">    commandEntry-&gt;inputApplicationHandle = applicationHandle;</span><br><span class="line">    commandEntry-&gt;inputWindowHandle = windowHandle;</span><br><span class="line">    commandEntry-&gt;reason = reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::doNotifyANRLockedInterruptible(</span><br><span class="line">        CommandEntry* commandEntry) &#123;</span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    nsecs_t newTimeout = mPolicy-&gt;notifyANR(</span><br><span class="line">            commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle,</span><br><span class="line">            commandEntry-&gt;reason);</span><br><span class="line"></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    resumeAfterTargetsNotReadyTimeoutLocked(newTimeout,</span><br><span class="line">            commandEntry-&gt;inputWindowHandle != NULL</span><br><span class="line">                    ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(NULL), mLastDropReason(DROP_REASON_NOT_DROPPED),</span><br><span class="line">    mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(NULL),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    mLooper = new Looper(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = NULL;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到mPolicy是InputDispatcherPolicyInterface,对应的在JNI层frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class NativeInputManager : public virtual RefBase,</span><br><span class="line">    public virtual InputReaderPolicyInterface,</span><br><span class="line">    public virtual InputDispatcherPolicyInterface,</span><br><span class="line">    public virtual PointerControllerPolicyInterface &#123;</span><br><span class="line">protected:</span><br><span class="line">    virtual ~NativeInputManager();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</span><br><span class="line"></span><br><span class="line">    inline sp&lt;InputManager&gt; getInputManager() const &#123; <span class="built_in">return</span> mInputManager; &#125;</span><br><span class="line"></span><br><span class="line">    void dump(String8&amp; dump);</span><br><span class="line"></span><br><span class="line">    void setVirtualDisplayViewports(JNIEnv* env, jobjectArray viewportObjArray);</span><br><span class="line">    void setDisplayViewport(int32_t viewportType, const DisplayViewport&amp; viewport);</span><br><span class="line"></span><br><span class="line">    status_t registerInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor);</span><br><span class="line">    status_t unregisterInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel);</span><br><span class="line"></span><br><span class="line">    void setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray);</span><br><span class="line">    void setFocusedApplication(JNIEnv* env, jobject applicationHandleObj);</span><br><span class="line">    void setInputDispatchMode(bool enabled, bool frozen);</span><br><span class="line">    void setSystemUiVisibility(int32_t visibility);</span><br><span class="line">    void setPointerSpeed(int32_t speed);</span><br><span class="line">    void setInputDeviceEnabled(uint32_t deviceId, bool enabled);</span><br><span class="line">    void setShowTouches(bool enabled);</span><br><span class="line">    void setInteractive(bool interactive);</span><br><span class="line">    void reloadCalibration();</span><br><span class="line">    void setPointerIconType(int32_t iconId);</span><br><span class="line">    void reloadPointerIcons();</span><br><span class="line">    void setCustomPointerIcon(const SpriteIcon&amp; icon);</span><br><span class="line">    void setPointerCapture(bool enabled);</span><br><span class="line"></span><br><span class="line">    /* --- InputReaderPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void getReaderConfiguration(InputReaderConfiguration* outConfig);</span><br><span class="line">    virtual sp&lt;PointerControllerInterface&gt; obtainPointerController(int32_t deviceId);</span><br><span class="line">    virtual void notifyInputDevicesChanged(const Vector&lt;InputDeviceInfo&gt;&amp; inputDevices);</span><br><span class="line">    virtual sp&lt;KeyCharacterMap&gt; getKeyboardLayoutOverlay(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual String8 getDeviceAlias(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(JNIEnv *env,</span><br><span class="line">            jfloatArray matrixArr);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(</span><br><span class="line">            const String8&amp; inputDeviceDescriptor, int32_t surfaceRotation);</span><br><span class="line"></span><br><span class="line">    /* --- InputDispatcherPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void notifySwitch(nsecs_t when, uint32_t switchValues, uint32_t switchMask,</span><br><span class="line">            uint32_t policyFlags);</span><br><span class="line">    virtual void notifyConfigurationChanged(nsecs_t when);</span><br><span class="line">    virtual nsecs_t notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const String8&amp; reason);</span><br><span class="line">    virtual void notifyInputChannelBroken(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle);</span><br><span class="line">    virtual bool filterInputEvent(const InputEvent* inputEvent, uint32_t policyFlags);</span><br><span class="line">    virtual void getDispatcherConfiguration(InputDispatcherConfiguration* outConfig);</span><br><span class="line">    virtual void interceptKeyBeforeQueueing(const KeyEvent* keyEvent, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual void interceptMotionBeforeQueueing(nsecs_t when, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual nsecs_t interceptKeyBeforeDispatching(</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags);</span><br><span class="line">    virtual bool dispatchUnhandledKey(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags, KeyEvent* outFallbackKeyEvent);</span><br><span class="line">    virtual void pokeUserActivity(nsecs_t eventTime, int32_t eventType);</span><br><span class="line">    virtual bool checkInjectEventsPermissionNonReentrant(</span><br><span class="line">            int32_t injectorPid, int32_t injectorUid);</span><br><span class="line"></span><br><span class="line">    /* --- PointerControllerPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void loadPointerIcon(SpriteIcon* icon);</span><br><span class="line">    virtual void loadPointerResources(PointerResources* outResources);</span><br><span class="line">    virtual void loadAdditionalMouseResources(std::map&lt;int32_t, SpriteIcon&gt;* outResources,</span><br><span class="line">            std::map&lt;int32_t, PointerAnimation&gt;* outAnimationResources);</span><br><span class="line">    virtual int32_t getDefaultPointerIconId();</span><br><span class="line">    virtual int32_t getCustomPointerIconId();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>JNI层中notifyANR的实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">nsecs_t NativeInputManager::notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, const String8&amp; reason) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_INPUT_DISPATCHER_POLICY</span></span><br><span class="line">    ALOGD(<span class="string">"notifyANR"</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    // 将应用程序句柄、窗口句柄、ANR原因字符串，转化为Java层的对象</span><br><span class="line">    jobject inputApplicationHandleObj =</span><br><span class="line">            getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);</span><br><span class="line">    jobject inputWindowHandleObj =</span><br><span class="line">            getInputWindowHandleObjLocalRef(env, inputWindowHandle);</span><br><span class="line">    jstring reasonObj = env-&gt;NewStringUTF(reason.string());</span><br><span class="line"></span><br><span class="line">    // 调用Java层的InputManagerService.notifyANR()方法</span><br><span class="line">    jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,</span><br><span class="line">                gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,</span><br><span class="line">                reasonObj);</span><br><span class="line">    <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"notifyANR"</span>)) &#123;</span><br><span class="line">        newTimeout = 0; // abort dispatch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(newTimeout &gt;= 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(reasonObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputWindowHandleObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputApplicationHandleObj);</span><br><span class="line">    <span class="built_in">return</span> newTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，ANR的处理逻辑转交到了Java层。底层(Native)发现一旦有输入事件派发超时，就会通知上层(Java)，上层收到ANR通知后，决定是否终止当前输入事件的派发。</p><p>发生ANR时，Java层最开始的入口是InputManagerService.notifyANR()，它是直接被Native层调用的。我们先把ANR的Java层调用关系列出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputManagerService.notifyANR()</span><br><span class="line">└── InputMonitor.notifyANR()</span><br><span class="line">    ├── IApplicationToken.keyDispatchingTimedOut()</span><br><span class="line">    │   └── ActivityRecord.keyDispatchingTimedOut()</span><br><span class="line">    │       └── AMS.inputDispatchingTimedOut()</span><br><span class="line">    │           └── AMS.appNotResponding()</span><br><span class="line">    │</span><br><span class="line">    └── AMS.inputDispatchingTimedOut()</span><br><span class="line">        └── AMS.appNotResponding()</span><br></pre></td></tr></table></figure><p>在Java层的InputManagerService代码: frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private WindowManagerCallbacks mWindowManagerCallbacks;</span><br><span class="line">....</span><br><span class="line"> // Native callback.</span><br><span class="line"> private long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">         InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">     <span class="built_in">return</span> mWindowManagerCallbacks.notifyANR(</span><br><span class="line">             inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>WindowManagerCallbacks由 InputMonitor.java实现： frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java<br>InputManagerService.notifyANR()只是为Native层定义了一个接口，它直接调用InputMonitor.notifyANR()。 如果该方法的返回值等于0, 则放弃本次输入事件;如果大于0, 则表示 需要继续等待的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">final class InputMonitor implements InputManagerService.WindowManagerCallbacks &#123;</span><br><span class="line">    private final WindowManagerService mService;</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">    /* Notifies the window manager about an application that is not responding.</span><br><span class="line">     * Returns a new timeout to <span class="built_in">continue</span> waiting <span class="keyword">in</span> nanoseconds, or 0 to abort dispatch.</span><br><span class="line">     *</span><br><span class="line">     * Called by the InputManager.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">            InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">        AppWindowToken appWindowToken = null;</span><br><span class="line">        WindowState windowState = null;</span><br><span class="line">        boolean aboveSystem = <span class="literal">false</span>;</span><br><span class="line">        synchronized (mService.mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputWindowHandle != null) &#123;</span><br><span class="line">                windowState = (WindowState) inputWindowHandle.windowState;</span><br><span class="line">                <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                    appWindowToken = windowState.mAppToken;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (appWindowToken == null &amp;&amp; inputApplicationHandle != null) &#123;</span><br><span class="line">                appWindowToken = (AppWindowToken)inputApplicationHandle.appWindowToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to "</span> + windowState.mAttrs.getTitle()</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">                // Figure out whether this window is layered above system windows.</span><br><span class="line">                // We need to <span class="keyword">do</span> this here to <span class="built_in">help</span> the activity manager know how to</span><br><span class="line">                // layer its ANR dialog.</span><br><span class="line">                int systemAlertLayer = mService.mPolicy.getWindowLayerFromTypeLw(</span><br><span class="line">                        TYPE_APPLICATION_OVERLAY, windowState.mOwnerCanAddInternalSystemWindow);</span><br><span class="line">                aboveSystem = windowState.mBaseLayer &gt; systemAlertLayer;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appWindowToken != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to application "</span> + appWindowToken.stringName</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mService.saveANRStateLocked(appWindowToken, windowState, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // All the calls below need to happen without the WM lock held since they call into AM.</span><br><span class="line">        mService.mAmInternal.saveANRState(reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) &#123;</span><br><span class="line">        // appToken实际上就是当前的ActivityRecord。</span><br><span class="line">            // 如果发生ANR的Activity还存在，则直接通过ActivityRecord通知事件派发超时</span><br><span class="line">            // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">            // to abort dispatching or keep waiting.</span><br><span class="line">            final AppWindowContainerController controller = appWindowToken.getController();</span><br><span class="line">            final boolean abort = controller != null</span><br><span class="line">                    &amp;&amp; controller.keyDispatchingTimedOut(reason,</span><br><span class="line">                            (windowState != null) ? windowState.mSession.mPid : -1);</span><br><span class="line">            <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">                // The activity manager declined to abort dispatching.</span><br><span class="line">                // Wait a bit longer and timeout again later.</span><br><span class="line">                <span class="built_in">return</span> appWindowToken.mInputDispatchingTimeoutNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">        // 如果发生ANR的Activity已经销毁了，则通过AMS通知事件派发超时</span><br><span class="line">            try &#123;</span><br><span class="line">                // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">                // to abort dispatching or keep waiting.</span><br><span class="line">                long timeout = ActivityManager.getService().inputDispatchingTimedOut(</span><br><span class="line">                        windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt;= 0) &#123;</span><br><span class="line">                    // The activity manager declined to abort dispatching.</span><br><span class="line">                    // Wait a bit longer and timeout again later.</span><br><span class="line">                    <span class="built_in">return</span> timeout * 1000000L; // nanoseconds</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> 0; // abort dispatching</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法中有两种不同的调用方式，但最终都会交由AMS.inputDispatchingTimedOut()处理。AMS有重载的inputDispatchingTimedOut()方法，他们的参数不一样。 ActivityRecord 调用时，可以传入的信息更多一点(当前发生ANR的界面是哪一个)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord proc;</span><br><span class="line">        long timeout;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                proc = mPidsSelfLocked.get(pid);// 1. 根据进程号获取到ProcessRecord</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 获取超时时间</span><br><span class="line">            // 测试环境下的超时时间是INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT(60秒)，</span><br><span class="line">            // 正常环境下的超时时间是KEY_DISPATCHING_TIMEOUT(5秒)</span><br><span class="line">            timeout = getInputDispatchingTimeoutLocked(proc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用重载的函数，如果返回True，则表示需要中断当前的事件派发;</span><br><span class="line">        <span class="keyword">if</span> (inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 返回继续等待的时间，这个值会传递到Native层</span><br><span class="line">        <span class="built_in">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Handle input dispatching timeouts.</span><br><span class="line">     * Returns whether input dispatching should be aborted or not.</span><br><span class="line">     */</span><br><span class="line">    public boolean inputDispatchingTimedOut(final ProcessRecord proc,</span><br><span class="line">            final ActivityRecord activity, final ActivityRecord parent,</span><br><span class="line">            final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String annotation;</span><br><span class="line">        <span class="keyword">if</span> (reason == null) &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out ("</span> + reason + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proc != null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                <span class="keyword">if</span> (proc.debugging) &#123;// 1. 发生ANR进程正处于调试状态，不需要中断事件</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2. 发生ANR的进程是测试进程，需要中断，但不在UI界面显示ANR信息判断</span><br><span class="line">                <span class="keyword">if</span> (proc.instr != null) &#123;</span><br><span class="line">                    Bundle info = new Bundle();</span><br><span class="line">                    info.putString(<span class="string">"shortMsg"</span>, <span class="string">"keyDispatchingTimedOut"</span>);</span><br><span class="line">                    info.putString(<span class="string">"longMsg"</span>, annotation);</span><br><span class="line">                    finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3. 通知UI界面显示ANR信息</span><br><span class="line">            mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                    mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，我们回答了第二个问题：</p><p>在InputDispatcher派发输入事件时，会寻找接收事件的窗口，如果无法正常派发，则可能会导致当前需要派发的事件超时(默认是5秒)。 Native层发现超时了，会通知Java层，Java层经过一些处理后，会反馈给Native层，是继续等待还是丢弃当前派发的事件。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ANR监测机制包含三种：</p><blockquote><ul><li>Service ANR，前台进程中Service生命周期不能超过20秒，后台进程中Service的生命周期不能超过200秒。 在启动Service时，抛出定时消息SERVICE_TIMEOUT_MSG或SERVICE_BACKGOURND_TIMEOUT_MSG，如果定时消息响应了，则说明发生了ANR</li></ul></blockquote><blockquote><ul><li>Broadcast ANR，前台的“串行广播消息”必须在10秒内处理完毕，后台的“串行广播消息”必须在60秒处理完毕， 每派发串行广播消息到一个接收器时，都会抛出一个定时消息BROADCAST_TIMEOUT_MSG，如果定时消息响应，则判断是否广播消息处理超时，超时就说明发生了ANR</li></ul></blockquote><blockquote><ul><li>Input ANR，输入事件必须在5秒内处理完毕。在派发一个输入事件时，会判断当前输入事件是否需要等待，如果需要等待，则判断是否等待已经超时，超时就说明发生了ANR</li></ul></blockquote><p>ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对几种操作的响应;否则，就可以认为应用程序主线程失去响应能力。</p><p>从ANR的三种监测机制中，我们看到不同超时机制的设计：</p><p>Service和Broadcast都是由AMS调度，利用Handler和Looper，设计了一个TIMEOUT消息交由AMS线程来处理，整个超时机制的实现都是在Java层； InputEvent由InputDispatcher调度，待处理的输入事件都会进入队列中等待，设计了一个等待超时的判断，超时机制的实现在Native层。</p><h3 id="ANR的报告机制"><a href="#ANR的报告机制" class="headerlink" title="ANR的报告机制"></a>ANR的报告机制</h3><p>无论哪种类型的ANR发生以后，最终都会调用 AMS.appNotResponding() 方法，所谓“殊途同归”。这个方法的职能就是向用户或开发者报告ANR发生了。 最终的表现形式是：弹出一个对话框，告诉用户当前某个程序无响应;输入一大堆与ANR相关的日志，便于开发者解决问题。</p><p>最终形式我们见过很多，但输出日志的原理是什么，未必所有人都了解，下面我们就来认识一下是如何输出ANR日志的。</p><p>在  <a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/AppErrors.java" target="_blank" rel="noopener">AppErrors.java</a>  frameworks/base/services/core/java/com/android/server/am/AppErrors.java中处理ANR的弹框<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">final void appNotResponding(ProcessRecord app, ActivityRecord activity,</span><br><span class="line">        ActivityRecord parent, boolean aboveSystem, final String annotation) &#123;</span><br><span class="line">        // app: 当前发生ANR的进程</span><br><span class="line">// activity: 发生ANR的界面</span><br><span class="line">// parent: 发生ANR的界面的上一级界面</span><br><span class="line">// aboveSystem:</span><br><span class="line">// annotation: 发生ANR的原因</span><br><span class="line">    ArrayList&lt;Integer&gt; firstPids = new ArrayList&lt;Integer&gt;(5);</span><br><span class="line">    SparseArray&lt;Boolean&gt; lastPids = new SparseArray&lt;Boolean&gt;(20);</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 0 == <span class="built_in">continue</span>, -1 = <span class="built_in">kill</span> process immediately</span><br><span class="line">            int res = mService.mController.appEarlyNotResponding(</span><br><span class="line">                    app.processName, app.pid, annotation);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">                app.kill(<span class="string">"anr"</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            mService.mController = null;</span><br><span class="line">            Watchdog.getInstance().setActivityController(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long anrTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;// 1. 更新CPU使用信息。ANR的第一次CPU信息采样</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">    &#125;</span><br><span class="line">    // Unless configured otherwise, swallow ANRs <span class="keyword">in</span> background processes &amp; <span class="built_in">kill</span> the process.</span><br><span class="line">    boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">            Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;</span><br><span class="line">    boolean isSilentANR;</span><br><span class="line">    synchronized (mService) &#123;</span><br><span class="line">        // PowerManager.reboot() can block <span class="keyword">for</span> a long time, so ignore ANRs <span class="keyword">while</span> shutting down.</span><br><span class="line">        <span class="keyword">if</span> (mService.mShuttingDown) &#123;//正在关机过程中的ANR，直接忽视掉</span><br><span class="line">            Slog.i(TAG, <span class="string">"During shutdown skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.notResponding) &#123;//重复的ANR，直接忽略掉，不重复弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping duplicate ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.crashing) &#123;//APP crash 引起的ANR，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Crashing app skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killedByAm) &#123;// APP 已经被 AM <span class="built_in">kill</span>掉的，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"App already killed by AM skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killed) &#123;//APP 已经挂掉了，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping died app ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // In <span class="keyword">case</span> we come through here <span class="keyword">for</span> the same app before completing</span><br><span class="line">        // this one, mark as anring now so we will bail out.</span><br><span class="line">        app.notResponding = <span class="literal">true</span>;</span><br><span class="line">        // Log the ANR to the event <span class="built_in">log</span>.</span><br><span class="line">        //2.将ANR 信息写入event <span class="built_in">log</span>中</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,</span><br><span class="line">                app.processName, app.info.flags, annotation);</span><br><span class="line">        // Dump thread traces as quickly as we can, starting with <span class="string">"interesting"</span> processes.</span><br><span class="line">        // 3. 填充firstPids和lastPids数组。从最近运行进程(Last Recently Used)中挑选：</span><br><span class="line">//    firstPids用于保存ANR进程及其父进程，system_server进程和persistent的进程(譬如Phone进程)</span><br><span class="line">//    lastPids用于保存除firstPids外的其他进程</span><br><span class="line">        firstPids.add(app.pid);</span><br><span class="line">        // Don<span class="string">'t dump other PIDs if it'</span>s a background ANR</span><br><span class="line">        isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);</span><br><span class="line">        <span class="keyword">if</span> (!isSilentANR) &#123;</span><br><span class="line">            int parentPid = app.pid;</span><br><span class="line">            <span class="keyword">if</span> (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) &#123;</span><br><span class="line">                parentPid = parent.app.pid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid != app.pid) firstPids.add(parentPid);</span><br><span class="line">            <span class="keyword">if</span> (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</span><br><span class="line">            <span class="keyword">for</span> (int i = mService.mLruProcesses.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                ProcessRecord r = mService.mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (r != null &amp;&amp; r.thread != null) &#123;</span><br><span class="line">                    int pid = r.pid;</span><br><span class="line">                    <span class="keyword">if</span> (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.persistent) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding persistent proc: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.treatLikeActivity) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding likely IME: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastPids.put(pid, Boolean.TRUE);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding ANR proc: "</span> + r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Log the ANR to the main <span class="built_in">log</span>. </span><br><span class="line">    //4. 将ANR信息输出到 main <span class="built_in">log</span>中</span><br><span class="line">    StringBuilder info = new StringBuilder();</span><br><span class="line">    info.setLength(0);</span><br><span class="line">    info.append(<span class="string">"ANR in "</span>).append(app.processName);</span><br><span class="line">    <span class="keyword">if</span> (activity != null &amp;&amp; activity.shortComponentName != null) &#123;</span><br><span class="line">        info.append(<span class="string">" ("</span>).append(activity.shortComponentName).append(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(<span class="string">"\n"</span>);</span><br><span class="line">    info.append(<span class="string">"PID: "</span>).append(app.pid).append(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (annotation != null) &#123;</span><br><span class="line">        info.append(<span class="string">"Reason: "</span>).append(annotation).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != null &amp;&amp; parent != activity) &#123;</span><br><span class="line">        info.append(<span class="string">"Parent: "</span>).append(parent.shortComponentName).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(<span class="literal">true</span>);</span><br><span class="line">    // don<span class="string">'t dump native PIDs for background ANRs unless it is the process of interest</span></span><br><span class="line"><span class="string">    String[] nativeProcs = null;</span></span><br><span class="line"><span class="string">    if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">        for (int i = 0; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;</span></span><br><span class="line"><span class="string">            if (NATIVE_STACKS_OF_INTEREST[i].equals(app.processName)) &#123;</span></span><br><span class="line"><span class="string">                nativeProcs = new String[] &#123; app.processName &#125;;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        nativeProcs = NATIVE_STACKS_OF_INTEREST;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int[] pids = nativeProcs == null ? null : Process.getPidsForCommands(nativeProcs);</span></span><br><span class="line"><span class="string">    ArrayList&lt;Integer&gt; nativePids = null;</span></span><br><span class="line"><span class="string">    if (pids != null) &#123;</span></span><br><span class="line"><span class="string">        nativePids = new ArrayList&lt;Integer&gt;(pids.length);</span></span><br><span class="line"><span class="string">        for (int i : pids) &#123;</span></span><br><span class="line"><span class="string">            nativePids.add(i);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // For background ANRs, don'</span>t pass the ProcessCpuTracker to</span><br><span class="line">    // avoid spending 1/2 second collecting stats to rank lastPids.</span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="literal">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? null : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? null : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line">    String cpuInfo = null;</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">        synchronized (mService.mProcessCpuTracker) &#123;</span><br><span class="line">            cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);</span><br><span class="line">        &#125;</span><br><span class="line">        info.append(processCpuTracker.printCurrentLoad());</span><br><span class="line">        info.append(cpuInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(processCpuTracker.printCurrentState(anrTime));</span><br><span class="line">    Slog.e(TAG, info.toString());//将上面拿到的所有信息，打印到main <span class="built_in">log</span>中</span><br><span class="line">    <span class="keyword">if</span> (tracesFile == null) &#123;//5.将<span class="built_in">log</span>打印到 traces.txt中</span><br><span class="line">        // There is no trace file, so dump (only) the alleged culprit<span class="string">'s threads to the log</span></span><br><span class="line"><span class="string">        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation,</span></span><br><span class="line"><span class="string">            cpuInfo, tracesFile, null);// 6.将log打印到dropbox</span></span><br><span class="line"><span class="string">    if (mService.mController != null) &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately</span></span><br><span class="line"><span class="string">            int res = mService.mController.appNotResponding(</span></span><br><span class="line"><span class="string">                    app.processName, app.pid, info.toString());</span></span><br><span class="line"><span class="string">            if (res != 0) &#123;</span></span><br><span class="line"><span class="string">                if (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span></span><br><span class="line"><span class="string">                    app.kill("anr", true);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">                        mService.mServices.scheduleServiceTimeoutLocked(app);</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            mService.mController = null;</span></span><br><span class="line"><span class="string">            Watchdog.getInstance().setActivityController(null);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // 弹框处理</span></span><br><span class="line"><span class="string">    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);</span></span><br><span class="line"><span class="string">        if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">            app.kill("bg anr", true);</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // Set the app'</span>s notResponding state, and look up the errorReportReceiver</span><br><span class="line">        makeAppNotRespondingLocked(app,</span><br><span class="line">                activity != null ? activity.shortComponentName : null,</span><br><span class="line">                annotation != null ? <span class="string">"ANR "</span> + annotation : <span class="string">"ANR"</span>,</span><br><span class="line">                info.toString());</span><br><span class="line">        // Bring up the infamous App Not Responding dialog</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = map;</span><br><span class="line">        msg.arg1 = aboveSystem ? 1 : 0;</span><br><span class="line">        map.put(<span class="string">"app"</span>, app);</span><br><span class="line">        <span class="keyword">if</span> (activity != null) &#123;</span><br><span class="line">            map.put(<span class="string">"activity"</span>, activity);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的主体逻辑可以分成五个部分来看：</p><ol><li>更新CPU的统计信息。这是发生ANR时，第一次CPU使用信息的采样，采样数据会保存在mProcessStats这个变量中</li><li>将Log信息，写入Event log中</li><li>填充firstPids和lastPids数组。当前发生ANR的应用会首先被添加到firstPids中，这样打印函数栈的时候，当前进程总是在trace文件的最前面打印函数调用栈(StackTrace)。具体实现由dumpStackTraces()函数完成更新CPU的统计信息。这是发生ANR时，第二次CPU使用信息的采样，两次采样的数据分别对应ANR发生前后的CPU使用情况</li><li>准备main log需要的参数，将ANR信息输出到main log中</li><li>将log打印到trace.txt文件中</li><li>将log打印到dropbox中</li><li>弹框处理，显示ANR对话框。抛出SHOW_NOT_RESPONDING_MSG消息，AMS.MainHandler会处理这条消息，显示AppNotRespondingDialog</li></ol><p>当然，除了主体逻辑，发生ANR时还会输出各种类别的日志：</p><blockquote><p>event log，通过检索”am_anr”关键字，可以找到发生ANR的应用<br>main log，通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况<br>dropbox，通过检索”anr”类型，可以找到ANR的信息,log位于/data/system/dropbox<br>traces, 发生ANR时，各进程的函数调用栈信息，log位于/data/anr<br>我们分析ANR问题，往往是从main log中的CPU使用情况和traces中的函数调用栈开始。所以，更新CPU的使用信息updateCpuStatsNow()方法和打印函数栈dumpStackTraces()方法，是系统报告ANR问题关键所在。</p></blockquote><h4 id="CPU的使用情况"><a href="#CPU的使用情况" class="headerlink" title="CPU的使用情况"></a>CPU的使用情况</h4><p>AMS.updateCpuStatsNow()方法的实现见下面的代码，更新CPU使用信息的间隔最小是5秒，即如果5秒内连续调用updateCpuStatsNow()方法，其实是没有更新CPU使用信息的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">updateCpuStatsNow</span></span>() &#123;</span><br><span class="line">        synchronized (mProcessCpuTracker) &#123;</span><br><span class="line">            mProcessCpuMutexFree.set(<span class="literal">false</span>);</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            boolean haveNewCpuStats = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE &amp;&amp;</span><br><span class="line">                    mLastCpuTime.get() &lt; (now-MONITOR_CPU_MIN_TIME)) &#123;</span><br><span class="line">                mLastCpuTime.set(now);</span><br><span class="line">                mProcessCpuTracker.update();</span><br><span class="line">                <span class="keyword">if</span> (mProcessCpuTracker.hasGoodLastStats()) &#123;</span><br><span class="line">                    haveNewCpuStats = <span class="literal">true</span>;</span><br><span class="line">                    //Slog.i(TAG, mProcessCpu.printCurrentState());</span><br><span class="line">                    //Slog.i(TAG, <span class="string">"Total CPU usage: "</span></span><br><span class="line">                    //        + mProcessCpu.getTotalCpuPercent() + <span class="string">"%"</span>);</span><br><span class="line"></span><br><span class="line">                    // Slog the cpu usage <span class="keyword">if</span> the property is <span class="built_in">set</span>.</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(SystemProperties.get(<span class="string">"events.cpu"</span>))) &#123;</span><br><span class="line">                        int user = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                        int system = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                        int iowait = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                        int irq = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                        int softIrq = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                        int idle = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line"></span><br><span class="line">                        int total = user + system + iowait + irq + softIrq + idle;</span><br><span class="line">                        <span class="keyword">if</span> (total == 0) total = 1;</span><br><span class="line"></span><br><span class="line">                        EventLog.writeEvent(EventLogTags.CPU,</span><br><span class="line">                                ((user+system+iowait+irq+softIrq) * 100) / total,</span><br><span class="line">                                (user * 100) / total,</span><br><span class="line">                                (system * 100) / total,</span><br><span class="line">                                (iowait * 100) / total,</span><br><span class="line">                                (irq * 100) / total,</span><br><span class="line">                                (softIrq * 100) / total);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final BatteryStatsImpl bstats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">            synchronized(bstats) &#123;</span><br><span class="line">                synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (haveNewCpuStats) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bstats.startAddingCpuLocked()) &#123;</span><br><span class="line">                            int totalUTime = 0;</span><br><span class="line">                            int totalSTime = 0;</span><br><span class="line">                            final int N = mProcessCpuTracker.countStats();</span><br><span class="line">                            <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                                ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);</span><br><span class="line">                                <span class="keyword">if</span> (!st.working) &#123;</span><br><span class="line">                                    <span class="built_in">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                ProcessRecord pr = mPidsSelfLocked.get(st.pid);</span><br><span class="line">                                totalUTime += st.rel_utime;</span><br><span class="line">                                totalSTime += st.rel_stime;</span><br><span class="line">                                <span class="keyword">if</span> (pr != null) &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = pr.curProcBatteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        pr.curProcBatteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                pr.info.uid, pr.processName);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                    pr.curCpuTime += st.rel_utime + st.rel_stime;</span><br><span class="line">                                    <span class="keyword">if</span> (pr.lastCpuTime == 0) &#123;</span><br><span class="line">                                        pr.lastCpuTime = pr.curCpuTime;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = st.batteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        st.batteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                bstats.mapUid(st.uid), st.name);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            final int userTime = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                            final int systemTime = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                            final int iowaitTime = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                            final int irqTime = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                            final int softIrqTime = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                            final int idleTime = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line">                            bstats.finishAddingCpuLocked(totalUTime, totalSTime, userTime,</span><br><span class="line">                                    systemTime, iowaitTime, irqTime, softIrqTime, idleTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mLastWriteTime &lt; (now-BATTERY_STATS_TIME)) &#123;</span><br><span class="line">                    mLastWriteTime = now;</span><br><span class="line">                    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CPU使用信息由ProcessCpuTracker这个类维护， 每次调用ProcessCpuTracker.update()方法，就会读取设备节点 /proc 下的文件，来更新CPU使用信息，具体有以下几个维度：</p><blockquote><p>CPU的使用时间: 读取 /proc/stat</p><blockquote><p>user： 用户进程的CPU使用时间<br>nice： 降低过优先级进程的CPU使用时间。Linux进程都有优先级，这个优先级可以进行动态调整，譬如进程初始优先级的值设为10,运行时降低为8,那么，修正值-2就定义为nice。 Android将user和nice这两个时间归类成user<br>sys： 内核进程的CPU使用时间<br>idle： CPU空闲的时间<br>wait： CPU等待IO的时间<br>hw irq： 硬件中断的时间。如果外设（譬如硬盘）出现故障，需要通过硬件终端通知CPU保存现场，发生上下文切换的时间就是CPU的硬件中断时间<br>sw irg： 软件中断的时间。同硬件中断一样，如果软件要求CPU中断，则上下文切换的时间就是CPU的软件中断时间</p></blockquote></blockquote><blockquote><p>CPU负载: 读取 /proc/loadavg, 统计最近1分钟，5分钟，15分钟内，CPU的平均活动进程数。 CPU的负载可以比喻成超市收银员负载，如果有1个人正在买单，有2个人在排队，那么该收银员的负载就是3。 在收银员工作时，不断会有人买单完成，也不断会有人排队，可以在固定的时间间隔内(譬如，每隔5秒)统计一次负载，那么，就可以统计出一段时间内的平均负载。</p></blockquote><blockquote><p>页错误信息： 进程的CPU使用率最后输出的“faults: xxx minor/major”部分表示的是页错误次数，当次数为0时不显示。 major是指Major Page Fault(主要页错误，简称MPF)，内核在读取数据时会先后查找CPU的高速缓存和物理内存，如果找不到会发出一个MPF信息，请求将数据加载到内存。 minor是指Minor Page Fault(次要页错误，简称MnPF)，磁盘数据被加载到内存后，内核再次读取时，会发出一个MnPF信息。 一个文件第一次被读写时会有很多的MPF，被缓存到内存后再次访问MPF就会很少，MnPF反而变多，这是内核为减少效率低下的磁盘I/O操作采用的缓存技术的结果。</p></blockquote><h4 id="堆栈调用"><a href="#堆栈调用" class="headerlink" title="堆栈调用"></a>堆栈调用</h4><p>AMS.dumpStackTraces()方法用于打印进程的函数调用栈，该方法的主体逻辑如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * If a stack trace dump file is configured, dump process stack traces.</span><br><span class="line"> * @param clearTraces causes the dump file to be erased prior to the new</span><br><span class="line"> *    traces being written, <span class="keyword">if</span> <span class="literal">true</span>; when <span class="literal">false</span>, the new traces will be</span><br><span class="line"> *    appended to any existing file content.</span><br><span class="line"> * @param firstPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> first</span><br><span class="line"> * @param lastPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> last</span><br><span class="line"> * @param nativePids optional list of native pids to dump stack crawls</span><br><span class="line"> */</span><br><span class="line">public static File dumpStackTraces(boolean clearTraces, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; extraPids = null;</span><br><span class="line"></span><br><span class="line">    // Measure CPU usage as soon as we<span class="string">'re called in order to get a realistic sampling</span></span><br><span class="line"><span class="string">    // of the top users at the time of the request.</span></span><br><span class="line"><span class="string">    if (processCpuTracker != null) &#123;</span></span><br><span class="line"><span class="string">        processCpuTracker.init();</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            Thread.sleep(200);</span></span><br><span class="line"><span class="string">        &#125; catch (InterruptedException ignored) &#123;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        processCpuTracker.update();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // We'</span>ll take the stack crawls of just the top apps using CPU.</span><br><span class="line">        final int N = processCpuTracker.countWorkingStats();</span><br><span class="line">        extraPids = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; N &amp;&amp; extraPids.size() &lt; 5; i++) &#123;</span><br><span class="line">            ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);</span><br><span class="line">            <span class="keyword">if</span> (lastPids.indexOfKey(stats.pid) &gt;= 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_ANR) Slog.d(TAG, <span class="string">"Collecting stacks for extra pid "</span> + stats.pid);</span><br><span class="line"></span><br><span class="line">                extraPids.add(stats.pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_ANR) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Skipping next CPU consuming process, not a java proc: "</span></span><br><span class="line">                        + stats.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean useTombstonedForJavaTraces = <span class="literal">false</span>;</span><br><span class="line">    File tracesFile;</span><br><span class="line"></span><br><span class="line">    final String tracesDirProp = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-dir"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (tracesDirProp.isEmpty()) &#123;</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is not <span class="built_in">set</span>, we are using the <span class="string">"old"</span> trace</span><br><span class="line">        // dumping scheme. All traces are written to a global trace file (usually</span><br><span class="line">        // <span class="string">"/data/anr/traces.txt"</span>) so the code below must take care to unlink and recreate</span><br><span class="line">        // the file <span class="keyword">if</span> requested.</span><br><span class="line">        //</span><br><span class="line">        // This mode of operation will be removed <span class="keyword">in</span> the near future.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String globalTracesPath = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-file"</span>, null);</span><br><span class="line">        <span class="keyword">if</span> (globalTracesPath.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"dumpStackTraces: no trace path configured"</span>);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tracesFile = new File(globalTracesPath);</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (clearTraces &amp;&amp; tracesFile.exists()) &#123;</span><br><span class="line">                tracesFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tracesFile.createNewFile();</span><br><span class="line">            FileUtils.setPermissions(globalTracesPath, 0666, -1, -1); // -rw-rw-rw-</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to prepare ANR traces file: "</span> + tracesFile, e);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        File tracesDir = new File(tracesDirProp);</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is <span class="built_in">set</span>, we use the <span class="string">"new"</span> trace dumping scheme.</span><br><span class="line">        // Each <span class="built_in">set</span> of ANR traces is written to a separate file and dumpstate will process</span><br><span class="line">        // all such files and add them to a captured bug report <span class="keyword">if</span> they<span class="string">'re recent enough.</span></span><br><span class="line"><span class="string">        maybePruneOldTraces(tracesDir);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // NOTE: We should consider creating the file in native code atomically once we'</span>ve</span><br><span class="line">        // gotten rid of the old scheme of dumping and lot of the code that deals with paths</span><br><span class="line">        // can be removed.</span><br><span class="line">        tracesFile = createAnrDumpFile(tracesDir);</span><br><span class="line">        <span class="keyword">if</span> (tracesFile == null) &#123;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        useTombstonedForJavaTraces = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids,</span><br><span class="line">            useTombstonedForJavaTraces);</span><br><span class="line">    <span class="built_in">return</span> tracesFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void dumpStackTraces(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids,</span><br><span class="line">        boolean useTombstonedForJavaTraces) &#123;</span><br><span class="line"></span><br><span class="line">    // We don<span class="string">'t need any sort of inotify based monitoring when we'</span>re dumping traces via</span><br><span class="line">    // tombstoned. Data is piped to an <span class="string">"intercept"</span> FD installed <span class="keyword">in</span> tombstoned so we<span class="string">'re in full</span></span><br><span class="line"><span class="string">    // control of all writes to the file in question.</span></span><br><span class="line"><span class="string">    final DumpStackFileObserver observer;</span></span><br><span class="line"><span class="string">    if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">        observer = null;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Use a FileObserver to detect when traces finish writing.</span></span><br><span class="line"><span class="string">        // The order of traces is considered important to maintain for legibility.</span></span><br><span class="line"><span class="string">        observer = new DumpStackFileObserver(tracesFile);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // We must complete all stack dumps within 20 seconds.</span></span><br><span class="line"><span class="string">    long remainingTime = 20 * 1000;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.startWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // First collect all of the stacks of the most important pids.</span></span><br><span class="line"><span class="string">        if (firstPids != null) &#123;</span></span><br><span class="line"><span class="string">            int num = firstPids.size();</span></span><br><span class="line"><span class="string">            for (int i = 0; i &lt; num; i++) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for pid "</span></span><br><span class="line"><span class="string">                        + firstPids.get(i));</span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(firstPids.get(i), tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(firstPids.get(i), remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current firstPid=" + firstPids.get(i) +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Next collect the stacks of the native pids</span></span><br><span class="line"><span class="string">        if (nativePids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : nativePids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for native pid " + pid);</span></span><br><span class="line"><span class="string">                final long nativeDumpTimeoutMs = Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long start = SystemClock.elapsedRealtime();</span></span><br><span class="line"><span class="string">                Debug.dumpNativeBacktraceToFileTimeout(</span></span><br><span class="line"><span class="string">                        pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));</span></span><br><span class="line"><span class="string">                final long timeTaken = SystemClock.elapsedRealtime() - start;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current native pid=" + pid +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with native pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Lastly, dump stacks for all extra PIDs from the CPU tracker.</span></span><br><span class="line"><span class="string">        if (extraPids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : extraPids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for extra pid " + pid);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(pid, remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current extra pid=" + pid +</span></span><br><span class="line"><span class="string">                            "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with extra pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.stopWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="问题分析方法"><a href="#问题分析方法" class="headerlink" title="问题分析方法"></a>问题分析方法</h2><p>分析ANR问题，有三大利器：Logcat，traces和StrictMode。 在StrictMode机制一文中，有介绍StrictMode的实现机制以及用途，本文中不讨论利用StrictMode来解决ANR问题，但各位读者需要有这个意识。 在Watchdog机制以及问题分析一文中，我们介绍过logcat和traces这两种日志的用途。 分析ANR问题同Watchdog问题一样，都需要经过日志获取、问题定位和场景还原三个步骤。</p><h3 id="日志的获取"><a href="#日志的获取" class="headerlink" title="日志的获取"></a>日志的获取</h3><p>分析ANR问题最主要的途径就是通过log来分析。Android中log的获取见，Android的log机制分析一问中log的存储位置章节。</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>通过在event log中检索 am_anr 关键字，就可以找到发生ANR的进程，譬如以下日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:27 820 907 I am_anr: [0,29533,com.android.systemui,1082670605,Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;]</span><br></pre></td></tr></table></figure></p><p>表示在 10-16 00:48:27 这个时刻，PID为 29533 进程发生了ANR，进程名是 com.android.systemui<br>接下来可以在system log检索 ANR in 关键字，找到发生ANR前后的CPU使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:50:10 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.systemui, time=130090695</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Load: 30.4 / 22.34 / 19.94</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Android time :[2015-10-16 00:50:05.76] [130191,266]</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: CPU usage from 6753ms to -4ms ago:</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   47% 320/netd: 3.1% user + 44% kernel / faults: 14886 minor 3 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   15% 10007/com.sohu.sohuvideo: 2.8% user + 12% kernel / faults: 1144 minor</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   13% 10654/hif_thread: 0% user + 13% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   11% 175/mmcqd/0: 0% user + 11% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   5.1% 12165/app_process: 1.6% user + 3.5% kernel / faults: 9703 minor 540 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.3% 29533/com.android.systemui: 2.6% user + 0.7% kernel / faults: 8402 minor 343 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.2% 820/system_server: 0.8% user + 2.3% kernel / faults: 5120 minor 523 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   2.5% 11817/com.netease.pomelo.push.l.messageservice_V2: 0.7% user + 1.7% kernel / faults: 7728 minor 687 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.6% 11887/com.android.email: 0.5% user + 1% kernel / faults: 6259 minor 587 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11854/com.android.settings: 0.7% user + 0.7% kernel / faults: 5404 minor 471 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11869/android.process.acore: 0.7% user + 0.7% kernel / faults: 6131 minor 561 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.3% 11860/com.tencent.mobileqq: 0.1% user + 1.1% kernel / faults: 5542 minor 470 major</span><br><span class="line">...</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 12832/cat: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 13211/zygote64: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: 87% TOTAL: 3% user + 18% kernel + 64% iowait + 0.5% softirq</span><br></pre></td></tr></table></figure></p><p>这一段日志对于Android开发人员而言，实在太熟悉不过了，它包含的信息量巨大：</p><ul><li><strong>发生ANR的时间。</strong>event log中，ANR的时间是 00：48：27，因为AMS.appNotResponding()首先会打印event log，然后再打印system log， 所以，在system log中，找到ANR的时间是 00:50:10。可以从这个时间点之前的日志中，还原ANR出现时系统的运行状态</li><li><strong>打印ANR日志的进程。</strong>ANR日志都是在system_server进程的AMS线程打印的，在event log和system log中，都能看到 820 和 907， 所以system_server的PID是 802，AMS线程的TID是 907。ANR的监测机制实现在AMS线程，分析一些受系统影响的ANR，需要知道system_server进程的运行状态</li><li><strong>发生ANR的进程。</strong>ANR in关键字就表明了当前ANR的进程是com.android.system.ui，通过event log，知道进程的PID是 29533</li><li><strong>发生ANR的原因。</strong>Reason关键字表明了当前发生ANR的原因是，处理TIME_TICK广播消息超时。 隐含的意思是TIME_TICK是一个串行广播消息，在 29533 的主线程中，执行BroadcastReceiver.onReceive()方法已经超过10秒</li><li><strong>CPU负载。</strong>Load关键字表明了最近1分钟、5分钟、15分钟内的CPU负载分别是30.4、22.3、19.94。CPU最近1分钟的负载最具参考价值，因为ANR的超时限制基本都是1分钟以内， 这可以近似的理解为CPU最近1分钟平均有30.4个任务要处理，这个负载值是比较高的</li><li><strong>CPU使用统计时间段。</strong>CPU usage from XX to XX ago关键字表明了这是在ANR发生之前一段时间内的CPU统计。 类似的还有CPU usage from XX to XX after关键字，表明是ANR发生之后一段时间内的CPU统计</li><li><strong>各进程的CPU使用率。</strong>我们以com.android.systemui进程的CPU使用率为例，它包含以下信息：<br>  1）<strong>总的CPU使用率:</strong> 3.3%，其中systemui进程在用户态的CPU使用率是2.6%，在内核态的使用率是0.7%<br>  2) <strong>缺页次数fault：</strong>8402 minor表示高速缓存中的缺页次数，343 major表示内存的缺页次数。minor可以理解为进程在做内存访问，major可以理解为进程在做IO操作。 当前minor和major值都是比较高的，从侧面反映了发生ANR之前，systemui进程有有较多的内存访问操作，引发的IO次数也会较多<br>  3) <strong>CPU使用率前面的 “+”。</strong>部分进程的CPU使用率前面有 “+” 号，譬如cat和zygote64，表示在上一次CPU统计的时间片段内，还没有这些进程，而这一次CPU统计的时间片段内，运行了这些进程。 类似的还有 “-” 号，表示两次CPU统计时间片段时，这些进程消亡了</li><li><strong>CPU使用汇总。</strong>TOTAL关键字表明了CPU使用的汇总，87%是总的CPU使用率，其中有一项iowait表明CPU在等待IO的时间，占到64%，说明发生ANR以前，有大量的IO操作。app_process、 system_server, com.android.systemui这几个进程的major值都比较大，说明这些进程的IO操作较为频繁，从而拉升了整个iowait的时间</li></ul><p>信息量是如此的庞大，以致于我们都要下结论了：CPU大量的时间都在等待IO，导致systemui进程分配不到CPU时间，从而主线程处理广播消息超时，发生了ANR。<br>对于一个严谨的开发人员而言，这种结论下得有点早，因为还有太多的疑问：</p><ul><li>systemui进程也分到了一些CPU时间(3.3%)，难道BroadcastReceiver.onReceive()方法就一直无法执行吗？</li><li>为什么iowait的时间会这么多，而且多个进程的major值都很高？<br>接下来还是需要从其他日志中还原ANR出现的场景。</li></ul><h3 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h3><h4 id="第一个假设和验证"><a href="#第一个假设和验证" class="headerlink" title="第一个假设和验证"></a>第一个假设和验证</h4><p>带着上文提出来的第一个疑问，我们先来做一个假设：如果systemui进程正在执行BroadcatReceiver.onReceive()方法，那么从traces.txt文件中，应该可以看到主线程的函数调用栈正在执行这个方法。<br>接下来，我们首先从traces文件中，找到发生ANR时(00:48:27)，sysemtui进程的函数调用栈信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">----- pid 29533 at 2015-10-16 00:48:06 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (53):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 288625433917 93454573244 903419 ) utm=20570 stm=8292 core=3 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00060b0c  /system/lib64/libc.so (__epoll_pwait+8)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0001bb54  /system/lib64/libc.so (epoll_pwait+32)</span></span><br><span class="line">  native: <span class="comment">#02 pc 0001b3d8  /system/lib64/libutils.so (android::Looper::pollInner(int)+144)</span></span><br><span class="line">  native: <span class="comment">#03 pc 0001b75c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+76)</span></span><br><span class="line">  native: <span class="comment">#04 pc 000d7194  /system/lib64/libandroid_runtime.so (android::NativeMessageQueue::pollOnce(_JNIEnv*, int)+48)</span></span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:148)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:151)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line"></span><br><span class="line">----- pid 29533 at 2015-10-16 00:48:29 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (54):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 289080040422 93461978317 904874 ) utm=20599 stm=8309 core=0 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.println(SourceFile:77)</span><br><span class="line">  - waiting to lock &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger) held by thread 49</span><br><span class="line">  at android.os.Looper.loop(Looper.java:195)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line">...</span><br><span class="line"><span class="string">"Binder_5"</span> prio=5 tid=49 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x136760a0 self=0x7f7e453000</span><br><span class="line">  | sysTid=6945 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f6e3ce000</span><br><span class="line">  | state=S schedstat=( 5505571091 4567508913 30743 ) utm=264 stm=286 core=4 HZ=100</span><br><span class="line">  | stack=0x7f6b83f000-0x7f6b841000 stackSize=1008KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00019d14  /system/lib64/libc.so (syscall+28)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0005b5d8  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#02 pc 002c6f18  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#03 pc 00032c40  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  at libcore.io.Posix.getpid(Native method)</span><br><span class="line">  at libcore.io.ForwardingOs.getpid(ForwardingOs.java:83)</span><br><span class="line">  at android.system.Os.getpid(Os.java:176)</span><br><span class="line">  at android.os.Process.myPid(Process.java:754)</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.dump(SourceFile:219)</span><br><span class="line">  - locked &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger)</span><br><span class="line">  at com.mediatek.anrappmanager.ANRAppManager.dumpMessageHistory(SourceFile:65)</span><br><span class="line">  at android.app.ActivityThread<span class="variable">$ApplicationThread</span>.dumpMessageHistory(ActivityThread.java:1302)</span><br><span class="line">  at android.app.ApplicationThreadNative.onTransact(ApplicationThreadNative.java:682)</span><br><span class="line">  at android.os.Binder.execTransact(Binder.java:451)</span><br></pre></td></tr></table></figure><p>最终，我们找到systemui进程ANR时刻(00:48:27)附近的两个函数调用栈:</p><ul><li>在ANR发生之前(00:48:06)，主线程的函数调用栈处于正常状态：消息队列中，循环中处理消息</li><li>在ANR发生之后2秒(00:48:29)，主线程处于Blocked状态，在等待一个被49号线程持有的锁。而49号线程是一个Binder线程，anrappmanager正在做dump操作。</li></ul><blockquote><p>笔者分析的日志是MTK平台产生的，所以从函数调用栈中看到com.mediatek.anrappmanager.MessageLogger这样的类，它是MTK在AOSP上的扩展，用于打印ANR日志。</p></blockquote><p>至此，systemui进程发生ANR的直接原因我们已经找到了，systemui进程正在打印traces，存在较长时间的IO操作，导致主线程阻塞，从而无法处理TIME_TICK广播消息，所以发生了ANR。</p><p>要避免这种场景下的ANR，我们就需要打破主线程中Blocked的逻辑。其实本例是由于MTK在AOSP的android.os.Looper.loop()扩展了打印消息队列的功能，该功能存在设计缺陷，会导致锁等待的情况。</p><h4 id="第二个假设和验证"><a href="#第二个假设和验证" class="headerlink" title="第二个假设和验证"></a>第二个假设和验证</h4><p>我们进一步挖掘在systemui还没有发生ANR时，就在打印traces的原因。带着上文提出的第二个疑问，我们来做另一个假设： iowait较高，而且多个进程的major都很高，可能是由于当前正在调用AMS.dumpStackTraces()方法，很多进程都需要将自己的函数调用栈写到traces文件，所以IO就会较高。 如果当前正在调用AMS.dumpStackTraces()方法，那说明当时系统已经发生了异常，要么已经有ANR发生，要么有SNR发生</p><p>从event log中，我们检索到了另一个ANR：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:47:58 820 907 I am_anr  : [0,10464,com.android.settings,1086864965,Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)]</span><br></pre></td></tr></table></figure></p><p>在 00:47:58 这个时刻，com.android.settings进程发生了ANR，而且ANR的时间在systemui之前(00:48:27)。这一下，我们就找到佐证了，正是因为settings进程先发生了ANR，调用AMS.dumpStackTraces()， 从而很多进程都开始了打印traces的操作，所以系统的整个iowait比较高，大量进程的major值也比较高，systemui就在其列。在MTK逻辑的影响下，打印ANR日志会导致主线程阻塞，从而就连带引发了其他应用的ANR。</p><p>在system log中，我们检索到了settings进程ANR的CPU使用信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:12 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.settings (com.android.settings/.SubSettings), time=130063718</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Load: 21.37 / 19.25 / 18.84</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Android time :[2015-10-16 00:48:12.24] [130077,742]</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: CPU usage from 0ms to 7676ms later:</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   91% 820/system_server: 16% user + 75% kernel / faults: 13192 minor 167 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   3.2% 175/mmcqd/0: 0% user + 3.2% kernel</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.9% 29533/com.android.systemui: 2.3% user + 0.6% kernel / faults: 1352 minor 10 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 1736/com.android.phone: 0.9% user + 1.3% kernel / faults: 1225 minor 1 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 10464/com.android.settings: 0.7% user + 1.4% kernel / faults: 2801 minor 105 major</span><br></pre></td></tr></table></figure></p><p>具体的涵义我们不再赘述了，只关注一下ANR的原因:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.</span><br><span class="line">Outbound queue length: 0. Wait queue length: 1.)</span><br></pre></td></tr></table></figure></p><p>之前对Input ANR机制的分析派上用长了，我们轻松知道这种ANR的原因是什么。 Wait queue length： 1表示之前的输入事件已经派发到Settings进程了，但Settings进程还没有处理完毕，新来的KeyEvent事件已经等待超过了5秒，所以ANR产生了。<br>接下来，又需要找到Settings的traces，分析Settings主线程处理输入事件超时的原因，我们点到为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Android ANR机制进行了深入的分析：</p><ul><li><strong>ANR的监测机制</strong>，从Service，Broadcast，InputEvent三种不同的ANR监测机制的源码实现开始，分析了Android如何发现各类ANR。在启动服务、派发广播消息和输入事件时，植入超时检测，用于发现ANR</li><li><strong>ANR的报告机制</strong>，分析Android如何输出ANR日志。当ANR被发现后，两个很重要的日志输出是：CPU使用情况和进程的函数调用栈，这两类日志是我们解决ANR问题的利器</li></ul><p>ANR的解决方法，通过一个案例，对ANR日志进行了深入解读，梳理了分析ANR问题的思路和途径<br>最后，致各位读者，从日志出发解决ANR问题，理解ANR机制背后的实现原理，碰到再难的ANR问题也无需惊慌。</p><p> <strong>Android中的各种log机制以及分析。</strong></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li>ANR机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a></li><li>ANR问题分析流程  <a href="https://blog.csdn.net/mathcompfrac/article/details/53862441" target="_blank" rel="noopener">https://blog.csdn.net/mathcompfrac/article/details/53862441</a></li><li>StrictMode 机制以及使用场景 <a href="http://duanqz.github.io/2015-11-04-StrictMode-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-11-04-StrictMode-Analysis</a></li><li>Watchdog机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文目标讲解Android中的ANR原理以及如何分析ANR问题&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;   ANR(Application Not Respondi
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android ANR" scheme="http://yoursite.com/tags/Android-ANR/"/>
    
  </entry>
  
  <entry>
    <title>Android8.1.0 DeskClock横屏滑动冲突</title>
    <link href="http://yoursite.com/2018/06/20/Android8-1-0-DeskClock%E6%A8%AA%E5%B1%8F%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <id>http://yoursite.com/2018/06/20/Android8-1-0-DeskClock横屏滑动冲突/</id>
    <published>2018-06-20T09:06:20.000Z</published>
    <updated>2018-06-26T08:16:48.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>【Android版本】:Android 8.1.0<br>【预置条件】在时钟界面添加多个不同国家世界时钟<br>【操作步骤】<br> 1.竖屏下滑动查看<br> 2.切换至横屏滑动查看<br>【实际结果】<br>  2.横屏下出现滑动条不动，时钟界面自己在不停的更新，见视频<br>【期望结果】<br> 横屏下可正常滑动查看</p><h2 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h2><p><strong> 1）</strong> 找到滑动的View的布局代码在<br>竖屏是布局：packages/apps/DeskClock/res/layout/clock_fragment.xml<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:id=<span class="string">"@+id/cities"</span></span><br><span class="line">    android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_weight=<span class="string">"1"</span></span><br><span class="line">    android:clickable=<span class="string">"false"</span></span><br><span class="line">    android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/fab_height"</span></span><br><span class="line">    android:scrollbarStyle=<span class="string">"outsideOverlay"</span></span><br><span class="line">    android:scrollbars=<span class="string">"vertical"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>横屏的布局：packages/apps/DeskClock/res/layout-land/clock_fragment.xml<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Left gutter. --&gt;</span><br><span class="line">    &lt;Space</span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_weight=<span class="string">"@integer/gutter_width_percent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Clock: 62% of total width (4% given to right gutter). --&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_weight=<span class="string">"62"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:paddingBottom=<span class="string">"@dimen/fab_height"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;include</span><br><span class="line">            android:id=<span class="string">"@+id/main_clock_left_pane"</span></span><br><span class="line">            layout=<span class="string">"@layout/main_clock_frame"</span></span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_weight=<span class="string">"29"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Right gutter. --&gt;</span><br><span class="line">        &lt;Space</span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_weight=<span class="string">"2"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- World Clock List: 33% of total width. Right gutter is applied <span class="keyword">in</span> world_clock_item. --&gt;</span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">"@+id/cities"</span></span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_weight=<span class="string">"33"</span></span><br><span class="line">        android:clickable=<span class="string">"false"</span></span><br><span class="line">        android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">        android:paddingBottom=<span class="string">"@dimen/fab_height"</span></span><br><span class="line">        android:paddingTop=<span class="string">"16dp"</span></span><br><span class="line">        android:scrollbarStyle=<span class="string">"outsideOverlay"</span></span><br><span class="line">        android:scrollbars=<span class="string">"vertical"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>Java代码实现滑动：packages/apps/DeskClock/src/com/android/deskclock/ClockFragment.java</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h2&gt;&lt;p&gt;【Android版本】:Android 8.1.0&lt;br&gt;【预置条件】在时钟界面添加多个不同国家世界时钟&lt;br&gt;【操
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android DeskClock View" scheme="http://yoursite.com/tags/Android-DeskClock-View/"/>
    
  </entry>
  
  <entry>
    <title>StrictMode 机制以及性能调优</title>
    <link href="http://yoursite.com/2018/06/10/StrictMode-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>http://yoursite.com/2018/06/10/StrictMode-机制以及性能调优/</id>
    <published>2018-06-10T01:26:27.000Z</published>
    <updated>2018-06-29T08:46:41.725Z</updated>
    
    <content type="html"><![CDATA[<p>作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文主要介绍StrictMode 在Android 应用开发中的应用和一些问题。</p><p>Google 官方的StrictMode文档： <a href="https://developer.android.com/reference/android/os/StrictMode" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/StrictMode</a></p><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>StrictMode，严苛模式，是Android提供的一种运行时检测机制，用于检测代码运行时的一些不规范的操作，最常见的场景是用于发现主线程的IO操作和网络读写等耗时的操作。</p><p>StrictMode包含两个维度的概念：</p><ul><li><p><strong>Policy(策略):</strong> 是指StrictMode对一些违规操作的发现策略，分为两类：<br> 一类是针对一个具体的线程(<strong>ThreadPolicy</strong>)。<br> 线程策略检测的内容有</p><ul><li>自定义的耗时调用 使用detectCustomSlowCalls()开启</li><li>磁盘读取操作 使用detectDiskReads()开启</li><li>磁盘写入操作 使用detectDiskWrites()开启</li><li><p>网络操作 使用detectNetwork()开启</p><p>另一类是针对虚拟机的所有对象(<strong>VMPolicy</strong>)。<br>虚拟机策略检测的内容有</p></li><li>Activity泄露 使用detectActivityLeaks()开启</li><li>未关闭的Closable对象泄露 使用detectLeakedClosableObjects()开启</li><li>泄露的Sqlite对象 使用detectLeakedSqlLiteObjects()开启</li><li>检测实例数量 使用setClassInstanceLimit()开启</li></ul></li><li><p><strong>Penalty(惩罚)：</strong>是指StrictMode发现违规操作后进行惩罚的方式，譬如绘制红框、打印日志、显示对话框、杀掉进程等。</p></li></ul><p>Android在很多关键的代码路径上都植入了StrictMode，譬如磁盘读写、网络访问、系统进程启动等。StrictMode会根据设置的策略进行检查，如果某个进程在代码运行时出现了违规操作，那么就会受到”惩罚”。</p><p>应用程序可以利用StrictMode尽可能的发现一些编码的疏漏， Android在 packages/experimental/StrictModeTest 这个APK中提供了常见违规操作的样例， 谨作为大家的反面教材。</p><p>本文深入分析StrictMode背后的实现原理以及使用场景。</p><h1 id="StrictMode机制"><a href="#StrictMode机制" class="headerlink" title="StrictMode机制"></a>StrictMode机制</h1><p>StrictMode的实现涉及到以下源码：</p><ul><li><a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/BlockGuard.java" target="_blank" rel="noopener">libcore/dalvik/src/main/java/dalvik/system/BlockGuard.java</a></li><li><a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/CloseGuard.java" target="_blank" rel="noopener">libcore/dalvik/src/main/java/dalvik/system/CloseGuard.java</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/StrictMode.java" target="_blank" rel="noopener">frameworks/base/core/java/android/os/StrictMode.java</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/StrictMode.aidl" target="_blank" rel="noopener">StrictMode.aidl</a></li></ul><p>总体而言，StrictMode机制所涉及到的代码量并不大，但Android中植入StrictMode的地方都是一些重要的关口，StrictMode所体现的面向接口编程的思想以及设计模式的应用，值得我们好好学习。 下面，我们就深入源码，分析一下StrictMode机制的内部实现。</p><h2 id="BlockGuard和CloseGuard"><a href="#BlockGuard和CloseGuard" class="headerlink" title="BlockGuard和CloseGuard"></a>BlockGuard和CloseGuard</h2><p>StrictMode针对单个线程和虚拟机的所有对象都定义了检查策略，用来发现一些违规操作，譬如：主线程中的磁盘读/写、网络访问、未关闭cursor，这些操作都能够被StrictMode检查出来。 怎么做到的呢？在做这些操作时，植入StrictMode的检查代码就可以了。有一部分植入代码是建立在BlockGuard和CloseGuard之上的，可以说，StrictMode是建立在BlockGuard和CloseGuard之上的机制。</p><p><strong>Guard</strong>有“守卫”的意思，<strong>Block</strong>是阻塞的意思，在进行一些耗时操作时，譬如磁盘读写、网络操作，有一个守卫在监测着，它就是BlockGuard，如果这些耗时的操作导致主线程阻塞，BlockGuard就会发出通知; <strong>Close</strong>对应到可打开的文件，在文件被打开后，也有一个守卫在监测着，它就是CloseGuard，如果没有关闭文件，则CloseGuard就会发出通知。</p><p>对应的来看一下 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/BlockGuard.java" target="_blank" rel="noopener">BlockGuard.java</a>的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">import java.io.FileDescriptor;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Mechanism to <span class="built_in">let</span> threads <span class="built_in">set</span> restrictions on what code is allowed</span><br><span class="line"> * to <span class="keyword">do</span> <span class="keyword">in</span> their thread.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is meant <span class="keyword">for</span> applications to prevent certain blocking</span><br><span class="line"> * operations from running on their main event loop (or <span class="string">"UI"</span>) threads.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that this is all best-effort to catch most accidental mistakes</span><br><span class="line"> * and isn<span class="string">'t intended to be a perfect mechanism, nor provide any sort of</span></span><br><span class="line"><span class="string"> * security.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @hide</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">public final class BlockGuard &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // TODO: refactor class name to something more generic, since its scope is</span></span><br><span class="line"><span class="string">    // growing beyond just blocking/logging.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static final int DISALLOW_DISK_WRITE = 0x01;//不允许磁盘盘写</span></span><br><span class="line"><span class="string">    public static final int DISALLOW_DISK_READ = 0x02;//不允许从磁盘读</span></span><br><span class="line"><span class="string">    public static final int DISALLOW_NETWORK = 0x04;//不允许有网络操作</span></span><br><span class="line"><span class="string">    public static final int PASS_RESTRICTIONS_VIA_RPC = 0x08;</span></span><br><span class="line"><span class="string">    public static final int PENALTY_LOG = 0x10;//惩罚的log</span></span><br><span class="line"><span class="string">    public static final int PENALTY_DIALOG = 0x20;//惩罚的dialog</span></span><br><span class="line"><span class="string">    public static final int PENALTY_DEATH = 0x40;//惩罚kill</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public interface Policy &#123;</span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on disk writes.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onWriteToDisk();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on disk reads.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onReadFromDisk();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on network operations.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onNetwork();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on unbuffered input/ouput operations.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onUnbufferedIO();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Returns the policy bitmask, for shipping over Binder calls</span></span><br><span class="line"><span class="string">         * to remote threads/processes and reinstantiating the policy</span></span><br><span class="line"><span class="string">         * there.  The bits in the mask are from the DISALLOW_* and</span></span><br><span class="line"><span class="string">         * PENALTY_* constants.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        int getPolicyMask();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static class BlockGuardPolicyException extends RuntimeException &#123;</span></span><br><span class="line"><span class="string">        // bitmask of DISALLOW_*, PENALTY_*, etc flags</span></span><br><span class="line"><span class="string">        private final int mPolicyState;</span></span><br><span class="line"><span class="string">        private final int mPolicyViolated;</span></span><br><span class="line"><span class="string">        private final String mMessage;   // may be null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public BlockGuardPolicyException(int policyState, int policyViolated) &#123;</span></span><br><span class="line"><span class="string">            this(policyState, policyViolated, null);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public BlockGuardPolicyException(int policyState, int policyViolated, String message) &#123;</span></span><br><span class="line"><span class="string">            mPolicyState = policyState;</span></span><br><span class="line"><span class="string">            mPolicyViolated = policyViolated;</span></span><br><span class="line"><span class="string">            mMessage = message;</span></span><br><span class="line"><span class="string">            fillInStackTrace();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public int getPolicy() &#123;</span></span><br><span class="line"><span class="string">            return mPolicyState;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public int getPolicyViolation() &#123;</span></span><br><span class="line"><span class="string">            return mPolicyViolated;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public String getMessage() &#123;</span></span><br><span class="line"><span class="string">            // Note: do not change this format casually.  It'</span>s</span><br><span class="line">            // somewhat unfortunately Parceled and passed around</span><br><span class="line">            // Binder calls and parsed back into an Exception by</span><br><span class="line">            // Android<span class="string">'s StrictMode.  This was the least invasive</span></span><br><span class="line"><span class="string">            // option and avoided a gross mix of Java Serialization</span></span><br><span class="line"><span class="string">            // combined with Parcels.</span></span><br><span class="line"><span class="string">            return "policy=" + mPolicyState + " violation=" + mPolicyViolated +</span></span><br><span class="line"><span class="string">                    (mMessage == null ? "" : (" msg=" + mMessage));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * The default, permissive policy that doesn'</span>t prevent any operations.</span><br><span class="line">     */</span><br><span class="line">    public static final Policy LAX_POLICY = new <span class="function"><span class="title">Policy</span></span>() &#123;</span><br><span class="line">            public void <span class="function"><span class="title">onWriteToDisk</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onReadFromDisk</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onNetwork</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onUnbufferedIO</span></span>() &#123;&#125;</span><br><span class="line">            public int <span class="function"><span class="title">getPolicyMask</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Policy&gt; threadPolicy = new ThreadLocal&lt;Policy&gt;() &#123;</span><br><span class="line">        @Override protected Policy <span class="function"><span class="title">initialValue</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> LAX_POLICY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the current thread<span class="string">'s policy.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @return the current thread'</span>s policy.  Never returns null.</span><br><span class="line">     *     Will <span class="built_in">return</span> the LAX_POLICY instance <span class="keyword">if</span> nothing <span class="keyword">else</span> is <span class="built_in">set</span>.</span><br><span class="line">     */</span><br><span class="line">    public static Policy <span class="function"><span class="title">getThreadPolicy</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> threadPolicy.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the current thread<span class="string">'s block guard policy.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @param policy policy to set.  May not be null.  Use the public LAX_POLICY</span></span><br><span class="line"><span class="string">     *   if you want to unset the active policy.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    public static void setThreadPolicy(Policy policy) &#123;</span></span><br><span class="line"><span class="string">        if (policy == null) &#123;</span></span><br><span class="line"><span class="string">            throw new NullPointerException("policy == null");</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        threadPolicy.set(policy);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private BlockGuard() &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>从BlockGuard的代码来看，很简单，就定义了一些类型和方法接口。</p><p>同样的看看<a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/CloseGuard.java" target="_blank" rel="noopener">CloseGuard.java</a>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CloseGuard is a mechanism <span class="keyword">for</span> flagging implicit finalizer cleanup of</span><br><span class="line"> * resources that should have been cleaned up by explicit close</span><br><span class="line"> * methods (aka <span class="string">"explicit termination methods"</span> <span class="keyword">in</span> Effective Java).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A simple example: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   class Foo &#123;</span><br><span class="line"> *</span><br><span class="line"> *       private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"> *</span><br><span class="line"> *       ...</span><br><span class="line"> *</span><br><span class="line"> *       public <span class="function"><span class="title">Foo</span></span>() &#123;</span><br><span class="line"> *           ...;</span><br><span class="line"> *           guard.open(<span class="string">"cleanup"</span>);</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line"> *          guard.close();</span><br><span class="line"> *          ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       protected void finalize() throws Throwable &#123;</span><br><span class="line"> *           try &#123;</span><br><span class="line"> *               // Note that guard could be null <span class="keyword">if</span> the constructor threw.</span><br><span class="line"> *               <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line"> *                   guard.warnIfOpen();</span><br><span class="line"> *               &#125;</span><br><span class="line"> *               cleanup();</span><br><span class="line"> *           &#125; finally &#123;</span><br><span class="line"> *               super.finalize();</span><br><span class="line"> *           &#125;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * In usage <span class="built_in">where</span> the resource to be explicitly cleaned up are</span><br><span class="line"> * allocated after object construction, CloseGuard protection can</span><br><span class="line"> * be deferred. For example: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   class Bar &#123;</span><br><span class="line"> *</span><br><span class="line"> *       private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"> *</span><br><span class="line"> *       ...</span><br><span class="line"> *</span><br><span class="line"> *       public <span class="function"><span class="title">Bar</span></span>() &#123;</span><br><span class="line"> *           ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">connect</span></span>() &#123;</span><br><span class="line"> *          ...;</span><br><span class="line"> *          guard.open(<span class="string">"cleanup"</span>);</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line"> *          guard.close();</span><br><span class="line"> *          ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       protected void finalize() throws Throwable &#123;</span><br><span class="line"> *           try &#123;</span><br><span class="line"> *               // Note that guard could be null <span class="keyword">if</span> the constructor threw.</span><br><span class="line"> *               <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line"> *                   guard.warnIfOpen();</span><br><span class="line"> *               &#125;</span><br><span class="line"> *               cleanup();</span><br><span class="line"> *           &#125; finally &#123;</span><br><span class="line"> *               super.finalize();</span><br><span class="line"> *           &#125;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * When used <span class="keyword">in</span> a constructor calls to &#123;@code open&#125; should occur at</span><br><span class="line"> * the end of the constructor since an exception that would cause</span><br><span class="line"> * abrupt termination of the constructor will mean that the user will</span><br><span class="line"> * not have a reference to the object to cleanup explicitly. When used</span><br><span class="line"> * <span class="keyword">in</span> a method, the call to &#123;@code open&#125; should occur just after</span><br><span class="line"> * resource acquisition.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public final class CloseGuard &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Instance used when CloseGuard is disabled to avoid allocation.</span><br><span class="line">     */</span><br><span class="line">    private static final CloseGuard NOOP = new CloseGuard();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Enabled by default so we can catch issues early <span class="keyword">in</span> VM startup.</span><br><span class="line">     * Note, however, that Android disables this early <span class="keyword">in</span> its startup,</span><br><span class="line">     * but enables it with DropBoxing <span class="keyword">for</span> system apps on debug builds.</span><br><span class="line">     */</span><br><span class="line">    private static volatile boolean ENABLED = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Hook <span class="keyword">for</span> customizing how CloseGuard issues are reported.</span><br><span class="line">     */</span><br><span class="line">    private static volatile Reporter REPORTER = new DefaultReporter();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The default &#123;@link Tracker&#125;.</span><br><span class="line">     */</span><br><span class="line">    private static final DefaultTracker DEFAULT_TRACKER = new DefaultTracker();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Hook <span class="keyword">for</span> customizing how CloseGuard issues are tracked.</span><br><span class="line">     */</span><br><span class="line">    private static volatile Tracker currentTracker = DEFAULT_TRACKER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a CloseGuard instance. If CloseGuard is enabled, &#123;@code</span><br><span class="line">     * <span class="comment">#open(String)&#125; can be used to set up the instance to warn on</span></span><br><span class="line">     * failure to close. If CloseGuard is disabled, a non-null no-op</span><br><span class="line">     * instance is returned.</span><br><span class="line">     */</span><br><span class="line">    public static CloseGuard <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span> NOOP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> new CloseGuard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Used to <span class="built_in">enable</span> or <span class="built_in">disable</span> CloseGuard. Note that CloseGuard only</span><br><span class="line">     * warns <span class="keyword">if</span> it is enabled <span class="keyword">for</span> both allocation and finalization.</span><br><span class="line">     */</span><br><span class="line">    public static void setEnabled(boolean enabled) &#123;</span><br><span class="line">        ENABLED = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * True <span class="keyword">if</span> CloseGuard mechanism is enabled.</span><br><span class="line">     */</span><br><span class="line">    public static boolean <span class="function"><span class="title">isEnabled</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> ENABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Used to replace default Reporter used to warn of CloseGuard</span><br><span class="line">     * violations. Must be non-null.</span><br><span class="line">     */</span><br><span class="line">    public static void setReporter(Reporter reporter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reporter == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"reporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        REPORTER = reporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns non-null CloseGuard.Reporter.</span><br><span class="line">     */</span><br><span class="line">    public static Reporter <span class="function"><span class="title">getReporter</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> REPORTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the &#123;@link Tracker&#125; that is notified when resources are allocated and released.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     *</span><br><span class="line">     * @throws NullPointerException <span class="keyword">if</span> tracker is null</span><br><span class="line">     */</span><br><span class="line">    public static void setTracker(Tracker tracker) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tracker == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"tracker == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentTracker = tracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@link <span class="comment">#setTracker(Tracker) last Tracker that was set&#125;, or otherwise a default</span></span><br><span class="line">     * Tracker that does nothing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     */</span><br><span class="line">    public static Tracker <span class="function"><span class="title">getTracker</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> currentTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">CloseGuard</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * If CloseGuard is enabled, &#123;@code open&#125; initializes the instance</span><br><span class="line">     * with a warning that the <span class="built_in">caller</span> should have explicitly called the</span><br><span class="line">     * &#123;@code closer&#125; method instead of relying on finalization.</span><br><span class="line">     *</span><br><span class="line">     * @param closer non-null name of explicit termination method</span><br><span class="line">     * @throws NullPointerException <span class="keyword">if</span> closer is null, regardless of</span><br><span class="line">     * whether or not CloseGuard is enabled</span><br><span class="line">     */</span><br><span class="line">    public void open(String closer) &#123;</span><br><span class="line">        // always perform the check <span class="keyword">for</span> valid API usage...</span><br><span class="line">        <span class="keyword">if</span> (closer == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"closer == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...but avoid allocating an allocationSite <span class="keyword">if</span> disabled</span><br><span class="line">        <span class="keyword">if</span> (this == NOOP || !ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String message = <span class="string">"Explicit termination method '"</span> + closer + <span class="string">"' not called"</span>;</span><br><span class="line">        allocationSite = new Throwable(message);</span><br><span class="line">        currentTracker.open(allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Throwable allocationSite;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Marks this CloseGuard instance as closed to avoid warnings on</span><br><span class="line">     * finalization.</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">close</span></span>() &#123;</span><br><span class="line">        currentTracker.close(allocationSite);</span><br><span class="line">        allocationSite = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * If CloseGuard is enabled, logs a warning <span class="keyword">if</span> the <span class="built_in">caller</span> did not</span><br><span class="line">     * properly cleanup by calling an explicit close method</span><br><span class="line">     * before finalization. If CloseGuard is disabled, no action is</span><br><span class="line">     * performed.</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">warnIfOpen</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (allocationSite == null || !ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String message =</span><br><span class="line">                (<span class="string">"A resource was acquired at attached stack trace but never released. "</span></span><br><span class="line">                 + <span class="string">"See java.io.Closeable for information on avoiding resource leaks."</span>);</span><br><span class="line"></span><br><span class="line">        REPORTER.report(message, allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Interface to allow customization of tracking behaviour.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     */</span><br><span class="line">    public interface Tracker &#123;</span><br><span class="line">        void open(Throwable allocationSite);</span><br><span class="line">        void close(Throwable allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default tracker <span class="built_in">which</span> does nothing special and simply leaves it up to the GC to detect a</span><br><span class="line">     * leak.</span><br><span class="line">     */</span><br><span class="line">    private static final class DefaultTracker implements Tracker &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void open(Throwable allocationSite) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void close(Throwable allocationSite) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Interface to allow customization of reporting behavior.</span><br><span class="line">     */</span><br><span class="line">    public interface Reporter &#123;</span><br><span class="line">        void report (String message, Throwable allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default Reporter <span class="built_in">which</span> reports CloseGuard violations to the <span class="built_in">log</span>.</span><br><span class="line">     */</span><br><span class="line">    private static final class DefaultReporter implements Reporter &#123;</span><br><span class="line">        @Override public void report (String message, Throwable allocationSite) &#123;</span><br><span class="line">            System.logW(message, allocationSite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android在很多代码中植入了BlockGuard，以BlockGuardOs为例，这个类代理大部分POSIX系统调用接口，所谓代理，从代码角度，就是在一个类外层再做一层封装。 BlockGuardOs代理了Os类，并植入了BlockGuard，譬如BlockGuardOs.read()这个系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="built_in">read</span>(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException &#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    <span class="built_in">return</span> os.read(fd, bytes, byteOffset, byteCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过BlockGuard的一层封装，在每次进行read()系统调用时，都会通过BlockGuard通知发生了读磁盘的操作：BlockGuard.getThreadPolicy().onReadFromDisk()<br>这里用到了BlockGuard的getThreadPolicy()方法，其实BlockGuard内部有一个Policy，定义了可能导致阻塞的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Policy &#123;</span><br><span class="line">    void onWriteToDisk();</span><br><span class="line">    void onReadFromDisk();</span><br><span class="line">    void onNetwork();</span><br><span class="line">    int getPolicyMask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个Policy只是一个接口定义，专门暴露给外部的 ，StrictMode就实现了BlockGuard.Policy：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static class AndroidBlockGuardPolicy implements BlockGuard.Policy &#123;</span><br><span class="line">    private int mPolicyMask;</span><br><span class="line"></span><br><span class="line">    // Map from violation stacktrace hashcode -&gt; uptimeMillis of</span><br><span class="line">    // last violation.  No locking needed, as this is only</span><br><span class="line">    // accessed by the same thread.</span><br><span class="line">    private ArrayMap&lt;Integer, Long&gt; mLastViolationTime;</span><br><span class="line"></span><br><span class="line">    public AndroidBlockGuardPolicy(final int policyMask) &#123;</span><br><span class="line">        mPolicyMask = policyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"AndroidBlockGuardPolicy; mPolicyMask="</span> + mPolicyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Part of BlockGuard.Policy interface:</span><br><span class="line">    public int <span class="function"><span class="title">getPolicyMask</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> mPolicyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Part of BlockGuard.Policy interface:</span><br><span class="line">    public void <span class="function"><span class="title">onWriteToDisk</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPolicyMask &amp; DETECT_DISK_WRITE) == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tooManyViolationsThisLoop()) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BlockGuard.BlockGuardPolicyException e = new StrictModeDiskWriteViolation(mPolicyMask);</span><br><span class="line">        e.fillInStackTrace();</span><br><span class="line">        startHandlingViolationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>StrictMode不仅针对BlockGuard.Policy实现了自身的处理逻辑，还扩展了一个方法onCustomSlowCall()，通过BlockGuard.setThreadPolicy()就能够将AndroidBlockGuardPolicy植入到BlockGuard中。</p><p>再来看CloseGuard，与BlockGuard一样，Android在很多代码中也植入了CloseGuard，以FileInputStream为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStream extends InputStream &#123;</span><br><span class="line">    // 1. 新建CloseGuard全局变量</span><br><span class="line">    private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"></span><br><span class="line">    public FileInputStream(File file) throws FileNotFoundException &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 2. 设置CloseGuard标志</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws IOException &#123;</span><br><span class="line">        // 3. 清除CloseGuard标志</span><br><span class="line">        guard.close();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() throws IOException &#123;</span><br><span class="line">        // 4. 判断Close标志是否被清除</span><br><span class="line">        <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line">            guard.warnIfOpen();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CloseGuard的植入逻辑很清晰，一共分为4部分：</p><ul><li>1)新建一个CloseGuard全局变量</li><li>2)在对象初始化时，设置一个标志，表示需要调用close()方法关闭该对象</li><li>3)在关闭方法中，调用CloseGuard.close()方法，清除标志</li><li>4)在对象销毁时，调用CloaseGuard.warnIfOpen()方法，判断标志是否被清除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">warnIfOpen</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (allocationSite == null || !ENABLED) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String message =</span><br><span class="line">        (<span class="string">"A resource was acquired at attached stack trace but never released. "</span></span><br><span class="line">        + <span class="string">"See java.io.Closeable for information on avoiding resource leaks."</span>);</span><br><span class="line"></span><br><span class="line">    REPORTER.report(message, allocationSite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从CloseGuard.warnIfOpen()方法中，可以看到，设置的标志就是allocationSite变量，如果该变量已经置空了，表示已经被清除过了; 否则，就会通过REPORTER报告违规操作。</p><p>REPORTER是CloseGuard暴露一个接口，StrictMode就实现了这个接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class AndroidCloseGuardReporter implements CloseGuard.Reporter &#123;</span><br><span class="line">    public void report (String message, Throwable allocationSite) &#123;</span><br><span class="line">        onVmPolicyViolation(message, allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当StrictMode启用时，REPORTER就被设置成了AndroidCloseGuardReporter对象，如此一来，StrictMode就能够收集到CloseGuard报告的未关闭文件。</p><p>至此，我们揭开了StrictMode的面纱：Android通过BlockGuard和CloseGuard在一些执行路径中埋入了一些切点，譬如磁盘读写时BlockGuard会收到通知，对象销毁时CloseGuard就会收到通知。 BlockGuard和CloseGuard都设计了一套接口：BlockGuard.Policy和CloseGuard.Reporter，其实就是切点的不同分类，StrictMode正是利用这两个接口所定义的一些切点，切入了自已的处理逻辑。</p><blockquote><p>题外话: 得益于面向接口的设计，我们可以另起炉灶，完全独立于StrictMode再实现其他BlockGuard.Policy和CloseGuard.Reporter的处理逻辑; 也可以对BlockGuard.Policy和CloseGuard.Reporter进行扩展，StrictMode只需要实现新的处理逻辑即可，这都不会影响已有的架构。 接口定义和接口实现分离，两者可以独立变化，适应新的需求，这是桥接模式(Bridge Pattern)的精髓，它降低了Guard和StrictMode两者之间的耦合度。<br>从BlockGuardOs的设计中，我们也看到了代理模式(Proxy Pattern)，BlockGuardOs对被代理的Os类进行了简单控制，植入了BlockGuard的逻辑，作为一个中间者，处于调用者和被调用实体中间，能够降低两者的耦合度。</p></blockquote><h2 id="StrictMode-Policy"><a href="#StrictMode-Policy" class="headerlink" title="StrictMode Policy"></a>StrictMode Policy</h2><p>StrictMode利用了BlockGuard和CloseGuard，不仅实现了两者定义的一些策略(Policy)，还进行了扩展。 这些策略，在StrictMode看来，就是一些违规操作，下面我们深入介绍StrictMode定义的每一项违规操作。</p><h3 id="ThreadPolicy"><a href="#ThreadPolicy" class="headerlink" title="ThreadPolicy"></a>ThreadPolicy</h3><p>ThreadPolicy细分为以下几种：</p><ul><li>Disk Write：实现了BlockGuard的策略，写磁盘操作</li><li>Disk Read：实现了BlockGuard的策略，读磁盘操作</li><li>Network Access：实现了BlockGuard的策略，网络访问操作</li><li>Custom Slow Code：StrictMode扩展的策略，目前只有Webview中植入了这项检查<br>前三项的植入都是通过BlockGuard完成的，StrictMode只是实现了处理逻辑;最后一项是StrictMode扩展的， 如果一个方法执行的时间较长，可以调用StrictMode.noteSlowCall()方法来发出通知。 当这些操作发生后，最终都会调用StrictMode.handleViolation()方法进行处理，后文再展开讨论这个方法。</li></ul><p>StrictMode通过标志位来区别以上几项，为此还特意封装了一个内部类StrictMode.ThreadPlicy，目的是为了方便标志位的设定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final class ThreadPolicy &#123;</span><br><span class="line">    // ThreadPolicy标志位</span><br><span class="line">    final int mask;</span><br><span class="line">    private ThreadPolicy(int mask) &#123;</span><br><span class="line">            this.mask = mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用Builder完成标志位的初始化</span><br><span class="line">    public static final class Builder &#123;</span><br><span class="line">        private int mMask = 0;</span><br><span class="line"></span><br><span class="line">        public Builder <span class="function"><span class="title">detectDiskReads</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">enable</span>(DETECT_DISK_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadPolicy的初始化采用了构建者模式(Builder Pattern)，这样一来，调用者在使用起来就会更加自然一点，不用记住各个标志位的意义。 为了完成标志位的设定，StrictMode提供setThreadPolicy()方法，接收ThreadPolicy类型的对象作为参数，该方法的实现就是直接调用setThreadPolicyMask()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void setThreadPolicy(final ThreadPolicy policy) &#123;</span><br><span class="line">    setThreadPolicyMask(policy.mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pivate static void setThreadPolicyMask(final int policyMask) &#123;</span><br><span class="line">    setBlockGuardPolicy(policyMask);</span><br><span class="line">    Binder.setThreadStrictModePolicy(policyMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里完成了两个层面的ThreadPolicy设定：</p><ul><li><p><strong>Java层</strong>，通过StrictMode.setBlockGuardPolicy()完成，最终会调用BlockGuard.setThreadPolicy()方法， 将AndroidBlockGuardPolicy对象设定为BlockGuard的Policy;</p></li><li><p><strong>Native层</strong>，通过Binder.setThreadStrictModePolicy()完成，看到这里，想必各位读者心中有了疑问，为什么还会有Native层的ThreadPolicy设置？ 其实，看到Binder，就很容易联想到这是用作跨进程调用的，当进程A发起跨进程调用进入到进程B后，那进程B中的违规操作怎么判定呢？当然也需要一个ThreadPolicy， Binder.setThreadStrictModePolicy()就是用来设置其他进程的ThreadPolicy。进程B中的违规异常也会通过Binder再传回进程A中，如此一来， 一个方法执行路径上的所有违规操作都会被StrictMode发现。</p></li></ul><h3 id="VMPolicy"><a href="#VMPolicy" class="headerlink" title="VMPolicy"></a>VMPolicy</h3><p>ThreadPolicy主要用于发现一些容易导致主线程阻塞的操作，所以它针对的对象是单个线程; 而VMPolicy主要用于发现Java层的内存泄漏，所以它针对的是虚拟机的所有对象。 VMPolicy细分为以下几种：</p><ul><li><strong>Cursor Leak：</strong> 如果注册SQlite Cursor后没有调用close()，则发生了泄漏。</li><li><strong>Closable Leak：</strong>这一项是CloseGuard的实现。如果存在未关闭的对象，则发生了泄漏。</li><li><strong>Activity Leak：</strong> 如果Activity在销毁后，其对象引用还被持有，则发生了泄漏。</li><li><strong>Instance Leak：</strong> StrictMode允许设置一个类的对象数量上限，在系统闲时，Strict会统计虚拟机中实际的对象数量，如果超出设定的上限，则判定为对象泄漏。</li><li><strong>Registion Leak：</strong> 如果注册IntentReceiver后没有调用unregisterReceiver()，则发生了泄漏</li><li><strong>File URI Exposure：</strong>这一项是安全性检查。通过file://的方式共享文件时，存在安全隐患。Android建议通过content://的方式共享文件。</li></ul><p>如同ThreadPolicy一样，VMPolicy也采用了构建者模式(Builder Pattern)进行初始化，在Closable Leak这一项的使用上，与BlockGuard有异曲同工之妙， 但除了Closable Leak是利用CloseGuard以外，其他违规项都是StrictMode自身的逻辑，需要在一些关键路径上植入StrictMode的代码，我们举出两例：</p><p>例1：Cursor Leak</p><p>以下是SQLite Cursor植入了StrictMode机制的代码片段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public SQLiteCursor(SQLiteCursorDriver driver, String editTable, SQLiteQuery query) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (StrictMode.vmSqliteObjectLeaksEnabled()) &#123;</span><br><span class="line">        mStackTrace = new DatabaseObjectNotClosedException().fillInStackTrace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStackTrace = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void <span class="function"><span class="title">finalize</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">if</span> the cursor hasn<span class="string">'t been closed yet, close it first</span></span><br><span class="line"><span class="string">        if (mWindow != null) &#123;</span></span><br><span class="line"><span class="string">            if (mStackTrace != null) &#123;</span></span><br><span class="line"><span class="string">                String sql = mQuery.getSql();</span></span><br><span class="line"><span class="string">                int len = sql.length();</span></span><br><span class="line"><span class="string">                StrictMode.onSqliteObjectLeaked(</span></span><br><span class="line"><span class="string">                    "Finalizing a Cursor that has not been deactivated or closed. " +</span></span><br><span class="line"><span class="string">                    "database = " + mQuery.getDatabase().getLabel() +</span></span><br><span class="line"><span class="string">                    ", table = " + mEditTable +</span></span><br><span class="line"><span class="string">                    ", query = " + sql.substring(0, (len &gt; 1000) ? 1000 : len),</span></span><br><span class="line"><span class="string">                    mStackTrace);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            close();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        super.finalize();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>在SQLiteCursor对象初始化时，设置一个变量mStackTrace，如果开启了DETECT_VM_CURSOR_LEAKS，则将其置为非空。 在SQLiteCursor对象销毁时，会对Cursor是否关闭进行判断(如果CursorWindow非空，则说明没有显示关闭Cursor)。此时，如果mStackTrace变量非空，则向StrictMode报告。</p><p>例2：Activity Leak</p><p>再来一例Activity植入StrictMode的逻辑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.performLaunchActivity()</span><br><span class="line">└── StrictMode.incrementExpectedActivityCount()</span><br><span class="line"></span><br><span class="line">ActivityThread.performDestroyActivity()</span><br><span class="line">└── StrictMode.decrementExpectedActivityCount()</span><br></pre></td></tr></table></figure></p><p>StrictMode对象中维护了Activity的计数器，统计着Activity对象的数量。在Activity对象新建和销毁的时候，会分别调用increment和decrement，对计数进行增减调整。 每一次有Activity对象销毁，都会调用VMDebug.countInstancesOfClass()，计算虚拟机中实际的Activity对象数量，如果实际Activity对象的数量超出了StrictMode的统计值， 则说明Activity对象虽然销毁了，但其对象引用还在，这就存在泄漏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void decrementExpectedActivityCount(Class klass) &#123;</span><br><span class="line">    ...</span><br><span class="line">    long instances = VMDebug.countInstancesOfClass(klass, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (instances &gt; <span class="built_in">limit</span>) &#123;</span><br><span class="line">        Throwable tr = new InstanceCountViolation(klass, instances, <span class="built_in">limit</span>);</span><br><span class="line">        onVmPolicyViolation(tr.getMessage(), tr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两例中，我们看到，虽然检测的形式各有不同，但本质都是在被检测的对象初始化时(constructor)设置一个标志，在对象销毁时(finalize)再对这个标志进行判断。其他的检测项的实现方式也都大同小异。</p><h2 id="StrictMode-Penalty"><a href="#StrictMode-Penalty" class="headerlink" title="StrictMode Penalty"></a>StrictMode Penalty</h2><p>当StrictMode发现有违规操作后，提供一些惩罚的方式，使用者可以自行组合。</p><ul><li><strong>penaltyDialog：</strong> 弹出对话框</li><li><strong>penaltyDeath：</strong> 杀掉进程</li><li><strong>penaltyDeathOnNetwork</strong></li><li><strong>penaltyFlashScreen：</strong> 在屏幕的最外围绘制一个红框</li><li><strong>penaltyLog：</strong>打印StrictMode日志</li><li><strong>penaltyDropBox：</strong>将日志保存到Dropbox中</li></ul><p>StrictMode内部是通过标志位来记录惩罚操作的类型的，并提供了上述的方法来设置不同的标志位。 StrictMode检测到违规操作后，最终都会调用StrictMode.handleViolation()方法，该方法中就会根据设置的标志位进行惩罚：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void handleViolation(final ViolationInfo info) &#123;</span><br><span class="line">    final boolean justDropBox = (info.policy &amp; THREAD_PENALTY_MASK) == PENALTY_DROPBOX;</span><br><span class="line">    <span class="keyword">if</span> (justDropBox) &#123;</span><br><span class="line">        dropboxViolationAsync(violationMaskSubset, info);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(</span><br><span class="line">                    RuntimeInit.getApplicationObject(),</span><br><span class="line">                    violationMaskSubset,</span><br><span class="line">                    info);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((info.policy &amp; PENALTY_DEATH) != 0) &#123;</span><br><span class="line">        executeDeathPenalty(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法的实现逻辑一目了然，最终通过Binder发起跨进程调用，走到ActivityManagerService.handleApplicationStrictModeViolation()中.</p><h1 id="StrictMode使用"><a href="#StrictMode使用" class="headerlink" title="StrictMode使用"></a>StrictMode使用</h1><p>StrictMode机制只是用于发现一些违规操作，这些违规操作一般都是我们编码的疏漏，在运行时会被StrictMode暴露出来，但StrictMode并非真正意思上的“动态代码检查”。 各位读者有必要知道StrictMode的使用范围：</p><blockquote><p>StrictMode只是用在开发调试阶段，在正式发布时，应该关掉StrictMode,</p><blockquote><p>AOSP的源码中，USER版并没有打开StrictMode<br>由于Android还会对StrictMode的检查策略进行调整，所以Google Play建议上架的APK都关闭StrictMode; 从另一个角度，Google认为所有StrictMode的错误，在正式发布前，都应该解决。<br>StrictMode并不能发现Native层的违规操作，仅仅是用在Java层<br>StrictMode的使用场景可以分为三类，使用方式也都比较固定，可见StrictMode的对外接口还是封装得比较优美的。 下面，我们逐个介绍一下StrictMode的使用场景。</p></blockquote></blockquote><h2 id="普通应用开启StrictMode"><a href="#普通应用开启StrictMode" class="headerlink" title="普通应用开启StrictMode"></a>普通应用开启StrictMode</h2><p>对于应用程序而言，Android提供了一个最佳使用实践：尽可能早的在android.app.Application或android.app.Activity的生命周期使能StrictMode， onCreate()方法就是一个最佳的时机，越早开启就能在更多的代码执行路径上发现违规操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">onCreate</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</span><br><span class="line">       StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()</span><br><span class="line">               .detectDiskReads()</span><br><span class="line">               .detectDiskWrites()</span><br><span class="line">               .detectNetwork()   // or .detectAll() <span class="keyword">for</span> all detectable problems</span><br><span class="line">               .penaltyLog()</span><br><span class="line">               .build());</span><br><span class="line">       StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()</span><br><span class="line">               .detectLeakedSqlLiteObjects()</span><br><span class="line">               .detectLeakedClosableObjects()</span><br><span class="line">               .penaltyLog()</span><br><span class="line">               .penaltyDeath()</span><br><span class="line">               .build());</span><br><span class="line">    &#125;</span><br><span class="line">    super.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上StrictMode的使能代码限定在DEVELOPER_MODE：</p><ul><li>设定了Disk Read, Disk Write, Network Access三项ThreadPolicy，惩罚是打印日志;</li><li>设定了Cursor Leak, Closable Leak两项VMPolicy，惩罚是打印日志和杀掉进程。<br>当出现一些ThreadPolicy相关违规操作时，Android也提供了很多标准的解决方案，譬如Handler， AsyncTask， IntentService，能够将耗时的操作从主线程中分离出来。</li></ul><h2 id="系统应用开启StrictMode"><a href="#系统应用开启StrictMode" class="headerlink" title="系统应用开启StrictMode"></a>系统应用开启StrictMode</h2><p>对于Android系统应用和系统进程(system_server)而言，其实默认就会开启StrictMode。 StrictMode提供了conditionallyEnableDebugLogging()方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static boolean <span class="function"><span class="title">conditionallyEnableDebugLogging</span></span>() &#123;</span><br><span class="line">    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, <span class="literal">false</span>)</span><br><span class="line">                &amp;&amp; !amTheSystemServerProcess();</span><br><span class="line">    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!doFlashes &amp;&amp; (IS_USER_BUILD || suppress)) &#123;</span><br><span class="line">        setCloseGuardEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   int threadPolicyMask = StrictMode.DETECT_DISK_WRITE |</span><br><span class="line">            StrictMode.DETECT_DISK_READ |</span><br><span class="line">            StrictMode.DETECT_NETWORK;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!IS_USER_BUILD) &#123;</span><br><span class="line">        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StrictMode.setThreadPolicyMask(threadPolicyMask);</span><br><span class="line">    <span class="keyword">if</span> (IS_USER_BUILD) &#123;</span><br><span class="line">        setCloseGuardEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll().penaltyDropBox();</span><br><span class="line">        ...</span><br><span class="line">        setVmPolicy(policyBuilder.build());</span><br><span class="line">        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的目的就是要设置ThreadPolicy和VMPolicy，不过会有一些条件判断，具体的逻辑不表。我们来看一下调用这个方法的地方：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.run()</span><br><span class="line">ServiceThread.run()</span><br><span class="line">ActivityThread.handleBindApplication()</span><br><span class="line">└── StrictMode.conditionallyEnableDebugLogging()</span><br></pre></td></tr></table></figure></p><p>这表示在system_server进程、一些全局的消息线程(IoThread, UiThread, FgThread, DisplayThread)、应用进程这些东西启动的时候开启StrictMode。 在ActivityThread.handleBindApplication()中有这么一段限制：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags &amp;</span><br><span class="line">         (ApplicationInfo.FLAG_SYSTEM |</span><br><span class="line">          ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != 0) &#123;</span><br><span class="line">        StrictMode.conditionallyEnableDebugLogging();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表示只为系统应用(FLAG_SYSTEM, FLAG_UPDATED_SYSTEM_APP)开启了StrictMode，其他应用还是需要自行开启。</p><h2 id="临时关闭StrictMode"><a href="#临时关闭StrictMode" class="headerlink" title="临时关闭StrictMode"></a>临时关闭StrictMode</h2><p>对于某些操作而言，我们明确知道是StrictMode定义的违规操作，但实际上对性能并没有什么影响，那么，在执行这类操作的时候，可以临时关闭StrictMode。 譬如针对一些主线程快速写磁盘的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.ThreadPolicy old = StrictMode.getThreadPolicy();</span><br><span class="line">StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder(old)</span><br><span class="line">                                 .permitDiskWrites()</span><br><span class="line">                                 .build());</span><br><span class="line">// 进行磁盘写操作...</span><br><span class="line">StrictMode.setThreadPolicy(old);</span><br></pre></td></tr></table></figure></p><p>首先，将旧的ThreadPolicy缓存一把; 然后，设置新的ThreadPolicy，并允许写磁盘操作; 最后，在进行完正常的写磁盘操作后，还原旧的ThreadPolicy。 这样就临时性的避开了StrictMode对写磁盘操作的检查。</p><h2 id="查看开启StrictMode的结果"><a href="#查看开启StrictMode的结果" class="headerlink" title="查看开启StrictMode的结果"></a>查看开启StrictMode的结果</h2><p>严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。<br>adb logcat -b all | grep -rn StrictMode</p><h2 id="解决违例"><a href="#解决违例" class="headerlink" title="解决违例"></a>解决违例</h2><ul><li>如果是主线程中出现文件读写违例，建议使用工作线程（必要时结合Handler）完成。</li><li>如果是对SharedPreferences写入操作，在API 9 以上 建议优先调用apply而非commit。</li><li>如果是存在未关闭的Closable对象，根据对应的stacktrace进行关闭。</li><li>如果是SQLite对象泄露，根据对应的stacktrace进行释放。</li></ul><p>举个例子<br>以主线程中的文件写入为例，引起违例警告的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">    File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">    try &#123;</span><br><span class="line">      OutputStream output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">        output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">        output.flush();</span><br><span class="line">        output.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引起的警告为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/StrictMode( 9730): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode<span class="variable">$StrictModeDiskReadViolation</span>: policy=31 violation=2</span><br><span class="line">D/StrictMode( 9730):    at android.os.StrictMode<span class="variable">$AndroidBlockGuardPolicy</span>.onReadFromDisk(StrictMode.java:1176)</span><br><span class="line">D/StrictMode( 9730):    at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)</span><br><span class="line">D/StrictMode( 9730):    at libcore.io.IoBridge.open(IoBridge.java:390)</span><br><span class="line">D/StrictMode( 9730):    at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:88)</span><br><span class="line">D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.writeToExternalStorage(MainActivity.java:56)</span><br><span class="line">D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:30)</span><br><span class="line">D/StrictMode( 9730):    at android.app.Activity.performCreate(Activity.java:4543)</span><br></pre></td></tr></table></figure></p><p>因为上述属于主线程中的IO违例，解决方法就是讲写入操作放入工作线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          super.run();</span><br><span class="line">          File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">          File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">          try &#123;</span><br><span class="line">              OutputStream output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">              output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">              output.flush();</span><br><span class="line">              output.close();</span><br><span class="line">          &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而这并非完善，因为OutputStream.write方法可能抛出IOException，导致存在OutputStream对象未关闭的情况，仍然需要改进避免出现Closable对象未关闭的违例。改进如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          super.run();</span><br><span class="line">            File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">            File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">            OutputStream output = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">                output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">                output.flush();</span><br><span class="line">                output.close();</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="keyword">if</span> (null != output) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      output.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用StrictMode检测内存泄露"><a href="#使用StrictMode检测内存泄露" class="headerlink" title="使用StrictMode检测内存泄露"></a>使用StrictMode检测内存泄露</h2><p>通常情况下，检测内存泄露，我们需要使用MAT对heap dump 文件进行分析，这种操作不困难，但也不容易。使用严格模式，只需要过滤日志就能发现内存泄露。</p><p>这里以Activity为例说明，首先我们需要开启对检测Activity泄露的违例检测。使用上面的detectAll或者detectActivityLeaks()均可。其次写一段能够产生Activity泄露的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LeakyActivity extends Activity&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        MyApplication.sLeakyActivities.add(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyApplication中关于sLeakyActivities的部分实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">  public static final boolean IS_DEBUG = <span class="literal">true</span>;</span><br><span class="line">    public static ArrayList&lt;Activity&gt; sLeakyActivities = new ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们反复进入LeakyActivity再退出，过滤StrictMode就会得到这样的日志:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E/StrictMode( 2622): class com.example.strictmodedemo.LeakyActivity; instances=2; <span class="built_in">limit</span>=1</span><br><span class="line">E/StrictMode( 2622): android.os.StrictMode<span class="variable">$InstanceCountViolation</span>: class com.example.strictmodedemo.LeakyActivity; instances=2; <span class="built_in">limit</span>=1</span><br><span class="line">E/StrictMode( 2622):    at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)</span><br></pre></td></tr></table></figure></p><p>分析日志，LeakyActivity本应该是只存在一份实例，但现在出现了2个，说明LeakyActivity发生了内存泄露。</p><p>严格模式除了可以检测Activity的内存泄露之外，还能自定义检测类的实例泄露。从API 11 开始，系统提供的这个方法可以实现我们的需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)</span><br></pre></td></tr></table></figure><p>举个栗子，比如一个浏览器中只允许存在一个SearchBox实例，我们就可以这样设置已检测SearchBox实例的泄露<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.setVmPolicy(new VmPolicy.Builder().setClassInstanceLimit(SearchBox.class, 1).penaltyLog().build());</span><br></pre></td></tr></table></figure></p><h2 id="自定义-noteSlowCall"><a href="#自定义-noteSlowCall" class="headerlink" title="自定义 noteSlowCall"></a>自定义 noteSlowCall</h2><p>StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutor &#123;</span><br><span class="line">    public void execute(Runnable task) &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutor &#123;</span><br><span class="line"></span><br><span class="line">    private static long SLOW_CALL_THRESHOLD = 500;</span><br><span class="line">    public void executeTask(Runnable task) &#123;</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        task.run();</span><br><span class="line">        long cost = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (cost &gt; SLOW_CALL_THRESHOLD) &#123;</span><br><span class="line">            StrictMode.noteSlowCall(<span class="string">"slowCall cost="</span> + cost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行一个耗时2000毫秒的任务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskExecutor executor = new TaskExecutor();</span><br><span class="line">executor.executeTask(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">  @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p> 得到的违例日志，注意其中~duration=20 ms并非耗时任务的执行时间，而我们的自定义信息msg=slowCall cost=2000才包含了真正的耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D/StrictMode(23890): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode<span class="variable">$StrictModeCustomViolation</span>: policy=31 violation=8 msg=slowCall cost=2000</span><br><span class="line">D/StrictMode(23890):    at android.os.StrictMode<span class="variable">$AndroidBlockGuardPolicy</span>.onCustomSlowCall(StrictMode.java:1163)</span><br><span class="line">D/StrictMode(23890):    at android.os.StrictMode.noteSlowCall(StrictMode.java:1974)</span><br><span class="line">D/StrictMode(23890):    at com.example.strictmodedemo.TaskExecutor.executeTask(TaskExecutor.java:17)</span><br><span class="line">D/StrictMode(23890):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:36)</span><br><span class="line">D/StrictMode(23890):    at android.app.Activity.performCreate(Activity.java:4543)</span><br><span class="line">D/StrictMode(23890):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2158)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2237)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.access<span class="variable">$600</span>(ActivityThread.java:139)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread<span class="variable">$H</span>.handleMessage(ActivityThread.java:1262)</span><br><span class="line">D/StrictMode(23890):    at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">D/StrictMode(23890):    at android.os.Looper.loop(Looper.java:156)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.main(ActivityThread.java:5005)</span><br><span class="line">D/StrictMode(23890):    at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">D/StrictMode(23890):    at java.lang.reflect.Method.invoke(Method.java:511)</span><br><span class="line">D/StrictMode(23890):    at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:784)</span><br><span class="line">D/StrictMode(23890):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)</span><br><span class="line">D/StrictMode(23890):    at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。</p><p><strong>注意</strong></p><blockquote><p>在线上环境即Release版本不建议开启严格模式。<br>严格模式无法监控JNI中的磁盘IO和网络请求。<br>应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。</p></blockquote><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote><ol><li><a href="http://duanqz.github.io/2015-11-04-StrictMode-Analysis" target="_blank" rel="noopener">StrictMode机制以及使用场景</a></li><li><a href="https://www.cnblogs.com/yaowen/p/6024690.html" target="_blank" rel="noopener">Android严苛模式StrictMode使用详解</a> </li><li><a href="https://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/index.html" target="_blank" rel="noopener">Android性能调优利器StrictMode</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android StrictMode" scheme="http://yoursite.com/tags/Android-StrictMode/"/>
    
  </entry>
  
  <entry>
    <title>Watchdog机制以及问题分析</title>
    <link href="http://yoursite.com/2018/06/01/Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/01/Watchdog机制以及问题分析/</id>
    <published>2018-06-01T13:23:33.000Z</published>
    <updated>2018-06-29T12:19:50.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Watchdog的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运行状态进行实时监测，针对运行故障做一些保护处理，譬如让系统重启。这种Watchdog属于硬件层面，必须有硬件电路的支持。</p><p>Linux也引入了Watchdog，在Linux内核下，当Watchdog启动后，便设定了一个定时器，如果在超时时间内没有对/dev/Watchdog进行写操作，则会导致系统重启。通过定时器实现的Watchdog属于软件层面。</p><p>Android设计了一个软件层面Watchdog，用于保护一些重要的系统服务，当出现故障时，通常会让Android系统重启。由于这种机制的存在，就经常会出现一些system_server进程被Watchdog杀掉而发生手机重启的问题。</p><p>本文期望回答以下问题：</p><ul><li>1)Watchdog是怎么工作的？这涉及到Watchdog的工作机制。</li><li>2)遇到Watchdog的问题该怎么办？这涉及到分析Watchdog问题的惯用方法。</li></ul><p><strong>本文主要分析的是Framework中的Watchdog，底层(Kernel)侧也有Watchdog机制。但本文不分析。</strong></p><h1 id="Watchdog机制"><a href="#Watchdog机制" class="headerlink" title="Watchdog机制"></a>Watchdog机制</h1><p>本文以<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/Watchdog.java</a>为蓝本，分析Watchdog的实现逻辑。为了描述方便，ActivityManagerService， PackageManagerService， WindowManagerService会分别简称为AMS, PKMS, WMS。</p><h2 id="Watchdog的初始化"><a href="#Watchdog的初始化" class="headerlink" title="Watchdog的初始化"></a>Watchdog的初始化</h2><p>Android的Watchdog是一个单例线程，在System Server时就会初始化Watchdog。Watchdog在初始化时，会构建很多HandlerChecker，大致可以分为两类：</p><ul><li>Monitor Checker，用于检查是Monitor对象可能发生的死锁, AMS, PKMS, WMS等核心的系统服务都是Monitor对象。</li><li>Looper Checker，用于检查线程的消息队列是否长时间处于工作状态。Watchdog自身的消息队列，Ui, Io, Display这些全局的消息队列都是被检查的对象。此外，一些重要的线程的消息队列，也会加入到Looper Checker中，譬如AMS, PKMS，这些是在对应的对象初始化时加入的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private <span class="function"><span class="title">Watchdog</span></span>() &#123;</span><br><span class="line">    ....</span><br><span class="line">    mMonitorChecker = new HandlerChecker(FgThread.getHandler(),</span><br><span class="line">                <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">    mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(new Handler(Looper.getMainLooper()),</span><br><span class="line">                <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(),</span><br><span class="line">                <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(),</span><br><span class="line">                <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">                <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两类HandlerChecker的侧重点不同，Monitor Checker预警我们不能长时间持有核心系统服务的对象锁，否则会阻塞很多函数的运行; Looper Checker预警我们不能长时间的霸占消息队列，否则其他消息将得不到处理。这两类都会导致系统卡住(System Not Responding)。</p><h2 id="添加Watchdog监测对象"><a href="#添加Watchdog监测对象" class="headerlink" title="添加Watchdog监测对象"></a>添加Watchdog监测对象</h2><p>Watchdog初始化以后，就可以作为system_server进程中的一个单独的线程运行了。但这个时候，还不能触发Watchdog的运行，因为AMS, PKMS等系统服务还没有加入到Watchdog的监测集。 所谓监测集，就是需要Watchdog关注的对象，Android中有成千上万的消息队列在同时运行，然而，Watchdog毕竟是系统层面的东西，它只会关注一些核心的系统服务。</p><p>Watchdog提供两个方法，分别用于添加Monitor Checker对象和Looper Checker对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void addMonitor(Monitor monitor) &#123;</span><br><span class="line">    // 将monitor对象添加到Monitor Checker中，</span><br><span class="line">    // 在Watchdog初始化时，可以看到Monitor Checker本身也是一个HandlerChecker对象</span><br><span class="line">    mMonitors.add(monitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addThread(Handler thread, long timeoutMillis) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">"Threads can't be added once the Watchdog is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        final String name = thread.getLooper().getThread().getName();</span><br><span class="line">        // 为Handler构建一个HandlerChecker对象，其实就是**Looper Checker**</span><br><span class="line">        mHandlerCheckers.add(new HandlerChecker(thread, name, timeoutMillis));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被Watchdog监测的对象，都需要将自己添加到Watchdog的监测集中。以下是AMS的类定义和构造器的代码片段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line"></span><br><span class="line">    public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Watchdog.getInstance().addMonitor(this);</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">monitor</span></span>() &#123;</span><br><span class="line">        synchronized (this) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AMS实现了Watchdog.Monitor接口，这个接口只有一个方法，就是monitor()，它的作用后文会再解释。这里可以看到在AMS的构造器中，将自己添加到Monitor Checker对象中，然后将自己的handler添加到Looper Checker对象中。 其他重要的系统服务添加到Watchdog的代码逻辑都与AMS差不多。</p><p>整个Android系统中，被monitor的对象并不多，十个手指头就能数出来Watchdog.Monitor的实现类的个数。</p><h2 id="Watchdog的监测机制"><a href="#Watchdog的监测机制" class="headerlink" title="Watchdog的监测机制"></a>Watchdog的监测机制</h2><p>Watchdog本身是一个线程，它的run()方法实现如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">    boolean waitedHalf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ...</span><br><span class="line">            // 1. 调度所有的HandlerChecker</span><br><span class="line">            <span class="keyword">for</span> (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                hc.scheduleCheckLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            // 2. 开始定期检查</span><br><span class="line">            long start = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (timeout &gt; 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="built_in">wait</span>(timeout);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    Log.wtf(TAG, e);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 检查HandlerChecker的完成状态</span><br><span class="line">            final int waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">            <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 存在超时的HandlerChecker</span><br><span class="line">            blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">            subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">            allowRestart = mAllowRestart;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 5. 保存日志，判断是否需要杀掉系统进程</span><br><span class="line">        Slog.w(TAG, <span class="string">"*** GOODBYE!"</span>);</span><br><span class="line">        Process.killProcess(Process.myPid());</span><br><span class="line">        System.exit(10);</span><br><span class="line">    &#125; // end of <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码片段主要的运行逻辑如下：</p><ol><li>Watchdog运行后，便开始无限循环，依次调用每一个HandlerChecker的scheduleCheckLocked()方法</li><li>调度完HandlerChecker之后，便开始定期检查是否超时，每一次检查的间隔时间由CHECK_INTERVAL常量设定，为30秒</li><li>每一次检查都会调用evaluateCheckerCompletionLocked()方法来评估一下HandlerChecker的完成状态：<ul><li>COMPLETED表示已经完成</li><li>WAITING和WAITED_HALF表示还在等待，但未超时</li><li>OVERDUE表示已经超时。默认情况下，timeout是1分钟，但监测对象可以通过传参自行设定，譬如PKMS的Handler Checker的超时是10分钟</li></ul></li><li>如果超时时间到了，还有HandlerChecker处于未完成的状态(OVERDUE)，则通过getBlockedCheckersLocked()方法，获取阻塞的HandlerChecker，生成一些描述信息</li><li>保存日志，包括一些运行时的堆栈信息，这些日志是我们解决Watchdog问题的重要依据。如果判断需要杀掉system_server进程，则给当前进程(system_server)发送signal 9</li></ol><p>只要Watchdog没有发现超时的任务，HandlerChecker就会被不停的调度，那HandlerChecker具体做一些什么检查呢？ 直接上代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class HandlerChecker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">scheduleCheckLocked</span></span>() &#123;</span><br><span class="line">        // Looper Checker中是不包含monitor对象的，判断消息队列是否处于空闲</span><br><span class="line">        <span class="keyword">if</span> (mMonitors.size() == 0 &amp;&amp; mHandler.getLooper().isIdling()) &#123;</span><br><span class="line">            mCompleted = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 将Monitor Checker的对象置于消息队列之前，优先运行</span><br><span class="line">        mHandler.postAtFrontOfQueue(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        // 依次调用Monitor对象的monitor()方法</span><br><span class="line">        <span class="keyword">for</span> (int i = 0 ; i &lt; size ; i++) &#123;</span><br><span class="line">            synchronized (Watchdog.this) &#123;</span><br><span class="line">                mCurrentMonitor = mMonitors.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentMonitor.monitor();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对于Looper Checker而言，会判断线程的消息队列是否处于空闲状态。 如果被监测的消息队列一直闲不下来，则说明可能已经阻塞等待了很长时间</li><li>对于Monitor Checker而言，会调用实现类的monitor方法，譬如上文中提到的AMS.monitor()方法， 方法实现一般很简单，就是获取当前类的对象锁，如果当前对象锁已经被持有，则monitor()会一直处于wait状态，直到超时，这种情况下，很可能是线程发生了死锁</li></ul><p>至此，我们已经分析了Watchdog的工作机制，回答了我们提出的第一个问题：<br>Watchdog定时检查一些重要的系统服务，举报长时间阻塞的事件，甚至杀掉system_server进程，让Android系统重启。</p><h1 id="问题分析方法"><a href="#问题分析方法" class="headerlink" title="问题分析方法"></a>问题分析方法</h1><h2 id="日志获取"><a href="#日志获取" class="headerlink" title="日志获取"></a>日志获取</h2><p>Andriod的日志门类繁多，而且，为了调试的需要，设备厂商和应用开发者都会在AOSP的基础上增加很多日志。 面对如此庞大复杂的日志系统，通常只有对应领域的专家才能看懂其透露的细节信息，就像去医院就诊，医生一看检查报告就知道患者身体出了什么问题，而外行对这些诊断信息往往是束手无策的。</p><p>解决Watchdog相关的问题，对日志的要求比较高，有些问题与当时的系统环境相关，仅仅凭借单一的日志并不能定位问题。 以下罗列出获取Android日志的一些重要手段，部分场景下，Watchdog相关的问题甚至需要以下所有的日志：</p><ul><li><p><strong>logcat</strong> 通过adb logcat命令输出Android的一些当前运行日志，可以通过logcat的 -b 参数指定要输出的日志缓冲区，缓冲区对应着logcat的一种日志类型。 高版本的logcat可以使用 -b all 获取到所有缓冲区的日志</p><ul><li><strong>event</strong> 通过android.util.EventLog工具类打印的日志，一些重要的系统事件会使用此类日志</li><li><strong>main</strong> 通过android.util.Log工具类打印的日志，应用程序，尤其是基于SDK的应用程序，会使用此类日志</li><li><strong>system</strong> 通过android.util.Slog工具类打印的日志，系统相关的日志一般都是使用此类日志，譬如SystemServer</li><li><strong>radio</strong> 通过android.util.Rlog工具类打印的日志，通信模块相关的日志一般都是使用此类日志，譬如RIL</li></ul></li><li><p><strong>dumpsys</strong> 通过adb dumpsys命令输出一些重要的系统服务信息，譬如内存、电源、磁盘等， 工作原理可以查阅dumpsys介绍一文</p></li><li><p><strong>traces</strong> 该文件记录了一个时间段的函数调用栈信息，通常在应用发生ANR(Application Not Responding)时，会触发打印各进程的函数调用栈。 站在Linux的角度，其实就是向进程发送SIGNAL_QUIT(3)请求，譬如，我们可以通过adb shell kill -3 <pid>命令，打印指定进程的的trace。 SIGNAL_QUIT(3)表面意思有一点误导，它其实并不会导致进程退出。输出一般在 <em>/data/anr/traces.txt</em> 文件中，当然，这是可以灵活配置的， Android提供的系统属性dalvik.vm.stack-trace-file可以用来配置生成traces文件的位置。</pid></p></li><li><p><strong>binder</strong> 通过Binder跨进程调用的日志，可以通过adb shell cat命令从 /proc/binder 下取出对应的日志</p><ul><li><strong>failed_transaction_log</strong></li><li><strong>transaction_log</strong></li><li><strong>transactions</strong></li><li><strong>stats</strong></li></ul></li><li><p><strong>dropbox</strong> 为了记录历史的logcat日志，Android引入了Dropbox，将历史日志持久化到磁盘中(/data/system/dropbox)。 logcat的缓冲区大小毕竟是有限的，所以需要循环利用，这样历史的日志信息就会被冲掉。在一些自动化测试的场景下，譬如Monkey需要长时间的运行， 就需要把历史的日志全都保存下来。</p></li><li><p><strong>tombstone</strong> tombstone错误一般由Dalvik错误、native层的代码问题导致的。当系统发生tombstone时，内核会上报一个严重的警告信号， 上层收到后，把当前的调用栈信息持久化到磁盘中(/data/tombstone)</p></li><li><p><strong>bugreport</strong> 通过adb bugreport命令输出，日志内容多到爆，logcat, traces, dmesg, dumpsys, binder的日志都包含在其中。 由于输出bugreport的时间很长，当系统发生错误时，我们再执行bugreport往往就来不及了(此时，系统可能都已经重启了)，所以，要动用bugreport就需要结合一些其他机制， 譬如在杀掉system_server进程之前，先让bugreport运行完。</p></li></ul><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>Watchdog出现的日志很明显，logcat中的event, system中都会有体现，要定位问题，可以从检索日志中的watchdog关键字开始。</p><p>发生Watchdog检测超时这么重要的系统事件，Android会打印一个EventLog：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchdog: Blocked <span class="keyword">in</span> handler XXX    <span class="comment"># 表示HandlerChecker超时了</span></span><br><span class="line">watchdog: Blocked <span class="keyword">in</span> monitor XXX    <span class="comment"># 表示MonitorChecker超时了</span></span><br></pre></td></tr></table></figure></p><p>Watchdog是运行在system_server进程中，会打印一些System类型的日志。在手机处于非调试状态时，伴随Watchdog出现的往往是system_server进程被杀，从而系统重启。 当Watchdog要主动杀掉system_server进程时，以下关键字就会出现在SystemLog中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: XXX</span><br><span class="line">Watchdog: XXX</span><br><span class="line">Watchdog: <span class="string">"*** GOODBYE!</span></span><br></pre></td></tr></table></figure></p><p>当我们在日志中检索到上述两类关键信息时，说明“Watchdog显灵”了，从另一个角度来理解，就是“System Not Responding”了。 接下来，我们需要进一步定位在watchdog出现之前，system_server进程在干什么，处于一个什么状态。 这与排除”Application Not Responding“问题差不多，我们需要进程的traces信息、当前系统的CPU运行信息、IO信息。</p><p>找到Watchddog出现之前的traces.txt文件，这个时间差最好不要太大，因为Watchdog默认的超时时间是1分钟，太久以前的traces并不能说明问题。 诱导Watchdong出现的直接原因其实就是system_server中某个线程被阻塞了，这个信息在event和system的log中清晰可见。 我们以一个systemLog为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="keyword">in</span> monitor com.android.server.wm.WindowManagerService on foreground thread (android.fg)</span><br></pre></td></tr></table></figure></p><p>Watchdog告诉我们Monitor Checker超时了，具体在哪呢？ 名为android.fg的线程在WindowManagerService的monitor()方法被阻塞了。这里隐含了两层意思：</p><ol><li>WindowManagerService实现了Watchdog.Monitor这个接口，并将自己作为Monitor Checker的对象加入到了Watchdog的监测集中</li><li>monitor()方法是运行在android.fg线程中的。Android将android.fg设计为一个全局共享的线程，意味着它的消息队列可以被其他线程共享， Watchdog的Monitor Checker就是使用的android.fg线程的消息队列。因此，出现Monitor Checker的超时，肯定是android.fg线程阻塞在monitor()方法上。</li></ol><p>我们打开system_server进程的traces，检索 android.fg 可以快速定位到该线程的函数调用栈：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"android.fg"</span> prio=5 tid=25 Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12eef900 self=0x7f7a8b1000</span><br><span class="line">  | sysTid=973 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f644e9000</span><br><span class="line">  | state=S schedstat=( 3181688530 2206454929 8991 ) utm=251 stm=67 core=1 HZ=100</span><br><span class="line">  | stack=0x7f643e7000-0x7f643e9000 stackSize=1036KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.wm.WindowManagerService.monitor(WindowManagerService.java:13125)</span><br><span class="line">  - waiting to lock &lt;0x126dccb8&gt; (a java.util.HashMap) held by thread 91</span><br><span class="line">  at com.android.server.Watchdog<span class="variable">$HandlerChecker</span>.run(Watchdog.java:204)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:194)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:61)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:46)</span><br></pre></td></tr></table></figure></p><p>android.fg线程调用栈告诉我们几个关键的信息：</p><ul><li>这个线程当前的状态是Blocked，阻塞</li><li>由Watchdog发起调用monitor()，这是一个Watchdog检查，阻塞已经超时</li><li>waiting to lock <0x126dccb8>： 阻塞的原因是monitor()方法中在等锁<0x126dccb8></0x126dccb8></0x126dccb8></li><li>held by thread 91： 这个锁被编号为91的线程持有，需要进一步观察91号线程的状态。</li></ul><blockquote><p>题外话：每一个进程都会对自己所辖的线程编号，从1开始。1号线程通常就是我们所说的主线程。 线程在Linux系统中还有一个全局的编号，由sysTid表示。我们在logcat等日志中看到的一般是线程的全局编号。 譬如，本例中android.fg线程在system_server进程中的编号是25，系统全局编号是973。</p></blockquote><p>可以在traces.txt文件中检索 tid=91 来快速找到91号线程的函数调用栈信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Binder_C"</span> prio=5 tid=91 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12e540a0 self=0x7f63289000</span><br><span class="line">  | sysTid=1736 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f6127c000</span><br><span class="line">  | state=S schedstat=( 96931835222 49673449591 260122 ) utm=7046 stm=2647 core=2 HZ=100</span><br><span class="line">  | stack=0x7f5ffbc000-0x7f5ffbe000 stackSize=1008KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at libcore.io.Posix.writeBytes(Native method)</span><br><span class="line">  at libcore.io.Posix.write(Posix.java:258)</span><br><span class="line">  at libcore.io.BlockGuardOs.write(BlockGuardOs.java:313)</span><br><span class="line">  at libcore.io.IoBridge.write(IoBridge.java:537)</span><br><span class="line">  at java.io.FileOutputStream.write(FileOutputStream.java:186)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.flushBytesLocked(FastPrintWriter.java:334)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.flushLocked(FastPrintWriter.java:355)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.appendLocked(FastPrintWriter.java:303)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.print(FastPrintWriter.java:466)</span><br><span class="line">  - locked &lt;@addr=0x134c4910&gt; (a com.android.internal.util.FastPrintWriter<span class="variable">$DummyWriter</span>)</span><br><span class="line">  at com.android.server.wm.WindowState.dump(WindowState.java:1510)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dumpWindowsNoHeaderLocked(WindowManagerService.java:12279)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dumpWindowsLocked(WindowManagerService.java:12266)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</span><br><span class="line">  - locked &lt;0x126dccb8&gt; (a java.util.HashMap)</span><br><span class="line">  at android.os.Binder.dump(Binder.java:324)</span><br><span class="line">  at android.os.Binder.onTransact(Binder.java:290)</span><br></pre></td></tr></table></figure></p><p>91号线程的名字是Binder_C，它的函数调用栈告诉我们几个关键信息：</p><ul><li>Native，表示线程处于运行状态(RUNNING)，并且正在执行JNI方法</li><li>在WindowManagerService.dump()方法申请了锁<0x126dccb8>，这个锁正是android.fg线程所等待的</0x126dccb8></li><li>FileOutputStream.write()表示Binder_C线程在执行IO写操作，正式因为这个写操作一直在阻塞，导致线程持有的锁不能释放</li></ul><blockquote><p>题外话：关于Binder线程。当Android进程启动时，就会创建一个线程池，专门处理Binder事务。线程池中会根据当前的binder线程计数器的值来构造新创建的binder线程, 线程名”Binder_%X”，X是十六进制。当然，线程池的线程数也有上限，默认情况下为16，所以，可以看到 Binder_1 ~ Binder_F 这样的线程命名。</p></blockquote><p>聪明的你看到这或许已经能够想到解决办法了，在这个IO写操作上加一个超时机制，并且这个超时小于Watchdog的超时，不就可以让线程释放它所占有的锁了吗？ 是的，这确实可以作为一个临时解决方案(Workaround)，或者说一个保护机制。但我们可以再往深处想一想，这个IO写操作为什么会阻塞：</p><ul><li>是不是IO缓冲区满了，导致写阻塞呢？</li><li>是不是写操作有什么锁，导致这个write方法在等锁呢？</li><li>是不是当前系统的IO负载过于高，导致写操作效率很低呢？</li></ul><p>这都需要我们再进一步从日志中去找原因。如果已有的日志不全，找不到论据，我们还需要设计场景来验证假设，解决问题的难度陡然上升。</p><h2 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h2><p>我们经历了两个关键步骤：</p><ol><li>通过event或system类型的日志，发现了Watchdog杀掉system_server导致系统重启</li><li>通过traces日志，发了导致Watchdog出现的具体线程操作</li></ol><p>这两个过程基本就涵盖了Watchdog的运行机制了，但这并没有解决问题啊。我们需要找到线程阻塞的原因是什么，然而，线程阻塞的原因就千奇百怪了。 如果有问题出现的现场，并且问题可以重现，那么我们可以通过调试的手段来分析问题产生的原因。 如果问题只是偶然出现，甚至只有一堆日志，我们就需要从日志中来还原问题出现的场景，这一步才是真正考验大家Android/Linux功底的地方。</p><p>继续以上述问题为例，我们来进一步还原问题出现的场景，从Java层的函数调用栈来看：</p><ul><li>首先，跨进程发起了Binder.dump()方法的调用：at android.os.Binder.dump(Binder.java:324)</li><li>然后，进入了WMS的dump()：at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</li><li>接着，发生了写文件操作：at java.io.FileOutputStream.write(FileOutputStream.java:186)</li><li>最后，调用了JNI方法：at libcore.io.Posix.writeBytes(Native method)</li></ul><p>Binder_C线程要出现这种函数调用栈，我们可以初步确定是Android接受了如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys window</span><br></pre></td></tr></table></figure></p><p>当通过命令行运行以上命令时，客户端(PC)的adb server会向服务端(手机)的adbd发送指令， adbd进程会fork出一个叫做dumpsys的子进程，dumpsys进程再利用Binder机制和system_server通信</p><p>仅凭这个还是分析不出问题所在，我们需要启用内核的日志了。当调用JNI方法libcore.io.Posix.writeBytes()时，会触发系统调用， Linux会从用户态切换到内核态，内核的函数调用栈也可以从traces中找到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel: __switch_to+0x74/0x8c</span><br><span class="line">kernel: pipe_wait+0x60/0x9c</span><br><span class="line">kernel: pipe_write+0x278/0x5cc</span><br><span class="line">kernel: do_sync_write+0x90/0xcc</span><br><span class="line">kernel: vfs_write+0xa4/0x194</span><br><span class="line">kernel: SyS_write+0x40/0x8c</span><br><span class="line">kernel: cpu_switch_to+0x48/0x4c</span><br></pre></td></tr></table></figure></p><p>在Java层，明确指明要写文件(FileOutputStream)，正常情况下，系统调用write()就完事了，但Kernel却打开了一个管道，最终阻塞在了pipe_wait()方法。 什么场景下会打开一个管道，而且管道会阻塞呢？一系列的猜想和验证过程接踵而至。</p><p>这里有必要先补充一些基础知识了：</p><blockquote><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html" target="_blank" rel="noopener">Linux进程间通信之管道(pipe)</a><br>   Linux的管道实现借助了文件系统的file结构和VFS(Virtual File System)，通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面时， 实际上就建立了一个管道。<br>这就解释了为什么发起系统调用write的时候，打开了一个管道。因为dumpsys和system_server进程，将自己的file结构指向了同一个VFS索引节点。</p></blockquote><blockquote><p><a href="https://blog.csdn.net/sj13051180/article/details/47865803" target="_blank" rel="noopener">管道挂起的案例</a><br>  管道是一个生产者-消费者模型，当缓冲区满时，则生产者不能往管道中再写数据了，需等到消费者读数据。如果消费者来不及处理缓冲区的数据，或者锁定缓冲区，则生产者就挂起了。<br>结合到例子中的场景，system_server进程无法往管道中写数据，很可能是dumpsys进程一直忙碌来不及处理新的数据。</p></blockquote><p>接下来，需要再从日志中寻找dumpsys进程的运行状态了：</p><ul><li>是不是dumpsys进程的负载太高？</li><li>是不是dumpsys进程死掉了，导致一直没有处理缓冲区数据？</li><li>是不是dumpsys进程有死锁？</li></ul><p>接下来的分析过程已经偏离Watchdog机制越来越远了，我们点到为止。</p><p>小伙伴们可以看到，场景还原涉及到的知识点非常之宽泛，而且有一定的深度。在没有现场的情况下，伴随一系列的假设和验证过程，充满了不确定性和发现问题的喜悦。 正所谓，同问题做斗争，其乐无穷！</p><p>至此，我们分析Watchdog问题的惯用方法，回答前面提出来的第二个问题：<br>通过event或system类型的logcat日志，检索Watchdog出现的关键信息；通过traces，分析出导致Watchdog检查超时的直接原因；通过其他日志，还原出问题出现的场景。</p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p>在上面介绍Watchdog问题分析方法的时候，我们其实已经举了一个例子。通常，比较容易定位导致Watchdog出现的直接原因(Direct Cause)，但很难找到更深层次的原因(Root Cause)。 这个小节，我们再介绍一个实例，来分析Watchdog出现的另一种场景。诚然，仅凭几个例子，远不够涵盖Watchdog的所有问题，我们的章法还是按照一定的方法论来深究问题。</p><p>回顾一下解决问题三部曲：</p><ol><li>日志获取。日志种类繁多，分析Watchdog问题，宁滥毋缺</li><li>问题定位。从logcat中锁定watchdog的出现，从traces锁定直接原因</li><li>场景还原。结合各类日志，不断假设验证</li></ol><p>以CPU占用过高的场景为例：<br>从sys_log中，检索到了Watchdog的出现关键信息</p><blockquote><p>TIPS: 在sys_log中搜索关键字”WATCHDOG KILLING SYSTEM PROCESS”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-14 17:10:51.548   892  1403 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="keyword">in</span> handler on ActivityManager (ActivityManager)</span><br></pre></td></tr></table></figure></p></blockquote><p>这是一个Watchdog的Looper Checker超时，由于ActivityManager这个线程一直处于忙碌状态，导致Watchdog检查超时。 Watchdog出现的时间是10-14 17:10:51.548左右，需要从traces.txt中找到这个时间段的system_server进程的函数调用栈信息， system_server的进程号是892。</p><p>从traces.txt中找到对应的函数调用栈</p><p>traces.txt包含很多进程在不同时间段的函数调用栈信息，为了检索的方便，首先可以将traces.txt分块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ActivityManager"</span> prio=5 tid=17 TimedWaiting</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12c0e6d0 self=0x7f84caf000</span><br><span class="line">  | sysTid=938 nice=-2 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f7d887000</span><br><span class="line">  | state=S schedstat=( 107864628645 628257779012 60356 ) utm=7799 stm=2987 core=2 HZ=100</span><br><span class="line">  | stack=0x7f6e68f000-0x7f6e691000 stackSize=1036KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait!(Native method)</span><br><span class="line">  - waiting on &lt;0x264ff09d&gt; (a com.android.server.am.ActivityManagerService<span class="variable">$5</span>)</span><br><span class="line">  at java.lang.Object.wait(Object.java:422)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5395)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5282)</span><br><span class="line">  at com.android.server.am.ActivityManagerService<span class="variable">$AnrActivityManagerService</span>.dumpStackTraces(ActivityManagerService.java:22676)</span><br><span class="line">  at com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpMgr</span>.dumpAnrDebugInfoLocked(SourceFile:1023)</span><br><span class="line">  at com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpMgr</span>.dumpAnrDebugInfo(SourceFile:881)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.appNotResponding(ActivityManagerService.java:6122)</span><br><span class="line">  - locked &lt;0x21c77912&gt; (a com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpRecord</span>)</span><br><span class="line">  at com.android.server.am.BroadcastQueue<span class="variable">$AppNotResponding</span>.run(BroadcastQueue.java:228)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:192)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:61)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:46)</span><br></pre></td></tr></table></figure></p><p>ActivityManager线程实际上运行着AMS的消息队列，这个函数调用栈的关键信息：</p><ul><li>线程状态为TimedWaiting, 这表示当前线程阻塞在一个超时的wait()方法</li><li>正在处理广播消息超时发生的ANR(Application Not Responding)，需要将当前的函数调用栈打印出来</li><li>最终在<0x264ff09d>等待，可以从AMS的源码 中找到这一处锁的源码，因为dumpStackTraces()会写文件，所以AMS设计了一个200毫秒的超时锁。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.wait(200);  // Wait <span class="keyword">for</span> write-close, give up after 200msec</span><br></pre></td></tr></table></figure></0x264ff09d></li></ul><p>还原问题的场景<br>从ActivityManager这个线程的调用栈，我们就会有一些疑惑：</p><ul><li>是哪个应用发生了ANR？为什么会发生ANR？</li><li>超时锁只用200毫秒就释放了，为什么会导致Watchdog检查超时？(AMS的Looper默认超时是1分钟)<br>带着这些疑惑，我们再回到日志中：</li></ul><p>从sys_log中，可以检索到Watchdog出现的时间点(17:10:51.548)之前，com.android.systemui发生了ANR，从而引发AMS打印函数调用栈:</p><blockquote><p>TIPS: 在sys_log中检索”ANR in”关键字或在event_log中检索”anr”关键字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10-14 17:10:04.215   892   938 E ANRManager: ANR <span class="keyword">in</span> com.android.systemui, time=27097912</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Load: 89.22 / 288.15 / 201.91</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Android time :[2015-10-14 17:10:04.14] [27280.396]</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: CPU usage from 17016ms to 0ms ago:</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   358% 23682/float_bessel: 358% user + 0% kernel</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   57% 23604/debuggerd64: 3.8% user + 53% kernel / faults: 11369 minor</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   2% 892/system_server: 0.9% user + 1% kernel / faults: 136 minor</span><br></pre></td></tr></table></figure></p></blockquote><p>从这个日志信息中，我们两个疑惑就释然了：</p><p>发生ANR之前的CPU负载远高于正常情况好几倍(Load： 89.22 / 288.15 / 201.91)，在这种CPU负载下，com.android.systemui进程发生处理广播消息超时(Reason: Broadcast of Intent)再正常不过了。 在这之前CPU都被float_bessel这个进程给占了，这货仅凭一己之力就耗了358%的CPU资源。</p><p>observer.wait(200)在调用后，便进入排队等待唤醒状态(Waiting)，在等待200毫秒后，便重新开始申请CPU资源，而此时，CPU资源一直被float_bessel占着没有释放，所以该线程一直在等CPU资源。 等了1分钟后，Watchdog跳出来说“不行，你已经等了1分钟了，handler处理其他消息了”。</p><p>在多核情况下，CPU的使用率统计会累加多个核的使用率，所以会出现超过100%的情况。那么float_bessel究竟是什么呢？它是一个Linux的测试样本，贝塞尔函数的计算，耗的就是CPU。</p><p>这样，该问题的场景我们就还原出来了：在压力测试的环境下，CPU被float_bessel运算占用，导致com.android.systemui进程发生ANR，从而引发AMS打印trace; 但由于AMS一直等不到CPU资源，Watchdog检测超时，杀掉system_server进程，系统重启。</p><p>对于压力测试而言，我们一般会设定一个通过标准，在某些压力情况下，出现一些错误是允许的。对于Android实际用户的使用场景而言，本例中的压力通常是不存在的，所以在实际项目中，这种类型的Watchdog问题，我们一般不解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android中Watchdog用来看护system_server进程，system_server进程运行着系统最终要的服务，譬如AMS、PKMS、WMS等， 当这些服务不能正常运转时，Watchdog可能会杀掉system_server，让系统重启。</p><p>Watchdog的实现利用了锁和消息队列机制。当system_server发生死锁或消息队列一直处于忙碌状态时，则认为系统已经没有响应了(System Not Responding)。</p><p>在分析Watchdog问题的时候，首先要有详尽的日志，其次要能定位出导致Watchdog超时的直接原因，最重要的是能还原出问题发生的场景。</p><!-- 可以用来注释，参与编译，在Html文档中会有这句话，但是不会显示 ^-^ --><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2" target="_blank" rel="noopener">Watchdog机制以及问题分析</a><br><a href="https://blog.csdn.net/fu_kevin0606/article/details/64479489" target="_blank" rel="noopener">Android7.0 Watchdog机制</a><br><a href="https://blog.csdn.net/xichangbao/article/details/76727425" target="_blank" rel="noopener">Android系统高通平台Kernel Watchdog</a><br><a href="https://blog.csdn.net/yangwen123/article/details/11264461" target="_blank" rel="noopener">Android软Watchdog源码分析</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java" target="_blank" rel="noopener">Watchdog.java</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;Watchdog的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Watchdog" scheme="http://yoursite.com/tags/Watchdog/"/>
    
  </entry>
  
  <entry>
    <title>Android中PackageManagerService相关的文件</title>
    <link href="http://yoursite.com/2018/05/31/Android%E4%B8%ADPackageManagerService%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/05/31/Android中PackageManagerService相关的文件/</id>
    <published>2018-05-31T14:55:56.000Z</published>
    <updated>2018-06-29T02:53:34.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="system-etc-sysconfig-目录下的文件"><a href="#system-etc-sysconfig-目录下的文件" class="headerlink" title="/system/etc/sysconfig 目录下的文件"></a>/system/etc/sysconfig 目录下的文件</h1><h2 id="framework-sysconfig-xml"><a href="#framework-sysconfig-xml" class="headerlink" title="framework-sysconfig.xml"></a>framework-sysconfig.xml</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!-- Copyright (C) 2017 The Android Open Source Project</span><br><span class="line"></span><br><span class="line">     Licensed under the Apache License, Version 2.0 (the <span class="string">"License"</span>);</span><br><span class="line">     you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">     You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">          http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">     Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">     distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line">     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">     See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">     limitations under the License.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- These are configurations that must exist on all Android devices. --&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Broadcast actions that are currently exempted from O+ background</span><br><span class="line">         delivery restrictions. --&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.SIM_STATE_CHANGED"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.PACKAGE_CHANGED"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.MEDIA_SCANNER_SCAN_FILE"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.media.action.OPEN_AUDIO_EFFECT_CONTROL_SESSION"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.media.action.CLOSE_AUDIO_EFFECT_CONTROL_SESSION"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Whitelist of what components are permitted as backup data transports.  The</span><br><span class="line">         <span class="string">'service'</span> attribute here is a flattened ComponentName string. --&gt;</span><br><span class="line">    &lt;backup-transport-whitelisted-service</span><br><span class="line">        service=<span class="string">"android/com.android.internal.backup.LocalTransportService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Whitelist of bundled applications <span class="built_in">which</span> all handle URLs to their websites by default --&gt;</span><br><span class="line">    &lt;app-link package=<span class="string">"com.android.carrierdefaultapp"</span> /&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><h2 id="QualCommon-platform-下的qti-whitelist-xml"><a href="#QualCommon-platform-下的qti-whitelist-xml" class="headerlink" title="QualCommon platform 下的qti_whitelist.xml"></a>QualCommon platform 下的qti_whitelist.xml</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> standalone=<span class="string">"yes"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">/* Copyright (c) 2017, The Linux Foundation. All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> * Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without</span><br><span class="line"> * modification, are permitted provided that the following conditions are</span><br><span class="line"> * met:</span><br><span class="line"> *     * Redistributions of <span class="built_in">source</span> code must retain the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer.</span><br><span class="line"> *     * Redistributions <span class="keyword">in</span> binary form must reproduce the above</span><br><span class="line"> *       copyright notice, this list of conditions and the following</span><br><span class="line"> *       disclaimer <span class="keyword">in</span> the documentation and/or other materials provided</span><br><span class="line"> *       with the distribution.</span><br><span class="line"> *     * Neither the name of The Linux Foundation nor the names of its</span><br><span class="line"> *       contributors may be used to endorse or promote products derived</span><br><span class="line"> *       from this software without specific prior written permission.</span><br><span class="line"> *</span><br><span class="line"> * THIS SOFTWARE IS PROVIDED <span class="string">"AS IS"</span> AND ANY EXPRESS OR IMPLIED</span><br><span class="line"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span><br><span class="line"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT</span><br><span class="line"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS</span><br><span class="line"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span><br><span class="line"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span><br><span class="line"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span><br><span class="line"> * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span><br><span class="line"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE</span><br><span class="line"> * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</span><br><span class="line"> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"> */</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;!-- These are telephony components that need to freely run <span class="keyword">in</span> the background --&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.atfwd"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.telephonyservice"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qulacomm.qcrilmsgtunnel"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.ims"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.radioconfiginterface"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.simcontacts"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.autoregistration"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.server.wigigapp"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.StatsPollManager"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.gsma.services.nfc"</span> /&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;system-etc-sysconfig-目录下的文件&quot;&gt;&lt;a href=&quot;#system-etc-sysconfig-目录下的文件&quot; class=&quot;headerlink&quot; title=&quot;/system/etc/sysconfig 目录下的文件&quot;&gt;&lt;/a&gt;/sys
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android PackageManagerService" scheme="http://yoursite.com/tags/Android-PackageManagerService/"/>
    
      <category term="File" scheme="http://yoursite.com/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Android中PackageManagerService机制分析</title>
    <link href="http://yoursite.com/2018/05/31/Android%E4%B8%ADPackageManagerService%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/05/31/Android中PackageManagerService机制分析/</id>
    <published>2018-05-31T14:13:56.000Z</published>
    <updated>2018-06-29T04:15:17.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>每一个社会群落都有管理机制，其中有三个要素：被管理者、管理者以及管理机制的运转。在Android的世界中，有一处群落叫“包管理”，要研究Android的包管理机制，同样可以从以下几个角度来思考：</p><ol><li>被管理的对象是什么？</li><li>管理者的职能是什么？</li><li>管理机制是如何运转的？<br>所谓包，其实就是一种文件格式，譬如APK包、JAR包等。在Android中存活着很多包，所有的应用程序都是APK包，很多构成Android运行环境的都是JAR包，还有一些以so为后缀的库文件，包管理者很重要的一个职能就是识别不同的包，统一维护这些包的信息。当有一个包进入或离开Android世界，都需要向包管理者申报，其他管理部门要获取包的具体信息，也都需要向包管理者申请。</li></ol><p>如同社会是由人与人的协作形成，不同的包之间也需要进行协作。既然有协作，自然就有协作的规范，一个包可以干什么，不可以干什么，都需要有一个明确的范围界定，这就是包管理中的权限设计。涉及到的内容非常广泛，Linux的UGO（User Group Other）和ACL（Access Control List，访问控制列表）权限管理、数字签名与验证、Android授权机制、Selinux，都是包管理中权限设计的组成部分。</p><p>Android的世界就如同一个井然有序的人类社会，除了包管理部门，还有其他各种管理部门，譬如电源管理、窗口管理、活动管理等等，大家不仅各司其职，而且也有交流往来。从APK的安装到Activity的显示这么一个看似简单的过程，却需要大量管理部门参与进来，不断地进行数据解析、封装、传递、呈现，内部机理十分复杂。</p><blockquote><p>PackageManagerService是包管理中最重要的服务，为了描述方便，本文会简写成PMS。<br>PMS的部分函数带有LI后缀，表示需要获取mInstalllock这个锁时才能执行；部分函数带有LP后缀，表示需要获取mPackages这个锁才能执行。</p></blockquote><p>PackageManagerService相关的代码路径如下：<br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/content/pm/" target="_blank" rel="noopener">frameworks/base/core/java/android/content/pm/</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/pm/" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/pm</a></p><h1 id="被管理对象的形态"><a href="#被管理对象的形态" class="headerlink" title="被管理对象的形态"></a>被管理对象的形态</h1><p>Android中的APK和JAR包都以静态文件的形式分布在不同的硬件分区，包管理者面临的第一个任务就是将这些静态的文件转化成内存的数据结构，这样才能将其管理起来。Android中最重要的包管理对象就是APK，APK可以包含so文件，负责将静态文件转换内存中数据结构的工具就是PackageParser，包解析器。<br><img src="http://duanqz.github.io/assets/images/packagemanager/1-packagemanager-package-from-static-to-dynamic.png" alt="PackageParser"></p><p>Android L(5.0)以后，支持APK拆分，即一个APK可以分割成很多部分，位于相同的目录下，每一个部分都是一个单独的APK文件，所有的APK文件具备相同的签名，在APK解析过程中，会将拆分的APK重新组合成内存中的一个Package。对于一个完整的APK，Android称其为Monolithic；对于拆分后的APK，Android称其为Cluster。</p><blockquote><p>在Android L(5.0)以前，APK文件都是直接位于app或priv-app目录下，譬如短彩信APK的目录就是/system/priv-app/Mms.apk；到了Android L(5.0)之后，多了一级目录结构，譬如短彩信APK的目录是/system/priv-app/Mms/Mms.apk，这是Android为了支持APK拆分而做的改动，如果要将短彩信APK进行拆分，那所有被拆出来的APK都位于/system/priv-app/Mms/即可，这样在包解析时，就会变成以Cluster的方式解析目录。</p></blockquote><p>一个包在内存中的数据结构就是Package，那么，Package有一些什么属性?是怎么从APK文件中获取数据的呢？ 这就涉及到包解析器的工作原理。</p><h1 id="包解析器"><a href="#包解析器" class="headerlink" title="包解析器"></a>包解析器</h1><p>为了先让读者对被管理对象有一个初步的认识，我们先把一个包最终在内存中的数据结构拎出来。其实生成这个数据结构，需要包管理者进行大量的调度工作，调度中心是PMS，包解析的过程也都是由PMS驱动的。在分析包解析过程之前，我们先上包解析的结果：<br><img src="http://duanqz.github.io/assets/images/packagemanager/2-packagemanager-packageparser.png" alt="包解析结果"><br>这个类图，示意了一个包最终在内存中的数据结构Package，它包含很多属性，部分属性还是包解析器中的子数据结构。我们可以从设计的角度来理解这个类图：</p><ul><li><p>一个包中有很多组件，为此设计了一个高层的基类Component，所有具体的组件都是Component的子类。什么是组件呢？AndroidManifest.xml文件中所定义的的一些标签，就是组件，譬如<activity>，<service>，<provider>，<permission>等，这些标签分别对应到包解析器中的一个数据结构，它们各自有自身的属性。</permission></provider></service></activity></p></li><li><p>诸如<activity>，<service>标签，都可以配置<intent-filter>，来过滤其可以接收的Intent，这些信息也需要在包解析器中体现出来，为此组件Component依赖于IntentInfo这个数据结构。每一个具体的组件所依赖的IntentInfo不同，所以Component和IntentInfo之间的依赖关系采用了桥接(Bridge)这种设计模式，通过泛型的手段实现。</intent-filter></service></activity></p></li><li><p>各种组件最终聚合到Package这个数据结构中，形成了最终包解析器的输出。当然，在解析的过程中，还有利用了一些数据结构来优化设计，PackageLite和ApkLite就是一些很简单的数据封装。</p></li></ul><p>要得到以上的数据结构，包解析器<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/content/pm/PackageParser.java" target="_blank" rel="noopener">PackageParser</a>功不可没，从接收一个静态的文件(File类型)开始，会经过一个漫长的包解析过程，直到生成最终的Package：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parsePackages(File file...)</span><br><span class="line">└── parseClusterPackage(File packageDir...)</span><br><span class="line">    └── parseClusterPackageLite(File packageDir...)</span><br><span class="line">    |   └── parseApkLite(File apkFile...)</span><br><span class="line">    |       └── parseApkLite(String codePath...)</span><br><span class="line">    └── parseBaseApk()</span><br><span class="line">        └── parseBaseApplication()</span><br><span class="line">        |    └── parseActivity()</span><br><span class="line">        |    └── parseService()</span><br><span class="line">        |    └── ...</span><br><span class="line">        └── parseInstrumentation()</span><br><span class="line">        └── ...</span><br></pre></td></tr></table></figure></p><p>这些函数的具体逻辑本文不予分析，仅把关键的流程捋出来:</p><ol><li><p>PackageParser.parsePackages()是包解析器的入口函数，它首先会判定给定的输入是否为一个目录，如果是目录，则以为着目录下可能存在多个拆分后的APK，这就需要以Cluster的方式进行解析；如果仅仅是一个APK文件，就以Monolithic的方式解析；</p></li><li><p>解析APK，需要先得到一个中间数据结构PacakgeLite，包名、版本、拆分包等信息都会保存在这个数据结构中；由于一个包可能有多个拆分的APK，所以PackageLite可能关联到多个APK，每一个APK都对应到ApkLite这个数据结构，也是一些基本信息的封装。之所以以Lite为后缀命名，是因为这两个数据结构都比较轻量，只保存APK中很少信息；</p></li><li><p>一个APK真正的信息都写在AndroidManifest.xml这个文件中，PackageParser.parseBaseApk()这个函数就是用来解析该文件。其解析过程与AndroidManifest.xml的文件结构一一对应，譬如先解析<application>标签的内容，然后解析其下的<activity>,<service>等标签。由于AndroidManifest.xml文件的结构非常复杂，所以该函数逻辑也非常庞大，读者们可以自行分析源码。<br>至此，包解析器PackageParser就将一个静态的文件，转换成了内存中的数据结构Package，它包含了一个包的所有信息，如包名、包路径、权限、四大组件等，其数据来源主要就是AndroidManifest.xml文件。</service></activity></application></p></li></ol><h1 id="包信息体"><a href="#包信息体" class="headerlink" title="包信息体"></a>包信息体</h1><p>包解析器从静态文件中获取的数据，很多都是需要用于跨进程传递的，譬如初次启动Activity时，就需要把包信息从系统进程传递到应用进程，先完成应用进程的启动。在包解析器的类图中，我们看到Activity、Service、Provider、Permission、Instrumentaion这些类都有一个共同的特征：都具备info这个属性，其实这些类的结构非常简单，就是对info的一次封装，info这个结构体才是真正的包数据，笔者暂且称之为“包信息体”:<br><img src="http://duanqz.github.io/assets/images/packagemanager/3-packagemanager-packageparser-parcelable.png" alt="包信息体"><br>所有的info都实现了Parcelable接口，意图很明显，info是可以进行跨进程传递的。不同组件的info类型是不同的，除了实现了Parcelable接口，它们之间又构成了一个庞大的数据结构，把这些具体的info类型展开，就是以下的类图：<br><img src="http://duanqz.github.io/assets/images/packagemanager/4-packagemanager-packageparser-parcelable.png" alt="Info展开图"><br>可以看到，这个类图与PackageParser中的类图在结构上很相似，我们依旧是从设计的角度来理解这个类图：</p><ul><li>PackageItemInfo作为包每一项信息的高层基类：<ul><li>针对permission，permission，instrumentation等，分别为其设计了一个类，都继承自PackageItemInfo</li><li>针对activity，service，provider等四大组件，在PackageItemInfo之下又多设计了一层：ComponentInfo作为四大组件的基类</li></ul></li><li>ApplicationInfo也是包信息中的一项，但与四大组件紧密相连，四大组件肯定都属于某个Application，所以ComponentInfo与Application存在依赖关系，继而，具体到每个组件都与Application存在依赖关系</li><li>所有的包信息都聚合到PackageInfo这个类中，PackageInfo就是一个包向外提供的所有信息。其实除了上图列出来的类，还有一些类没有示意出来，譬如ConfigurationInfo，FeatureInfo，它们都可以对应到AndroidManifest.xml中的标签。<br>这些结构体中的数据，都是在包解析器时初始化的，譬如Activity依赖于ActivityInfo，在解析Activity时，就会创建一个ActivityInfo对象，把<activity>所定义的数据全都填充到ActivityInfo中。读者可以思考一下PackageParser中的Activity与此处的ActivityInfo的分开设计的目的和好处是什么？<blockquote><p>在分析包的形态时，我们见到了很多类，类的命名方式还有点相似，初读代码的时候，很容易陷入各个类之间复杂的关系网之中。不得不说，包在内存中的数据结构是比较庞大的，因为它蕴含的信息大多了。</p></blockquote></activity></li></ul><h1 id="PMS的启动过程"><a href="#PMS的启动过程" class="headerlink" title="PMS的启动过程"></a>PMS的启动过程</h1><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/pm/PackageManagerService.java" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</a></p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><h3 id="PMS部分属性初始化"><a href="#PMS部分属性初始化" class="headerlink" title="PMS部分属性初始化"></a>PMS部分属性初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段1：PMS部分属性的初始化</span><br><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    // 关键的Event日志，PMS开始启动了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mContext = context;</span><br><span class="line">    mFactoryTest = factoryTest;</span><br><span class="line">    mOnlyCore = onlyCore;</span><br><span class="line">    // 如果是eng版，则延迟做DexOpt</span><br><span class="line">    mLazyDexOpt = <span class="string">"eng"</span>.equals(SystemProperties.get(<span class="string">"ro.build.type"</span>));</span><br><span class="line">    mMetrics = new DisplayMetrics();</span><br><span class="line">    // Settings是包管理中一个很重要的数据结构，用于维护所有包的信息</span><br><span class="line">    mSettings = new Settings(mPackages);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>, Process.SYSTEM_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.phone"</span>, RADIO_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.log"</span>, LOG_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.nfc"</span>, NFC_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.bluetooth"</span>, BLUETOOTH_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.shell"</span>, SHELL_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"></span><br><span class="line">    long dexOptLRUThresholdInMinutes;</span><br><span class="line">    <span class="keyword">if</span> (mLazyDexOpt) &#123;</span><br><span class="line">        dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps <span class="keyword">for</span> eng builds.</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used <span class="keyword">in</span> the 7 days <span class="keyword">for</span> users.</span><br><span class="line">    &#125;</span><br><span class="line">    mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;</span><br><span class="line">    ...</span><br><span class="line">    mInstaller = installer;</span><br><span class="line">    // DexOpt工具类</span><br><span class="line">    mPackageDexOptimizer = new PackageDexOptimizer(this);</span><br><span class="line">    mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line">    mOnPermissionChangeListeners = new OnPermissionChangeListeners(</span><br><span class="line">                FgThread.get().getLooper());</span><br><span class="line">    getDefaultDisplayMetrics(context, mMetrics);</span><br><span class="line">    // 读取系统默认的权限</span><br><span class="line">    SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">    mGlobalGids = systemConfig.getGlobalGids();</span><br><span class="line">    mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line">    mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line"></span><br><span class="line">    // 这里上了两把锁: mInstallLock是安装APK时需要用到的锁；mPackage是更新APK信息时需要的锁</span><br><span class="line">    synchronized (mInstallLock) &#123;</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        // 构建一个后台线程，并将线程的消息队列绑定到Handler</span><br><span class="line">        mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">                Process.THREAD_PRIORITY_BACKGROUND, <span class="literal">true</span> /*allowIo*/);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        mHandler = new PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">        // 将PMS加入Watchdog的监控列表</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        // 初始化一些文件目录</span><br><span class="line">        File dataDir = Environment.getDataDirectory();</span><br><span class="line">        mAppDataDir = new File(dataDir, <span class="string">"data"</span>);</span><br><span class="line">        mAppInstallDir = new File(dataDir, <span class="string">"app"</span>);</span><br><span class="line">        mAppLib32InstallDir = new File(dataDir, <span class="string">"app-lib"</span>);</span><br><span class="line">        mAsecInternalPath = new File(dataDir, <span class="string">"app-asec"</span>).getPath();</span><br><span class="line">        mUserAppDataDir = new File(dataDir, <span class="string">"user"</span>);</span><br><span class="line">        mDrmAppPrivateInstallDir = new File(dataDir, <span class="string">"app-private"</span>);</span><br><span class="line"></span><br><span class="line">        // 初始化系统权限</span><br><span class="line">        ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</span><br><span class="line">                = systemConfig.getPermissions();</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;permConfig.size(); i++) &#123;</span><br><span class="line">            SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</span><br><span class="line">            BasePermission bp = mSettings.mPermissions.get(perm.name);</span><br><span class="line">            <span class="keyword">if</span> (bp == null) &#123;</span><br><span class="line">                bp = new BasePermission(perm.name, <span class="string">"android"</span>, BasePermission.TYPE_BUILTIN);</span><br><span class="line">                mSettings.mPermissions.put(perm.name, bp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (perm.gids != null) &#123;</span><br><span class="line">                bp.setGids(perm.gids, perm.perUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 初始化PMS中的ShareLibraries</span><br><span class="line">        ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;libConfig.size(); i++) &#123;</span><br><span class="line">            mSharedLibraries.put(libConfig.keyAt(i),</span><br><span class="line">                    new SharedLibraryEntry(libConfig.valueAt(i), null));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 读取mac_permission.xml文件的内容</span><br><span class="line">        mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</span><br><span class="line"></span><br><span class="line">        mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(<span class="literal">false</span>),</span><br><span class="line">                mSdkVersion, mOnlyCore);</span><br><span class="line">        String customResolverActivity = Resources.getSystem().getString(</span><br><span class="line">                        R.string.config_customResolverActivity);</span><br><span class="line"></span><br><span class="line">// 未完接代码片段2</span><br></pre></td></tr></table></figure><p>【代码片段1】完成了很多PMS的属性初始化操作，几个重要的属性如下：</p><ul><li><p><strong>mSettings：</strong>PMS内部有一个Settings数据结构，用于维护所有包的信息。写过Android应用程序的朋友可能知道两个APK可以运行在相同的进程中，前提是两个APK具有相同的签名和ShareUid。Android系统中定义了一些默认的ShareUid，譬如android.uid.system表示系统进程的UID，如果有一个APK想要运行在系统进程中，则其需要在AndroidManifest.xml文件中声明ShareUid为android.uid.system，并且该APK的签名必须与framework-res.apk的签名一致，即platform签名。</p><p>PMS在创建完Settings对象之后，便把很多系统默认的ShareUid加入其中。</p></li><li><p><strong>mInstaller：</strong>Installer是一个系统服务，它封装了很多PMS进行包管理需要用到的函数，譬如install()、 dexopt()、rename()等。在Installer内部，其实是通过Socket连接installd，将执行指令发送到installd完成具体的操作。</p></li><li><p><strong>mPackageDexOptimizer:</strong> 进行Dex优化的工具类。对于一个APK而言，编译后其APK包中可执行文件的格式dex，安装到了手机上以后，需要经过文件格式转化才能运行，譬如APK需要转换成oat格式才能在ART虚拟机上运行，文件格式转换的过程就叫DexOpt。</p><p>DalvikVM的时代，Android可执行文件的格式是dex，有一种进一步优化的格式叫odex；ART虚拟机的时代，Android可执行文件的格式是oat。虽然都叫做DexOpt，但在DalvikVM和ART两种不同虚拟机的时代分别有不同的内涵。</p></li><li><p><strong>SystemConfig:</strong> 系统全局的配置信息的数据结构。原始的数据来源于/system/etc/sysconfig和/system/etc/permissions目录下的XML文件,XML文件的详细信息见 Android中PackageManagerService相关的文件 这篇文章，在SystemConfig对象构建时，会读取这两个目录下所有XML文件的内容，主要有以下几个维度：</p><ul><li><p>权限与GID的映射关系，譬如，以下内容表示属于inet这个组的用户都拥有android.permission.INTERNET权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission name=<span class="string">"android.permission.INTERNET"</span> &gt;</span><br><span class="line">  &lt;group git=<span class="string">"inet"</span>&gt;</span><br><span class="line">&lt;/permission&gt;</span><br></pre></td></tr></table></figure></li><li><p>权限与UID的映射关系，譬如，以下内容表示UID为meida用户拥有android.permission.CAMERA这个权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;assign-permission name=<span class="string">"android.permission.CAMERA"</span> uid=<span class="string">"media"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>公共库的定义。Android中有很多公共库，除了BOOTCLASSPATH中定义的，框架层还支持额外的扩展，譬如，以下内容表示公共库的包名和其路径的关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;library name=<span class="string">"android.test.runner"</span></span><br><span class="line">       file=<span class="string">"/system/framework/android.test.runner.jar"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mHandler：</strong> 创建PackageHandler对象，将其绑定到一个后台线程的消息队列。可想而知，一些厚重的活，譬如安装APK，就交由这个后台线程完成了。由于PMS是一个重要的系统服务，这个后台线程的消息队列如果过于忙碌，则会导致系统一直卡住，所以需要将这个消息队列加入Watchdog的监控列表，以便在这种情况下，Watchdog可以做出一些应急操作。</p></li><li><p><strong>初始化一些/data文件目录：</strong>应用程序的安装和运行都需要用到Data分区，PMS会在Data分区新建一些子目录。</p></li><li><p><strong>初始化系统权限：</strong>在SystemConfig初始化的时候，从/system/etc/permissions和/system/etc/sysconfig目录下读取了XML文件，这些信息要添加到Settings这个数据结构中。Android设计了一个BasePermission的数据结构，主要用于保存权限与包名之间的映射关系，此处，添加的权限是从SystemConfig中取出，包名是android，也就是先将系统权限添加到Settings中。</p></li><li><p><strong>mFoundPolicyFile:</strong> 有了SeLinux以后，Android会为每个文件打上SE Label，对于APK而言，打SE Label的准则就是签名，即根据签名信息打上不同的SE Label。Android将签名分类成为platform，testkey, media等，签名与类别的映射关系就存在一个叫mac_permission.xml的文件中。此处，需要读取该文件的内容。</p></li></ul><h3 id="PMS-系统文件Dexopt扫描"><a href="#PMS-系统文件Dexopt扫描" class="headerlink" title="PMS 系统文件Dexopt扫描"></a>PMS 系统文件Dexopt扫描</h3><p>在完成部分属性的初始化之后，PMS要进入扫描安装阶段了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">//代码片段2：DexOpt处理，扫描系统文件</span><br><span class="line">    // 关键日志，开始扫描系统APP</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">            startTime);</span><br><span class="line"></span><br><span class="line">    // 设置扫描参数</span><br><span class="line">    final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line">    // 1. 构建数组变量用于保存已经做过DexOpt的文件，后文中，会往这个数组变量中添加元素</span><br><span class="line">    final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();</span><br><span class="line">    final String bootClassPath = System.getenv(<span class="string">"BOOTCLASSPATH"</span>);</span><br><span class="line">    final String systemServerClassPath = System.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line"></span><br><span class="line">    // BOOTCLASSPATH环境变量所定义的文件已经做过DexOpt</span><br><span class="line">    <span class="keyword">if</span> (bootClassPath != null) &#123;</span><br><span class="line">        String[] bootClassPathElements = splitString(bootClassPath, <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : bootClassPathElements) &#123;</span><br><span class="line">            alreadyDexOpted.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // SYSTEMSERVERCLASSPATH环境变量所定义的文件已经做过了DexOpt</span><br><span class="line">    <span class="keyword">if</span> (systemServerClassPath != null) &#123;</span><br><span class="line">        String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : systemServerClassPathElements) &#123;</span><br><span class="line">            alreadyDexOpted.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取指令集，以便后续进行DexOpt</span><br><span class="line">    final List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</span><br><span class="line">    final String[] dexCodeInstructionSets =</span><br><span class="line">            getDexCodeInstructionSets(</span><br><span class="line">                        allInstructionSets.toArray(new String[allInstructionSets.size()]));</span><br><span class="line"></span><br><span class="line">    // 公共库是定义在 etc/sysconfig 和 etc/permissions 文件夹下的XML文件中</span><br><span class="line">    // 需要这些公共库进行DexOpt处理</span><br><span class="line">    <span class="keyword">if</span> (mSharedLibraries.size() &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</span><br><span class="line">                final String lib = libEntry.path;</span><br><span class="line">                <span class="keyword">if</span> (lib == null) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                        alreadyDexOpted.add(lib);</span><br><span class="line">                        mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class="literal">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File frameworkDir = new File(Environment.getRootDirectory(), <span class="string">"framework"</span>);</span><br><span class="line">    alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/framework-res.apk"</span>);</span><br><span class="line">    alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/core-libart.jar"</span>);</span><br><span class="line"></span><br><span class="line">    // system/framework目录下，除了framework-res.apk和core-libart.jar这两个文件外</span><br><span class="line">    // 其他的APK和JAR文件都需要进行DexOpt处理</span><br><span class="line">    String[] frameworkFiles = frameworkDir.list();</span><br><span class="line">    <span class="keyword">if</span> (frameworkFiles != null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i=0; i&lt;frameworkFiles.length; i++) &#123;</span><br><span class="line">                File libPath = new File(frameworkDir, frameworkFiles[i]);</span><br><span class="line">                String path = libPath.getPath();</span><br><span class="line">                <span class="keyword">if</span> (alreadyDexOpted.contains(path)) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!path.endsWith(<span class="string">".apk"</span>) &amp;&amp; !path.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                        mInstaller.dexopt(path, Process.SYSTEM_UID, <span class="literal">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. Android M的APK授权机制有了变化，此处是与授权相关的版本兼容处理</span><br><span class="line">    final VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">    mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line">    mPromoteSystemApps =</span><br><span class="line">            mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line">    <span class="keyword">if</span> (mPromoteSystemApps) &#123;</span><br><span class="line">        Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">            <span class="keyword">if</span> (isSystemApp(ps)) &#123;</span><br><span class="line">                mExistingSystemPackages.add(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 扫描系统文件</span><br><span class="line">    File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);</span><br><span class="line">    // 扫描 /vendor/overlay 目录下的文件</span><br><span class="line">    scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);</span><br><span class="line">    // 扫描 /system/framework 目录下的文件</span><br><span class="line">    scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">            | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line">            scanFlags | SCAN_NO_DEX, 0);</span><br><span class="line">    // 扫描 /system/priv-app 目录下的文件</span><br><span class="line">    final File privilegedAppDir = new File(Environment.getRootDirectory(), <span class="string">"priv-app"</span>);</span><br><span class="line">    scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">            | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);</span><br><span class="line">    // 扫描 /system/app 目录下的文件</span><br><span class="line">    final File systemAppDir = new File(Environment.getRootDirectory(), <span class="string">"app"</span>);</span><br><span class="line">    scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    // 扫描 /vendor/app 目录下的文件</span><br><span class="line">    File vendorAppDir = new File(<span class="string">"/vendor/app"</span>);</span><br><span class="line">    try &#123;</span><br><span class="line">        vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">    &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">    scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    // 扫描 /oem/app 目录下的文件</span><br><span class="line">    final File oemAppDir = new File(Environment.getOemDirectory(), <span class="string">"app"</span>);</span><br><span class="line">    scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    mInstaller.moveFiles();</span><br><span class="line"></span><br><span class="line">    // 4. 对扫描到的系统文件善后处理</span><br><span class="line">    final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = psit.next();</span><br><span class="line">            <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            final PackageParser.Package scannedPkg = mPackages.get(ps.name);</span><br><span class="line">            <span class="keyword">if</span> (scannedPkg != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                    removePackageLI(ps, <span class="literal">true</span>);</span><br><span class="line">                    mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                psit.remove();</span><br><span class="line">                removeDataDirsLI(null, ps.name);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">                <span class="keyword">if</span> (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123;</span><br><span class="line">                    possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; deletePkgsList.size(); i++) &#123;</span><br><span class="line">        cleanupInstallFailedPackage(deletePkgsList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    deleteTempPackageFiles();</span><br><span class="line">    mSettings.pruneSharedUsersLPw();</span><br><span class="line">// 未完接代码片段3</span><br></pre></td></tr></table></figure></p><p>【代码片段2】的主体逻辑如下：</p><ol><li><p>通过不断往alreadyDexOpted数组中填充元素，来略过不需要做DexOpt的文件：BOOTCLASSPATH和SYSTEMSERVERPATH这两个环境变量中定义的文件、system/framework-res.apk、system/core-libart.jar。除略过的文件外，其他APK和JAR文件都是需要做DexOpt处理的，通过调用Installer.dexopt()函数完成，这个函数只是将dexopt命令发送给installd。</p></li><li><p>由于Android M的APK授权机制发生了变化，在扫描系统文件之前，做了一些简单的记录，以便后续的授权处理：</p><blockquote><p>mIsUpgrade：如果当前版本的指纹与历史版本的指纹信息不一致，表示当前版本是一次OTA升级上来更新版本<br>mPromoteSystemApps：如果历史版本是Android M之前的版本(ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1)，当前又有版本升级，则需要用一个布尔变量，表示当前需要对系统应用的授权做特殊处理，此时会先把已有的系统应用都保存在mExistingSystemPackages这个数组中</p></blockquote></li><li><p>扫描系统文件，PMS中所有的文件扫描都是调用scanDirLI()函数，扫描系统文件重要的参数就是 PackageParser.PARSE_IS_SYSTEM和PackageParser.PARSE_IS_SYSTEM_DIR，在后文中我们会剖析这个函数。此处，需要注意的是被扫描目录的顺序，这个顺序意味着：先被扫描到的文件，就是最终被用到的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vendor/overlay &gt;&gt; /system/framework &gt;&gt; /system/priv-app &gt;&gt; /system/app &gt;&gt; /vendor/app &gt;&gt; /oem/app</span><br></pre></td></tr></table></figure></li><li><p>possiblyDeletedUpdatedSystemApps这个变量表示“可能被删除的系统APP”，这是一个什么概念呢？除了 possiblyDeletedUpdatedSystemApps ，还有mExpectingBetter，表示当前这个APK有更好的选择，这又是什么概念呢？对于一个系统APP而言，在一次OTA升级的过程中，有三种可能：</p><ul><li>保持原状。即这个系统APP没有任何更新。</li><li>更新版本。即新的OTA版本中，这个系统APP有更新。<br>-不复存在。在新的OTA版本中已经删除了这个系统APP。<br>当系统APP升级过后，PMS的Settings中会将原来的系统APP标识为Disable状态，这时候通过Settings.isDisabledSystemPackageLPr()函数调用便返回了false。因此，如果系统APP有更新版本，则属于mExpectingBetter这一类，接下来会扫描Data分区的文件，更新的系统APP就安装在Data分区。</li></ul></li></ol><p>如果一个系统APP不复存在，而且也没有被标记为Disable状态，说明这个系统APP已经彻底不存在了，需要把其在Data分区下的数据删除；如果不复存在的系统APP被标记为Disable状态，那还不能确定该系统APP是否已经被删除，因为还没有扫描Data分区的文件，所以，只能暂时将其放到possiblyDeletedUpdatedSystemApps变量中，表示“可能被删除”，在扫描Data分区之前，这是不能确定的。</p><h3 id="PMS-Data分区扫描"><a href="#PMS-Data分区扫描" class="headerlink" title="PMS Data分区扫描"></a>PMS Data分区扫描</h3><p>扫描完系统文件之后，接下来会扫描Data分区的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段3：扫描Data分区文件，更新公共库信息</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        // 关键日志，PMS对Data分区的文件扫描开始了</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">        // 1. 扫描Data分区的文件目录</span><br><span class="line">        scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">        scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</span><br><span class="line">                scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">        // 2. 扫描完Data分区后，处理“可能被删除的系统应用”</span><br><span class="line">        <span class="keyword">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</span><br><span class="line">            PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</span><br><span class="line">            mSettings.removeDisabledSystemPackageLPw(deletedAppName);</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (deletedPkg == null) &#123;</span><br><span class="line">                removeDataDirsLI(null, deletedAppName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">               PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</span><br><span class="line">               deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 处理有版本更新的系统应用</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">            final String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">                final File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line">                final int reparseFlags;</span><br><span class="line">                // 设置重新扫描的解析参数</span><br><span class="line">                <span class="keyword">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</span><br><span class="line">                    reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">                            | PackageParser.PARSE_IS_PRIVILEGED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">                // 将原来的系统应用重新置为Enable状态</span><br><span class="line">                mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line">                try &#123;</span><br><span class="line">                    scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);</span><br><span class="line">                &#125; catch (PackageManagerException e) &#123; ... &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // end of <span class="string">"if (!mOnlyCore)"</span></span><br><span class="line">    mExpectingBetter.clear();</span><br><span class="line"></span><br><span class="line">    // 4. 处理公共库</span><br><span class="line">    updateAllSharedLibrariesLPw();</span><br><span class="line">    <span class="keyword">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">         adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,</span><br><span class="line">                 <span class="literal">false</span> /* force dexopt */, <span class="literal">false</span> /* defer dexopt */);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPackageUsage.readLP();</span><br><span class="line">    // 关键日志，PMS扫描结束了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">// 未完接代码片段4</span><br></pre></td></tr></table></figure></p><p>Data分区文件的扫描都被mOnlyCore这个布尔变量笼罩，当其为true时，表示只需要扫描系统文件；当其为false时，才会扫描Data分区文件。【代码片段3】的主体逻辑如下：</p><ol><li><p>调用PMS.scanDirLI()函数扫描 /data/app 和 /data/app-private两个目录的文件。后文会详细剖析该函数。</p></li><li><p>扫描完Data分区的文件后，需要对之前系统文件的余孽做一些处理，第一类是possiblyDeletedUpdatedSystemApps，因为在扫描Data分区文件之前，不能确定系统应用有没有被彻底删除，如果在Data分区也无法找到了不复存在的系统应用，则需要彻底删除该系统应用；如果在Data分区找到了不复存在的系统应用，则需要去除其系统应用的标识。</p></li><li><p>另外一类系统应用的余孽是mExpectingBetter，表示系统应用已经升级过。如果在Data分区无法找到这些升级过的系统应用，那很可能是用户在OTA升级时，清除了Data分区的数据，对于这种场景，需要重新扫描一下该应用原来位于系统分区的文件。</p></li><li><p>SystemConfig中定义了公共库，在APK的AndroidManifest.xml文件中，会通过<use-library>标签标记该APK动态依赖的公共库，此处的逻辑就是将APK与SystemConfig中的公共库关联起来。如果APK使用的公共库并不存在，则会抛出异常(INSTALL_FAILED_MISSING_SHARED_LIBRARY)。</use-library></p></li></ol><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段4：收尾工作</span><br><span class="line">    // 授权</span><br><span class="line">    int updateFlags = UPDATE_PERMISSIONS_ALL;</span><br><span class="line">    <span class="keyword">if</span> (ver.sdkVersion != mSdkVersion) &#123;</span><br><span class="line">        updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</span><br><span class="line">    &#125;</span><br><span class="line">    updatePermissionsLPw(null, null, updateFlags);</span><br><span class="line">    ver.sdkVersion = mSdkVersion;</span><br><span class="line"></span><br><span class="line">    // 多用户场景下的版本兼容处理</span><br><span class="line">    <span class="keyword">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (UserInfo user : sUserManager.getUsers(<span class="literal">true</span>)) &#123;</span><br><span class="line">            mSettings.applyDefaultPreferredAppsLPw(this, user.id);</span><br><span class="line">            applyFactoryDefaultBrowserLPw(user.id);</span><br><span class="line">            primeDomainVerificationsLPw(user.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果是升级新版本，则需要清除已有的Code cache目录</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">            final PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">                deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">    &#125;</span><br><span class="line">    checkDefaultBrowser();</span><br><span class="line">    mExistingSystemPackages.clear();</span><br><span class="line">    mPromoteSystemApps = <span class="literal">false</span>;</span><br><span class="line">    ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line"></span><br><span class="line">    // 关键日志，PMS已经启动完毕了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mRequiredVerifierPackage = getRequiredVerifierLPr();</span><br><span class="line">    mRequiredInstallerPackage = getRequiredInstallerLPr();</span><br><span class="line">    // 初始化包安装服务</span><br><span class="line">    mInstallerService = new PackageInstallerService(context, this);</span><br><span class="line">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</span><br><span class="line">    mIntentFilterVerifier = new IntentVerifierProxy(mContext,</span><br><span class="line">            mIntentFilterVerifierComponent);</span><br><span class="line">    &#125; // synchronized (mPackages)</span><br><span class="line">    &#125; // synchronized (mInstallLock)</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());</span><br><span class="line">&#125; // PMS构造函数完结</span><br></pre></td></tr></table></figure><p>【代码片段4】主要进行一些收尾工作，有几个关键点：</p><ul><li>授权，通过调用PMS.updatePermissionsLPw()函数，后文会详细分析</li><li>版本兼容处理，Android M引入了多用户，需要更新每个APK关联到的userid</li><li>将PMS的Settings信息写入/system/packages.xml文件中，Settings是PMS中所有包信息的汇总的数据结构，PMS对包的管理极其依赖于这个数据结构。</li><li>初始化包安装服务PackageInstallerService。<br>至此，PMS对象的构建过程已经分析完毕，整个逻辑还是较为清晰的，但其实这是一个非常耗时的过程，开机时间大部分都耗在文件扫描上。</li></ul><h2 id="文件扫描"><a href="#文件扫描" class="headerlink" title="文件扫描"></a>文件扫描</h2><p>scanDirLI()只是文件扫描的起点，由此引发出一串的与文件扫描相关的函数。<br><img src="http://duanqz.github.io/assets/images/packagemanager/5-packagemanager-scan-seq.png" alt="文件扫描"><br>接下来，笔者会按照调用时序，对关键函数进行分析。PMS对象构建时，待扫描的目录有很多，不同目录的文件扫描，只是在扫描参数上略有区别，整体逻辑上并无不同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123;</span><br><span class="line">    final File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        final boolean isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</span><br><span class="line">                    scanFlags, currentTime, null);</span><br><span class="line">        &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;</span><br><span class="line">                    e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">                // 如果扫描Data分区的APK失败，则删除Data分区扫描失败的文件</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    mInstaller.rmPackageDir(file.getAbsolutePath());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://duanqz.github.io/2017-01-04-Package-Manage-Mechanism#1-%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">Android包管理机制</a><br><a href="https://blog.csdn.net/linliang815/article/details/76640262" target="_blank" rel="noopener">Android 包管理（PackageManagerService）</a><br><a href="https://blog.csdn.net/innost/article/details/47253179" target="_blank" rel="noopener">第4章  深入理解PackageManagerService</a><br><a href="http://wiki.jikexueyuan.com/project/deep-android-v2/packagemanagerservice.html" target="_blank" rel="noopener">深入理解 PackageManagerService</a><br><a href="https://blog.csdn.net/gaugamela/article/details/52619720" target="_blank" rel="noopener">Android7.0 PackageManagerService (1) 通信结构、启动和main函数</a><br><a href="https://www.cnblogs.com/chenlong-50954265/p/5729553.html" target="_blank" rel="noopener">Android PackageManagerService详细分析</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/75129690" target="_blank" rel="noopener">Android8.0 PackageManagerService相关 – APK安装和install 的变更和源码浅析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;每一个社会群落都有管理机制，其中有三个要素：被管理者、管理者以及管理机制的运转。在Android的世界中，有一处群落叫“包管理”，要研究An
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android PackageManagerService" scheme="http://yoursite.com/tags/Android-PackageManagerService/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 配置 OpenGork 服务</title>
    <link href="http://yoursite.com/2018/05/31/year-06-23-Ubuntu-%E9%85%8D%E7%BD%AE-OpenGork-%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/05/31/year-06-23-Ubuntu-配置-OpenGork-服务/</id>
    <published>2018-05-31T09:38:08.000Z</published>
    <updated>2018-07-01T11:48:33.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenGork的配置"><a href="#OpenGork的配置" class="headerlink" title="OpenGork的配置"></a>OpenGork的配置</h1><p>OpenGork的好处，这里不做介绍了，可以参考<a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24369747</a><br>OpenGork是用Java实现的，源码见 <a href="https://github.com/oracle/opengrok/" target="_blank" rel="noopener">https://github.com/oracle/opengrok/</a><br>OpenGork官网：<a href="http://oracle.github.io/opengrok/" target="_blank" rel="noopener">http://oracle.github.io/opengrok/</a><br>OpenGork下载地址：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a> 这里可以下载编译好的文件，或者下载源码</p><p>配置OpenGork之前需要一些其他的环境：  </p><ol><li>Java环境：JDK 以及配置好环境变量<br>—如何实现请自行查找  </li><li>Tomcat 服务：需要下载Tomcat服务<br>下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a><br><strong>注意一：Tomcat7.0版本和JDK1.8版本无法兼容</strong>  </li><li>OpenGork：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a>  </li><li>遗漏了ctags，如果这个工具没有安装和在Opengork里面配置的话，就算Tomcat和Opengork都配置好了，且都能正常运行，还是无法进行搜索，而且Opengork网站里面也无法打开文件。根本原因是ctags 就是用来建立索引的工具，没了它，后面的搜索就无从说起。<br>Ubuntu 安装ctags命令:sudo apt-get install ctags<br>Ubuntu自带了exuberant ctags,在后面的OpenGork的配置文件中，需要FindExuberanCtags()函数的binary中需要填写为binay=”exuberant ctags”</li></ol><p><strong>注意二：Tomcat 和 Jdk不要直接用sudo apt-get install的命令方式来安装。这样做了，后面改配置文件会很痛苦</strong></p><p>前期准备工作做好了之后，下面来进行安装和配置：  </p><ol><li><p>安装Tomcat<br>1)解压下载下来的Tomcat压缩包<br>进入Tomcat解压目录/bin 下执行sudo ./startup.sh<br>启动Tomcat<br>2).在浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 或者192.168.0.1:8080<br>局域网内其他机器可以输入<a href="http://ip:8080" target="_blank" rel="noopener">http://ip:8080</a>来测试Tomcat服务是否启动成功</p></li><li><p>安装OpenGork<br>1)在/opt目录下新建opengork目录<br>2)将下载下来的opengork压缩包解压到/opt/opengork目录下<br>3)opengrok/lib目录下的source.war包拷贝到apache-tomcat/webapps目录下<br>4)在浏览器输入<a href="http://localhost:8080/source" target="_blank" rel="noopener">http://localhost:8080/source</a><br>5)能正常看到opengork起来了的界面就Ok了。<br>如果Tomcat版本是7.0，JDK版本是1.8的话，或在这个界面报各种http 400/500等各种乱七八糟的错误</p></li><li><p>配置OpenGork<br>在/opt/opengrok目录的bin文件下 vim OpenGork文件<br>找到DefaultInstanceConfiguration函数里面的<br>OPENGROK_INSTANCE_BASE=”${OPENGROK_INSTANCE_BASE:-/var/opengrok}”</p></li></ol><p>这一块<a href="https://blog.csdn.net/tyronne/article/details/34984805" target="_blank" rel="noopener">https://blog.csdn.net/tyronne/article/details/34984805</a> 这篇文章写的蛮好，可以参考</p><ol start="4"><li>客制化Opengork<br>由于Opengork的代码需要建立索引，一般是在/opt/opengork/有src data等目录<br>其实可以自己克制化这个目录<br>比如：在/home/xxx/Code/目录下新建一个opengork目录<br>在里面再建好src data etc三个目录</li></ol><p>在第三步的/opt/opengork/bin/OpenGork这个配置文件里面和Tomcat的web.xml文件里面<br>把路径都配置成/home/xxx/Code/opengork就可以了</p><p>后面可以把代码放在/home/xxx/Code/src目录下面</p><h1 id="Android源码-OpenGork"><a href="#Android源码-OpenGork" class="headerlink" title="Android源码 OpenGork"></a>Android源码 OpenGork</h1><p>以下三个OpenGork都已经部署好，可以查询从Android1.6到最新版本的Android 以及Kernel代码</p><p><a href="http://androidxref.com/" target="_blank" rel="noopener">androidxref</a><br><a href="https://www.androidos.net.cn/" target="_blank" rel="noopener">androidos</a><br><a href="http://android.macpod.net/" target="_blank" rel="noopener">macpod</a></p><p>这三个网站各有各自的优点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OpenGork的配置&quot;&gt;&lt;a href=&quot;#OpenGork的配置&quot; class=&quot;headerlink&quot; title=&quot;OpenGork的配置&quot;&gt;&lt;/a&gt;OpenGork的配置&lt;/h1&gt;&lt;p&gt;OpenGork的好处，这里不做介绍了，可以参考&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
  </entry>
  
  <entry>
    <title>Android虚拟机Dalvik</title>
    <link href="http://yoursite.com/2018/05/29/Android%E8%99%9A%E6%8B%9F%E6%9C%BADalvik/"/>
    <id>http://yoursite.com/2018/05/29/Android虚拟机Dalvik/</id>
    <published>2018-05-29T13:23:33.000Z</published>
    <updated>2018-06-29T06:32:31.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这个选题很大，但并不是一开始就有这么高大上的追求。最初之时，只是源于对Xposed的好奇。Xposed几乎是定制ROM的神器软件技术架构或者说方法了。它到底是怎么实现呢？我本意就是想搞明白Xposed的实现原理，但随着代码研究的深入，我发现如果不了解虚拟机的实现，而仅简单停留在Xposed的调用流程之上，那真是对Xposed最大的不敬了。另外，歪果仁为什么能写出Xposed？Android上的Java虚拟机对他们来说应该也是相对陌生的，何以他们能做而我们没有人搞出这样的东西？</p><p>所以，在研究Xposed之后，我决定把虚拟机方面的东西也来研究一番。诚如我在很多场合中提到的关于Android学习的三个终极问题（其实对其他各科学习也适用）：学什么？怎么学？学到什么程度为止？关于这三个问题，以本次研究的情况来看，回答如下：</p><ul><li>学习目标是：按顺序是dalvik虚拟机，然后是Xposed针对dalvik的实现，然后是art虚拟机。</li><li>学习方法：VM原理配合具体实现，以代码为主。Java VM有一套规范，各公司具体的VM实现必须遵守此规范。所以对VM学习而言，规范很重要，它是不变的，而代码实现只不过是该规范的一种实现罢了。这里也直接体现了我提出的关于专业知识学习的一句警语“基于Android，高于Android”。对VM而言，先掌握规范才是最最重要和核心的事情。</li><li>学到什么程度为止：对于dalvik虚拟机，我们以学会一段Java程序从代码，到字节码，最后到如何被VM加载并运行它为止。关于dalvik的内存管理我们不会介绍。对于XPosed，基于dalvik+selinux环境的代码我们会全部分析。对于ART，由于它是Google未来较长一段时期的重点，所以我们也会围绕它做更多的分析，诸如内存管理怕是肯定会加上的。</li></ul><p>除了这三个问题，其实还有一个隐含的疑问，学完之后有什么用呢？</p><ul><li>这个问题的答案要看各位的需求了。从本人角度来看，我就是想知道Xposed是怎么实现的。另外，如果了解虚拟机实现的话，我还想定制它，使得它在智能POS领域变得更安全一点。</li><li>当然，我自己有一个比较高大上的梦想，就是我一直想写Linux Kernel方面的书，而且我自认为已经找到了一个绝妙的学习它的入手点（我在魅族做分享的时候介绍过。到今天为止一年多过去了，不知道当初的有心人是否借此脱引而出，如果有的话也请和大家分享下你的学习经历）。Anyway，从目前的工作环境和需求来看，VM是当前更好的学习目标。</li></ul><h1 id="Class、dex、odex文件结构"><a href="#Class、dex、odex文件结构" class="headerlink" title="Class、dex、odex文件结构"></a>Class、dex、odex文件结构</h1><h2 id="Class-文件结构总览"><a href="#Class-文件结构总览" class="headerlink" title="Class 文件结构总览"></a>Class 文件结构总览</h2><p>Class文件是理解Vm实现的关键。关于Class文件的结构，这里介绍的内容直接参考JVM规范，因为它是最权威的资料。<br>Oracle的JVM SE7官方规范：<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/</a><br>还算很有良心，纯网页版的，也可以下载PDF版。另外，周志明老师曾经翻译过中文版的JVM规范，网上可搜索到。</p><p>Class文件到底是什么东西？我觉得一种通俗易懂的解释就是：</p><ol><li>*.java文件是人编写的，给人看的。</li><li><em>.class是通过工具处理</em>.java文件后的产物，它是给VM看的，给VM操作的<br>在某种哲学意义上看，java源文件和处理得到的class文件是同一种东西……</li></ol><p>那么，这个给VM使用的class文件，其内部结构是怎样的呢？Jvm规范很聪明，它通过一个C的数据结构表达了class文件结构。这个数据结构如图2所示：</p><p>没有图片，看的费劲!!!!!<br>没看完</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/innost/article/details/50377905" target="_blank" rel="noopener">深入理解Android之Java虚拟机Dalvik</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这个选题很大，但并不是一开始就有这么高大上的追求。最初之时，只是源于对Xposed的好奇。Xposed几乎是定制ROM的神器软件技术架构或者
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dalvik" scheme="http://yoursite.com/tags/Dalvik/"/>
    
  </entry>
  
  <entry>
    <title>Android系统性能调优工具</title>
    <link href="http://yoursite.com/2018/05/28/Android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/05/28/Android系统性能调优工具/</id>
    <published>2018-05-28T13:23:33.000Z</published>
    <updated>2018-06-30T06:40:46.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在软件开发过程中，想必很多读者都遇到过系统性能问题。而解决系统性能问题的几个主要步骤是：</p><ul><li>测评：对系统进行大量有针对性的测试，以得到合适的测试数据。</li><li>分析系统瓶颈：分析测试数据，找到其中的hotspot（热点，即bottleneck）。</li><li>性能优化：对hotspot相关的代码进行优化。<br>由上述步骤可知，性能优化的目标对象是hotspot。如果找到的hotspot并非真正的热点，则性能优化的结果必然是事倍功半甚至竹篮打水一场空。所以，作为Android性能调优相关知识的第一部分，本篇首先将向读者介绍Android平台中三个重要的性能测试工具，它们能很好得帮助开发者找到hotspot。</li></ul><p>Android官方的性能和功耗的优化介绍： <a href="https://developer.android.com/topic/performance/" target="_blank" rel="noopener">https://developer.android.com/topic/performance/</a></p><h1 id="Android性能相关的关键词"><a href="#Android性能相关的关键词" class="headerlink" title="Android性能相关的关键词:"></a>Android性能相关的关键词:</h1><ol><li><a href="https://developer.android.com/topic/performance/vitals/" target="_blank" rel="noopener">Android Vitals</a>：Android性能指标</li><li>[TraceView] ：Android性能分析工具</li><li>[dmtracedump] :Google提供的工具，能画函数调用图，dmtracedump和TraceView是一对兄弟，一起使用，用来分析性能</li></ol><h2 id="Android-性能指标"><a href="#Android-性能指标" class="headerlink" title="Android 性能指标"></a>Android 性能指标</h2><p>Android的性能指标，可以参考Google提供的 Android Vitals 仪表盘只能在Google play store上使用，用来监测APP性能数据.<br>见<a href="https://support.google.com/googleplay/android-developer/answer/7385505" target="_blank" rel="noopener">https://support.google.com/googleplay/android-developer/answer/7385505</a></p><ol><li>ANR比例</li><li>Crash 比例</li><li>过度唤醒 WakeLock ,AlarmManager</li><li>过度的后台Wifi扫描</li><li>过度的后台网络使用</li><li>渲染慢,UI 渲染要在16ms以下，60fps即60帧/s以上，不然的话就是Jank(不合格)，用户明显能够感受到卡顿现象。<blockquote><p>识别Jank的方法：<br>a) 通过在 开发者选项中打开 GPU 渲染开关后，查看柱形条<br>b)使用systrace<br>c)</p></blockquote></li><li></li></ol><h2 id="Android-性能指标监测工具"><a href="#Android-性能指标监测工具" class="headerlink" title="Android 性能指标监测工具"></a>Android 性能指标监测工具</h2><p><a href="https://blog.csdn.net/u011974987/article/details/51753774" target="_blank" rel="noopener">Android 性能指标检测工具</a></p><p>Android 常见问题:</p><ul><li>内存泄漏：不使用的内存空间(对象)一直被引用着没有得到释放。</li><li>内存抖动：短时间内大量创建对象又在短时间内频繁触发GC导致内存波动很大，android虚拟机执行GC操作时需要耗费CPU性能频繁GC会到来严重的性能问题。内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</li><li>内存溢出：内存泄漏到一定程度超出系统给进程分配的内存大小就会造成内存溢出程序奔溃，或者加载一个或多个大型文件(图片)到内存中也会导致内存溢出。</li><li>ANR：应用无响应，代码效率过低或者在主线程执行耗时操作。</li></ul><p>内存监控工具如下:</p><p><a href="https://blog.csdn.net/ekeuy/article/details/48661595" target="_blank" rel="noopener">Android性能测试工具列表</a></p><h1 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h1><h2 id="TraceView介绍与用途"><a href="#TraceView介绍与用途" class="headerlink" title="TraceView介绍与用途"></a>TraceView介绍与用途</h2><p>TraceView 是 Android SDK 中内置的一个工具，它可以加载 trace 文件，<strong>用图形的形式展示代码的执行时间、次数及调用栈</strong>，便于我们分析。</p><p>从代码层面分析性能问题，针对每个方法来分析，比如当我们发现我们的应用出现卡顿的时候，我们可以来分析出现卡顿时在方法的调用上有没有很耗时的操作，关注以下两个问题：</p><pre><code>- 调用次数不多，但是每一次执行都很耗时- 方法耗时不大，但是调用次数太多</code></pre><p>简单一点来说就是我们能找到频繁被调用的方法，也能找到执行非常耗时的方法，前者可能会造成Cpu频繁调用，手机发烫的问题，后者就是卡顿的问题</p><p>两方面用途： </p><ol><li>查看跟踪代码的执行时间，分析哪些是耗时操作，主要用于分析方法和线程</li><li>可以用于跟踪方法的调用，尤其是android Framework层的方法调用关系</li></ol><p>Traceview是Android平台特有的数据采集和分析工具，它主要用于分析Android中应用程序的hotspot。Traceview本身只是一个数据分析工具，而数据的采集则需要使用Android SDK中的Debug类或者利用DDMS工具。二者的用法如下：</p><ul><li>开发者在一些关键代码段开始前调用Android SDK中Debug类的startMethodTracing函数，并在关键代码段结束前调用stopMethodTracing函数。这两个函数运行过程中将采集运行时间内该应用所有线程（注意，只能是Java线程）的函数执行情况，并将采集数据保存到/mnt/sdcard/下的一个文件中。开发者然后需要利用SDK中的Traceview工具来分析这些数据。</li><li>借助Android SDK中的DDMS工具。DDMS可采集系统中某个正在运行的进程的函数调用信息。对开发者而言，此方法适用于没有目标应用源代码的情况。DDMS工具中Traceview的使用如图1-1所示。<br><img src="https://img-blog.csdn.net/20130602213318781" alt="图1-1"><br><center>图1-1  DDMS中Traceview使用示意图</center><br>点击图1-1中所示按钮即可以采集目标进程的数据。当停止采集时，DDMS会自动触发Traceview工具来浏览采集数据。</li></ul><h2 id="TraceView的使用"><a href="#TraceView的使用" class="headerlink" title="TraceView的使用"></a>TraceView的使用</h2><p><a href="https://blog.csdn.net/superxlcr/article/details/78219673" target="_blank" rel="noopener">TraceView工具如何使用</a><br>Google官方TraceView 教程：</p><ol><li>使用TraceView收集log <a href="https://developer.android.com/studio/profile/generate-trace-logs" target="_blank" rel="noopener">https://developer.android.com/studio/profile/generate-trace-logs</a></li><li>分析TraceView log <a href="https://developer.android.com/studio/profile/traceview#timelinepanel" target="_blank" rel="noopener">https://developer.android.com/studio/profile/traceview#timelinepanel</a></li></ol><p>Android代码调试工具 traceview 和 dmtracedump的波折演绎 <a href="https://blog.csdn.net/yiyaaixuexi/article/details/6716884" target="_blank" rel="noopener">https://blog.csdn.net/yiyaaixuexi/article/details/6716884</a> 此文的优点：可以使用dmtracedump来输出函数调用关系图</p><p>以下章节来自：<br><a href="https://blog.csdn.net/u011240877/article/details/54347396" target="_blank" rel="noopener">Android 性能优化：使用 TraceView 找到卡顿的元凶</a></p><h3 id="生成TraceView文件"><a href="#生成TraceView文件" class="headerlink" title="生成TraceView文件"></a>生成TraceView文件</h3><p>生成 trace 文件有三种方法：</p><ol><li>使用代码</li><li>使用 Android Studio</li><li>使用 DDMS</li></ol><h4 id="使用代码生成trace文件"><a href="#使用代码生成trace文件" class="headerlink" title="使用代码生成trace文件"></a>使用代码生成trace文件</h4><p>android.os.Debug类，其中重要的两个方法Debug.startMethodTracing()和Debug.stopMethodTracing()。这两个方法用来创建.trace文件，将从Debug.startMethodTracing()开始，到Debug.stopMethodTracing()结束，期间所有的调用过程保存在.trace文件中，包括调用的函数名称和执行的时间等信息。<br>    把下面代码分别在加在调试起始代码的位置，和终止位置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(Environment.getExternalStorageDirectory().getPath()+<span class="string">"/"</span>+TAG);    //开始 trace，保存文件到外部存储空间的TAG.trace，/mnt/sdcard目录下</span><br><span class="line">    // ...</span><br><span class="line">Debug.stopMethodTracing();    //结束</span><br></pre></td></tr></table></figure></p><p>代码很简单，当你调用开始代码的时候，系统会生产 trace 文件，并且产生追踪数据，当你调用结束代码时，会将追踪数据写入到 trace 文件中。</p><p>下一步使用 adb 命令将 trace 文件导出到电脑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/TAG.trace /tmp</span><br></pre></td></tr></table></figure></p><p>使用代码生成 trace 方式的好处是容易控制追踪的开始和结束，缺点就是步骤稍微多了一点。</p><h4 id="使用Android-Studio生成trace文件"><a href="#使用Android-Studio生成trace文件" class="headerlink" title="使用Android Studio生成trace文件"></a>使用Android Studio生成trace文件</h4><p>暂时没有用过</p><h3 id="使用Android-Device-Monitor生成Trace文件"><a href="#使用Android-Device-Monitor生成Trace文件" class="headerlink" title="使用Android Device Monitor生成Trace文件"></a>使用Android Device Monitor生成Trace文件</h3><p>参考: <a href="https://blog.csdn.net/itfootball/article/details/48792435" target="_blank" rel="noopener">Android性能专项测试之TraceView工具(Device Monitor)</a></p><h2 id="根据-TraceView-显示内容定位问题"><a href="#根据-TraceView-显示内容定位问题" class="headerlink" title="根据 TraceView 显示内容定位问题"></a>根据 TraceView 显示内容定位问题</h2><p>定位问题时 TraceView 的使用方式：</p><ul><li>从上半部分查看哪些线程执行时间长？什么时候开始执行？与主线程交错时间？</li><li>哪些方法的执行需要花费很长时间点击 TraceView 中的 Cpu Time/Call，按照占用 CPU 时间从高到低排序</li><li>哪些方法调用次数非常频繁,点击 TraceView 中的 Calls + Recur Calls/Total ，按照调用次数从高到底排序排序后，然后逐个排查是否有项目代码或者依赖库代码，有的话点击查看详情，查看是这个方法还是调用的子方法的问题，进一步定位问题。</li></ul><h1 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h1><h2 id="Systrace简介"><a href="#Systrace简介" class="headerlink" title="Systrace简介"></a>Systrace简介</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p><ul><li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li><li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li><li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/platform-tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。</li></ul><p>从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace。Android 4.1为系统中的几个关键进程和模块都添加了Systrace功能。以显示系统中重要模块Hwcomposer为例，其代码中使用Systrace的方法如图2-1所示：</p><h1 id="Oprofile"><a href="#Oprofile" class="headerlink" title="Oprofile"></a>Oprofile</h1><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">Android 内存泄漏总结</a><br><a href="http://drakeet.me/android-leaks/" target="_blank" rel="noopener">Android 内存泄漏案例和解析</a><br><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3.md" target="_blank" rel="noopener">Handler内存泄漏分析及解决</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/innost/article/details/9008691" target="_blank" rel="noopener">Android系统性能调优工具介绍</a>  介绍了TraceView、Systrace、Oprofile等性能分析工具<br><a href="https://blog.csdn.net/cangely/article/details/80504292" target="_blank" rel="noopener">Android Vitals各性能指标介绍</a> Google官方的性能介绍<br><a href="https://blog.csdn.net/u011974987/article/details/51753774" target="_blank" rel="noopener">Android 性能指标检测工具</a><br><a href="http://www.cnblogs.com/sunzn/p/3192231.html" target="_blank" rel="noopener">Android 编程下的 TraceView 简介及其案例实战</a><br><a href="https://blog.csdn.net/u011240877/article/details/54347396" target="_blank" rel="noopener">Android 性能优化：使用 TraceView 找到卡顿的元凶</a><br><a href="https://juejin.im/post/5874bff0128fe1006b443fa0" target="_blank" rel="noopener">Android性能优化（一）之启动加速35%</a><br><a href="https://blog.csdn.net/u011240877/article/details/54141714" target="_blank" rel="noopener">Android 性能优化：使用 Lint 优化代码、去除多余资源</a><br><a href="https://blog.csdn.net/u011240877/article/details/53142177" target="_blank" rel="noopener">Android 性能优化：多线程</a></p><p><a href="https://race604.com/android-weekly-30/" target="_blank" rel="noopener">[第 30 期] Android 周报</a>  有些性能的文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在软件开发过程中，想必很多读者都遇到过系统性能问题。而解决系统性能问题的几个主要步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测评：对系统进行大量有针
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发者指南阅读</title>
    <link href="http://yoursite.com/2018/05/02/Android-%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/05/02/Android-开发者指南阅读/</id>
    <published>2018-05-02T13:23:33.000Z</published>
    <updated>2018-06-29T12:23:03.635Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/guide/" target="_blank" rel="noopener">Android 开发者指南</a><br>进入<a href="https://developer.android.com" target="_blank" rel="noopener">https://developer.android.com</a> -&gt; Doc -&gt; Guides即可</p><p>由于东西太多，就先从自己感兴趣的开始翻译。<br>已经完成：<br>Best practices<br>└── Performance</p><h1 id="APP-Basics"><a href="#APP-Basics" class="headerlink" title="APP Basics"></a>APP Basics</h1><p>应用基础知识</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Build-your-first-app"><a href="#Build-your-first-app" class="headerlink" title="Build your first app"></a>Build your first app</h2><h2 id="App-fundamentals"><a href="#App-fundamentals" class="headerlink" title="App fundamentals"></a>App fundamentals</h2><h2 id="App-resources"><a href="#App-resources" class="headerlink" title="App resources"></a>App resources</h2><h2 id="App-manifest-file"><a href="#App-manifest-file" class="headerlink" title="App manifest file"></a>App manifest file</h2><h2 id="App-permissions"><a href="#App-permissions" class="headerlink" title="App permissions"></a>App permissions</h2><h1 id="Devices"><a href="#Devices" class="headerlink" title="Devices"></a>Devices</h1><p>设备</p><h2 id="Device-compatibility"><a href="#Device-compatibility" class="headerlink" title="Device compatibility"></a>Device compatibility</h2><h2 id="Wear"><a href="#Wear" class="headerlink" title="Wear"></a>Wear</h2><h2 id="Android-TV"><a href="#Android-TV" class="headerlink" title="Android TV"></a>Android TV</h2><h2 id="Android-Auto"><a href="#Android-Auto" class="headerlink" title="Android Auto"></a>Android Auto</h2><h2 id="Android-Things"><a href="#Android-Things" class="headerlink" title="Android Things"></a>Android Things</h2><h2 id="Chrome-OS-devices"><a href="#Chrome-OS-devices" class="headerlink" title="Chrome OS devices"></a>Chrome OS devices</h2><h1 id="Core-topics"><a href="#Core-topics" class="headerlink" title="Core topics"></a>Core topics</h1><h2 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h2><h3 id="Introduction-to-activities"><a href="#Introduction-to-activities" class="headerlink" title="Introduction to activities"></a>Introduction to activities</h3><h3 id="The-activity-lifecycle"><a href="#The-activity-lifecycle" class="headerlink" title="The activity lifecycle"></a>The activity lifecycle</h3><h3 id="Activity-state-changes"><a href="#Activity-state-changes" class="headerlink" title="Activity state changes"></a>Activity state changes</h3><h3 id="Tasks-and-back-stack"><a href="#Tasks-and-back-stack" class="headerlink" title="Tasks and back stack"></a>Tasks and back stack</h3><h3 id="Processes-and-app-lifecycle"><a href="#Processes-and-app-lifecycle" class="headerlink" title="Processes and app lifecycle"></a>Processes and app lifecycle</h3><h3 id="Parcelables-and-bundles"><a href="#Parcelables-and-bundles" class="headerlink" title="Parcelables and bundles"></a>Parcelables and bundles</h3><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><h3 id="Interact-with-other-apps"><a href="#Interact-with-other-apps" class="headerlink" title="Interact with other apps"></a>Interact with other apps</h3><h3 id="Handling-app-links"><a href="#Handling-app-links" class="headerlink" title="Handling app links"></a>Handling app links</h3><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><h3 id="Recents-screen"><a href="#Recents-screen" class="headerlink" title="Recents screen"></a>Recents screen</h3><h3 id="Multi-window-support"><a href="#Multi-window-support" class="headerlink" title="Multi-window support"></a>Multi-window support</h3><h3 id="App-shorcuts"><a href="#App-shorcuts" class="headerlink" title="App shorcuts"></a>App shorcuts</h3><h3 id="App-widgets"><a href="#App-widgets" class="headerlink" title="App widgets"></a>App widgets</h3><h2 id="Intents-and-intent-filters"><a href="#Intents-and-intent-filters" class="headerlink" title="Intents and intent filters"></a>Intents and intent filters</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Common-intents"><a href="#Common-intents" class="headerlink" title="Common intents"></a>Common intents</h3><h2 id="User-interface-amp-navigation"><a href="#User-interface-amp-navigation" class="headerlink" title="User interface &amp; navigation"></a>User interface &amp; navigation</h2><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h3><h3 id="Look-and-feel"><a href="#Look-and-feel" class="headerlink" title="Look and feel"></a>Look and feel</h3><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><h3 id="Add-the-app-bar"><a href="#Add-the-app-bar" class="headerlink" title="Add the app bar"></a>Add the app bar</h3><h3 id="Control-the-system-UI-visibility"><a href="#Control-the-system-UI-visibility" class="headerlink" title="Control the system UI visibility"></a>Control the system UI visibility</h3><h3 id="Designing-effective-navigation"><a href="#Designing-effective-navigation" class="headerlink" title="Designing effective navigation"></a>Designing effective navigation</h3><h3 id="Implementing-effective"><a href="#Implementing-effective" class="headerlink" title="Implementing effective"></a>Implementing effective</h3><h3 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h3><h3 id="Slide-between-fragments-using-ViewPager"><a href="#Slide-between-fragments-using-ViewPager" class="headerlink" title="Slide between fragments using ViewPager"></a>Slide between fragments using ViewPager</h3><h3 id="Supporting-swipe-to-refresh"><a href="#Supporting-swipe-to-refresh" class="headerlink" title="Supporting swipe-to-refresh"></a>Supporting swipe-to-refresh</h3><h3 id="Toasts-overview"><a href="#Toasts-overview" class="headerlink" title="Toasts overview"></a>Toasts overview</h3><h3 id="Pop-up-messages-overview"><a href="#Pop-up-messages-overview" class="headerlink" title="Pop-up messages overview"></a>Pop-up messages overview</h3><h3 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h3><h3 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h3><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><h3 id="Copy-and-paste"><a href="#Copy-and-paste" class="headerlink" title="Copy and paste"></a>Copy and paste</h3><h3 id="Drag-and-drop"><a href="#Drag-and-drop" class="headerlink" title="Drag and drop"></a>Drag and drop</h3><h3 id="Creating-backward-compatible"><a href="#Creating-backward-compatible" class="headerlink" title="Creating backward-compatible"></a>Creating backward-compatible</h3><h3 id="Uis"><a href="#Uis" class="headerlink" title="Uis"></a>Uis</h3><h2 id="Animations-amp-transitions"><a href="#Animations-amp-transitions" class="headerlink" title="Animations &amp; transitions"></a>Animations &amp; transitions</h2><h3 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Animations-overview"><a href="#Animations-overview" class="headerlink" title="Animations overview"></a>Animations overview</h3><h3 id="Property-animation-overview"><a href="#Property-animation-overview" class="headerlink" title="Property animation overview"></a>Property animation overview</h3><h3 id="Animate-drawable-graphics"><a href="#Animate-drawable-graphics" class="headerlink" title="Animate drawable graphics"></a>Animate drawable graphics</h3><h3 id="Reveal-or-hide-a-view-using-animation"><a href="#Reveal-or-hide-a-view-using-animation" class="headerlink" title="Reveal or hide a view using animation"></a>Reveal or hide a view using animation</h3><h3 id="Move-a-view-using-animation"><a href="#Move-a-view-using-animation" class="headerlink" title="Move a view using animation"></a>Move a view using animation</h3><h3 id="Move-a-view-using-fling-animation"><a href="#Move-a-view-using-fling-animation" class="headerlink" title="Move a view using fling animation"></a>Move a view using fling animation</h3><h3 id="Enlarge-a-view-using-a-zoom-animation"><a href="#Enlarge-a-view-using-a-zoom-animation" class="headerlink" title="Enlarge a view using a zoom animation"></a>Enlarge a view using a zoom animation</h3><h3 id="Animate-movement-using-spring-physics"><a href="#Animate-movement-using-spring-physics" class="headerlink" title="Animate movement using spring physics"></a>Animate movement using spring physics</h3><h3 id="Auto-animate-layout-updates"><a href="#Auto-animate-layout-updates" class="headerlink" title="Auto animate layout updates"></a>Auto animate layout updates</h3><h3 id="Animate-layout-changes-using-a-transtiton"><a href="#Animate-layout-changes-using-a-transtiton" class="headerlink" title="Animate layout changes using a transtiton"></a>Animate layout changes using a transtiton</h3><h3 id="Create-a-custom-transition"><a href="#Create-a-custom-transition" class="headerlink" title="Create a custom transition"></a>Create a custom transition</h3><h3 id="Start-an-activity-using-an-animation"><a href="#Start-an-activity-using-an-animation" class="headerlink" title="Start an activity using an animation"></a>Start an activity using an animation</h3><h2 id="Images-amp-graphics"><a href="#Images-amp-graphics" class="headerlink" title="Images &amp; graphics"></a>Images &amp; graphics</h2><h3 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Drawable-overview"><a href="#Drawable-overview" class="headerlink" title="Drawable overview"></a>Drawable overview</h3><h3 id="Vector-drawables-overview"><a href="#Vector-drawables-overview" class="headerlink" title="Vector drawables overview"></a>Vector drawables overview</h3><h3 id="Handling-bitmaps"><a href="#Handling-bitmaps" class="headerlink" title="Handling bitmaps"></a>Handling bitmaps</h3><h3 id="Selecting-colors-with-the-palette-API"><a href="#Selecting-colors-with-the-palette-API" class="headerlink" title="Selecting colors with the palette API"></a>Selecting colors with the palette API</h3><h3 id="Reducing-image-download-size"><a href="#Reducing-image-download-size" class="headerlink" title="Reducing image download size"></a>Reducing image download size</h3><h3 id="Hardware-accelertation"><a href="#Hardware-accelertation" class="headerlink" title="Hardware accelertation"></a>Hardware accelertation</h3><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><h3 id="Displaying-graphics-with-OpenGL"><a href="#Displaying-graphics-with-OpenGL" class="headerlink" title="Displaying graphics with OpenGL"></a>Displaying graphics with OpenGL</h3><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><h3 id="Enhancing-graphics-with-wide-color-content"><a href="#Enhancing-graphics-with-wide-color-content" class="headerlink" title="Enhancing graphics with wide color content"></a>Enhancing graphics with wide color content</h3><h2 id="Audio-amp-Video"><a href="#Audio-amp-Video" class="headerlink" title="Audio &amp; Video"></a>Audio &amp; Video</h2><h3 id="Audio-amp-video-overview"><a href="#Audio-amp-video-overview" class="headerlink" title="Audio &amp; video overview"></a>Audio &amp; video overview</h3><h3 id="Supported-media-formats"><a href="#Supported-media-formats" class="headerlink" title="Supported media formats"></a>Supported media formats</h3><h3 id="Media-app-architecture"><a href="#Media-app-architecture" class="headerlink" title="Media app architecture"></a>Media app architecture</h3><h3 id="Routing-between-devices"><a href="#Routing-between-devices" class="headerlink" title="Routing between devices"></a>Routing between devices</h3><h3 id="Control-amplitude-with-VolumeShaper"><a href="#Control-amplitude-with-VolumeShaper" class="headerlink" title="Control amplitude with VolumeShaper"></a>Control amplitude with VolumeShaper</h3><h3 id="MediaPlayer-overview"><a href="#MediaPlayer-overview" class="headerlink" title="MediaPlayer overview"></a>MediaPlayer overview</h3><h3 id="MediaRecorder-overview"><a href="#MediaRecorder-overview" class="headerlink" title="MediaRecorder overview"></a>MediaRecorder overview</h3><h3 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h3><h2 id="Background-tasks"><a href="#Background-tasks" class="headerlink" title="Background tasks"></a>Background tasks</h2><h3 id="Overview-4"><a href="#Overview-4" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Guide-to-background-processing"><a href="#Guide-to-background-processing" class="headerlink" title="Guide to background processing"></a>Guide to background processing</h3><h3 id="Sending-operations-to-multiple"><a href="#Sending-operations-to-multiple" class="headerlink" title="Sending operations to multiple"></a>Sending operations to multiple</h3><h3 id="threads"><a href="#threads" class="headerlink" title="threads"></a>threads</h3><h3 id="Schedule-jobs-intelligently"><a href="#Schedule-jobs-intelligently" class="headerlink" title="Schedule jobs intelligently"></a>Schedule jobs intelligently</h3><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><h3 id="Background-optimizations"><a href="#Background-optimizations" class="headerlink" title="Background optimizations"></a>Background optimizations</h3><h3 id="Broadcastes-overview"><a href="#Broadcastes-overview" class="headerlink" title="Broadcastes overview"></a>Broadcastes overview</h3><h3 id="Manage-device-awake-state"><a href="#Manage-device-awake-state" class="headerlink" title="Manage device awake state"></a>Manage device awake state</h3><h2 id="App-data-amp-files"><a href="#App-data-amp-files" class="headerlink" title="App data &amp; files"></a>App data &amp; files</h2><h3 id="Overview-5"><a href="#Overview-5" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Storage-overview"><a href="#Storage-overview" class="headerlink" title="Storage overview"></a>Storage overview</h3><h3 id="Save-files-on-device-storage"><a href="#Save-files-on-device-storage" class="headerlink" title="Save files on device storage"></a>Save files on device storage</h3><p>…….太多了，先不加了</p><h1 id="Best-practices"><a href="#Best-practices" class="headerlink" title="Best practices"></a>Best practices</h1><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>性能</p><h3 id="Overview-6"><a href="#Overview-6" class="headerlink" title="Overview"></a>Overview</h3><p>性能表现在：</p><ul><li>快速启动</li><li>快速响应用户交互<h3 id="Android-Vitals"><a href="#Android-Vitals" class="headerlink" title="Android Vitals"></a>Android Vitals</h3></li></ul><h3 id="Processes-and-Threads-Overview"><a href="#Processes-and-Threads-Overview" class="headerlink" title="Processes and Threads Overview"></a>Processes and Threads Overview</h3><h3 id="Better-Performance-through-Threading"><a href="#Better-Performance-through-Threading" class="headerlink" title="Better Performance through Threading"></a>Better Performance through Threading</h3><h3 id="Optimizing-for-Battery-Life"><a href="#Optimizing-for-Battery-Life" class="headerlink" title="Optimizing for Battery Life"></a>Optimizing for Battery Life</h3><h3 id="Reducing-APK-Size"><a href="#Reducing-APK-Size" class="headerlink" title="Reducing APK Size"></a>Reducing APK Size</h3><h3 id="Manager-Your-App’s-Memory"><a href="#Manager-Your-App’s-Memory" class="headerlink" title="Manager Your App’s Memory"></a>Manager Your App’s Memory</h3><h3 id="Overview-of-Memory-Managemement"><a href="#Overview-of-Memory-Managemement" class="headerlink" title="Overview of Memory Managemement"></a>Overview of Memory Managemement</h3><h3 id="Designing-for-Seamlessness"><a href="#Designing-for-Seamlessness" class="headerlink" title="Designing for Seamlessness"></a>Designing for Seamlessness</h3><h3 id="Keeping-Your-App-Responsive"><a href="#Keeping-Your-App-Responsive" class="headerlink" title="Keeping Your App Responsive"></a>Keeping Your App Responsive</h3><h3 id="Performance-Tips"><a href="#Performance-Tips" class="headerlink" title="Performance Tips"></a>Performance Tips</h3><h3 id="SMP-Primer-for-Android"><a href="#SMP-Primer-for-Android" class="headerlink" title="SMP Primer for Android"></a>SMP Primer for Android</h3><h3 id="Verifying-App-Behavior-on-th-ANdroid-Runtime-ART"><a href="#Verifying-App-Behavior-on-th-ANdroid-Runtime-ART" class="headerlink" title="Verifying App Behavior on th ANdroid Runtime(ART)"></a>Verifying App Behavior on th ANdroid Runtime(ART)</h3><h2 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h2><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h2 id="Build-for-Billions"><a href="#Build-for-Billions" class="headerlink" title="Build for Billions"></a>Build for Billions</h2><h2 id="Build-for-Enterprise"><a href="#Build-for-Enterprise" class="headerlink" title="Build for Enterprise"></a>Build for Enterprise</h2><h2 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android 开发者指南&lt;/a&gt;&lt;br&gt;进入&lt;a href=&quot;https://developer.android.c
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="指南" scheme="http://yoursite.com/tags/%E6%8C%87%E5%8D%97/"/>
    
      <category term="Guides" scheme="http://yoursite.com/tags/Guides/"/>
    
  </entry>
  
  <entry>
    <title>IT学习方法论</title>
    <link href="http://yoursite.com/2017/05/05/IT%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>http://yoursite.com/2017/05/05/IT学习方法论/</id>
    <published>2017-05-04T16:00:00.000Z</published>
    <updated>2018-07-03T12:27:33.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.360doc.com/content/16/0701/22/202378_572290345.shtml" target="_blank" rel="noopener">IT学习方法论</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/16/0701/22/202378_57229
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="方法论" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="IT" scheme="http://yoursite.com/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>Android开发常用网站</title>
    <link href="http://yoursite.com/2017/04/23/2017-04-23-Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2017/04/23/2017-04-23-Android开发常用网站/</id>
    <published>2017-04-23T09:38:08.000Z</published>
    <updated>2018-07-03T13:20:07.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android开发常用网站"><a href="#Android开发常用网站" class="headerlink" title="Android开发常用网站"></a>Android开发常用网站</h1><h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a></p><h1 id="实用的OpenGork网站："><a href="#实用的OpenGork网站：" class="headerlink" title="实用的OpenGork网站："></a>实用的OpenGork网站：</h1><p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a><br><a href="https://www.androidos.net.cn/" target="_blank" rel="noopener">https://www.androidos.net.cn/</a><br><a href="http://android.macpod.net/" target="_blank" rel="noopener">http://android.macpod.net/</a></p><h1 id="Android工具网站："><a href="#Android工具网站：" class="headerlink" title="Android工具网站："></a>Android工具网站：</h1><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a></p><h1 id="Android-开发技术周报"><a href="#Android-开发技术周报" class="headerlink" title="Android 开发技术周报"></a>Android 开发技术周报</h1><p><a href="https://androidweekly.io/" target="_blank" rel="noopener">https://androidweekly.io/</a>  每周一篇最新的技术周报<br><a href="https://androidweekly.cn/" target="_blank" rel="noopener">https://androidweekly.cn/</a><br>Android 开发的技术文章、开源项目、开发工具、视频教程、Android 设计教程、设计资源等</p><h1 id="编程刷题网站："><a href="#编程刷题网站：" class="headerlink" title="编程刷题网站："></a>编程刷题网站：</h1><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a><br><a href="https://www.jiuzhang.com/solutions/" target="_blank" rel="noopener">https://www.jiuzhang.com/solutions/</a><br><a href="http://www.codevs.cn/" target="_blank" rel="noopener">http://www.codevs.cn/</a><br><a href="https://www.hackerrank.com/onboarding/challenge" target="_blank" rel="noopener">https://www.hackerrank.com/onboarding/challenge</a><br><a href="http://www.codeding.com/" target="_blank" rel="noopener">http://www.codeding.com/</a></p><h1 id="语言手册"><a href="#语言手册" class="headerlink" title="语言手册"></a>语言手册</h1><p><a href="https://mirrors.segmentfault.com/" target="_blank" rel="noopener">https://mirrors.segmentfault.com/</a><br>Introduction to Tornado 中文翻译<br>Android 设计指南简体中文版<br>Swift语言指南<br>PHP 中文手册<br>Node.js 手册<br>Golang 手册<br>Python 2.x 手册<br>Python 3.x 手册<br>Laravel 手册<br>Rust 手册<br>React 手册<br>Kotlin 手册</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android开发常用网站&quot;&gt;&lt;a href=&quot;#Android开发常用网站&quot; class=&quot;headerlink&quot; title=&quot;Android开发常用网站&quot;&gt;&lt;/a&gt;Android开发常用网站&lt;/h1&gt;&lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; c
      
    
    </summary>
    
      <category term="Android Tools" scheme="http://yoursite.com/categories/Android-Tools/"/>
    
    
      <category term="Android Tools" scheme="http://yoursite.com/tags/Android-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Android 好文</title>
    <link href="http://yoursite.com/2017/01/01/Android-%E5%A5%BD%E6%96%87/"/>
    <id>http://yoursite.com/2017/01/01/Android-好文/</id>
    <published>2016-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T07:48:12.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优秀的网站"><a href="#优秀的网站" class="headerlink" title="优秀的网站"></a>优秀的网站</h1><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge" target="_blank" rel="noopener">常用的Android开发的一些技能点汇集</a></p><p><a href="https://github.com/DanluTeam/ColdStart" target="_blank" rel="noopener">awesome-android-performance</a> 性能优化</p><p><a href="https://github.com/EricChows/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">免费的编程书籍</a></p><p><a href="https://github.com/EricChows/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">Android优质资源合集</a></p><h1 id="优秀的期刊"><a href="#优秀的期刊" class="headerlink" title="优秀的期刊"></a>优秀的期刊</h1><p><a href="https://www.androidweekly.cn/" target="_blank" rel="noopener">Android开发技术周刊</a></p><p><a href="http://www.androidblog.cn/" target="_blank" rel="noopener">Android博客周刊</a></p><h1 id="重点阅读文章"><a href="#重点阅读文章" class="headerlink" title="重点阅读文章"></a>重点阅读文章</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">罗升阳–那两年炼就的Android内功修养</a><br><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">Android校招面试指南</a><br><a href="https://github.com/helen-x/AndroidInterview" target="_blank" rel="noopener">Android面试资料</a><br><a href="https://github.com/open-android/Android" target="_blank" rel="noopener">阅读里面的Android面试题</a><br><a href="https://github.com/tangqi92/Android-Tips" target="_blank" rel="noopener">Android踩坑历史</a><br><a href="https://github.com/lizhangqu/CoreLink" target="_blank" rel="noopener">Android 日常积累</a><br><a href="https://github.com/stormzhang/android-interview-questions-cn" target="_blank" rel="noopener">Android面试指南</a><br><a href="https://github.com/Juude/droidReverse" target="_blank" rel="noopener">Android一些重要知识点整理</a></p><p><a href="https://blog.csdn.net/china_style/article/details/79280137" target="_blank" rel="noopener">Android 8.0后台运行策略学习</a></p><h1 id="优秀的文章"><a href="#优秀的文章" class="headerlink" title="优秀的文章"></a>优秀的文章</h1><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge/blob/master/github_README/README%E6%96%87%E6%A1%A3%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95.md" target="_blank" rel="noopener">README文档的规范写法</a></p><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge/blob/master/interview/summary.md" target="_blank" rel="noopener">国内一线互联网公司面试题汇总</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjQ0MTU0NA==&amp;mid=2247484617&amp;idx=1&amp;sn=3734e643d241ac9615424dd44462ee2d&amp;chksm=e82c3deedf5bb4f82e7be0823739774a0a2cf8372284c8409471c2752fea1f367ca3f6857795&amp;mpshare=1&amp;scene=23&amp;srcid=1128DKotEvTe4dheaTextbqp#rd" target="_blank" rel="noopener">阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集</a></p><p><a href="https://zhuanlan.zhihu.com/p/30016683" target="_blank" rel="noopener">2017下半年，一二线互联网公司Android面试题汇总</a></p><p><a href="https://zhuanlan.zhihu.com/p/26327485" target="_blank" rel="noopener">2017 年初、阿里、腾讯、百度、华为、京东、搜狗和滴滴面试题汇集（更新篇）</a>  带答案</p><p><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">Android校招面试指南</a></p><p><a href="http://www.jackywang.tech/AndroidInterview-Q-A/" target="_blank" rel="noopener">The top Internet companies android interview questions and answers</a></p><p><a href="https://crossoverjie.top/2018/06/21/personal/Interview-experience/" target="_blank" rel="noopener">一个学渣的阿里之路</a></p><p><a href="https://github.com/DanluTeam/ColdStart" target="_blank" rel="noopener">App 启动优化</a></p><p><a href="http://zmywly8866.github.io/2016/05/04/android-application-leak-analysis-and-fix.html" target="_blank" rel="noopener">Android应用内存泄露分析、改善经验总结</a></p><p><a href="http://wiki.jikexueyuan.com/project/deep-android-v2/packagemanagerservice.html" target="_blank" rel="noopener">第4章  深入理解 PackageManagerService</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">罗升阳–那两年炼就的Android内功修养</a> 老罗博客的总纲</p><p>需要把 <a href="https://github.com/EricChows/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">https://github.com/EricChows/Worth-Reading-the-Android-technical-articles</a> 这里面的优秀文章一篇一篇的看完。</p><p><a href="https://github.com/helen-x/AndroidInterview" target="_blank" rel="noopener">Android面试资料</a></p><h1 id="Android开发工具"><a href="#Android开发工具" class="headerlink" title="Android开发工具"></a>Android开发工具</h1><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></p><p><a href="https://github.com/inferjay/AndroidDevTools/" target="_blank" rel="noopener">AndroidDevTools(Github)</a></p><p><a href="http://androidblog.cn/tools/" target="_blank" rel="noopener">Android开发工具汇总</a></p><h1 id="Android官方文档-中文版"><a href="#Android官方文档-中文版" class="headerlink" title="Android官方文档 中文版"></a>Android官方文档 中文版</h1><p><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">AndroidTraning中文版</a></p><h1 id="Android-性能相关"><a href="#Android-性能相关" class="headerlink" title="Android 性能相关"></a>Android 性能相关</h1><p><a href="https://mp.weixin.qq.com/s/A8NZbHlU1J2CsoNhTFX8Dg?utm_source=androidweekly.io&amp;utm_medium=website" target="_blank" rel="noopener">Android性能优化来龙去脉总结</a><br>总结： 大概的讲述了性能优化的类型和方式</p><p><a href="https://github.com/DanluTeam/ColdStart?utm_source=androidweekly.io&amp;utm_medium=website" target="_blank" rel="noopener">App 启动优化</a><br>总结：</p><p><a href="https://github.com/Juude/awesome-android-performance" target="_blank" rel="noopener">Android性能优化视频，文档以及工具</a></p><h1 id="Android-内存相关"><a href="#Android-内存相关" class="headerlink" title="Android 内存相关"></a>Android 内存相关</h1><p><a href="http://www.cnblogs.com/kingOfPointer/archive/2012/12/21/2828018.html" target="_blank" rel="noopener">android 开发如何做内存优化</a></p><h1 id="Android-稳定性相关"><a href="#Android-稳定性相关" class="headerlink" title="Android 稳定性相关"></a>Android 稳定性相关</h1><h1 id="Android-功耗相关"><a href="#Android-功耗相关" class="headerlink" title="Android 功耗相关"></a>Android 功耗相关</h1><h1 id="Android-Flutter-相关"><a href="#Android-Flutter-相关" class="headerlink" title="Android Flutter 相关"></a>Android Flutter 相关</h1><p><a href="https://mp.weixin.qq.com/s/vlHt8jxbdzBqJZDobpsFVw?utm_source=androidweekly.io&amp;utm_medium=website" target="_blank" rel="noopener">深入理解flutter的编译原理与优化</a></p><h1 id="Android-虚拟机相关"><a href="#Android-虚拟机相关" class="headerlink" title="Android 虚拟机相关"></a>Android 虚拟机相关</h1><p> <a href="https://github.com/chinageek/jvm" target="_blank" rel="noopener">《JVM必知必会》</a><br> <a href="https://github.com/JeffLi1993/jvm-core-learning-example" target="_blank" rel="noopener">JVM 学习的例子</a>\</p><h1 id="Android-PackageManagerService-PKMS-相关"><a href="#Android-PackageManagerService-PKMS-相关" class="headerlink" title="Android PackageManagerService (PKMS)相关"></a>Android PackageManagerService (PKMS)相关</h1><h1 id="Android-PowerManagerService-PMS-相关"><a href="#Android-PowerManagerService-PMS-相关" class="headerlink" title="Android PowerManagerService (PMS)相关"></a>Android PowerManagerService (PMS)相关</h1><h1 id="Android-ActivityManagerService-AMS-相关"><a href="#Android-ActivityManagerService-AMS-相关" class="headerlink" title="Android ActivityManagerService (AMS)相关"></a>Android ActivityManagerService (AMS)相关</h1><h1 id="Android-View相关"><a href="#Android-View相关" class="headerlink" title="Android View相关"></a>Android View相关</h1><h1 id="Android-Binder相关"><a href="#Android-Binder相关" class="headerlink" title="Android Binder相关"></a>Android Binder相关</h1><h1 id="Android-JNI-相关"><a href="#Android-JNI-相关" class="headerlink" title="Android JNI 相关"></a>Android JNI 相关</h1><h1 id="Android-AIDL-相关"><a href="#Android-AIDL-相关" class="headerlink" title="Android AIDL 相关"></a>Android AIDL 相关</h1><h1 id="Android-升级相关"><a href="#Android-升级相关" class="headerlink" title="Android 升级相关"></a>Android 升级相关</h1><h1 id="Android-Java-基础"><a href="#Android-Java-基础" class="headerlink" title="Android/Java 基础"></a>Android/Java 基础</h1><h1 id="线程、多线程和线程池"><a href="#线程、多线程和线程池" class="headerlink" title="线程、多线程和线程池"></a>线程、多线程和线程池</h1><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>  Android方面，并发编程用的比较少，需要好好的研究一下</p><h1 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://mp.weixin.qq.com/s/cXa6Rwiet5gN8bSe-h4QNw" target="_blank" rel="noopener">通过Google挖掘细分市场的一个案例</a></p><p><a href="https://36kr.com/p/5107620.html" target="_blank" rel="noopener">Facebook PM谈顶级产品经理具备的4个特征</a></p><p><a href="https://mp.weixin.qq.com/s/wqGgaH6EhSOqjj1SyJ4U7w" target="_blank" rel="noopener">陈春花：具有战略思维而非竞争理念</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优秀的网站&quot;&gt;&lt;a href=&quot;#优秀的网站&quot; class=&quot;headerlink&quot; title=&quot;优秀的网站&quot;&gt;&lt;/a&gt;优秀的网站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/AweiLoveAndroid/CommonDevKnowl
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="好文" scheme="http://yoursite.com/tags/%E5%A5%BD%E6%96%87/"/>
    
      <category term="good" scheme="http://yoursite.com/tags/good/"/>
    
  </entry>
  
  <entry>
    <title>Android中Binder机制解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADBinder%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Binder机制解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T13:55:00.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6621566" target="_blank" rel="noopener">浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6627260" target="_blank" rel="noopener">浅谈Android系统进程间通信（IPC）机制Binder中的Server和Client获得Service Manager接口之路</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6629298" target="_blank" rel="noopener">Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6633311" target="_blank" rel="noopener">Android系统进程间通信（IPC）机制Binder中的Client获得Server远程接口过程源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6642463" target="_blank" rel="noopener">Android系统进程间通信Binder机制在应用程序框架层的Java接口源代码分析</a></p><p>目标：通过阅读罗升阳的这几篇文章，形成自己的理解，并加深自己的理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Binder" scheme="http://yoursite.com/categories/Android/Binder/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Binder" scheme="http://yoursite.com/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Android中Launcher解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADLauncher%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Launcher解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T03:47:02.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Keygaurd-滑动解锁，绘制"><a href="#Keygaurd-滑动解锁，绘制" class="headerlink" title="Keygaurd 滑动解锁，绘制"></a>Keygaurd 滑动解锁，绘制</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/yj934672573/article/details/54571704" target="_blank" rel="noopener">Android 7.0 Keyguard流程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Keygaurd-滑动解锁，绘制&quot;&gt;&lt;a href=&quot;#Keygaurd-滑动解锁，绘制&quot; class=&quot;headerlink&quot; title=&quot;Keygaurd 滑动解锁，绘制&quot;&gt;&lt;/a&gt;Keygaurd 滑动解锁，绘制&lt;/h1&gt;&lt;h1 id=&quot;参考文献&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Launcher" scheme="http://yoursite.com/categories/Android/Launcher/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Launcher" scheme="http://yoursite.com/tags/Launcher/"/>
    
  </entry>
  
  <entry>
    <title>Android中SurfaceFlinger解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADService%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Service解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:10:14.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7846923" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7857163" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务的连接过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7867340" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7884628" target="_blank" rel="noopener">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7932268" target="_blank" rel="noopener">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/8010977" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8022957" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务的启动过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8046659" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8062945" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务的线程模型分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8079456" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="SurfaceFlinger" scheme="http://yoursite.com/categories/Android/SurfaceFlinger/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="SurfaceFlinger" scheme="http://yoursite.com/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>Android中SurfaceFlinger解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADSurfaceFlinger%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中SurfaceFlinger解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:10:14.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7846923" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7857163" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务的连接过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7867340" target="_blank" rel="noopener">Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7884628" target="_blank" rel="noopener">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/7932268" target="_blank" rel="noopener">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/8010977" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8022957" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务的启动过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8046659" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8062945" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务的线程模型分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8079456" target="_blank" rel="noopener">Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="SurfaceFlinger" scheme="http://yoursite.com/categories/Android/SurfaceFlinger/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="SurfaceFlinger" scheme="http://yoursite.com/tags/SurfaceFlinger/"/>
    
  </entry>
  
  <entry>
    <title>Android中SystemUI解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADSystemUI%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中SystemUI解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T03:42:21.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="SystemUI" scheme="http://yoursite.com/categories/Android/SystemUI/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="SystemUI" scheme="http://yoursite.com/tags/SystemUI/"/>
    
  </entry>
  
  <entry>
    <title>Android中Activity解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADActivity%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Activity解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:16:04.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="noopener">Android应用程序的Activity启动过程简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener">Android应用程序启动过程源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6703247" target="_blank" rel="noopener">Android应用程序内部启动Activity过程（startActivity）的源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6720261" target="_blank" rel="noopener">Android应用程序在新的进程中启动新的Activity的方法和过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6714543" target="_blank" rel="noopener">解开Android应用程序组件Activity的”singleTask”之谜</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/categories/Android/Activity/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Activity" scheme="http://yoursite.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Android中Handler解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADHandler%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Handler解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:24:03.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="noopener">Android应用程序消息处理机制（Looper、Handler）分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6882903" target="_blank" rel="noopener">Android应用程序键盘（Keyboard）消息处理机制分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6905587" target="_blank" rel="noopener">Android应用程序线程消息循环模型分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Handler" scheme="http://yoursite.com/categories/Android/Handler/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Handler" scheme="http://yoursite.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android中ContentProvider解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADContentProvider%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中ContentProvider解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:20:23.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6946067" target="_blank" rel="noopener">Android应用程序组件Content Provider简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6950440" target="_blank" rel="noopener">Android应用程序组件Content Provider应用实例</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6963418" target="_blank" rel="noopener">Android应用程序组件Content Provider的启动过程源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6967204" target="_blank" rel="noopener">Android应用程序组件Content Provider在应用程序之间共享数据的原理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6985171" target="_blank" rel="noopener">Android应用程序组件Content Provider的共享数据更新通知机制分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="ContentProvider" scheme="http://yoursite.com/categories/Android/ContentProvider/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ContentProvider" scheme="http://yoursite.com/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>Android中ActivityManagerService解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADActivityManagerService%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中ActivityManagerService解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:01:22.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8170307" target="_blank" rel="noopener">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8201936" target="_blank" rel="noopener">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8223770" target="_blank" rel="noopener">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8245546" target="_blank" rel="noopener">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8275938" target="_blank" rel="noopener">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8303098" target="_blank" rel="noopener">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8372924" target="_blank" rel="noopener">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="ActivityManagerService" scheme="http://yoursite.com/categories/Android/ActivityManagerService/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ActivityManagerService" scheme="http://yoursite.com/tags/ActivityManagerService/"/>
    
      <category term="AMS" scheme="http://yoursite.com/tags/AMS/"/>
    
  </entry>
  
  <entry>
    <title>Android中启动过程解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android启动过程解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T03:58:29.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6768304" target="_blank" rel="noopener">Android系统进程Zygote启动过程的源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6747696" target="_blank" rel="noopener">Android应用程序进程启动过程的源代码分析</a></p><p>Android开机流程概述：<br><a href="https://blog.csdn.net/h655370/article/details/77727554" target="_blank" rel="noopener">https://blog.csdn.net/h655370/article/details/77727554</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="启动" scheme="http://yoursite.com/categories/Android/%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Zegote" scheme="http://yoursite.com/tags/Zegote/"/>
    
      <category term="Init" scheme="http://yoursite.com/tags/Init/"/>
    
  </entry>
  
  <entry>
    <title>Android中启动过程解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E5%BC%82%E5%B8%B8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android异常解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T08:11:37.164Z</updated>
    
    <content type="html"><![CDATA[<p>android系统常见异常现象有应用无响应、应用停止运行、冻屏、重启、死机</p><p>应用程序无响应：ANR</p><p>应用停止运行：  </p><p>冻屏</p><p>黑屏</p><p>重启</p><p>死机：</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/zwq1457/article/details/75529264" target="_blank" rel="noopener">Android异常分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;android系统常见异常现象有应用无响应、应用停止运行、冻屏、重启、死机&lt;/p&gt;
&lt;p&gt;应用程序无响应：ANR&lt;/p&gt;
&lt;p&gt;应用停止运行：  &lt;/p&gt;
&lt;p&gt;冻屏&lt;/p&gt;
&lt;p&gt;黑屏&lt;/p&gt;
&lt;p&gt;重启&lt;/p&gt;
&lt;p&gt;死机：&lt;/p&gt;
&lt;h1 id=&quot;参考文献&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="启动" scheme="http://yoursite.com/categories/Android/%E5%90%AF%E5%8A%A8/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Zegote" scheme="http://yoursite.com/tags/Zegote/"/>
    
      <category term="Init" scheme="http://yoursite.com/tags/Init/"/>
    
  </entry>
  
  <entry>
    <title>Android中Keyguard解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADKeyguard%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Keyguard解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-05T14:31:10.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p> 本文是基于Android版本：8.1.0来讨论Keyguard相关代码.</p><p> 在Android 8.1.0版本中，将Keyguard模块的代码完全移到了SystemUI，将其和SystemUI进行了合并。那么为何要把SystemUI和Keyguard代码放在一起呢？估计基于以下几点考虑：<br> a) 虽然在之前的版本中，Keyguard模块和SystemUI模块的代码是分开放在两个目录，且单独参与编译，Keyguard模块编译生成keyguard.jar，SystemUI模块单独编译生成SystemUI.apk,且SystemUI.apk包含了Keyguard.jar. 两个模块都是公用一个进程com.android.systemui.<br> b) 两个模块有公用的小模块，比如StatusBar、NotificationView等等.<br> c) 两个模块都需要对滑动事件进行处理，而且大部分的处理逻辑很像.</p><p> Keyguard模块的重点是：<br> • 事件的处理<br> • LockPatternUtils<br> • 锁屏界面的显示<br> • 锁屏界面的隐藏<br> • 密码的认证和校验<br> •<br> • </p><h1 id="Keyguard相关文件功能预分析"><a href="#Keyguard相关文件功能预分析" class="headerlink" title="Keyguard相关文件功能预分析"></a>Keyguard相关文件功能预分析</h1><p> 与Keyguard相关的代码有如下这些：<br> 对于每个模块里面的每个块代码的初步分析顺序并不是按照其重要性来的，是按照每个模块里面相关类的字母顺序来讲解.<br> 在这个部分，我们主要任务是了解每个文件的功能和作用，因此，只是局限于单个文件眼前的功能，对Keyguard整体功能，并不能全面的理解.</p><h2 id="core模块代码"><a href="#core模块代码" class="headerlink" title="core模块代码"></a>core模块代码</h2><ol><li>framework/base/core模块有KeyguardManager,LockPatternUtils,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">framework/base/core/java/android/app/KeyguardManager.java</span><br><span class="line">framework/base/core/java/com/android/internal/widget/LockPatternUtils.java</span><br><span class="line">frameworks/base/core/java/android/app/admin/DevicePolicyManager.java</span><br></pre></td></tr></table></figure></li></ol><h2 id="services模块代码"><a href="#services模块代码" class="headerlink" title="services模块代码"></a>services模块代码</h2><ol start="2"><li>framework/base/services模块有PhoneWindowManager,KeyguardServiceDelegate,KeyguardServiceWrapper,KeyguardStateMonitor<br>PhoneWindowManager.java<br>KeyguardServiceDelegate  Keyguard服务代理<br>KeyguardServiceWrapper  Keyguard服务封装<br>KeyguardStateMonitor Keygurad状态监视<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">framework/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span><br><span class="line">framework/base/services/core/java/com/android/server/policy/keyguard/KeyguardServiceDelegate.java</span><br><span class="line">framework/base/services/core/java/com/android/server/policy/keyguard/KeyguardServiceWrapper.java</span><br><span class="line">framework/base/services/core/java/com/android/server/policy/keyguard/KeyguardStateMonitor.java</span><br><span class="line">framework/base/</span><br></pre></td></tr></table></figure></li></ol><h2 id="SystemUI模块代码"><a href="#SystemUI模块代码" class="headerlink" title="SystemUI模块代码"></a>SystemUI模块代码</h2><ol start="3"><li><p>SystemUI中的Keyguard模块代码在frameworks/base/packages/SystemUI/src/com/android/systemui/目录,其中处理Keyguard逻辑相关的代码有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>KeyguardHostView  即为最终需要展示界面的基类<br>KeyguardAbsKeyInputView<br>作为基类实现了key input password类型(PIN, Sim PIN, Sim PUK, password)的大多数公用函数。<br>KeyguardUpdateMonitor 注册了绝大多数的广播，负责处理界面的一些刷新流程处理<br>使用了观察者模式<br>KeyguardUpdateMonitorCallback<br>KeyguardDisplayManager  作为中间类去控制keyguard的show与hide,主要用于双屏异显<br>packages/Keyguard/src/com/android/keyguard/KeyguardDisplayManager.java<br>此类中涉及到两个重要的类<br>MediaRouter<br>Presentation 这个类是用来控制双屏异显的<br>LiftToActivateListener.java<br>AccessibilityService  无障碍/辅助功能</p></li></ol><p>KeyguardViewMediator 是整个待机解/锁屏业务的调度器，负责调度锁屏界面的相关动作及查询解锁屏状态。是一个服务<br>packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java</p><p>KeyguardService.java  KeyguardViewMediator为其子类</p><p>KeyguardBouncer 管理是非滑动解锁还是滑动解锁，控制安全锁屏的显示与隐藏<br>packages/SystemUI/src/com/android/systemui/statusbar/phone/KeyguardBouncer.java</p><h2 id="SystemUI中Keyguard模块代码"><a href="#SystemUI中Keyguard模块代码" class="headerlink" title="SystemUI中Keyguard模块代码"></a>SystemUI中Keyguard模块代码</h2><ol start="4"><li><p>SystemUI中的Keyguard模块中处理Keyguard的UI显示相关的代码有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/AlphaOptimizedImageButton.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/AlphaOptimizedLinearLayout.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/AlphaOptimizedRelativeLayout.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/CarrierText.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/EmergencyButton.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/EmergencyCarrierArea.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardAbsKeyInputView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardClockAccessibilityDelegate.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardConstants.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardDisplayManager.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardEsimArea.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardHostView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardMessageArea.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardPasswordView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardPatternView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardPinBasedInputView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardPINView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSecurityCallback.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSecurityContainer.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSecurityModel.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSecurityView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSecurityViewFlipper.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSimPinView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardSimPukView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardStatusView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitor.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/KeyguardUpdateMonitorCallback.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/LatencyTracker.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/LiftToActivateListener.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/NumPadKey.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/PasswordTextView.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/SecurityMessageDisplay.java</span><br><span class="line">frameworks/base/packages/SystemUI/src/com/android/keyguard/ViewMediatorCallback.java</span><br></pre></td></tr></table></figure><p><strong>AlphaOptimizedImageButton：</strong>A frame layout which does not have overlapping renderings commands and therefore does not need a layer when alpha is changed. 用于PIN码解锁时，确认键Button时使用.</p><p><strong>AlphaOptimizedLinearLayout:</strong>A linear layout which does not have overlapping renderings commands and therefore does not need a layer when alpha is changed. 一个LinearLayout，但是hasOverlappingRendering方法返回为false，主要目的是防止过度绘制，提升性能. 关于<a href="https://blog.csdn.net/xingchenxuanfeng/article/details/56488045" target="_blank" rel="noopener">hasOverlappingRendering方法请参考这里</a></p><p><strong>AlphaOptimizedRelativeLayout:</strong>同样的是一个相对布局的优化类.</p><p><strong>CarrierText:</strong> 继承自TextView，主要用来在锁屏界面，顶部StatusBar里面显示运营商信息以及当前的SIM卡状态和网络状态.</p><p><strong>EmergencyButton：</strong> 继承自Button， 锁屏界面的紧急拨号按钮</p><p><strong>EmergencyCarrierArea：</strong> 继承自AlphaOptimizedLinearLayout，主要处理紧急拨号按钮和这里的CarrierText的显示问题</p><p><strong>KeyguardAbsKeyInputView：</strong> 抽象类，继承自LinearLayout，实现了KeyguardSecurityView, EmergencyButton.EmergencyButtonCallback 三个类，主要的功能是：Base class for PIN and password unlock screens. 即 PIN码和密码解锁的基类,实现了对输入的密码处理的主要的三个函数verifyPasswordAndUnlock(), onPasswordChecked(), handleAttemptLockout().</p><p><strong>KeyguardClockAccessibilityDelegate:</strong>Replaces fancy colons with regular colons. Only works on TextViews.重新定义了一个冒号，继承自View.AccessibilityDelegate，主要用于锁屏界面时钟显示时的冒号</p><p><strong>KeyguardConstants：</strong> 定义Keyguard模块用到的三个Debug开关</p><p><strong>KeyguardDisplayManager：</strong>Support multiple external displays，支持多个扩展设备上显示. 控制Keyguard的显示和隐藏，主要有三个函数show(),hide(),updatedisplay(),还有一个KeyguardPresentation类，继承自Presentation，Presentation类就是Android支持双屏异显的类。还有一个MediaRouter.SimpleCallback，用于监视外接设备。</p><p><strong>KeyguardEsimArea：</strong>This button is used by the device with embedded SIM card to disable current carrier to unlock the device with no cellular service.<br>继承自Button，按钮的主要作用是在eSIM卡(eSIM卡比日常见到的SIM卡基于硬件芯片的模块，安全级别可以做到最高，具体可以查下资料)的PIN码和PUK码解锁的时候,在无网络的情况下，diable掉carrier实现解锁设备.(eSIM卡的知识不懂，为啥要这样解锁设备，还不清楚)</p><p><strong>KeyguardHostView:</strong> 继承自FrameLayout，实现了SecurityCallback接口.Base class for keyguard view.  {@link #reset} is where you should reset the state of your view.  Use the {@link KeyguardViewCallback} via {@link #getCallback()} to send information back (such as poking the wake lock,or finishing the keyguard). Handles intercepting of media keys that still work when the keyguard is showing.是整个Keyguard显示的基类，可以reset(重置)Keyguard的显示，可以使用KeyguardViewCallback回调的方式，发信息  .在锁屏界面对多媒体相关的按键事件，比如播放音乐、暂停音乐、静音、音量+、音量-、耳机插入、上一首、下一首等事件进行拦截以及处理.<br>SecurityCallback接口定义了四个函数,具体代码见com.android.keyguard.KeyguardSecurityContainer.SecurityCallback,分别是:<br>• dismiss();<br>• userActivity();<br>• onSecurityModeChanged();<br>• finish();<br>• reset();</p><p><strong>KeyguardMessageArea:</strong> 继承自TextView，实现SecurityMessageDisplay.PIN码/图案/密码解锁界面时显示输入密码错误，以及输入次数等消息.在KeyguardPatternView中有使用.</p><p><strong>KeyguardPasswordView:</strong>Displays an alphanumeric (latin-1) key entry for the user to enter an unlock password.显示一个文本框，用来处理用户输入的密码字符，这里要讲一下锁屏界面的密码和PIN码(这里的PIN码不是SIM卡的PIN码)，两者的区别是，密码可以是字母和数字的组合，但是PIN码只能是由数字组成. 继承了KeyguardAbsKeyInputView实现了 KeyguardSecurityView, OnEditorActionListener, TextWatcher. 此类完成了用户进入密码解锁界面后，密码输入，密码错误时的提示信息处理、密码校验等事情.</p><p><strong>KeyguardPatternView:</strong> 继承自LinearLayout，实现了KeyguardSecurityView, AppearAnimationCreator&lt;LockPatternView.CellState&gt;,        EmergencyButton.EmergencyButtonCallback 接口,这里不是图案解锁中九宫格的View实现，九宫格的图案解锁实现是在com.android.internal.widget.LockPatternView中.<br>此类中，完成了用户进入图案解锁界面后，图案密码输入、图案密码错误时的提示信息处理、密码校验等事情.</p><p><strong>KeyguardPinBasedInputView：</strong>A Pin based Keyguard input view.继承自KeyguardAbsKeyInputView，实现了View.OnKeyListener, View.OnTouchListener接口.是一个PIN码输入的基类，因为总共有三类PIN码，a)正常PIN码,b)SIM卡的PIN码,c)SIM卡的PUK码三种.由于PIN码全部是数字组成，所以在PIN输入的时候，可以不用调用输入法的输入面板，在此类中，实现了数字输入面板的处理逻辑.</p><p><strong>KeyguardPINView：</strong>Displays a PIN pad for unlocking.继承自KeyguardPinBasedInputView,显示一个PIN码解锁的界面.  </p><p><strong>KeyguardSecurityCallback:</strong> 一个接口，定义了5个方法.<br>• dismiss() //Dismiss the given security screen.<br>• userActivity() //Manually report user activity to keep the device awake.<br>• isVerifyUnlockOnly() //Checks if keyguard is in “verify credentials” mode.<br>• reportUnlockAttempt(int userId, boolean success, int timeoutMs) //Call to report an unlock attempt.<br>• reset() //Resets the keyguard view.<br>这个接口和上面提到的SecurityCallback接口的区别在哪里呢？</p><p><strong>KeyguardSecurityContainer:</strong> 继承自FrameLayout,实现了如下功能：<br>• 实现了KeyguardSecurityView接口<br>• 定义了SecurityCallback接口.定义SecurityCallback接接口的作用是// Used to notify the container when something interesting happens.<br>• 实现了showTimeoutDialog()函数，密码输入错误多次后的弹框提示<br>• showAlmostAtWipeDialog()和showWipeDialog()函数，密码输入太多次后，擦除cache数据的提示<br>• reportFailedUnlockAttempt()函数，上报错误次数<br>• KeyguardSecurityCallback 接口的实现，整个Keyguard里面，KeyguardSecurityCallback接口都是直接当内部类的方式new出来的，具体实现，就在KeyguardSecurityContainer里面，从KeyguardSecurityCallback的实现来看，是连接 SecurityCallback和KeyguardSecurityContainer的.代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> private KeyguardSecurityCallback mCallback = new <span class="function"><span class="title">KeyguardSecurityCallback</span></span>() &#123;</span><br><span class="line">    public void <span class="function"><span class="title">userActivity</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSecurityCallback != null) &#123;</span><br><span class="line">            mSecurityCallback.userActivity();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dismiss(boolean authenticated, int targetId) &#123;</span><br><span class="line">        mSecurityCallback.dismiss(authenticated, targetId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean <span class="function"><span class="title">isVerifyUnlockOnly</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> mIsVerifyUnlockOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reportUnlockAttempt(int userId, boolean success, int timeoutMs) &#123;</span><br><span class="line">        KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            monitor.clearFailedUnlockAttempts();</span><br><span class="line">            mLockPatternUtils.reportSuccessfulPasswordAttempt(userId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            KeyguardSecurityContainer.this.reportFailedUnlockAttempt(userId, timeoutMs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">reset</span></span>() &#123;</span><br><span class="line">        mSecurityCallback.reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>KeyguardSecurityView:</strong> 接口， 定义了如下方法：<br>• setKeyguardCallback(KeyguardSecurityCallback callback);//Interface back to keyguard to tell it when security<br>• setLockPatternUtils(LockPatternUtils utils); //Set {@link LockPatternUtils} object. Useful for providing a mock interface.<br>• reset(); //Reset the view and prepare to take input. This should do things like clearing the password or pattern and clear error messages.<br>• onPause(); //Emulate activity life cycle within the view. When called, the view should clean up and prepare to be removed.<br>• onResume(int reason); //Emulate activity life cycle within this view.  When called, the view should prepare itself<br>• needsInput(); //Inquire whether this view requires IME (keyboard) interaction.<br>• KeyguardSecurityCallback getCallback(); //Get {@link KeyguardSecurityCallback} for the given object<br>• showPromptReason(int reason); //Show a string explaining why the security view needs to be solved.<br>• showMessage(String message, int color); //Show a message on the security view with a specified color<br>• showUsabilityHint(); //Instruct the view to show usability hints, if any.<br>• startAppearAnimation(); //Starts the animation which should run when the security view appears. //Security View显示动画<br>• startDisappearAnimation(Runnable finishRunnable); //Starts the animation which should run when the security view disappears.//Security View消失动画</p><p><strong>KeyguardSecurityModel:</strong> 定义了7种不同的锁屏模式(还有指纹解锁和面部解锁不在这里面)，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum SecurityMode &#123;</span><br><span class="line">        Invalid, // NULL state</span><br><span class="line">        None, // No security enabled</span><br><span class="line">        Pattern, // Unlock by drawing a pattern.</span><br><span class="line">        Password, // Unlock by entering an alphanumeric password</span><br><span class="line">        PIN, // Strictly numeric password</span><br><span class="line">        SimPin, // Unlock by entering a sim pin.</span><br><span class="line">        SimPuk // Unlock by entering a sim puk</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>• 通过getSecurityMode方法获取当前的锁屏模式，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SecurityMode getSecurityMode(int userId) &#123;</span><br><span class="line">        KeyguardUpdateMonitor monitor = KeyguardUpdateMonitor.getInstance(mContext);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIsPukScreenAvailable &amp;&amp; SubscriptionManager.isValidSubscriptionId(</span><br><span class="line">                monitor.getNextSubIdForState(IccCardConstants.State.PUK_REQUIRED))) &#123;</span><br><span class="line">            <span class="built_in">return</span> SecurityMode.SimPuk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SubscriptionManager.isValidSubscriptionId(</span><br><span class="line">                monitor.getNextSubIdForState(IccCardConstants.State.PIN_REQUIRED))) &#123;</span><br><span class="line">            <span class="built_in">return</span> SecurityMode.SimPin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int security = mLockPatternUtils.getActivePasswordQuality(userId);</span><br><span class="line">        switch (security) &#123;</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX:</span><br><span class="line">                <span class="built_in">return</span> SecurityMode.PIN;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC:</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_COMPLEX:</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_MANAGED:</span><br><span class="line">                <span class="built_in">return</span> SecurityMode.Password;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:</span><br><span class="line">                <span class="built_in">return</span> SecurityMode.Pattern;</span><br><span class="line">            <span class="keyword">case</span> DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED:</span><br><span class="line">                <span class="built_in">return</span> SecurityMode.None;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                throw new IllegalStateException(<span class="string">"Unknown security quality:"</span> + security);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面有两个很重要的类LockPatternUtils和DevicePolicyManager，代码路径如下，具体分析见上面的模块分析.<br>frameworks/base/core/java/com/android/internal/widget/LockPatternUtils.java<br>frameworks/base/core/java/android/app/admin/DevicePolicyManager.java</p><p><strong>KeyguardSecurityViewFlipper:</strong> 继承自ViewFlipper，实现了KeyguardSecurityView接口.Subclass of the current view flipper that allows us to overload dispatchTouchEvent() so we can emulate {@link WindowManager.LayoutParams#FLAG_SLIPPERY} within a view hierarchy. 用在keyguard_host_view布局中，嵌套与KeyguardSecurityContainer内部，具体见下面的keyguard_host_view.xml代码. 继承ViewFlipper的原因是，从滑动解锁界面上滑进入图案解锁、PIN码解锁、密码解锁等界面时有一个切换，实现视图翻转,另一方面，由于是KeyguardSecurityContainer的子视图，可以重写dispatchTouchEvent()函数，在各种解锁界面处理事件分发.<a href="">具体可以看ViewFlipper</a>.</p><p><strong>KeyguardSimPinView:</strong> 继承自KeyguardPinBasedInputView.用于显示SIM卡PIN码解锁界面逻辑的处理,实现了如下方法：<br>• KeyguardUpdateMonitorCallback中的onSimStateChanged来监听SIM卡的状态<br>• CheckSimPin 是个抽象类，继承自Thread，开启后台线程，用于验证PIN码正确性<br>• verifyPasswordAndUnlock 验证密码并解锁<br>• showDefaultMessage<br>• getSimRemainingAttemptsDialog<br>• getSimUnlockProgressDialog</p><p><strong>KeyguardSimPukView：</strong> 继承自KeyguardPinBasedInputView.用于显示SIM卡PUK码解锁界面逻辑的处理,实现了如下方法：<br>• KeyguardUpdateMonitorCallback中的onSimStateChanged来监听SIM卡的状态，与SIM卡的PIN码一样<br>• StateMachine 类，由于PUK码是在PIN码输入错三次都输入错误之后，才开启输入PUK码的，且PIN码要求是4-8位数字，PUK码必须是8位数字.此类用于此过程的检查<br>• CheckSimPuk  是个抽象类，继承自Thread，开启后台线程，用于验证PUK码正确性<br>• verifyPasswordAndUnlock 验证密码并解锁<br>• showDefaultMessage<br>• getSimRemainingAttemptsDialog<br>• getSimUnlockProgressDialog</p><p><strong>KeyguardStatusView：</strong> 继承自GridLayout，布局文件是keyguard_status_view.xml,主要用于处理Keyguard界面的时钟，是否在充电，以及用户信息,并包含了keyguard_status_area的布局.整体来说，用于处理显示在Keyguard界面StatusBar以下，Notification以上的界面布局的逻辑.</p><p><strong>KeyguardUpdateMonitor:</strong> 实现了TrustManager.TrustListener接口，注册了绝大多数的广播，负责处理界面的一些刷新流程处理.<br>到frameworks/base/core/java/android/app/trust/TrustManager.java里面看看TrustListener接口代码，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface TrustListener &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reports that the trust state has changed.</span><br><span class="line">     * @param enabled <span class="keyword">if</span> <span class="literal">true</span>, the system believes the environment to be trusted.</span><br><span class="line">     * @param userId the user, <span class="keyword">for</span> <span class="built_in">which</span> the trust changed.</span><br><span class="line">     * @param flags flags specified by the trust agent when granting trust. See</span><br><span class="line">     *     &#123;@link android.service.trust.TrustAgentService<span class="comment">#grantTrust(CharSequence, long, int)</span></span><br><span class="line">     *                 TrustAgentService.grantTrust(CharSequence, long, int)&#125;.</span><br><span class="line">     */</span><br><span class="line">    void onTrustChanged(boolean enabled, int userId, int flags);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reports that whether trust is managed has changed</span><br><span class="line">     * @param enabled <span class="keyword">if</span> <span class="literal">true</span>, at least one trust agent is managing trust.</span><br><span class="line">     * @param userId the user, <span class="keyword">for</span> <span class="built_in">which</span> the state changed.</span><br><span class="line">     */</span><br><span class="line">    void onTrustManagedChanged(boolean enabled, int userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下，哪些广播会刷新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static final int MSG_TIME_UPDATE = 301;  //时间刷新</span><br><span class="line">private static final int MSG_BATTERY_UPDATE = 302; //电池状态刷新</span><br><span class="line">private static final int MSG_SIM_STATE_CHANGE = 304; //SIM卡状态改变</span><br><span class="line">private static final int MSG_RINGER_MODE_CHANGED = 305;  //响铃模式改变</span><br><span class="line">private static final int MSG_PHONE_STATE_CHANGED = 306;  //Phone状态改变</span><br><span class="line">private static final int MSG_DEVICE_PROVISIONED = 308; // 开机向导标记位</span><br><span class="line">private static final int MSG_DPM_STATE_CHANGED = 309; //DevicePolicyManage 设备授权</span><br><span class="line">private static final int MSG_USER_SWITCHING = 310;  // 切换用户</span><br><span class="line">private static final int MSG_KEYGUARD_RESET = 312;  //Keyguard重置</span><br><span class="line">private static final int MSG_BOOT_COMPLETED = 313;  //开机完成</span><br><span class="line">private static final int MSG_USER_SWITCH_COMPLETE = 314; //用户切换完成</span><br><span class="line">private static final int MSG_USER_INFO_CHANGED = 317;  // 用户信息变化</span><br><span class="line">private static final int MSG_REPORT_EMERGENCY_CALL_ACTION = 318; // 紧急拨号</span><br><span class="line">private static final int MSG_STARTED_WAKING_UP = 319;  // 开始唤醒</span><br><span class="line">private static final int MSG_FINISHED_GOING_TO_SLEEP = 320; //休眠完成</span><br><span class="line">private static final int MSG_STARTED_GOING_TO_SLEEP = 321;  //开始休眠</span><br><span class="line">private static final int MSG_KEYGUARD_BOUNCER_CHANGED = 322; //锁屏模式切换</span><br><span class="line">private static final int MSG_FACE_UNLOCK_STATE_CHANGED = 327; // 面部解锁状态改变</span><br><span class="line">private static final int MSG_SIM_SUBSCRIPTION_INFO_CHANGED = 328; //SIM卡SUBSCRIPTION信息变化</span><br><span class="line">private static final int MSG_AIRPLANE_MODE_CHANGED = 329;  //飞行模式切换</span><br><span class="line">private static final int MSG_SERVICE_STATE_CHANGE = 330;   // SIM卡服务状态切换</span><br><span class="line">private static final int MSG_SCREEN_TURNED_ON = 331;   //亮屏</span><br><span class="line">private static final int MSG_SCREEN_TURNED_OFF = 332;  //灭屏</span><br><span class="line">private static final int MSG_DREAMING_STATE_CHANGED = 333;  //屏保模式</span><br><span class="line">private static final int MSG_USER_UNLOCKED = 334;    //用户锁</span><br><span class="line">private static final int MSG_LOCALE_CHANGED = 500;  //语言切换</span><br><span class="line">private static final int MSG_ASSISTANT_STACK_CHANGED = 335;  // 指纹</span><br><span class="line">private static final int MSG_FINGERPRINT_AUTHENTICATION_CONTINUE = 336; //指纹认证</span><br></pre></td></tr></table></figure></li></ol><p> <strong>KeyguardUpdateMonitorCallback：</strong> 与KeyguardUpdateMonitor中广播消息对应的回调方法. Callback也是一种观察者模式，在Android的很多地方都有使用到.<br> <strong>现在下面要讲的是Android中经常用到的使用Callback来更新数据的一个实例，弄明白了，以后其他的使用也会很快理解到</strong></p><p> 在KeyguardUpdateMonitor中我们看看KeyguardUpdateMonitorCallback的使用.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;WeakReference&lt;KeyguardUpdateMonitorCallback&gt;&gt;</span><br><span class="line">        mCallbacks = Lists.newArrayList();</span><br></pre></td></tr></table></figure></p><p> 我们以MSG_TIME_UPDATE 时间的刷新为例，来看一下KeyguardUpdateMonitorCallback的用处.<br> 第一步：接收到时间刷新的广播<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private final BroadcastReceiver mBroadcastReceiver = new <span class="function"><span class="title">BroadcastReceiver</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            final String action = intent.getAction();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"received broadcast "</span> + action);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Intent.ACTION_TIME_TICK.equals(action)</span><br><span class="line">                    || Intent.ACTION_TIME_CHANGED.equals(action)</span><br><span class="line">                    || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) &#123;</span><br><span class="line">                mHandler.sendEmptyMessage(MSG_TIME_UPDATE);</span><br><span class="line">                ......</span><br></pre></td></tr></table></figure></p><p> 第二步：收到广播后，把消息发送给Handler，交由Handler来处理，我们来看看Handler收到MSG_TIME_UPDATE后的处理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final Handler mHandler = new <span class="function"><span class="title">Handler</span></span>() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_TIME_UPDATE:</span><br><span class="line">                    handleTimeUpdate();</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MSG_BATTERY_UPDATE:</span><br><span class="line">                    handleBatteryUpdate((BatteryStatus) msg.obj);</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                    ......</span><br></pre></td></tr></table></figure></p><p> 第三步：Hanlder收到MSG_TIME_UPDATE消息后，执行handleTimeUpdate函数，我们来看看handleTimeUpdate函数代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle &#123;@link <span class="comment">#MSG_TIME_UPDATE&#125;</span></span><br><span class="line"> */</span><br><span class="line">private void <span class="function"><span class="title">handleTimeUpdate</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.d(TAG, <span class="string">"handleTimeUpdate"</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; mCallbacks.size(); i++) &#123;</span><br><span class="line">        KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();</span><br><span class="line">        <span class="keyword">if</span> (cb != null) &#123;</span><br><span class="line">            cb.onTimeChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 第四步：在这里，我们看到了mCallbacks，从刚开始，我们看到mCallbacks的初始化，是空的，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private final ArrayList&lt;WeakReference&lt;KeyguardUpdateMonitorCallback&gt;&gt;</span><br><span class="line">            mCallbacks = Lists.newArrayList();</span><br></pre></td></tr></table></figure></p><p> 接着，在registerCallback函数里面进行了赋值，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void registerCallback(KeyguardUpdateMonitorCallback callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"*** register callback for "</span> + callback);</span><br><span class="line">    // Prevent adding duplicate callbacks</span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; mCallbacks.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallbacks.get(i).get() == callback) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.e(TAG, <span class="string">"Object tried to add another callback"</span>,</span><br><span class="line">                    new Exception(<span class="string">"Called by"</span>));</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCallbacks.add(new WeakReference&lt;KeyguardUpdateMonitorCallback&gt;(callback));</span><br><span class="line">    removeCallback(null); // remove unused references</span><br><span class="line">    sendUpdates(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 那么registerCallback又在什么时候调用呢？我们以EmergencyButton为例，看看EmergencyButton里面的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void <span class="function"><span class="title">onAttachedToWindow</span></span>() &#123;</span><br><span class="line">    super.onAttachedToWindow();</span><br><span class="line">    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mInfoCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 我们看到在EmergencyButton类中的onAttachedToWindow方法使用registerCallback方法，也就是说只要EmergencyButton可见，那么就开始注册这个Callback回调.<br> 这里用EmergencyButton来举例好像不大合适，因为，在收到时间刷新的广播之后，第三步执行handleTimeUpdate方法，里面调用的Callback函数是cb.onTimeChanged();在EmergencyButton里面肯定是不需要关心时间的.</p><p> 我们找个与时间有关的，找到KeyguardStatusView，在这里面看到registerCallback的调用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void <span class="function"><span class="title">onAttachedToWindow</span></span>() &#123;</span><br><span class="line">    super.onAttachedToWindow();</span><br><span class="line">    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mInfoCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 和mergencyButton差不多，在KeyguardStatusView加载时候，就开始注册registerCallback方法.现在收到了时间更新的广播，执行到了第三步，现在要执行cb.onTimeChanged();我们看看KeyguardStatusView里面的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private KeyguardUpdateMonitorCallback mInfoCallback = new <span class="function"><span class="title">KeyguardUpdateMonitorCallback</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">onTimeChanged</span></span>() &#123;</span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onKeyguardVisibilityChanged(boolean showing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (showing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.v(TAG, <span class="string">"refresh statusview showing:"</span> + showing);</span><br><span class="line">            refresh();</span><br><span class="line">            updateOwnerInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">onStartedWakingUp</span></span>() &#123;</span><br><span class="line">        setEnableMarquee(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinishedGoingToSleep(int why) &#123;</span><br><span class="line">        setEnableMarquee(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onUserSwitchComplete(int userId) &#123;</span><br><span class="line">        refresh();</span><br><span class="line">        updateOwnerInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p> 从代码中可以看到，在KeyguardUpdateMonitor里面收到了时间刷新的广播之后，对应的KeyguardStatusView能立即执行refesh()方法，来刷新时间.<br> 从上面代码中还可以看到KeyguardStatusView在KeyguardUpdateMonitor收到唤醒，休眠以及用户切换等广播时，也能进行相应的更新。</p><p> <strong>LatencyTracker：</strong> 我们先来看看关于这个类的官方注释<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class to track various latencies <span class="keyword">in</span> SystemUI. It <span class="keyword">then</span> outputs the latency to logcat so these latencies can be captured by tests and <span class="keyword">then</span> used <span class="keyword">for</span> dashboards.</span><br><span class="line">This is currently only <span class="keyword">in</span> Keyguard so it can be shared between SystemUI and Keyguard, but eventually we<span class="string">'d want to merge these two packages together so Keyguard can use common classes that are shared with SystemUI.</span></span><br></pre></td></tr></table></figure></p><p> 这个类主要的目的是用来跟踪SystemUI中各个小功能模块的耗时.方便后期性能分析和性能优化.这个类虽然在keyguard模块里面，由于Keyguard模块代码已经完全合入了SystemUI，所有他们两兄弟可以共用这个类.<br> 我们来看看跟踪了哪几个模块的耗时：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Time it takes until the first frame of the notification panel to be displayed <span class="keyword">while</span> expanding</span><br><span class="line"> */</span><br><span class="line">public static final int ACTION_EXPAND_PANEL = 0; // 通知面板下拉时间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Time it takes until the first frame of recents is drawn after invoking it with the button.</span><br><span class="line"> */</span><br><span class="line">public static final int ACTION_TOGGLE_RECENTS = 1; //Recent 最近任务栏显示时间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Time between we get a fingerprint acquired signal until we start with the unlock animation</span><br><span class="line"> */</span><br><span class="line">public static final int ACTION_FINGERPRINT_WAKE_AND_UNLOCK = 2; //指纹解锁时间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Time it takes to check PIN/Pattern/Password.</span><br><span class="line"> */</span><br><span class="line">public static final int ACTION_CHECK_CREDENTIAL = 3;   // PIN码解锁、图案解锁、密码解锁认证时间</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Time it takes to check fully PIN/Pattern/Password, i.e. that<span class="string">'s the time spent including the</span></span><br><span class="line"><span class="string"> * actions to unlock a user.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">public static final int ACTION_CHECK_CREDENTIAL_UNLOCKED = 4; //PIN码解锁、图案解锁、密码解锁从开始到解锁整个认证时间</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/**</span></span><br><span class="line"><span class="string"> * Time it takes to turn on the screen.</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">public static final int ACTION_TURN_ON_SCREEN = 5;  //亮屏时间</span></span><br></pre></td></tr></table></figure></p><p> 上述跟踪的几个时间模块，对应SystemUI来说的确非常重要，这几个模块的响应时间太长的话，给用户的体验就不好，因为这几个是每个用户最经常使用的地方.<br> 从代码来看，这个功能开关是debug.systemui.latency_tracking这个prop属性<br> 接下来看看具体如何进行耗时跟踪的,主要是onActionStart和onActionEnd两个方法.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Notifies that an action is starting. This needs to be called from the main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param action The action to start. One of the ACTION_* values.</span><br><span class="line"> */</span><br><span class="line">public void onActionStart(int action) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mEnabled) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.asyncTraceBegin(Trace.TRACE_TAG_APP, NAMES[action], 0);</span><br><span class="line">    mStartRtc.put(action, SystemClock.elapsedRealtime());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Notifies that an action has ended. This needs to be called from the main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param action The action to end. One of the ACTION_* values.</span><br><span class="line"> */</span><br><span class="line">public void onActionEnd(int action) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mEnabled) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    long endRtc = SystemClock.elapsedRealtime();</span><br><span class="line">    long startRtc = mStartRtc.get(action, -1);</span><br><span class="line">    <span class="keyword">if</span> (startRtc == -1) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mStartRtc.delete(action);</span><br><span class="line">    Trace.asyncTraceEnd(Trace.TRACE_TAG_APP, NAMES[action], 0);</span><br><span class="line">    long duration = endRtc - startRtc;</span><br><span class="line">    Log.i(TAG, <span class="string">"action="</span> + action + <span class="string">" latency="</span> + duration);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.SYSUI_LATENCY, action, (int) duration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们以跟踪ACTION_TOGGLE_RECENTS,最近历史任务为例，在NavigationBarFragment.java的onRecentsClick方法中代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void onRecentsClick(View v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (LatencyTracker.isEnabled(getContext())) &#123;</span><br><span class="line">        LatencyTracker.getInstance(getContext()).onActionStart(</span><br><span class="line">                LatencyTracker.ACTION_TOGGLE_RECENTS);</span><br><span class="line">    &#125;</span><br><span class="line">    mStatusBar.awakenDreams();</span><br><span class="line">    mCommandQueue.toggleRecentApps();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在RecentsActivity.java中，我们看到onActionEnd的调用如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private final OnPreDrawListener mRecentsDrawnEventListener =</span><br><span class="line">        new ViewTreeObserver.<span class="function"><span class="title">OnPreDrawListener</span></span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean <span class="function"><span class="title">onPreDraw</span></span>() &#123;</span><br><span class="line">                mRecentsView.getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">                EventBus.getDefault().post(new RecentsDrawnEvent());</span><br><span class="line">                <span class="keyword">if</span> (LatencyTracker.isEnabled(getApplicationContext())) &#123;</span><br><span class="line">                    DejankUtils.postAfterTraversal(() -&gt; LatencyTracker.getInstance(</span><br><span class="line">                            getApplicationContext()).onActionEnd(</span><br><span class="line">                            LatencyTracker.ACTION_TOGGLE_RECENTS));</span><br><span class="line">                &#125;</span><br><span class="line">                DejankUtils.postAfterTraversal(() -&gt; &#123;</span><br><span class="line">                    Recents.getTaskLoader().startLoader(RecentsActivity.this);</span><br><span class="line">                    Recents.getTaskLoader().getHighResThumbnailLoader().setVisible(<span class="literal">true</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p><p> 耗时计算的核心是onActionStart和onActionEnd两个方法的实现，需要追踪Trace.asyncTraceBegin和Trace.asyncTraceEnd两个方法，这里先不讲，偏题太远了.</p><p> <strong>LiftToActivateListener:</strong> 继承自View.OnHoverListener，我们来看看官方的注释：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hover listener that implements lift-to-activate interaction <span class="keyword">for</span> accessibility. May be added to multiple views.</span><br></pre></td></tr></table></figure></p><p> 通过继承View.OnHoverListener实现悬停监听，View.OnHoverListener是Android 4.0增加的对光标悬停事件、手写笔、鼠标按钮事件的支持。<br> 主要用于ACCESSIBILITY_SERVICE，辅助服务</p><p><strong>NumPadKey：</strong> 主要用于Keyguard模块中数字数码</p><p><strong>PasswordTextView：</strong> 与TextView相似，但是属于密码输入，且有动画</p><p><strong>SecurityMessageDisplay:</strong> 接口，定义了Keyguard中显示信息的几个方法.</p><p><strong>ViewMediatorCallback:</strong> 接口，这个Callback 和上面讲到的三个Callback不一样，</p><h2 id="SystemUI中Keyguard的UI显示模块代码"><a href="#SystemUI中Keyguard的UI显示模块代码" class="headerlink" title="SystemUI中Keyguard的UI显示模块代码"></a>SystemUI中Keyguard的UI显示模块代码</h2><ol start="5"><li><p>SystemUI中的Keyguard模块中UI显示相关的代码有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_bouncer.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_emergency_carrier_area.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_esim_area.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_host_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_message_area_large.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_message_area.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_num_pad_key.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_password_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_pattern_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_pin_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_presentation.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_sim_pin_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_sim_puk_view.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_status_area.xml</span><br><span class="line">frameworks/base/packages/SystemUI/res-keyguard/layout/keyguard_status_view.xml</span><br></pre></td></tr></table></figure><p><strong>keyguard_bouncer:</strong>是一个FrameLayout，include了keyguard_host_view文件.</p><p><strong>keyguard_emergency_carrier_area:</strong>锁屏上紧急拨号的UI处理，包含了显示当前运营商信息的CarrierText和一个接入紧急拨号界面的EmergencyButton.</p><p><strong>keyguard_host_view:</strong>This is the host view that generally contains two sub views: the widget view and the security view.<br>这是Keyguard显示模块主要的布局文件，包含两个子布局：一个带小部件(时钟)的布局，还有一个是安全布局(指的是图案解锁/密码/PIN码解锁界面)<br>功能由KeyguardHostView.java KeyguardSecurityContainer.java KeyguardSecurityViewFlipper.java实现<br>具体代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.android.keyguard.KeyguardHostView</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:androidprv=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    android:id=<span class="string">"@+id/keyguard_host_view"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:clipChildren=<span class="string">"false"</span></span><br><span class="line">    android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">    android:importantForAccessibility=<span class="string">"yes"</span>&gt; &lt;!-- Needed because TYPE_WINDOW_STATE_CHANGED is sent</span><br><span class="line">                                                  from this view when bouncer is shown --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;com.android.keyguard.KeyguardSecurityContainer</span><br><span class="line">        android:id=<span class="string">"@+id/keyguard_security_container"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        androidprv:layout_maxHeight=<span class="string">"@dimen/keyguard_security_max_height"</span></span><br><span class="line">        android:clipChildren=<span class="string">"false"</span></span><br><span class="line">        android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">        android:padding=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;com.android.keyguard.KeyguardSecurityViewFlipper</span><br><span class="line">            android:id=<span class="string">"@+id/view_flipper"</span></span><br><span class="line">            android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            android:clipChildren=<span class="string">"false"</span></span><br><span class="line">            android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">            android:paddingTop=<span class="string">"@dimen/keyguard_security_view_top_margin"</span></span><br><span class="line">            android:paddingStart=<span class="string">"@dimen/keyguard_security_view_lateral_margin"</span></span><br><span class="line">            android:paddingEnd=<span class="string">"@dimen/keyguard_security_view_lateral_margin"</span></span><br><span class="line">            android:gravity=<span class="string">"center"</span>&gt;</span><br><span class="line">        &lt;/com.android.keyguard.KeyguardSecurityViewFlipper&gt;</span><br><span class="line">    &lt;/com.android.keyguard.KeyguardSecurityContainer&gt;</span><br><span class="line"></span><br><span class="line">&lt;/com.android.keyguard.KeyguardHostView&gt;</span><br></pre></td></tr></table></figure><p><strong>keyguard_esim_area:</strong>This contains disable esim buttonas shared by sim_pin/sim_puk screens<br>SIM卡的PIN码和PUK码解锁时，禁用esim卡的按钮，功能由KeyguardEsimArea.java来实现.</p><p><strong>keyguard_message_area_large:</strong>This contains emergency call button and carrier as shared by pin/pattern/password screens.<br>PIN码/图案/密码解锁界面时显示输入密码错误，以及输入次数等消息,由KeyguardMessageArea.java来实现</p><p><strong>keyguard_message_area：</strong> 同上面的keyguard_message_area_large</p><p><strong>keyguard_num_pad_key:</strong></p><p><strong>keyguard_password_view:</strong> 密码输入界面</p><p><strong>keyguard_pattern_view：</strong> 图案解锁界面</p><p><strong>keyguard_pin_view：</strong> PIN码解锁界面</p><p><strong>keyguard_presentation：</strong> This is a view that shows general status information in Keyguard.</p><p><strong>keyguard_sim_pin_view:</strong> SIM卡PIN码解锁界面</p><p><strong>keyguard_sim_puk_view：</strong> SIM卡PUK码解锁界面</p><p><strong>keyguard_status_area：</strong> 锁屏界面的日期和闹钟</p><p><strong>keyguard_status_view：</strong> This is a view that shows general status information in<br>Keyguard.由KeyguardStatusView实现，主要显示Keyguard界面的时钟，是否在充电，以及用户信息,并包含了keyguard_status_area的布局.整体来说，用于显示Keyguard界面StatusBar以下，Notification以上的界面布局.</p></li></ol><h1 id="Keyguard里的一些属性配置"><a href="#Keyguard里的一些属性配置" class="headerlink" title="Keyguard里的一些属性配置"></a>Keyguard里的一些属性配置</h1><p> <strong>config_voice_capable</strong><br> <strong>config_enable_emergency_call_while_sim_locked</strong> SIM卡锁的时候，是否能紧急拨号的开关</p><p> <strong>debug.systemui.latency_tracking</strong> true:且debug模式开启模块耗时跟踪 false：关闭模块耗时跟踪</p><h1 id="锁屏界面的布局"><a href="#锁屏界面的布局" class="headerlink" title="锁屏界面的布局"></a>锁屏界面的布局</h1><h1 id="解锁界面的显示"><a href="#解锁界面的显示" class="headerlink" title="解锁界面的显示"></a>解锁界面的显示</h1><h1 id="解锁界面的隐藏"><a href="#解锁界面的隐藏" class="headerlink" title="解锁界面的隐藏"></a>解锁界面的隐藏</h1><h1 id="滑动实现解锁"><a href="#滑动实现解锁" class="headerlink" title="滑动实现解锁"></a>滑动实现解锁</h1><h1 id="图案解锁"><a href="#图案解锁" class="headerlink" title="图案解锁"></a>图案解锁</h1><h2 id="九宫格解锁的实现"><a href="#九宫格解锁的实现" class="headerlink" title="九宫格解锁的实现"></a>九宫格解锁的实现</h2><h1 id="PIN码解锁"><a href="#PIN码解锁" class="headerlink" title="PIN码解锁"></a>PIN码解锁</h1><h1 id="密码解锁"><a href="#密码解锁" class="headerlink" title="密码解锁"></a>密码解锁</h1><h1 id="指纹解锁"><a href="#指纹解锁" class="headerlink" title="指纹解锁"></a>指纹解锁</h1><h1 id="面部解锁"><a href="#面部解锁" class="headerlink" title="面部解锁"></a>面部解锁</h1><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/ocean2006/article/details/8079457" target="_blank" rel="noopener">Android4.0 Keyguard解锁屏机制</a><br><a href="https://blog.csdn.net/ocean2006/article/details/8079457" target="_blank" rel="noopener">Android 7.0 锁屏解锁之向上滑动显示解锁界面分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt; 本文是基于Android版本：8.1.0来讨论Keyguard相关代码.&lt;/p&gt;
&lt;p&gt; 在Android 8.1.0版本中，将Keygu
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Keyguard" scheme="http://yoursite.com/categories/Android/Keyguard/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Keyguard" scheme="http://yoursite.com/tags/Keyguard/"/>
    
  </entry>
  
  <entry>
    <title>Android中Dalvik虚拟机解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADDalvik%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中Dalvik虚拟机解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:34:39.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8852432" target="_blank" rel="noopener">Dalvik虚拟机简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8885792" target="_blank" rel="noopener">Dalvik虚拟机的启动过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8914953" target="_blank" rel="noopener">Dalvik虚拟机的运行过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="noopener">Dalvik虚拟机JNI方法的注册过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8923484" target="_blank" rel="noopener">Dalvik虚拟机进程和线程的创建过程分析</a></p><p>[Android虚拟机Dalvik]—myself</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/java/virtual-machine.md" target="_blank" rel="noopener">JVM</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Dalvik" scheme="http://yoursite.com/categories/Android/Dalvik/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Dalvik" scheme="http://yoursite.com/tags/Dalvik/"/>
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Android中BroadcastRecevier解析</title>
    <link href="http://yoursite.com/2016/01/01/A-Ongoing-Android%E4%B8%ADBroadcastRecevier%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/01/01/A-Ongoing-Android中BroadcastRecevier解析/</id>
    <published>2015-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T14:17:51.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6730748" target="_blank" rel="noopener">Android系统中的广播（Broadcast）机制简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6737352" target="_blank" rel="noopener">Android应用程序注册广播接收器（registerReceiver）的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6744448" target="_blank" rel="noopener">Android应用程序发送广播（sendBroadcast）的过程分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="BroadcastRecevier" scheme="http://yoursite.com/categories/Android/BroadcastRecevier/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="BroadcastRecevier" scheme="http://yoursite.com/tags/BroadcastRecevier/"/>
    
  </entry>
  
  <entry>
    <title>View及Viewgroup</title>
    <link href="http://yoursite.com/2015/08/01/View%E5%8F%8AViewgroup/"/>
    <id>http://yoursite.com/2015/08/01/View及Viewgroup/</id>
    <published>2015-08-01T13:14:10.000Z</published>
    <updated>2018-06-23T15:24:28.884Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html</a></p><p>.1.0 View及ViewGroup类关系<br>Android View和ViewGroup从组成架构上看，似乎ViewGroup在View之上，View需要继承ViewGroup，但实际上不是这样的。 View是基类，ViewGroup是它的子类。这就证明了一点，View代表了用户界面组件的一块可绘制的空间块。每一个View在屏幕上占据一个长方 形区域。在这个区域内，这个VIEW对象负责图形绘制和事件处理。View是小控件widgets和ViewGroup的父类。ViewGroup又是 Layout的基类。</p><p>image</p><p>image</p><p>从上面两图的对比中，可以看出，实际上ViewGroup是View的子类，因此，View的行为特征ViewGroup也具备，但同时因为 ViewGroup是Layout的祖先，所以具备了其它一些特点,View所未具有的。通常创建一个View，不论是通过XML还是通过代码创建。对任 何一个View及这个View的子类Widget，需要关注如下几个方面：<br>【1】设置属性，如长、宽、着色等。这些属性的设置通常可以用代码实现，也可以用XML文件。并用这些属性在运行时候也可以通常方法进行修改。<br>ID 属性，Android对每个UI元素的ID名称要求唯一，但也不绝对。同时在不同的Layout中是可以相同的元素名称的。给一个UI元素指定ID，有一个好处就是可以在代码中找得到。</p><p>image</p><p>Tags，同ID不同，这个不用来搜索View,类似于对View的一些描述性数据保存。<br>Animation，对任何一个View，可以使用动画对象进行操作。注意，如果View有子的话，子同样具备这个animation功能<br>Position, Size, padding and margins，对任一个View来说，表达这个View通常是宽和高。也可以设置padding和margins。不是所有的View都设置margins。</p><p>image</p><p>Orientatiion，对ViewGroup的子类Layout来说，设置Orienatation，可用来决定子类的位置<br>FillModel，出现这种情况主要是默认情况，某些元素不能完全占满父区域的空间，这时除非子VIEW已经设置具体和DPI，否则话需要告诉父控件，你所选择填充空间方式，如Fill-parent或者Wrap-content等。<br>Gravity，Gravity与Orientation是不同，Gravaity与Word文档中左对齐，右对齐类似。缺省是左上对齐。<br>Weight,这个在两个控制同时分配剩余空间，需要设置layout-weight决定两者谁的占比。<br>【2】请求焦点，可以通过函数实现焦点转换。不同的焦点可以实现不同的背景变换等功能。焦点在Android里分为几种情况，一种是可以获取焦点，另外一种是不能获取焦点，第三种是可获取焦点，但当前正取触摸状态下。<br>【3】设置事件监听者，所有的View都会在本身发生变化将自身的信息广播出去。比喻点击、焦点失去得到等。通常一个事件来到，Android会将事件传 递到相应的View，然后View将事件传递到相应的Listeners。这时View需要获取焦点，如果需要重新绘制View的话，需要调用 invalidate(0或者reqeustLayout重新绘制整个界面。<br>【4】设置显示与隐藏，还可以对其内容设置scrolling。<br>2.1.1 View、Window、Activity、Dispay之间的关系<br>这些都是组成Android 系统显示的关键元素。我们首先来了解Dispay。Dispay代表了硬件显示屏幕信息。</p><p>image</p><p>通过这些函数可以了解一个屏幕的宽、高及分辨率还有是横屏还坚屏等一些基本情况，透过这些函数，我们开发应用时可以方便的得到当前安装我这个应用的屏幕的 大小，以便调整应用使用户得到更好的用户体验。接下来我们看其它三者之间的关系，我想大家虽然看了前面的View的介绍和SDK中关系UI的基本介绍之后 还是对Android图形窗口十分困惑，看API也是，有WindowMangaer接口和Window类，但是在说明文档中，并未提到如何用这些。但实 际上这里面要去看到Android核心，Android核心底层GDI是SKIA，同chrome是一样的GDI，但是GUI是不一样的。这里面 Android实现的是C/S模式。如下图所示</p><p>image</p><p>从上图，我们可以理出大致的显示过程如下：<br>【1】ActivityManagerService创建Activity线程，激活一个activity<br>【2】系统调用Instrumentation.newActivity创建一个activity<br>【3】Activity创建后，attach到一个新创建的phonewindow中。这样Activity获取一个唯一的WindowManager服务的实例<br>【4】Activity创建过程中使用setcontentView设置用用户UI，这些VIEW被加入到PhoneWindow的ContentParent中。<br>【5】Activity线程继续执行，当执行到Activity.makeVisible是将根view DecoView加入到WindowManger中，WindowManger实全会为每个DecoView创建对应的ViewRoot<br>【6】每个ViewRoot拥有一个Surface，每个Surface将会调用底层库创建图形绘制的内存空间。这个底层库就是SurfaceFlinger。SurfaceFlinger同时也负责将个View绘制的图形合到一块（按照Z轴）显示到用户屏幕。<br>【7】如果用户直接在Canvas上绘制，实际上它直接操作Surface。但对每个View的变更，它是要通知到ViewRoot，然后 ViewRoot获取Canvas。如果绘制完成，surfaceFlinger得到通知，合并Surface成一个Surface到设备屏幕。<br>从上面的图形输出过程分析，我们可以知道真正显示图形的实际上跟Activity没有关系，完全由WindowManager来决定。 WindowManager是一个系统服务，因此可以直接调用这个服务来创建界面，并且更绝的是Dialog、Menu也是有WindowManager 来管理的。另外一个我们也可以看到，最底层都是Surface来，因此，常见开发游戏的人都推荐你使用SurfaceView来创建界面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/hnrainll/
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 编程下 Touch 事件的分发和消费机制</title>
    <link href="http://yoursite.com/2015/08/01/Android-%E7%BC%96%E7%A8%8B%E4%B8%8B-Touch-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2015/08/01/Android-编程下-Touch-事件的分发和消费机制/</id>
    <published>2015-08-01T09:49:07.000Z</published>
    <updated>2018-07-02T06:27:49.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Android 中与 Touch 事件相关的方法包括：dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)、onTouchEvent(MotionEvent ev)；能够响应这些方法的控件包括：ViewGroup、View、Activity。方法与控件的对应关系如下表所示：</p><p>Touch 事件相关方法 方法功能<br>                                                              ViewGroup    View    Activity<br>public boolean dispatchTouchEvent(MotionEvent ev) 事件分发     Yes          Yes      Yes<br>public boolean onInterceptTouchEvent(MotionEvent ev) 事件拦截  Yes          Yes      No<br>public boolean onTouchEvent(MotionEvent ev) 事件响应           Yes          Yes      Yes </p><p>  从这张表中我们可以看到 ViewGroup 和 View 对与 Touch 事件相关的三个方法均能响应，而 Activity 对 onInterceptTouchEvent(MotionEvent ev) 也就是事件拦截不进行响应。另外需要注意的是 View 对 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev) 的响应的前提是可以向该 View 中添加子 View，如果当前的 View 已经是一个最小的单元 View（比如 TextView），那么就无法向这个最小 View 中添加子 View，也就无法向子 View 进行事件的分发和拦截，所以它没有 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev)，只有 onTouchEvent(MotionEvent ev)。</p><h1 id="Touch-事件分析"><a href="#Touch-事件分析" class="headerlink" title="Touch 事件分析"></a>Touch 事件分析</h1><ol><li><p>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</p><p>Touch 事件发生时 Activity 的 dispatchTouchEvent(MotionEvent ev) 方法会以隧道方式（从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递）将事件传递给最外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法，并由该 View 的 dispatchTouchEvent(MotionEvent ev) 方法对事件进行分发。dispatchTouchEvent 的事件分发逻辑如下：</p><p>如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；<br>如果 return false，事件分发分为两种情况：  </p><pre><code>如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；  如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。  </code></pre><p>如果返回系统默认的 super.dispatchTouchEvent(ev)，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。  </p></li><li><p>事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</p><p>在外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法返回系统默认的 super.dispatchTouchEvent(ev) 情况下，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。onInterceptTouchEvent 的事件拦截逻辑如下：</p><p>如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；<br>如果 onInterceptTouchEvent 返回 false，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；<br>如果 onInterceptTouchEvent 返回 super.onInterceptTouchEvent(ev)，事件默认会被拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理。  </p></li><li><p>事件响应：public boolean onTouchEvent(MotionEvent ev)</p><p>在 dispatchTouchEvent 返回 super.dispatchTouchEvent(ev) 并且 onInterceptTouchEvent 返回 true 或返回 super.onInterceptTouchEvent(ev) 的情况下 onTouchEvent 会被调用。onTouchEvent 的事件响应逻辑如下：</p><p>如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。<br>如果返回了 true 则会接收并消费该事件。<br>如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。 </p></li></ol><p>到这里，与 Touch 事件相关的三个方法就分析完毕了。下面的内容会通过各种不同的的测试案例来验证上文中三个方法对事件的处理逻辑。</p><h1 id="Touch-案例介绍"><a href="#Touch-案例介绍" class="headerlink" title="Touch 案例介绍"></a>Touch 案例介绍</h1><p>同样在开始进行案例分析之前，我需要说明测试案例的结构，因为所有的测试都是针对这一个案例来进行的，测试中只是通过修改每个控件中与 Touch 事件相关的三个方法的返回值来体现不同的情况。先来看张图：</p><p>Touch 事件案例布局 UI</p><p>上面的图为测试案例的布局文件 UI 显示效果，布局文件代码如下：</p><p>复制代码</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Android 中与 Touch 事件相关的方法包括：dispatchTouchEvent(MotionEvent ev)、onInterc
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://yoursite.com/2015/08/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/08/01/适配器模式/</id>
    <published>2015-08-01T09:34:49.000Z</published>
    <updated>2018-06-23T15:24:29.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/beyond0525/article/details/22814129" target="_blank" rel="noopener">http://blog.csdn.net/beyond0525/article/details/22814129</a></p><p>适配者模式是也是android中应用很广泛的设计模式，如我们常见用 BaseAdpter, ArrayAdapter, CursorAdapter,就是用的适配者模式，看到源码你是不是对这种设计方式很陌生，没事，下面我们通过实际的例子来取理解这种设计模式。</p><p>一、作用</p><p>适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>二、适用场景</p><ol><li><p>业务的接口与工作的类不兼容，（比如：类中缺少实现接口的某些方法）但又需要两者一起工作</p></li><li><p>在现有接口和类的基础上为新的业务需求提供接口</p></li></ol><p>三、常见的使用方式</p><p>还是以Usb接口和Phone手机类的产品举例子，假设设计的Phone类中有 call(), sms(), takeAlong()属性方法，而在设计Usb接口时定义了 store(), takeAlong()的行为。如果现在有新的业务需求，需要生成 Xiaomi手机类具有 Phone类和Usb接口两者功能，假设Phone类和Usb接口已经在业务上投入使用，很显然，去修改原类中的方法和接口的行为去满足现在的新业务需求是不可取的，那么现在适配者模式就派上用场了。</p><p>（1）类适配模式</p><p>大致的意思是新的业务类Xiaomi通过继承旧业务的类Phone并实现接口Usb来满足新的业务的一种适配方式，如下图</p><p>Usb接口</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public interface Usb {</p><pre><code>void store();  void takeAlong();  </code></pre><p>}<br>Phone类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone {</p><pre><code>public void call() {      System.out.println(&quot;Phone call&quot;);  }  public void sms() {      System.out.println(&quot;Phone sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone takeAlong&quot;);  }  </code></pre><p>}<br>适配 Xiaomi 类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 类的适配器模式<br>* phone + Usb<br>* 将Phone的功能扩展到Usb里<br>* @author xuzhaohu  </p><ul><li><p>*/<br>public class Xiaomi extends Phone implements Usb {</p><p> @Override<br> public void store() {  </p><pre><code>// TODO Auto-generated method stub  System.out.println(&quot;store implements usb&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配完后使用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Xiaomi mi1 = new Xiaomi();<br>mi1.takeAlong();<br>mi1.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>这样新的业务需求就可以通过适配的 Xiaomi类去满足了。是不是觉得很简单呢！！:) 有没有其他的方式去实现同样的功能呢？当然有，就是下面要讲的对象适配模式。<br>（2）对象适配模式</p><p>实现的方式很简单，其实就是在适配的时候通过构造函数将旧的业务Phone 当作新的适配类（XiaomiWrapper）一个成员对象去处理，然后适配类只需要实现接口 Usb即可。如下类关系图</p><p>适配类XiaomiWrapper如下，注意takeAlong()方法，是直接调用原类对象（Phone）去执行的。</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 对象的适配器模式  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public class XiaomiWrapper implements Usb {</p><p> /** </p><ul><li>1.创建一个Wrapper类，持有原类的一个实例， </li><li><p>2.在Wrapper类的方法中，调用实例的方法就行<br>*/<br>private Phone phone;  </p><p>public XiaomiWrapper(Phone phone) {  </p><p> this.phone = phone;<br>}  </p><p>@Override<br>public void store() {<br> // TODO Auto-generated method stub<br> System.out.println(“store implements usb”);  </p><p>}  </p><p>@Override<br>public void takeAlong() {<br> // TODO Auto-generated method stub<br> phone.takeAlong();<br>}  </p></li></ul></li></ul><p>}<br>适配完后通过构造函数将原对象传入即可。<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>XiaomiWrapper mi2 = new XiaomiWrapper(new Phone());<br>mi2.takeAlong();<br>mi2.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>或许到这里，你会觉得这种方式很简单吧。但是如果出现这个Usb接口中有很多方法（大于2个），但是新的业务需求中也只需要其中的一两个，而且是需要适配很多这样的业务，这样的话，用上面的方法每次适配一次就会去实现所有Usb接口中的方法，实际上适配的类中有很多是用不到的，没有必要把接口中不使用的类也适配进去，这时候，就轮到下面的接口适配模式出场了。</p><p>（3）接口适配模式</p><p>适配新的业务需求的时候借助抽象实现类（AbsPhone实现Usb接口），也就说，抽象实现类把Usb接口中的行为都实现了，新的适配是需要跟抽象类对话就行，因为抽象实现类就能满足了所有适配的需求，并且做到了只适配业务本身的行为，接口中不需要的行为我根本不需要关注。这就是抽象实现类的作用。类图关系如下：</p><p>抽象类AbsPhone实现</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 接口的适配器模式<br>* 1.借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法<br>* 2.继承类可以选择性的实现接口中的方法  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public abstract class AbsPhone implements Usb {</p><p> public void store() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s store methond&quot;);  </code></pre><p> }  </p><p> public void takeAlong() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s takeAlong methond&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配类只跟AbsPhone打交道，根本不需要关心接口的行为，只显示自己所要关注的。<br>如Phone1适配只需要store()行为</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone1 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone1 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone1 sms&quot;);  }  public void store() {      System.out.println(&quot;Phone1 need usb&apos;s store methond&quot;);  }  </code></pre><p>}<br>Phone2适配只需要takeAlong()行为<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone2 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone2 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone2 sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone2 need usb&apos;s takeAlong methond&quot;);  }  </code></pre><p>}<br>实例化调用<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p2.takeAlong();<br>输出：<br>Phone1 need usb’s store methond<br>Phone2 need usb’s takeAlong methond<br>来一次完整的调用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p1.takeAlong();<br>p2.takeAlong();<br>p2.store();<br>输出：<br>Phone1 need usb’s store methond<br>AbsPhone implements usb’s takeAlong methond<br>Phone2 need usb’s takeAlong methond<br>AbsPhone implements usb’s store methond<br>这样很清晰的知道适配的什么方法了。</p><p>总结：适配者模式在android源码中有很多这样的体现，大家看完这个再去看源码，是不是会感觉看懂了不少呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/beyond0525/article/details/22814129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/beyond0525/article
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://yoursite.com/2015/08/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/08/01/观察者模式/</id>
    <published>2015-08-01T05:21:22.000Z</published>
    <updated>2018-06-23T15:24:29.019Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html</a></p><ol><li><p>概述</p><p>　　有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></li><li><p>解决的问题</p><p>　　将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p></li><li><p>模式中的角色</p><p>　　3.1 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><p>　　3.2 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p><p>　　3.3 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p><p>　　3.4 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p></li><li><p>模式解读</p><p>　　4.1 观察者模式的类图　　</p><p>　　4.2 观察者模式的代码</p></li></ol><p>复制代码<br>///<br>/// 抽象主题类<br>///<br>public abstract class Subject<br>{<br>private IList observers = new List();</p><pre><code>    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(Observer observer)    {        observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(Observer observer)    {        observers.Remove(observer);    }    /// &lt;summary&gt;    /// 向观察者（们）发出通知    /// &lt;/summary&gt;    public void Notify()    {        foreach (Observer o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己/// &lt;/summary&gt;public abstract class Observer{    public abstract void Update();}/// &lt;summary&gt;/// 具体观察者或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。/// &lt;/summary&gt;public class ConcreteSubject : Subject{    private string subjectState;    /// &lt;summary&gt;    /// 具体观察者的状态    /// &lt;/summary&gt;    public string SubjectState    {        get { return subjectState; }        set { subjectState = value; }    }}/// &lt;summary&gt;/// 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调/// &lt;/summary&gt;public class ConcreteObserver : Observer{    private string observerState;    private string name;    private ConcreteSubject subject;    /// &lt;summary&gt;    /// 具体观察者用一个具体主题来实现    /// &lt;/summary&gt;    public ConcreteSubject Subject    {        get { return subject; }        set { subject = value; }    }    public ConcreteObserver(ConcreteSubject subject, string name)    {        this.subject = subject;        this.name = name;    }    /// &lt;summary&gt;    /// 实现抽象观察者中的更新操作    /// &lt;/summary&gt;    public override void Update()    {        observerState = subject.SubjectState;        Console.WriteLine(&quot;The observer&apos;s state of {0} is {1}&quot;, name, observerState);    }}</code></pre><p>复制代码<br>　　4.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{<br>// 具体主题角色通常用具体自来来实现<br>ConcreteSubject subject = new ConcreteSubject();</p><pre><code>        subject.Attach(new ConcreteObserver(subject, &quot;Observer A&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer B&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer C&quot;));        subject.SubjectState = &quot;Ready&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　运行结果</p><ol><li><p>模式总结</p><p>　　5.1 优点</p><p>　　　　5.1.1 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p><p>　　5.2 缺点</p><p>　　　　5.2.1 依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p><p>　　5.3 适用场景</p><p>　　　　5.3.1 当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。</p><p>　　　　5.3.2 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p></li><li><p>模式引申，应用C#中的事件委托来彻底解除通知者和观察者之间的耦合。</p><p>　　　6.1 关于委托的定义：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的。</p><p>　　　6.2 关于事件：事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。</p></li><li><p>下面例子分别用观察者模式，事件机制来实现</p><p>　　7.1 实例描述：客户支付了订单款项，这时财务需要开具发票，出纳需要记账，配送员需要配货。</p><p>　　7.2 观察者模式的实现</p><p>　　　　7.2.1 类图</p><p>　　　　7.2.2 代码实现</p></li></ol><p>复制代码<br>///<br>/// 抽象观察者<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 工作岗位，作为这里的观察者的抽象/// &lt;/summary&gt;public abstract class JobStation{    public abstract void Update();}/// &lt;summary&gt;/// 具体主题，这里是客户/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    private IList&lt;JobStation&gt; observers = new List&lt;JobStation&gt;();    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(JobStation observer)    {        this.observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(JobStation observer)    {        this.observers.Remove(observer);    }    /// &lt;summary&gt;    /// 客户状态    /// &lt;/summary&gt;    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }    public void Notify()    {        foreach (JobStation o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 会计/// &lt;/summary&gt;public class Accountant : JobStation{    private string accountantState;    private Customer customer;    public Accountant(Customer customer)    {        this.customer = customer;    }    /// &lt;summary&gt;    /// 更新状态    /// &lt;/summary&gt;    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);            accountantState = &quot;已开发票&quot;;        }    }}/// &lt;summary&gt;/// 出纳/// &lt;/summary&gt;public class Cashier : JobStation{    private string cashierState;    private Customer customer;    public Cashier(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);            cashierState = &quot;已入账&quot;;        }    }}/// &lt;summary&gt;/// 配送员/// &lt;/summary&gt;public class Dilliveryman : JobStation{    private string dillivierymanState;    private Customer customer;    public Dilliveryman(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是配送员，我来发货。&quot;);            dillivierymanState = &quot;已发货&quot;;        }    }}</code></pre><p>复制代码<br>　　　　7.2.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        subject.Attach(new Accountant(subject));        subject.Attach(new Cashier(subject));        subject.Attach(new Dilliveryman(subject));        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果：</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p><p>　　7.3 事件实现</p><p>　　　　7.3.1 类图</p><p>　　　　通过类图来看，观察者和主题之间已经不存在任何依赖关系了。</p><p>　　　　7.3.2 代码实现</p><p>复制代码<br>///<br>/// 抽象主题<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 声明委托/// &lt;/summary&gt;public delegate void CustomerEventHandler();/// &lt;summary&gt;/// 具体主题/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    // 声明一个委托事件，类型为 CustomerEventHandler    public event CustomerEventHandler Update;    public void Notify()    {        if (Update != null)        {            // 使用事件来通知给订阅者            Update();        }    }    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }}/// &lt;summary&gt;/// 财务，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Accountant{    private string accountantState;    public Accountant()    { }    /// &lt;summary&gt;    /// 开发票    /// &lt;/summary&gt;    public void GiveInvoice()    {        Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);        accountantState = &quot;已开发票&quot;;    }}/// &lt;summary&gt;/// 出纳，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Cashier{    private string cashierState;    public void Recoded()    {        Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);        cashierState = &quot;已入账&quot;;    }}/// &lt;summary&gt;/// 配送员，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Dilliveryman{    private string dillivierymanState;    public void Dilliver()    {        Console.WriteLine(&quot;我是配送员，我来发货。&quot;);        dillivierymanState = &quot;已发货&quot;;    }}</code></pre><p>复制代码<br>　　　　7.3.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        Accountant accountant = new Accountant();        Cashier cashier = new Cashier();        Dilliveryman dilliveryman = new Dilliveryman();        // 注册事件        subject.Update += accountant.GiveInvoice;        subject.Update += cashier.Recoded;        subject.Update += dilliveryman.Dilliver;        /*         * 以上写法也可以用下面代码来替换        subject.Update += new CustomerEventHandler(accountant.GiveInvoice);        subject.Update += new CustomerEventHandler(cashier.Recoded);        subject.Update += new CustomerEventHandler(dilliveryman.Dilliver);         */        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/wangjq/arch
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2015/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2015/08/01/单例模式/</id>
    <published>2015-08-01T04:55:35.000Z</published>
    <updated>2018-06-23T15:24:28.881Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="noopener">http://cantellow.iteye.com/blog/838473</a></p><p>第一种（懒汉，线程不安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}</p><pre><code>public static Singleton getInstance() {  if (instance == null) {      instance = new Singleton();  }  return instance;  }  </code></pre><p>}</p><p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。<br>第二种（懒汉，线程安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}<br>public static synchronized Singleton getInstance() {<br>if (instance == null) {<br>instance = new Singleton();<br>}<br>return instance;<br>}<br>}</p><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。<br>第三种（饿汉）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance = new Singleton();<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return instance;<br>}<br>}</p><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。<br>第四种（饿汉，变种）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private Singleton instance = null;<br>static {<br>instance = new Singleton();<br>}<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return this.instance;<br>}<br>}</p><p>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance。<br>第五种（静态内部类）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static class SingletonHolder {<br>private static final Singleton INSTANCE = new Singleton();<br>}<br>private Singleton (){}<br>public static final Singleton getInstance() {<br>return SingletonHolder.INSTANCE;<br>}<br>}</p><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。<br>第六种（枚举）：</p><p>Java代码 收藏代码<br>public enum Singleton {<br>INSTANCE;<br>public void whateverMethod() {<br>}<br>}</p><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。<br>第七种（双重校验锁）：<br>Java代码 收藏代码<br>public class Singleton {<br>private volatile static Singleton singleton;<br>private Singleton (){}<br>public static Singleton getSingleton() {<br>if (singleton == null) {<br>synchronized (Singleton.class) {<br>if (singleton == null) {<br>singleton = new Singleton();<br>}<br>}<br>}<br>return singleton;<br>}<br>}</p><p>这个是第二种方式的升级版，俗称双重检查锁定，详细介绍请查看：<a href="http://www.ibm.com/developerworks/cn/java/j-dcl.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-dcl.html</a><br>在JDK1.5之后，双重检查锁定才能够正常达到单例效果。</p><p>总结<br>有两个问题需要注意：<br>1.如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>2.如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>对第一个问题修复的办法是：</p><p>Java代码 收藏代码<br>private static Class getClass(String classname)<br>throws ClassNotFoundException {<br>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</p><pre><code>if(classLoader == null)        classLoader = Singleton.class.getClassLoader();     return (classLoader.loadClass(classname));     </code></pre><p>}<br>}<br>对第二个问题修复的办法是：</p><p>Java代码 收藏代码<br>public class Singleton implements java.io.Serializable {<br>public static Singleton INSTANCE = new Singleton();</p><p>protected Singleton() {</p><p>}<br>private Object readResolve() {<br>return INSTANCE;<br>}<br>}</p><h1 id="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。"><a href="#对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。" class="headerlink" title="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。"></a>对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。</h1><p>superheizai同学总结的很到位：</p><p>不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://cantellow.iteye.com/blog/838473&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cantellow.iteye.com/blog/838473&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一种（懒汉，
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中堆内存和栈内存详解</title>
    <link href="http://yoursite.com/2015/07/29/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2015/07/29/Java中堆内存和栈内存详解/</id>
    <published>2015-07-29T14:20:41.000Z</published>
    <updated>2018-06-23T15:24:29.018Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html" target="_blank" rel="noopener">http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html</a></p><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。<br>堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。<br>引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p><p>java中内存分配策略及堆和栈的比较</p><p>　　1 内存分配策略</p><p>　　按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.</p><p>　　静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.</p><p>　　栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。</p><p>　　静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.</p><p>　　2 堆和栈的比较</p><p>　　上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈:</p><p>　　从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的:</p><p>　　在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时.</p><p>　　堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~).</p><p>　　3 JVM中的堆和栈</p><p>　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>　　我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.</p><p>　　从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p><p>　　每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p><p>　　Java 中的堆和栈</p><p>　　Java把内存划分成两种：一种是栈内存，一种是堆内存。</p><p>　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</p><p>　　当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p>　　堆内存用来存放由new创建的对象和数组。</p><p>　　在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p>　　在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。</p><p>　　引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><p>　　具体的说：</p><p>　　栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。</p><p>　　栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p><p>　　int a = 3;</p><p>　　int b = 3;</p><p>　　编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/whgw/archive/
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>android数字签名</title>
    <link href="http://yoursite.com/2015/07/22/android%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>http://yoursite.com/2015/07/22/android数字签名/</id>
    <published>2015-07-22T02:33:38.000Z</published>
    <updated>2018-06-23T15:24:29.018Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.oschina.net/question/157182_45890" target="_blank" rel="noopener">http://www.oschina.net/question/157182_45890</a></p><p>Android系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系,如果一个permission的protectionLevel为signature，那么就只有那些跟该permission所在的程序拥有同一个数字证书的应用程序才能取得该权限。Android使用Java的数字证书相关的机制来给apk加盖数字证书，要理解android的数字证书，需要先了解以下数字证书的概念和java的数字证书机制。Android系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字证书并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。<br>同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。</p><p>(1)有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。</p><p>(2)有利于程序的模块化设计和开发。Android系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。</p><p>(3)可以通过权限(permission)的方式在多个程序间共享数据和代码。Android提供了基于数字证书的权限赋予机制，应用程序可以和其他的程序共享概功能或者数据给那那些与自己拥有相同数字证书的程序。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。</p><p>在签名时，需要考虑数字证书的有效期：</p><p>(1)数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。</p><p>(2)如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。</p><p>(3)Android Market强制要求所有应用程序数字证书的有效期要持续到2033年10月22日以后。</p><p>Android数字证书包含以下几个要点：</p><pre><code>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。(5)Android使用标准的java工具 Keytool and Jarsigner 来生成数字证书，并给应用程序包签名。（6）使用zipalign优化程序。</code></pre><p>Android系统不会安装运行任何一款未经数字签名的apk程序，无论是在模拟器上还是在实际的物理设备上。Android的开发工具(ADT插件和Ant)都可以协助开发者给apk程序签名，它们都有两种模式：调试模式(debug mode)和发布模式(release mode)。</p><p>在调试模式下，android的开发工具会在每次编译时使用调试用的数字证书给程序签名，开发者无须关心。</p><p>当要发布程序时，开发者就需要使用自己的数字证书给apk包签名，可以有两种方法。</p><p>(1)在命令行下使用JDK中的和Keytool(用于生成数字证书)和Jarsigner(用于使用数字证书签名)来给apk包签名。</p><p>(2)使用ADT Export Wizard进行签名(如果没有数字证书可能需要生成数字证书)。</p><p>使用Keytool和Jarsigner给程序签名</p><p>命令：keytool -genkey -v -keystore android.keystore -alias android -keyalg RSA -validity 20000</p><p>该命令中，-keystore ophone.keystore 表示生成的证书，可以加上路径（默认在用户主目录下）；-alias ophone 表示证书的别名是ophone；-keyalg RSA 表示采用的RSA算法；-validity 20000表示证书的有效期是20000天。</p><p>image</p><p>此时，我们会在互用主目录下看到ophone.keystore，即我们刚刚创建的证书。</p><p>接着对程序进行签名：</p><p>jarsigner用法： [选项] jar 文件别名<br>jarsigner -verify [选项] jar 文件</p><p>执行：jarsigner -verbose -keystore android.keystore -signedjar android123_signed.apk android123.apk android 就可以生成签名的apk文件，这里输入文件android123.apk，最终生成android123_signed.apk为Android签名后的APK执行文件。下面提示输入的密码和keytool输入的一样就行了。（不过在我的JDK目录下没有找到jarsigner这个程序，不知道是怎么回事）</p><p>image</p><p>使用ADT Export Wizard进行签名</p><p>应用程序（apk）签名,在EC中，右键单击应用程序工程，如图选择</p><p>image</p><p>选择证书的存放路径，填写相关资料，完成，即可生成被签名的apk文件。如下图所示：</p><p>image</p><p>如上图所示，我们可以看到也可以在这里选择”Create new keystore“来创建一个证书。输入密码，点击下一步，填写相关信息，如下图所示。</p><p>image</p><p>使用zipalign优化APK</p><p>根据官方文档的描述，Android系统中Application的数据都保存在它的APK文件中，同时可以被多个进程访问，安装的过程包括如下几个步骤：</p><p>Installer通过每个apk的manifest文件获取与当前应用程序相关联的permissions信息<br>Home application读取当前APK的Name和Icon等信息。<br>System server将读取一些与Application运行相关信息，例如：获取和处理Application的notifications请求等。<br>最后，APK所包含的内容不仅限于当前Application所使用，而且可以被其它的Application调用，提高系统资源的可复用性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.oschina.net/question/157182_45890&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.oschina.net/question/157182_45890&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>android的task任务栈</title>
    <link href="http://yoursite.com/2015/07/22/android%E7%9A%84task%E4%BB%BB%E5%8A%A1%E6%A0%88/"/>
    <id>http://yoursite.com/2015/07/22/android的task任务栈/</id>
    <published>2015-07-22T01:23:27.000Z</published>
    <updated>2018-06-23T15:24:27.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/CSU-PL/p/3794280.html" target="_blank" rel="noopener">http://www.cnblogs.com/CSU-PL/p/3794280.html</a></p><p>上次我们讲到Activity的四种启动模式的时候，已经了解到一些关于task的技术，今天我再向大家介绍一下。task是一个具有栈结构的容器，可以放置多个Activity实例。启动一个应用，系统就会为之创建一个task，来放置根Activity；默认情况下，一个Activity启动另一个Activity时，两个Activity是放置在同一个task中的，后者被压入前者所在的task栈，当用户按下后退键，后者从task被弹出，前者又显示在幕前，特别是启动其他应用中的Activity时，两个Activity对用户来说就好像是属于同一个应用；系统task和task之间是互相独立的，当我们运行一个应用时，按下Home键回到主屏，启动另一个应用，这个过程中，之前的task被转移到后台，新的task被转移到前台，其根Activity也会显示到幕前，过了一会之后，在此按下Home键回到主屏，再选择之前的应用，之前的task会被转移到前台，系统仍然保留着task内的所有Activity实例，而那个新的task会被转移到后台，如果这时用户再做后退等动作，就是针对该task内部进行操作了。</p><p>我们今天就讲一下和task相关的知识，主要分一下几点：</p><p>1.Activity的affinity(亲和力)</p><p>2.Intent几种常见的flags</p><p>3.与task相关属性</p><p>affinity：</p><p>task对于Activity来说就好像它的身份证一样，可以告诉所在的task，自己属于这个task中的一员；拥有相同affinity的多个Activity理论同属于一个task，task自身的affinity决定于根Activity的affinity值。affinity在什么场合应用呢？1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合工作）；2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task。我们会在后面进行详细讲解。</p><p>默认情况下，一个应用内的所有Activity都具有相同的affinity，都是从Application（参考的taskAffinity属性）继承而来，而Application默认的affinity是中的包名，我们可以为设置taskAffinity属性值，这样可以应用到下的所有，也可以单独为某个Activity设置taskAffinity。例如：在系统自带的Browser中，package为com.android.browser，但是却自定义一个taskAffinity属性值：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/CSU-PL/p/3794280.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/CSU-PL/p/3794280.html&lt;/a&gt;&lt;/p
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发如何做内存优化</title>
    <link href="http://yoursite.com/2015/07/22/Android-%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2015/07/22/Android-开发如何做内存优化/</id>
    <published>2015-07-22T00:50:06.000Z</published>
    <updated>2018-07-04T03:09:37.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>   不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。  </p><p>   Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。  </p><h1 id="引用没释放造成的内存泄露"><a href="#引用没释放造成的内存泄露" class="headerlink" title="引用没释放造成的内存泄露"></a>引用没释放造成的内存泄露</h1><h2 id="注册没取消造成的内存泄露"><a href="#注册没取消造成的内存泄露" class="headerlink" title="注册没取消造成的内存泄露"></a>注册没取消造成的内存泄露</h2><p>　　这种Android的内存泄露比纯java的内存泄露还要严重，因为其他一些Android程序可能引用我们的Anroid程序的对象（比如注册机制）。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄露的内存依然不能被垃圾回收。<br>比如示例1:<br>　　假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>　　但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。<br>　　虽然有些系统程序，它本身好像是可以自动取消注册的（当然不及时），但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。</p><h2 id="集合中对象没清理造成的内存泄露"><a href="#集合中对象没清理造成的内存泄露" class="headerlink" title="集合中对象没清理造成的内存泄露"></a>集合中对象没清理造成的内存泄露</h2><p>　　我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。  </p><h1 id="资源对象没关闭造成的内存泄露"><a href="#资源对象没关闭造成的内存泄露" class="headerlink" title="资源对象没关闭造成的内存泄露"></a>资源对象没关闭造成的内存泄露</h1><p>　　资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。因为有些资源性对象，比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭），如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>　　程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。  </p><h1 id="一些不良代码成内存压力"><a href="#一些不良代码成内存压力" class="headerlink" title="一些不良代码成内存压力"></a>一些不良代码成内存压力</h1><p>　　有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存，对内存的回收和分配造成很大影响的，容易迫使虚拟机不得不给该应用进程分配更多的内存，造成不必要的内存开支。  </p><h2 id="Bitmap没调用recycle"><a href="#Bitmap没调用recycle" class="headerlink" title="Bitmap没调用recycle()"></a>Bitmap没调用recycle()</h2><p>　　Bitmap对象在不使用时,我们应该先调用recycle()释放内存，然后才它设置为null.虽然recycle()从源码上看，调用它应该能立即释放Bitmap的主要内存，但是测试结果显示它并没能立即释放内存。但是我它应该还是能大大的加速Bitmap的主要内存的释放。 </p><h2 id="构造Adapter时，没有使用缓存的-convertView"><a href="#构造Adapter时，没有使用缓存的-convertView" class="headerlink" title="构造Adapter时，没有使用缓存的 convertView"></a>构造Adapter时，没有使用缓存的 convertView</h2><p>　　以构造ListView的BaseAdapter为例，在BaseAdapter中提共了方法：<br>public View getView(int position, View convertView, ViewGroup parent)来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>　　由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费时间，也造成内存垃圾，给垃圾回收增加压力，如果垃圾回收来不及的话，虚拟机将不得不给该应用进程分配更多的内存，造成不必要的内存开支。ListView回收list item的view对象的过程可以查看:<br>view plaincopy to clipboardprint?<br>android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。</p><p>示例代码：</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = new Xxx(…);<br>4<br>5 … …<br>6<br>7 return view;<br>8<br>9 }<br>复制代码<br>修正示例代码：</p><p>Android内存管理</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = null;<br>4<br>5 if (convertView != null) {<br>6<br>7 view = convertView;<br>8<br>9 populate(view, getItem(position));<br>10<br>11 …<br>12<br>13 } else {<br>14<br>15 view = new Xxx(…);<br>16<br>17 …<br>18<br>19 }<br>20<br>21 return view;<br>22<br>23 }<br>复制代码  </p><p>概述：<br>　　在android的开发中，要时刻主要内存的分配和垃圾回收，因为系统为每一个dalvik虚拟机分配的内存是有限的，在google的G1中，分配的最大堆大小只有16M，后来的机器一般都为24M，实在是少的可怜。这样就需要我们在开发过程中要时刻注意。不要因为自己的代码问题而造成OOM错误。  </p><pre><code>JAVA的内存管理：  </code></pre><p>　　大家都知道，android应用层是由java开发的，android的davlik虚拟机与jvm也类似，只不过它是基于寄存器的。因此要了解android的内存管理就必须得了解java的内存分配和垃圾回收机制。<br>　　在java中，是通过new关键字来为对象分配内存的，而内存的释放是由垃圾收集器（GC）来回收的，工程师在开发的过程中，不需要显式的去管理内存。但是这样有可能在不知不觉中就会浪费了很多内存，最终导致java虚拟机花费很多时间去进行垃圾回收，更严重的是造成JVM的OOM。因此，java工程师还是有必要了解JAVA的内存分配和垃圾回收机制。</p><p>内存结构<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6926.png<br>上面这张图是JVM的结构图，它主要四个部分组成：Class Loader子系统和执行引擎，运行时方法区和本地方法区，我们主要来看下RUNTIME DATA AREA区，也就是我们常说的JVM内存。从图中可以看出，RUNTIMEDATA AREA区主要由5个部分组成：<br>· Method Area:被装载的class的元信息存储在Method Area中，它是线程共享的<br>· Heap(堆)：一个java虚拟机实例中只存在一个堆空间，存放一些对象信息，它是线程共享的<br>· Java栈： java虚拟机直接对java栈进行两种操作，以帧为单位的压栈和出栈（非线程共享）<br>· 程序计数器（非线程共享）<br>· 本地方法栈（非线程共享）</p><p>JVM的垃圾回收（GC）<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-12485.png<br>JVM的垃圾原理是这样的，它把对象分为年轻代（Young）、年老代（Tenured）、持久代（Perm），对不同生命周期的对象使用不同的垃圾回收算法。<br>· 年轻代(Young)<br>年轻代分为三个区，一个eden区，两个Survivor区。程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满了时，此区存活的对象又被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。<br>· 年老代（Tenured）<br>年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的对象生命周期都比较长。<br>· 持久代（Perm）<br>用于存放静态的类和方法，持久代对垃圾回收没有显著的影响。<br>Android中内存泄露监测<br>在了解了JVM的内存管理后，我们再回过头来看看，在android中应该怎样来监测内存，从而看在应用中是否存在内存分配和垃圾回收问题而造成内存泄露情况。<br>在android中，有一个相对来说还不错的工具，可以用来监测内存是否存在泄露情况：DDMS—Heap<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-22715.png<br>使用方法比较简单：<br>· 选择DDMS视图，并打开Devices视图和Heap视图<br>· 点击选择要监控的进程，比如：上图中我选择的是system_process<br>· 选中Devices视图界面上的”update heap” 图标<br>· 点击Heap视图中的”Cause GC” 按钮（相当于向虚拟机发送了一次GC请求的操作）<br>在Heap视图中选择想要监控的Type，一般我们会观察dataobject的 total size的变化，正常情况下total size的值会稳定在一个有限的范围内，也就说程序中的代码良好，没有造成程序中的对象不被回收的情况。如果代码中存在没有释放对象引用的情况，那么data object的total size在每次GC之后都不会有明显的回落，随着操作次数的增加而total size也在不断的增加。（说明：选择好data object后，不断的操作应用，这样才可以看出total size的变化）。如果totalsize确实是在不断增加而没有回落，说明程序中有没有被释放的资源引用。那么我们应该怎么来定位呢？<br>Android中内存泄露定位<br>Mat(memory analyzer tools)是我们常用的用来定位内存泄露的工具，如果你使用ADT，并且安装了MAT的eclipse插件，你需要做的是进入DDMS视图的Devices视图：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-2165.png<br>点击”dump HPROF file”按钮，然后使用MAT分析下载下来的文件。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6565.png</p><p>下面列出了存在的问题，点击detail进去，会列出详细的，可能会存在问题的代码：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-32625.png<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-21158.png<br>关于MAT的使用可以参考：<a href="http://www.blogjava.net/rosen/" target="_blank" rel="noopener">http://www.blogjava.net/rosen/</a> … .html<br>这位兄弟写的比较详细。</p><p>总结</p><p>不管是java还是android，都应该了解内存分配和垃圾回收机制，工程师要做到写的代码中没有bad code很难，关键是在出现问题的时候该怎么去排查Android内存优化  </p><p>一、 Android的内存机制<br>　　Android的程序由Java语言编写，所以Android的内存管理与Java的内存管理相似。程序员通过new为对象分配内存，所有对象在java堆内分配空间；然而对象的释放是由垃圾回收器来完成的。C／C++中的内存机制是“谁污染，谁治理”，java的就比较人性化了，给我们请了一个专门的清洁工（GC）。<br>　　那么GC怎么能够确认某一个对象是不是已经被废弃了呢？Java采用了有向图的原理。Java将引用关系考虑为图的有向边，有向边从引用者指向引用对象。线程对象可以作为有向图的起始顶点，该图就是从起始顶点开始的一棵树，根顶点可以到达的对象都是有效对象，GC不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被GC回收。<br>二、Android的内存溢出<br>Android的内存溢出是如何发生的?<br>　　Android的虚拟机是基于寄存器的Dalvik，它的最大堆大小一般是16M，有的机器为24M。因此我们所能利用的内存空间是有限的。如果我们的内存占用超过了一定的水平就会出现OutOfMemory的错误。<br>为什么会出现内存不够用的情况呢？我想原因主要有两个：</p><p>由于我们程序的失误，长期保持某些资源（如Context）的引用，造成内存泄露，资源造成得不到释放。</p><p>保存了多个耗用内存过大的对象（如Bitmap），造成内存超出限制。</p><p>三、万恶的static<br>　　static是Java中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用static修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context的情况最多），这时就要谨慎对待了。</p><p>复制代码<br>1 public class ClassName {<br>2<br>3 private static Context mContext;<br>4<br>5 //省略<br>6<br>7 }<br>复制代码<br>　　以上的代码是很危险的，如果将Activity赋值到么mContext的话。那么即使该Activity已经onDestroy，但是由于仍有对象保存它的引用，因此该Activity依然不会被释放。<br>我们举Android文档中的一个例子。</p><p>复制代码<br>private static Drawable sBackground;</p><p>@Override</p><p>protected void onCreate(Bundle state) {</p><p>super.onCreate(state);</p><p>TextView label = new TextView(this);</p><p>label.setText(“Leaks are bad”);</p><p>if (sBackground == null) {</p><pre><code>sBackground = getDrawable(R.drawable.large_bitmap);  </code></pre><p>}</p><p>label.setBackgroundDrawable(sBackground);</p><p>setContentView(label);</p><p>}<br>复制代码<br>　　sBackground是一个静态的变量，但是我们发现，我们并没有显式的保存Contex的引用，但是，当Drawable与View连接之后，Drawable就将View设置为一个回调，由于View中是包含Context的引用的，所以，实际上我们依然保存了Context的引用。这个引用链如下：<br>Drawable-&gt;TextView-&gt;Context<br>　　所以，最终该Context也没有得到释放，发生了内存泄露。<br>如何才能有效的避免这种引用的发生呢？</p><p>应该尽量避免static成员变量引用资源耗费过多的实例，比如Context。</p><p>Context尽量使用Application Context，因为Application的Context的生命周期比较长，引用它不会出现内存泄露的问题。</p><p>使用WeakReference代替强引用。比如可以使用WeakReference mContextRef;</p><p>该部分的详细内容也可以参考Android文档中Article部分。<br>四、都是线程惹的祸<br>　　线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。</p><p>复制代码<br>1 public class MyActivity extends Activity {<br>2<br>3 @Override<br>4<br>5 public void onCreate(Bundle savedInstanceState) {<br>6<br>7 super.onCreate(savedInstanceState);<br>8<br>9 setContentView(R.layout.main);<br>10<br>11 new MyThread().start();<br>12<br>13 }<br>14<br>15<br>16 private class MyThread extends Thread{<br>17<br>18 @Override<br>19<br>20 public void run() {<br>21<br>22 super.run();<br>23<br>24 //do somthing<br>25<br>26 }<br>27<br>28 }<br>29<br>30 }<br>复制代码<br>　　这段代码很平常也很简单，是我们经常使用的形式。我们思考一个问题：假设MyThread的run函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏，一般情况下当屏幕转换时会重新创建Activity，按照我们的想法，老的Activity应该会被销毁才对，然而事实上并非如此。<br>　　由于我们的线程是Activity的内部类，所以MyThread中保存了Activity的一个引用，当MyThread的run函数没有结束时，MyThread是不会被销毁的，因此它所引用的老的Activity也不会被销毁，因此就出现了内存泄露的问题。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6439.png<br>　　有些人喜欢用Android提供的AsyncTask，但事实上AsyncTask的问题更加严重，Thread只有在run函数不结束时才出现这种内存泄露问题，然而AsyncTask内部的实现机制是运用了ThreadPoolExcutor,该类产生的Thread对象的生命周期是不确定的，是应用程序无法控制的，因此如果AsyncTask作为Activity的内部类，就更容易出现内存泄露的问题。<br>这种线程导致的内存泄露问题应该如何解决呢？</p><p>将线程的内部类，改为静态内部类。</p><p>在线程内部采用弱引用保存Context引用。</p><p>解决的模型如下：</p><p>复制代码<br>1 public abstract class WeakAsyncTask</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/kingOfPointer/archive/2012/12/21/2828018.html" target="_blank" rel="noopener">android 开发如何做内存优化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;   不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 内存" scheme="http://yoursite.com/tags/Android-%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Linux脚本编写基础</title>
    <link href="http://yoursite.com/2015/06/29/Linux%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2015/06/29/Linux脚本编写基础/</id>
    <published>2015-06-29T06:23:08.000Z</published>
    <updated>2018-07-01T12:53:39.124Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍shell脚本编写的基础语法，开头、注释、变量和 环境变量，虽然不涉及具体东西，但打好基础确是最为关键的。<br>本文是一篇在学习中的文章，还没学习完，排版也还有一些问题，待继续</p><h1 id="shell脚本编写初步介绍"><a href="#shell脚本编写初步介绍" class="headerlink" title="shell脚本编写初步介绍"></a>shell脚本编写初步介绍</h1><p>##开头程序必须以下面的行开始（必须方在文件的第一行）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure></p><p>符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br>要使脚本可执行：<br>编译 chmod +x filename 这样才能用./filename 来运行  </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>　　以#开头的句子表示注释，直到这一行的结束。  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#对变量赋值：</span></span><br><span class="line">a=<span class="string">"hello world"</span> 首先输入的应该是包含减号的参数.</span><br><span class="line"><span class="comment"># 现在打印变量a的内容： </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A is:"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure></p><p>有时候变量名很容易与其他文字混淆，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"this is the <span class="variable">$numnd</span>"</span></span><br></pre></td></tr></table></figure></p><p>这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：</p><p>num=2<br>echo “this is the {num}nd”</p><p>这将打印： this is the 2nd</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。</p><h2 id="Shell命令和流程控制"><a href="#Shell命令和流程控制" class="headerlink" title="Shell命令和流程控制"></a>Shell命令和流程控制</h2><p>在shell脚本中可以使用三类命令：     </p><h3 id="1-Unix-命令"><a href="#1-Unix-命令" class="headerlink" title="1)Unix 命令:"></a>1)Unix 命令:</h3><p>　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。<br>常用命令语法及功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="built_in">echo</span> “some text”: 将文字内容打印在屏幕上     </span><br><span class="line">　　ls: 文件列表     </span><br><span class="line">　　wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数     </span><br><span class="line">　　cp sourcefile destfile: 文件拷贝     </span><br><span class="line">　　mv oldname newname : 重命名文件或移动文件     </span><br><span class="line">　　rm file: 删除文件     </span><br><span class="line">　　grep ‘pattern’ file: 在文件内搜索字符串比如：grep ‘searchstring’ file.txt     </span><br><span class="line">　　cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆,这是两个完全不同的命令     </span><br><span class="line">　　cat file.txt: 输出文件内容到标准输出设备（屏幕）上     </span><br><span class="line">　　file somefile: 得到文件类型     </span><br><span class="line">　　<span class="built_in">read</span> var: 提示用户输入，并将输入赋值给变量     </span><br><span class="line">　　sort file.txt: 对file.txt文件中的行进行排序     </span><br><span class="line">　　uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq     </span><br><span class="line">　　expr: 进行数学运算Example: add 2 and 3expr 2 “+” 3     </span><br><span class="line">　　find: 搜索文件比如：根据文件名搜索find . -name filename -<span class="built_in">print</span>     </span><br><span class="line">　　tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile     </span><br><span class="line">　　basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux     </span><br><span class="line">　　dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin     </span><br><span class="line">　　head file: 打印文本文件开头几行     </span><br><span class="line">　　tail file : 打印文本文件末尾几行     </span><br><span class="line">　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为LinuxFocus ：cat text.file | sed ‘s/linuxfocus/LinuxFocus/’ &gt; newtext.file     </span><br><span class="line">　　awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk -F, <span class="string">'&#123;print $1 "," $3 &#125;'</span></span><br></pre></td></tr></table></figure><p>这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA</p><h3 id="2-概念-管道-重定向和-backtick-这些不是系统命令，但是他们真的很重要。"><a href="#2-概念-管道-重定向和-backtick-这些不是系统命令，但是他们真的很重要。" class="headerlink" title="2) 概念: 管道, 重定向和 backtick 这些不是系统命令，但是他们真的很重要。"></a>2) 概念: 管道, 重定向和 backtick 这些不是系统命令，但是他们真的很重要。</h3><p>　　管道 (|) 将一个命令的输出作为另外一个命令的输入。<br>grep “hello” file.txt | wc -l<br>　　在file.txt中搜索包含有”hello”的行并计算其行数。<br>　　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br>　　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br>　　> 写入文件并覆盖旧文件<br>　　&gt;> 加到文件的尾部，保留旧文件内容。<br>反短斜线<br>　 使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br>命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>　　用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># The ticks are backticks (`) not normal quotes ('):</span></span><br><span class="line">tar -zcvf lastmod.tar.gz `find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span>`</span><br></pre></td></tr></table></figure><h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3) 流程控制"></a>3) 流程控制</h3><ol><li>if<br>　　“if” 表达式 如果条件为真则执行then后面的部分：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ….; <span class="keyword">then</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">elif</span> ….; <span class="keyword">then</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…<br>　　通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br>[ -f “somefile” ] ：判断是否是一个文件<br>[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限<br>[ -n “var”]：判断var” ] ：判断var变量是否有值<br>[ “a”=”a” = “b” ] ：判断a和a和b是否相等<br>　　执行man test可以查看所有测试表达式可以比较和判断的类型。<br>　　直接执行以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHELL</span>"</span> = <span class="string">"/bin/bash"</span> ]; <span class="keyword">then</span></span><br><span class="line">　<span class="built_in">echo</span> <span class="string">"your login shell is the bash (bourne again shell)"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　<span class="built_in">echo</span> <span class="string">"your login shell is not bash but <span class="variable">$SHELL</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">变量<span class="variable">$SHELL</span>包含了登录shell的名称，我们和/bin/bash进行了比较。  </span><br><span class="line">快捷操作符  </span><br><span class="line">熟悉C语言的朋友可能会很喜欢下面的表达式：  </span><br><span class="line">\[ -f “/etc/shadow” \] &amp;&amp; <span class="built_in">echo</span> “This computer uses shadow passwors”  </span><br><span class="line">　　这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mailfolder=/var/spool/mail/james</span><br><span class="line">[ -r <span class="string">"<span class="variable">$mailfolder</span>"</span> ]<span class="string">' '</span>&#123; <span class="built_in">echo</span> <span class="string">"Can not read <span class="variable">$mailfolder</span>"</span> ; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$mailfolder</span> has mail from:"</span></span><br><span class="line">grep <span class="string">"^From "</span> <span class="variable">$mailfolder</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：  </span><br><span class="line">　　-打印错误信息  </span><br><span class="line">　　-退出程序  </span><br><span class="line">　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。  </span><br><span class="line">　　不用与和或操作符，我们也可以用<span class="keyword">if</span>表达式作任何事情，但是使用与或操作符会更便利很多。</span><br><span class="line"></span><br><span class="line">2. <span class="keyword">case</span>  </span><br><span class="line"><span class="keyword">case</span> :表达式可以用来匹配一个给定的字符串，而不是数字。 </span><br><span class="line"></span><br><span class="line">``` bash </span><br><span class="line"><span class="keyword">case</span> … <span class="keyword">in</span>  </span><br><span class="line">…) <span class="keyword">do</span> something here ;;  </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>　　让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file lf.gz</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">　　这将返回：  </span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">lf.gz: gzip compressed data, deflated, original filename, last modified: Mon Aug 27 23:09:18 2001, os: Unix</span><br></pre></td></tr></table></figure><p>　我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ftype=`file <span class="string">"<span class="variable">$1</span>"</span>`</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$ftype</span>"</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"<span class="variable">$1</span>: Zip archive"</span>*)</span><br><span class="line">　　unzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: gzip compressed"</span>*)</span><br><span class="line">　　gunzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: bzip2 compressed"</span>*)</span><br><span class="line">　　bunzip2 <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">"File <span class="variable">$1</span> can not be uncompressed with smartzip"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>　　您可能注意到我们在这里使用了一个特殊的变量1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：smartziparticles.zip1。该变量包含了传递给该程序的第一个参数值。 也就是说，当我们运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartzip articles.zip</span><br></pre></td></tr></table></figure></p><p> $1 就是字符串 articles.zip </p><ol start="3"><li>selsect<br>select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select var <span class="keyword">in</span> … ; <span class="keyword">do</span>  </span><br><span class="line">　<span class="built_in">break</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><p>…. now $var can be used ….<br>下面是一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your favourite OS?"</span></span><br><span class="line">select var <span class="keyword">in</span> <span class="string">"Linux"</span> <span class="string">"Gnu Hurd"</span> <span class="string">"Free BSD"</span> <span class="string">"Other"</span>; <span class="keyword">do</span></span><br><span class="line">　　　　<span class="built_in">break</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"You have selected <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure></p><p>　　下面是该脚本运行的结果：<br>What is your favourite OS?<br>1) Linux<br>2) Gnu Hurd<br>3) Free BSD<br>4) Other</p><p>? 1</p><p>You have selected Linux </p><ol start="4"><li>loop<br>loop表达式： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> …; <span class="keyword">do</span>  </span><br><span class="line">….  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><p>　　while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true.<br>关键字”break” 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br>　　<br>for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> ….; <span class="keyword">do</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>在下面的例子中，将分别打印ABC到屏幕上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> A B C ; <span class="keyword">do</span></span><br><span class="line">　 <span class="built_in">echo</span> <span class="string">"var is <span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># list a content summary of a number of RPM packages</span></span><br><span class="line"><span class="comment"># USAGE: showrpm rpmfile1 rpmfile2 ...</span></span><br><span class="line"><span class="comment"># EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</span></span><br><span class="line"><span class="keyword">for</span> rpmpackage <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line">　<span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$rpmpackage</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">"=============== <span class="variable">$rpmpackage</span> =============="</span></span><br><span class="line">　　rpm -qi -p <span class="variable">$rpmpackage</span></span><br><span class="line">　<span class="keyword">else</span></span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">"ERROR: cannot read file <span class="variable">$rpmpackage</span>"</span></span><br><span class="line">　<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。<br>如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br>此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.</p><ol start="5"><li><p>引号<br>在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符比如(*）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。<br>1.编译SHELL脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch<span class="comment">#!/bin/sh mod +x filename</span></span><br></pre></td></tr></table></figure><p>./filename 来执行您的脚本。<br>　　这将打印出”mail.jpg tux.jpg”的结果。<br>　  引号 (单引号和双引号) 将防止这种通配符扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"*.jpg"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'*.jpg'</span></span><br><span class="line">``` </span><br><span class="line">　　这将打印”\*.jpg” 两次。  </span><br><span class="line">　　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。</span><br><span class="line">``` bash</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SHELL</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$SHELL'</span></span><br></pre></td></tr></table></figure></li></ol><p>运行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/bash</span><br><span class="line"><span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></p><p>　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> *.jpg  </span><br><span class="line"><span class="built_in">echo</span> SHELL</span><br></pre></td></tr></table></figure></p><p>这将输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∗.jpg SHELL</span><br></pre></td></tr></table></figure></p><ol start="6"><li>Here documents<br>当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents就不必用echo函数一行行输出。 一个 “Here document” 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here documents打印帮助：<pre><code class="bash"><span class="meta">#!/bin/sh</span><span class="comment"># we have less than 3 arguments. Print the help text:</span><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 3 ] ; <span class="keyword">then</span>cat &lt;<span class="comment">#ren -- renames a number of files using sed regular expressions</span>USAGE: ren <span class="string">'regexp'</span> <span class="string">'replacement'</span> files...EXAMPLE: rename all *.HTM files <span class="keyword">in</span> *.html:　ren <span class="string">'HTM$'</span> <span class="string">'html'</span> *.HTMHELP　<span class="built_in">exit</span> 0<span class="keyword">fi</span>OLD=<span class="string">"<span class="variable">$1</span>"</span>NEW=<span class="string">"<span class="variable">$2</span>"</span><span class="comment"># The shift command removes one argument from the list of</span><span class="comment"># command line arguments.</span><span class="built_in">shift</span><span class="built_in">shift</span><span class="comment"># $* contains now all the files:</span><span class="keyword">for</span> file <span class="keyword">in</span> $*; <span class="keyword">do</span>　　<span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$file</span>"</span> ] ; <span class="keyword">then</span>　　newfile=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span> | sed <span class="string">"s/<span class="variable">${OLD}</span>/<span class="variable">${NEW}</span>/g"</span>`　　　<span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$newfile</span>"</span> ]; <span class="keyword">then</span>　　　　<span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$newfile</span> exists already"</span>　　　<span class="keyword">else</span>　　　　<span class="built_in">echo</span> <span class="string">"renaming <span class="variable">$file</span> to <span class="variable">$newfile</span> ..."</span>　　　　mv <span class="string">"<span class="variable">$file</span>"</span> <span class="string">"<span class="variable">$newfile</span>"</span>　　　<span class="keyword">fi</span>　　<span class="keyword">fi</span><span class="keyword">done</span></code></pre>　这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参数列表# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递 给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等 于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我 们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参 数列表*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。  接着我 们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后  将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目 的：得到了旧文件名和新  文件名。然后使用mv命令进行重命名。</li></ol><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4)函数"></a>4)函数</h3><p>如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，<br>并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：<br>functionname()<br>{</p><h1 id="inside-the-body-1-is-the-first-argument-given-to-the-function"><a href="#inside-the-body-1-is-the-first-argument-given-to-the-function" class="headerlink" title="inside the body $1 is the first argument given to the function"></a>inside the body $1 is the first argument given to the function</h1><h1 id="2-the-second-…"><a href="#2-the-second-…" class="headerlink" title="$2 the second …"></a>$2 the second …</h1><p>body<br>}<br>您需要在每个程序的开始对函数进行声明。<br>　　下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。<br>这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。</p><h1 id="bin-sh"><a href="#bin-sh" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et"><a href="#vim-set-sw-4-ts-4-et" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　　cat &lt;<br>xtitlebar – change the name of an xterm, gnome-terminal or kde konsole<br>USAGE: xtitlebar [-h] “string_for_titelbar”<br>OPTIONS: -h help text<br>EXAMPLE: xtitlebar “cvs”<br>HELP<br>　　exit 0<br>}</p><h1 id="in-case-of-error-or-if-h-is-given-we-call-the-function-help"><a href="#in-case-of-error-or-if-h-is-given-we-call-the-function-help" class="headerlink" title="in case of error or if -h is given we call the function help:"></a>in case of error or if -h is given we call the function help:</h1><p>[ -z “1” ] &amp;&amp; help<br>[ “1” ] &amp;&amp; help [ “1” = “-h” ] &amp;&amp; help</p><h1 id="send-the-escape-sequence-to-change-the-xterm-titelbar"><a href="#send-the-escape-sequence-to-change-the-xterm-titelbar" class="headerlink" title="send the escape sequence to change the xterm titelbar:"></a>send the escape sequence to change the xterm titelbar:</h1><p>echo -e “33]0;107”     </p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br>命令行参数<br>　　我们已经见过107” # 在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。 命令行参数 　　我们已经见过* 和 1,1, 2 … $9 等特殊变量，这些特殊变量包含了用户从命令<br>行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的<br>参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的<br>自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (<br>比如文件名)。<br>有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p><h1 id="bin-sh-1"><a href="#bin-sh-1" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>help()<br>{<br>　cat &lt;<br>This is a generic command line parser demo.<br>USAGE EXAMPLE: cmdparser -l hello -f – -somefile1 somefile2<br>HELP<br>　exit 0<br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　-f) opt_f=1;shift 1;; # variable opt_f is set<br>　　-l) opt_l=2;shift 2;; # -l takes an argument -&gt; shift by 2<br>　　–) shift;break;; # end of options<br>　　-<em>) echo “error: no such option2;shift 2;; # -l takes an argument -&gt; shift by 2 　　–) shift;break;; # end of options 　　-</em>) echo “error: no such option 1. -h for help”;exit 1;;<br>　　*) break;;<br>esac<br>done<br>echo “opt_f is optf”echo“optlisopt_f” echo “opt_l is opt_l”<br>echo “first arg is 1”echo“2ndargis1” echo “2nd arg is 2”<br>　　您可以这样运行该脚本：<br>cmdparser -l hello -f – -somefile1 somefile2<br>　　返回的结果是：<br>opt_f is 1<br>opt_l is hello<br>first arg is -somefile1<br>2nd arg is somefile2<br>　　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数<br>与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，<br>首先输入的应该是包含减号的参数.<br>第2部分 实例<br>现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br>cp framework.sh myscript<br>　然后再插入自己的函数。<br>　　让我们再看两个例子：<br>　　二进制到十进制的转换<br>　　脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p><h1 id="bin-sh-2"><a href="#bin-sh-2" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-1"><a href="#vim-set-sw-4-ts-4-et-1" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　cat &lt;<br>b2h – convert binary to decimal<br>USAGE: b2h [-h] binarynum<br>OPTIONS: -h help text<br>EXAMPLE: b2h 111010<br>will return 58<br>HELP<br>　exit 0<br>}<br>error()<br>{<br>　　# print an error and exit<br>　　echo “1”<br>　　exit 1<br>}<br>lastchar()<br>{<br>　　# return the last character of a string in1” 　　exit 1 } lastchar() { 　　# return the last character of a string in rval<br>　　if [ -z “$1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　# now cut out the last char<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b $numofchar</code><br>}<br>chop()<br>{<br>　　# remove the last character in string and return it in rvalif[−z“rval 　　if [ -z “1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　if [ “$numofchar” = “1” ]; then<br>　　　　# only one char in string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　numofcharminus1=<code>expr $numofchar &quot;-&quot; 1</code><br>　　# now cut all but the last char:<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b 0-${numofcharminus1}</code><br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　–) shift;break;; # end of options<br>　　-<em>) error “error: no such option $1. -h for help”;;  　　</em>) break;;<br>esac<br>done</p><h1 id="The-main-program"><a href="#The-main-program" class="headerlink" title="The main program"></a>The main program</h1><p>sum=0<br>weight=1</p><h1 id="one-arg-must-be-given"><a href="#one-arg-must-be-given" class="headerlink" title="one arg must be given:"></a>one arg must be given:</h1><p>[ -z “1” ] &amp;&amp; help<br>binnum=”1” ] &amp;&amp; help binnum=”1”<br>binnumorig=”1”while[−n“1” while [ -n “binnum” ]; do<br>　　lastchar “binnum”if[“binnum” 　　if [ “rval” = “1” ]; then<br>　　　　sum=<code>expr &quot;$weight&quot; &quot;+&quot; &quot;$sum&quot;</code><br>　　fi<br>　　# remove the last position in binnumchop“binnum 　　chop “binnum”<br>　　binnum=”$rval”<br>　　weight=<code>expr &quot;$weight&quot; &quot;*&quot; 2</code><br>done<br>echo “binary binnumorigisdecimalbinnumorig is decimal sum”<br>　该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制”10”可<br>以这样转换成十进制：<br>0 <em> 1 + 1 </em> 2 = 2<br>　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，<br>然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br>文件循环程序<br>　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月<br>以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的 脚本rotatefile<br>可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，<br>而对于outmail.1就变成了outmail.2 等等等等…</p><h1 id="bin-sh-3"><a href="#bin-sh-3" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-2"><a href="#vim-set-sw-4-ts-4-et-2" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>ver=”0.1”<br>help()<br>{<br>　　cat &lt;<br>rotatefile – rotate the file name<br>USAGE: rotatefile [-h] filename<br>OPTIONS: -h help text<br>EXAMPLE: rotatefile out<br>This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1<br>and create an empty out-file<br>The max number is 10<br>version ver<br>HELP<br>　　exit 0<br>}<br>error()<br>{<br>　　echo “$1”<br>　　exit 1<br>}<br>while [ -n “ver HELP 　　exit 0 } error() { 　　echo “$1” 　　exit 1 } while [ -n “1” ]; do<br>case 1in−h)help;shift1;;–)break;;−∗)echo“error:nosuchoption1 in 　　-h) help;shift 1;; 　　–) break;; 　　-<em>) echo “error: no such option 1. -h for help”;exit 1;;  　　</em>) break;;<br>esac<br>done</p><h1 id="input-check"><a href="#input-check" class="headerlink" title="input check:"></a>input check:</h1><p>if [ -z “1”];thenerror“ERROR:youmustspecifyafile,use−hforhelp”fifilen=”1” ] ; then error “ERROR: you must specify a file, use -h for help” fi filen=”1”</p><h1 id="rename-any-1-2-etc-file"><a href="#rename-any-1-2-etc-file" class="headerlink" title="rename any .1 , .2 etc file:"></a>rename any .1 , .2 etc file:</h1><p>for n in 9 8 7 6 5 4 3 2 1; do<br>　　if [ -f “filen.filen.n” ]; then<br>　　　　p=<code>expr $n + 1</code><br>　　　　echo “mv filen.filen.n filen.filen.p”<br>　　　　mv filen.filen.n filen.filen.p<br>　　fi<br>done</p><h1 id="rename-the-original-file"><a href="#rename-the-original-file" class="headerlink" title="rename the original file:"></a>rename the original file:</h1><p>if [ -f “filen”];thenecho“mvfilen” ]; then 　　echo “mv filen filen.1”mvfilen.1” 　　mv filen filen.1fiechotouchfilen.1 fi echo touch filen<br>touch $filen<br>　　这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。<br>调试<br>　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br>　　shell也有一个真实的调试模式。如果在脚本”strangescript” 中有错误，您可以这样来进行调试：<br>sh -x strangescript<br>　　这将执行该脚本并显示所有变量的值。<br>　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br>sh -n your_script<br>　　这将返回所有语法错误</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/xmyzlz/article/details/8593228" target="_blank" rel="noopener">Linux脚本编写基础</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要介绍shell脚本编写的基础语法，开头、注释、变量和 环境变量，虽然不涉及具体东西，但打好基础确是最为关键的。&lt;br&gt;本文是一篇在学习中的文章，还没学习完，排版也还有一些问题，待继续&lt;/p&gt;
&lt;h1 id=&quot;shell脚本编写初步介绍&quot;&gt;&lt;a href=&quot;#shel
      
    
    </summary>
    
      <category term="Linux 脚本" scheme="http://yoursite.com/categories/Linux-%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="Linux 脚本" scheme="http://yoursite.com/tags/Linux-%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Android 编译</title>
    <link href="http://yoursite.com/2015/06/29/Android-%E7%BC%96%E8%AF%91/"/>
    <id>http://yoursite.com/2015/06/29/Android-编译/</id>
    <published>2015-06-29T06:21:51.000Z</published>
    <updated>2018-07-01T11:11:00.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文的目的是讲述Android代码编译过程,以及编译过程中Android.mk,Android.bp等文件里面变量的作用分析</p><h1 id="Android编译过程分析"><a href="#Android编译过程分析" class="headerlink" title="Android编译过程分析"></a>Android编译过程分析</h1><p><a href="https://blog.csdn.net/lizekun2010/article/details/52598105" target="_blank" rel="noopener">Android7.0 编译系统流程分析</a><br><a href="https://blog.csdn.net/huangyabin001/article/details/36383031" target="_blank" rel="noopener">深入理解：Android 编译系统</a></p><h1 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h1><p>一个Android.mk file用来向编译系统描述你的源代码。具体来说：该文件是GNU Makefile的一小部分，会被编译系统解析一次或多次。你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。每个模块属下列类型之一：<br>1）APK程序，一般的Android程序，编译打包生成apk文件<br>2）JAVA库，java类库，编译打包生成jar文件<br>3) C\C++应用程序，可执行的C\C++应用程序<br>4）C\C++静态库，编译生成C\C++静态库，并打包成.a文件<br>5）C\C++共享库， 编译生成共享库（动态链接库），并打包成.so， 有且只有共享库才能被安装/复制到您的应用软件（APK）包中。<br>（1）先看一个简单的例子：一个简单的”hello world”，比如下面的文件：<br>sources/helloworld/helloworld.c<br>sources/helloworld/Android.mk<br>相应的Android.mk文件会像下面这样：<br>———- cut here ——————<br>[cpp] view plaincopyprint?<br>1. LOCAL_PATH := (callmy−dir)2.include(call my-dir) 2. include (CLEAR_VARS)<br>3. LOCAL_MODULE<br>4. := helloworld<br>5. LOCAL_SRC_FILES := helloworld.c<br>6. include (BUILDSHAREDLIBRARY)———cuthere——————我们来解释一下这几行代码：1，LOCALPATH:=(BUILD_SHARED_LIBRARY) ——— cut here —————— 我们来解释一下这几行代码： 1，LOCAL_PATH := (call my-dir) ，一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数‘my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。<br>2，include (CLEARVARS)，CLEARVARS由编译系统提供（(可以在android安装目录下的/build/core/config.mk文件看到其定义，为CLEARVARS:=( CLEAR_VARS)，CLEAR_VARS由编译系统提供（(可以在 android 安装目录下的/build/core/config.mk 文件看到其定义，为 CLEAR_VARS:= (BUILD_SYSTEM)/clear_vars.mk)），指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…),除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。<br>3，LOCAL_MODULE := helloworld，LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。<br>4，LOCAL_SRC_FILES := helloworld.c，LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。<br>此处虽没用到其他常用的还有：<br>5，LOCAL_C_INCLUDES：可选变量，表示头文件的搜索路径。默认的头文件的搜索路径是LOCAL_PATH目录。示例：LOCAL_C_INCLUDES := sources/foo或LOCAL_C_INCLUDES := (LOCALPATH)/../foo6，TARGETARCH：目标CPU平台的名字；TARGETPLATFORM：Android.mk解析的时候，目标Android平台的名字；ARGETARCHABI：暂时只支持两个value，armeabi和armeabi−v7a7，LOCALSTATICLIBRARIES:表示该模块需要使用哪些静态库，以便在编译时进行链接。8，LOCALSHAREDLIBRARIES:表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。9，LOCALLDLIBS:编译模块时要使用的附加的链接器选项。10，LOCALARMMODE:默认情况下，arm目标二进制会以thumb的形式生成(16位)，你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式11，LOCALCFLAGS:可选的编译器选项，在编译C代码文件的时候使用12，include(LOCAL_PATH)/../foo 6，TARGET_ARCH：目标 CPU平台的名字；TARGET_PLATFORM：Android.mk 解析的时候，目标 Android 平台的名字；ARGET_ARCH_ABI：暂时只支持两个 value，armeabi 和 armeabi-v7a 7，LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接。 8，LOCAL_SHARED_LIBRARIES: 表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。 9，LOCAL_LDLIBS: 编译模块时要使用的附加的链接器选项。 10，LOCAL_ARM_MODE: 默认情况下， arm目标二进制会以 thumb 的形式生成(16 位)，你可以通过设置这个变量为 arm如果你希望你的 module 是以 32 位指令的形式 11，LOCAL_CFLAGS: 可选的编译器选项，在编译 C 代码文件的时候使用 12，include (call all-subdir-makefiles)：返回一个位于当前’my-dir’路径的子目录中的所有Android.mk的列表。<br>（2）在Android中增加本地程序或者库，这些程序和库与其所载路径没有任何关系，只和它们的Android.mk文件有关系。Android.mk和普通的Makefile有所不同，它具有统一的写法，主要包含一些系统公共的宏。在一个Android.mk中可以生成多个可执行程序、动态库和静态库。<br>A，编译C/C++应用程序的模板：  </p><p>#Test Exe<br>LOCAL_PATH := (call my-dir)    </p><pre><code>#include(call my-dir) #include (CLEAR_VARS)  </code></pre><p>LOCAL_SRC_FILES:= main.c<br>LOCAL_MODULE:= test_exe  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILDEXECUTABLE)（菜鸟级别解释：:=是赋值的意思，+=是追加的意思，(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，+=是追加的意思，是引用某变量的值）BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。补充说明：include (BUILDPACKAGE)则是编译出一个apk，include(BUILD_PACKAGE)则是编译出一个apk，include (BUILD_STATIC_JAVA_LIBRARY)则是编译出jar包。<br>B，编译静态库的模板：  </p><p>#Test Static Lib<br>LOCAL_PATH := (callmy−dir)include(call my-dir) include (CLEAR_VARS)<br>LOCAL_SRC_FILES:= /<br>helloworld.c<br>LOCAL_MODULE:= libtest_static  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILD_STATIC_LIBRARY)<br>一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。<br>C，编译动态库的模板：    </p><pre><code>#Test Shared Lib    LOCAL_PATH :=(BUILD\_STATIC\_LIBRARY) 一般的和上面相似，BUILD\_STATIC\_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。 C，编译动态库的模板： #Test Shared Lib LOCAL_PATH := (call my-dir)  </code></pre><p>include (CLEAR_VARS)<br>     LOCAL_SRC_FILES:= /<br>               helloworld.c<br>     LOCAL_MODULE:= libtest_shared<br>     TARGET_PRELINK_MODULES := false    </p><pre><code>#LOCAL\_C\_INCLUDES :=    #LOCAL\_STATIC\_LIBRARIES :=    #LOCAL\_SHARED\_LIBRARIES :=     include(CLEAR\_VARS) LOCAL\_SRC\_FILES:= / helloworld.c LOCAL\_MODULE:= libtest\_shared TARGET\_PRELINK\_MODULES := false #LOCAL\_C\_INCLUDES := #LOCAL\_STATIC\_LIBRARIES := #LOCAL\_SHARED_LIBRARIES := include (BUILD\_SHARED\_LIBRARY)  </code></pre><p>一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个动态库。<br>以上三者的生成结果分别在如下，generic依具体target会变：<br>out/target/product/generic/obj/EXECUTABLE<br>out/target/product/generic/obj/STATIC_LIBRARY<br>out/target/product/generic/obj/SHARED_LIBRARY<br>每个模块的目标文件夹分别为：<br>可执行程序：XXX_intermediates<br>静态库： XXX_static_intermediates<br>动态库： XXX_shared_intermediates<br>另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择：<br>TARGET_ROOT_OUT：表示根文件系统out/target/product/generic/root。<br>TARGET_OUT：表示system文件系统out/target/product/generic/system。<br>TARGET_OUT_DATA：表示data文件系统out/target/product/generic/data。<br>OUT_DIR：代码工程编译时的out生成目录<br>PRODUCT_OUT：映象生成目录</p><h1 id="Android-bp"><a href="#Android-bp" class="headerlink" title="Android.bp"></a>Android.bp</h1><p>待补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文的目的是讲述Android代码编译过程,以及编译过程中Android.mk,Android.bp等文件里面变量的作用分析&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="Android 编译" scheme="http://yoursite.com/categories/Android-%E7%BC%96%E8%AF%91/"/>
    
    
      <category term="make" scheme="http://yoursite.com/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>问题锦集-速查</title>
    <link href="http://yoursite.com/2015/06/29/%E9%97%AE%E9%A2%98%E9%94%A6%E9%9B%86-%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2015/06/29/问题锦集-速查/</id>
    <published>2015-06-29T06:17:50.000Z</published>
    <updated>2018-07-01T11:01:48.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文收集平常工作过程中遇到的一些常见问题，遇到的一些坑，把它们记录下来，以便日后再次遇到能快速排查。</p><h1 id="无法下载版本问题："><a href="#无法下载版本问题：" class="headerlink" title="无法下载版本问题："></a>无法下载版本问题：</h1><ol><li><p>确认主板中是否有download过软件——直接接电源开机，如可以开机，可以断定此主板已经down过版本了；如果无法开机，尝试焊接串口线，抓一下log，看看在哪一步停下来走不下去了。<br>一般而言，可以开机但是不能下载的，存在两种可能：<br>①新软件中未兼容主板上的Memory物料；<br>②分区表更新了。<br>对于这第一种情况，可以通过查配置表，找到Memory物料型号，然后跟软件开发人员核对，是否有兼容；或者查看flash download工具的log，发给开发人员，通过Memory ID来确认是否兼容该物料。<br>对于第二种情况，通常可以选择upgrade的升级方式，如实在不行，可以导出校准参数，然后格式化下载新软件，最后重新导入校准参数。 </p></li><li><p>如果遇到无法开机，又无法下载的，可能有三种种情况：<br>①软件中未兼容主板上的Memory物料；<br>②下载工具版本过旧，不支持当前平台的下载；<br>③主板有异常，尤其Memory可能有损坏。<br>第一种情况跟上面类似，不再赘述。第二种情况，可以先直接换一个新版本工具试试能否下载，如可以下载，说明工具需要更新，如仍然无法下载，说明跟工具无关。第三种情况，可以多找几块主板，如果有一块可以下载软件，基本就可以判断无法下载的主板存在硬件上的损坏。  </p></li><li><p>不开机问题：<br>1、 按开机键没有反应，屏幕不亮，用电源连接时发现电流无变化。这种情况，有两种可能：<br>①主板开机键或电池连接异常；<br>②单块主板损坏；<br>第一种情况，可以直接使用电源，然后用镊子连接主板power key测试点与地，如可以开机，说明开机键或电池异常；<br>第二种情况通常需要硬件同事介入分析。<br>2、开机到某个阶段停止不动。类似这样的情况，可以直接抓log分析。<br>比较实用的方法：①抓取不开机的uart log，部分手机不开机，同时抓取正常开机的uart log对比分析；②如果开机到android界面，可使用adb logcat -v time &gt; log.txt获取上层log信息。</p></li><li><p>部分手机开机时间非常长：<br>此类问题很大可能性是由于外设在读ID导致的，直接抓log查看即可。最方便的方式就是直接抓串口log来分析。此外还可以用adb shell logcat –v time &gt; 123.txt来抓取上层log来分析。</p></li><li><p>开机背光亮，有开机铃声，屏幕没有显示：<br>一般而言，问题在于屏没有兼容或者屏/主板单体损坏。如果是单体问题，我们可以做交叉实验，分析问题是主板还是屏导致的。如果全部显示都不对，可以跟软件开发同事确认是否软件不对，或者抓串口log，确认屏ID是否读到。</p></li><li><p>Camera应用丢失，Camera切换按钮丢失：<br>在MTK平台上，Camera的识别是在开机过程中完成的。如果开机时没有识别到任何Camera，开机之后Camera应用就会直接影藏；如果只识别到一个Camera，Camera切换按钮就是影藏。<br>1、如果有发现手机开机之后，Camera应用丢失，可以通过以下步骤去：<br>①将手机恢复出厂设置，然后重新开机，此时如果Camera应用显示出来，且多次使用都正常了，说明之前该机器很有可能是先开机过，然后再安装Camera的。<br>②如果恢复出厂设置还是无法显示Camera应用，首先需要确认此问题是单体（或小概率）问题还是大批量问题。单体问题的话，就需要去排查Camera焊接/连接是否正常。如焊接/连接正常，接着做交叉实验，确认是模组问题还是主板问题。模组问题就安排模组厂分析，主板问题就合硬件沟通解决。如果是大批量问题，一方面需要让模组厂参与进来分析，另一方面需要排查软件/硬件。软件上可以抓串口log给软件同事分析，硬件上排查走线、供电是否有异常。<br>③如果切换异常，通常是某个Camera的ID没有读到。可以在拨号界面输入“_#<em>#9375#</em>#_”（仅适用于MTK平台），确认下是否是没有读到ID，如确实ID没有读到，一方面检查Camera焊接/连接是否正常，另一方面抓下串口log给软件同事分析。</p></li><li><p>Camera花屏/闪绿线：<br>遇到Camera使用过程中花屏/闪绿线的问题，我们可以从两个方向去排查问题。首先还是按照惯例统计花屏的概率，如果是单体问题，需要去确认Camera数据线是否有问题，直接测量数据线信号即可，将波形发生给硬件同事检查。然后做交叉实验，确认是模组问题还是主板问题。模组问题让模组厂来分析，主板问题可以跟硬件沟通处理。<br>如果大批量都有问题，需要软件和硬件同事介入分析。软件上尝试修改Camera驱动能力，优化一个最好的组合，硬件上尝试包导电布、做接地处理。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文收集平常工作过程中遇到的一些常见问题，遇到的一些坑，把它们记录下来，以便日后再次遇到能快速排查。&lt;/p&gt;
&lt;h1 id=&quot;无法下载版本问
      
    
    </summary>
    
      <category term="问题" scheme="http://yoursite.com/categories/%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="问题 锦集 速查" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98-%E9%94%A6%E9%9B%86-%E9%80%9F%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>各类工具使用小技巧</title>
    <link href="http://yoursite.com/2015/06/29/%E5%90%84%E7%B1%BB%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/06/29/各类工具使用小技巧/</id>
    <published>2015-06-29T06:06:59.000Z</published>
    <updated>2018-07-01T10:47:06.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VIM-使用小技巧"><a href="#VIM-使用小技巧" class="headerlink" title="VIM 使用小技巧"></a>VIM 使用小技巧</h1><h2 id="配置鼠标和显示行号"><a href="#配置鼠标和显示行号" class="headerlink" title="配置鼠标和显示行号"></a>配置鼠标和显示行号</h2><p>服务器在安装了加密之后，vim无法使用鼠标，也无法显示行号了，可以通过如下方法修改：  </p><ol><li>在~路径下创建.vimrc，然后加入两行<br>set mouse=a<br>set nu<br>修改完之后保存退出。  </li><li>关闭bash窗口，或者source .vimrc，接下来vim就可以使用鼠标和显示行号了。</li></ol><h1 id="shell-脚本小技巧"><a href="#shell-脚本小技巧" class="headerlink" title="shell 脚本小技巧"></a>shell 脚本小技巧</h1><h2 id="shell脚本注意事项"><a href="#shell脚本注意事项" class="headerlink" title="shell脚本注意事项"></a>shell脚本注意事项</h2><p>有些情况下，我们会碰到一个问题，在编译时，有些shell脚本会无法执行。相信大家会第一时间去检查脚本的权限，看看脚本是否有可执行权限——ls查看下。如果权限不对，使用chmod指令修改下就好了。<br>但是有些时候，发现权限对了，脚本执行仍然不对，如这种提示——bad interpreter:No such file or directory。这种情况，其实是脚本的文件结尾符是dos格式的，而非unix标准编码。<br>碰到这种情况，可以通过如下方式定位、解决。  </p><ol><li>使用vim打开文件，然后进入命令模式，输入set: ff（ ）并回车，此时，文件下方会有提示 或者 如果是第二种，那么恭喜你中招了，这个文件的格式是dos的（也就是windows一系列系统的格式），这种格式的脚本，是无法在shell中执行的。  </li><li>想要修改，也非常简单。输入命令 ，然后回车，问题搞定了。保存文件，会发现该脚本已经可以执行了。</li></ol><h1 id="Putty-使用小技巧"><a href="#Putty-使用小技巧" class="headerlink" title="Putty 使用小技巧"></a>Putty 使用小技巧</h1><h2 id="实现输入中文和log行数增加"><a href="#实现输入中文和log行数增加" class="headerlink" title="实现输入中文和log行数增加"></a>实现输入中文和log行数增加</h2><ol><li>在Translation标签页，将putty的字符集修改为UTF-8。  </li><li>将字体设置成Fixedsys。  </li><li>在Window标签页，将Lines of Scrollback设置成为20000。  </li><li>将Session中的IP地址和Saved Session填写好。选择Save。  </li><li>下次登录的时候，只要选择存储的Session就可以了。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VIM-使用小技巧&quot;&gt;&lt;a href=&quot;#VIM-使用小技巧&quot; class=&quot;headerlink&quot; title=&quot;VIM 使用小技巧&quot;&gt;&lt;/a&gt;VIM 使用小技巧&lt;/h1&gt;&lt;h2 id=&quot;配置鼠标和显示行号&quot;&gt;&lt;a href=&quot;#配置鼠标和显示行号&quot; class
      
    
    </summary>
    
      <category term="Tools" scheme="http://yoursite.com/categories/Tools/"/>
    
    
      <category term="小技巧 工具 vim shell putty" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-%E5%B7%A5%E5%85%B7-vim-shell-putty/"/>
    
  </entry>
  
  <entry>
    <title>windows批处理 BAT技巧</title>
    <link href="http://yoursite.com/2015/06/29/windows%E6%89%B9%E5%A4%84%E7%90%86-BAT%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/06/29/windows批处理-BAT技巧/</id>
    <published>2015-06-29T03:49:50.000Z</published>
    <updated>2018-07-01T10:38:39.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Windows操作系统中，cmd可以执行bat格式的文件，可以自己编写bat文件完成一些重复性的工作。</p><h1 id="用批处理命令批量获取指定文件夹内的文件名"><a href="#用批处理命令批量获取指定文件夹内的文件名" class="headerlink" title="用批处理命令批量获取指定文件夹内的文件名"></a>用批处理命令批量获取指定文件夹内的文件名</h1><p>dir /s /w &gt;&gt;catalog.txt<br>::/s 表示只显示系统文件<br>::/w 表示只显示文件名，至于文件大小以及建立的日期和时间都省略<br>::dir *.doc /s /w &gt;&gt; catalog.txt 表示仅生成后缀为.doc文件</p><h1 id="BAT文件注释符"><a href="#BAT文件注释符" class="headerlink" title="::BAT文件注释符"></a>::BAT文件注释符</h1><p>:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>rem 注释内容（不能出现重定向符号和管道符号）<br>:注释内容（注释文本不能与已有标签重名）<br>%注释内容(可以用作行间注释，不能出现重定向符号和管道符号)%</p><p>rem 指定存放文件的目录<br>set originPath=C:\Documents and Settings\zhoudeshui\Desktop\临时文件</p><p>:@echo<br>:　　dir c:<em>.</em> &gt;a.txt　　　　　　　<br>:　　call c:\ucdos\ucdos.bat　　　　<br>:　　echo 你好 　　　　　　　　　　<br>:　　pause 　　　　　　　　　　　　</p><p>@echo off<br>for /f “delims=\” %%a in (‘dir /b /a-d /o-d “%originPath%<em>.</em>”’) do (<br>echo %%a &gt; aa.txt<br>)<br>pause</p><h1 id="使用bat-完成Android-log的自动抓取"><a href="#使用bat-完成Android-log的自动抓取" class="headerlink" title="使用bat 完成Android log的自动抓取"></a>使用bat 完成Android log的自动抓取</h1><p>可以将抓log的命令，做成一个合集，放在一个bat文件中，一步运行，抓取所有log。适合于工厂产线抓log。<br><a href="https://blog.csdn.net/maetelibom/article/details/51480980" target="_blank" rel="noopener">一种通过自动脚本抓取Android 手机log的方法</a><br><a href="https://blog.csdn.net/xxm282828/article/details/46433095" target="_blank" rel="noopener">使用脚本导出android 手机log</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;Windows操作系统中，cmd可以执行bat格式的文件，可以自己编写bat文件完成一些重复性的工作。&lt;/p&gt;
&lt;h1 id=&quot;用批处理命令
      
    
    </summary>
    
      <category term="批处理" scheme="http://yoursite.com/categories/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
    
      <category term="批处理" scheme="http://yoursite.com/tags/%E6%89%B9%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ADB (Android Debug Bridge)常用命令</title>
    <link href="http://yoursite.com/2015/06/29/ADB-Android-Debug-Bridge-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2015/06/29/ADB-Android-Debug-Bridge-常用命令/</id>
    <published>2015-06-29T03:27:47.000Z</published>
    <updated>2018-07-02T11:53:40.037Z</updated>
    
    <content type="html"><![CDATA[<!--修改记录：1.2016年完成第一版2.2018年修订完成目标：分析adb的源码    --><p>ADB (Android Debug Bridge)</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://android.googlesource.com/platform/system/core/+/master/adb/" target="_blank" rel="noopener">Android中Adb源码</a></p><p><strong>adb 源码分析： 待补充</strong></p><p>说明：下面一些命令需要有root权限才能执行成功<br>Windows环境下的adb<br>快速启动dos窗口执行adb：<br>1. adb.exe所在路径添加到系统环境变量中<br>2. 配置快捷键启动dos<br>进入C:\WINDOWS\system32目录下，找到cmd.exe.<br>右击菜单 “发送到” -> 桌面快捷方式。<br>在桌面上右击”快捷方式 到 cmd.exe” -&gt; “属性” -&gt; “快捷方式”页<br>-&gt; 光标高亮”快捷键” -> 按下自定义快捷键 (如：Ctrl + Alt + Z)</p><p>任何情况下，按下Ctrl + Alt + Z启动dos窗口就可以执行adb命令了</p><h1 id="查看设备连接状态-系列"><a href="#查看设备连接状态-系列" class="headerlink" title="查看设备连接状态 系列"></a>查看设备连接状态 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb get-serialno 获取设备的ID和序列号serialNumber  </span><br><span class="line">adb devices 查询当前计算机上连接那些设备（包括模拟器和手机），输出格式: \[serialNumber\] \[state\]  </span><br><span class="line">adb get-state 查看模拟器/设施的当前状态.</span><br></pre></td></tr></table></figure><p>说明：<br>序列号[serialNumber]——由adb创建的一个字符串，这个字符串通过自己的控制端口-<br>唯一地识别一个模拟器/设备实例。一个序列号的例子： emulator-5554</p><h1 id="发送命令到设备-系列"><a href="#发送命令到设备-系列" class="headerlink" title="发送命令到设备 系列"></a>发送命令到设备 系列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb \[-d|-e|-s \]  </span><br><span class="line">-d 发送命令给usb连接的设备  </span><br><span class="line">-e 发送命令到模拟器设备  </span><br><span class="line">-s 发送命令到指定设备</span><br></pre></td></tr></table></figure><p>如启动手机设备shell: adb -d shell</p><p>adb forward 发布端口,可以设置任意的端口号，<br>做为主机向模拟器或设备的请求端口。如：adb forward tcp:5555 tcp:8000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb reboot 重启手机  </span><br><span class="line">adb remount 将system分区重新挂载为可读写分区  </span><br><span class="line">adb <span class="built_in">kill</span>-server 终止adb服务进程  </span><br><span class="line">adb start-server 重启adb服务进程  </span><br><span class="line">adb root 已root权限重启adb服务  </span><br><span class="line">adb <span class="built_in">wait</span>-for-device 在模拟器/设备连接之前把命令转载在adb的命令器中  </span><br><span class="line">adb jdwp 查看指定的设施的可用的JDWP信息.  Java Debug Wire Protocol (JDWP, Java调试线协议)是</span><br><span class="line">可以用 forward jdwp: 端口映射信息来连接指定的JDWP进程.例如：  </span><br><span class="line">adb forward tcp:8000 jdwp:472  </span><br><span class="line">jdb -attach localhost:8000</span><br></pre></td></tr></table></figure><h1 id="adb-shell-am-命令可以启动应用程序"><a href="#adb-shell-am-命令可以启动应用程序" class="headerlink" title="adb shell am 命令可以启动应用程序"></a>adb shell am 命令可以启动应用程序</h1><p>adb shell input text 向设备输入文本（光标所在的文本框）<br>adb shell input keyevent 向设备发送按键事件<br>如：<br>在编辑短信时，往文本框输入文本：adb shell input text “hello”<br>向手机发送键值回Home：adb shell input keyevent 3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">event\_code 参考view/KeyEvent.java中的 KEYCODE\_*  </span><br><span class="line">public static final int KEYCODE\_SOFT\_LEFT = 1;  </span><br><span class="line">public static final int KEYCODE\_SOFT\_RIGHT = 2;  </span><br><span class="line">public static final int KEYCODE_HOME = 3;  </span><br><span class="line">public static final int KEYCODE_BACK = 4;  </span><br><span class="line">public static final int KEYCODE_CALL = 5;  </span><br><span class="line">public static final int KEYCODE_ENDCALL = 6;</span><br></pre></td></tr></table></figure></p><h1 id="安装卸载-系列"><a href="#安装卸载-系列" class="headerlink" title="安装卸载 系列"></a>安装卸载 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb install \[-l\] \[-r\] - push this package file to the device and install it  </span><br><span class="line">(‘-l’ means forward-lock the app)  </span><br><span class="line">(‘-r’ means reinstall the app, keeping its data)  </span><br><span class="line">adb uninstall \[-k\] - remove this app package from the device  </span><br><span class="line">(‘-k’ means keep the data and cache directories)</span><br></pre></td></tr></table></figure><p>如：<br>adb install d:\hello.apk<br>adb unstall com.huawei.hello<br>说明：如果带-r选项重新安装apk时，安装在 /data/local/tmp/目录下，手机重启后还是使用原来的apk.</p><h1 id="文件操作-系列"><a href="#文件操作-系列" class="headerlink" title="文件操作 系列"></a>文件操作 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push - copy file/dir to device  </span><br><span class="line">adb pull - copy file/dir from device</span><br></pre></td></tr></table></figure><h1 id="基本linux-shell命令-系列"><a href="#基本linux-shell命令-系列" class="headerlink" title="基本linux shell命令 系列"></a>基本linux shell命令 系列</h1><p>adb shell [command]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls 列出目录下的文件和文件夹  </span><br><span class="line"><span class="built_in">cd</span> 切换目录  </span><br><span class="line">rm 删除目录和文件  </span><br><span class="line">cat 查看文件内容  </span><br><span class="line">ps 可以看那个进程再跑  </span><br><span class="line">ps -x \[PID\] 查看单个进程的状态  </span><br><span class="line">top 可以看那个进程的占用率最高  </span><br><span class="line">su 切换到root用户  </span><br><span class="line"><span class="built_in">kill</span> \[pid\] 杀死一个进程  </span><br><span class="line">chmod 777 修改该文件为可执行权限</span><br></pre></td></tr></table></figure></p><p>从framework/base/cmds中查到的一些常用的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell am stack list 列出AM堆栈信息</span><br><span class="line">adb shell appops  应用权限授权管理框架,可以使用AppOps将其某项强制要求权限忽略掉</span><br><span class="line">adb shell appwidget 主要是设置apk是否有放在窗口的权限</span><br><span class="line">adb shell bmgr 备份用</span><br><span class="line">adb shell content</span><br><span class="line">adb shell dpm</span><br></pre></td></tr></table></figure></p><ol><li>打印某个进程中所有线程的backtrace<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell debuggerd -b pid</span><br></pre></td></tr></table></figure></li></ol><p>用于分析死锁</p><ol start="2"><li>打印系统所有注册的服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell service list</span><br></pre></td></tr></table></figure></li></ol><p>用于查看service是否注册成功</p><ol start="3"><li>查看某个应用时32位还是64位<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps --api</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">详细使用情况可以登录一台Linux服务器在shell下查看帮助手册, man</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统状态和信息 系列  </span></span><br><span class="line">``` bash</span><br><span class="line">adb shell procrank 查询各进程内存使用情况  </span><br><span class="line">adb shell service list 查看services信息  </span><br><span class="line">adb shell cat /proc/meminfo 查看当前的内存情况  </span><br><span class="line">adb shell cat /proc/cpuinfo 查看CPU信息（硬件）  </span><br><span class="line">adb shell cat /proc/iomem 查看IO内存分区</span><br><span class="line"></span><br><span class="line">adb shell getprop 列出系统所有属性  </span><br><span class="line">adb shell getprop | findstr “gsm” 列出包含gsm的属性  </span><br><span class="line">adb shell setprop 修改系统属性</span><br><span class="line"></span><br><span class="line">adb shell sqlite3 可以执行sql语句查看数据库信息， 具体使用情况待调查</span><br><span class="line"></span><br><span class="line">adb shell dmesg 查询内核缓冲区信息  </span><br><span class="line">adb shell dumpstate 各类信息，比如进程信息，内存信息，进程是否异常，kernnel的<span class="built_in">log</span>等  </span><br><span class="line">adb shell dumpcrash  </span><br><span class="line">adb shell dumpsys 查询所有service的状态</span><br></pre></td></tr></table></figure></li></ol><h1 id="adb-shell-dumpsys-系列"><a href="#adb-shell-dumpsys-系列" class="headerlink" title="adb shell dumpsys 系列"></a>adb shell dumpsys 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity top //查看当前运行Activity信息</span><br><span class="line">adb shell dumpsys package [pkgname] //查看指定包名应用详细信息，相当于AndroidManifest.xml中的内容</span><br><span class="line">adb shell dumpsys meminfo [pname/pid] //查看指定进程名或者进程id的内存信息</span><br><span class="line">adb shell dumpsys dbinfo [pkgname] //查看指定包名应用的数据库调用信息</span><br></pre></td></tr></table></figure><h1 id="adb-shell-截屏和录屏"><a href="#adb-shell-截屏和录屏" class="headerlink" title="adb shell 截屏和录屏"></a>adb shell 截屏和录屏</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/1.png  //截图保存</span><br><span class="line">adb shell screenrecord /sdcard/1.mp4  //录屏保存</span><br></pre></td></tr></table></figure><h1 id="Log-系列"><a href="#Log-系列" class="headerlink" title="Log 系列"></a>Log 系列</h1><p>adb logcat [ ] - View device log</p><h2 id="查看可用日志缓冲区"><a href="#查看可用日志缓冲区" class="headerlink" title="查看可用日志缓冲区:"></a>查看可用日志缓冲区:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s tag // 查看tag的日志</span><br><span class="line">adb logcat -b radio — 查看缓冲区的相关的信息.  </span><br><span class="line">adb logcat -b events — 查看和事件相关的的缓冲区.  </span><br><span class="line">adb logcat -b main — 查看主要的日志缓冲区</span><br></pre></td></tr></table></figure><h2 id="过滤日志输出"><a href="#过滤日志输出" class="headerlink" title="过滤日志输出:"></a>过滤日志输出:</h2><p>过滤器语句按照下面的格式描tag:priority … , tag 表示是标签, priority 是表示标签的报告的最低等级<br>adb logcat *:W 显示优先级为warning或更高的日志信息<br>adb logcat ActivityManager:I MyApp:D *:S</p><p>日志的标签是系统部件原始信息的一个简要的标志。（比如：“View”就是查看系统的标签）.<br>优先级有下列集中，是按照从低到高顺利排列的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V — Verbose (lowest priority)  </span><br><span class="line">D — Debug  </span><br><span class="line">I — Info  </span><br><span class="line">W — Warning  </span><br><span class="line">E — Error  </span><br><span class="line">F — Fatal  </span><br><span class="line">S — Silent (highest priority, on <span class="built_in">which</span> nothing is ever printed)</span><br></pre></td></tr></table></figure></p><p>如果你电脑上运行logcat ，相比在远程adb shell端，你还可以为环境变量ANDROID_LOG_TAGS :输入一个参数来设置默认的过滤<br>export ANDROID_LOG_TAGS=”ActivityManager:I MyApp:D *:S”<br>需要注意的是ANDROID_LOG_TAGS 过滤器如果通过远程shell运行logcat 或用adb shell logcat 来运行模拟器/设备不能输出日志.</p><h2 id="控制日志输出格式"><a href="#控制日志输出格式" class="headerlink" title="控制日志输出格式:"></a>控制日志输出格式:</h2><p>日志信息包括了许多元数据域包括标签和优先级。可以修改日志的输出格式，所以可以显示出特定的元数据域。可以通过 -v 选项得到格式化输出日志的相关信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brief — Display priority/tag and PID of originating process (the default format).  </span><br><span class="line">process — Display PID only.  </span><br><span class="line">tag — Display the priority/tag only.  </span><br><span class="line">thread — Display process:thread and priority/tag only.  </span><br><span class="line">raw — Display the raw <span class="built_in">log</span> message, with no other metadata fields.  </span><br><span class="line">time — Display the date, invocation time, priority/tag, and PID of the originating process.  </span><br><span class="line">long — Display all metadata fields and separate messages with a blank lines.</span><br></pre></td></tr></table></figure><p>当启动了logcat ，你可以通过-v 选项来指定输出格式:</p><p>[adb] logcat [-v ]<br>下面是用 thread 来产生的日志格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -v thread</span><br></pre></td></tr></table></figure><p>需要注意的是你只能-v 选项来规定输出格式 option.</p><h2 id="Logcat命令列表"><a href="#Logcat命令列表" class="headerlink" title="Logcat命令列表"></a>Logcat命令列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b 加载一个可使用的日志缓冲区供查看，比如event 和radio . 默认值是main 。具体查看Viewing Alternative Log Buffers.  </span><br><span class="line">-c 清楚屏幕上的日志.  </span><br><span class="line">-d 输出日志到屏幕上.  </span><br><span class="line">-f 指定输出日志信息的 ，默认是stdout .  </span><br><span class="line">-g 输出指定的日志缓冲区，输出后退出.  </span><br><span class="line">-n 设置日志的最大数目 .，默认值是4，需要和 -r 选项一起使用。  </span><br><span class="line">-r 每 时输出日志，默认值为16，需要和-f 选项一起使用.  </span><br><span class="line">-s 设置默认的过滤级别为silent.  </span><br><span class="line">-v 设置日志输入格式，默认的是brief 格式，要知道更多的支持的格式，参看Controlling Log Output Format</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb bugreport - <span class="built_in">return</span> all information from the device  </span><br><span class="line">that should be included <span class="keyword">in</span> a bug report.</span><br></pre></td></tr></table></figure><p>———–其他 ———–</p><p>模拟器使用镜像sdcard<br>用SDK里的mksdcard工具来创建FAT32磁盘镜像并在模拟器启动时加载它。这样创建镜像：? mksdcard ,<br>比如我要创建一个64M的SD卡模拟文件，文件路径是在D:\workspace\sdcard.img<br>mksdcard 64000000 D:\workspace\sdcard.img</p><p>Emulator –sdcard D:\workspace\sdcard.img<br>或者在eclipse的run菜单的open run dialog对话框中配置启动参数。</p><h1 id="adb-shell-top-系列"><a href="#adb-shell-top-系列" class="headerlink" title="adb shell top 系列"></a>adb shell top 系列</h1><p>top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Usage: top \[ -m max\_procs \] \[ -n iterations \] \[ -d delay \] \[ -s sort\_column \] \[ -t \] \[ -h \]  </span><br><span class="line">-m num Maximum number of processes to display.  //最多显示m个进程</span><br><span class="line">-n num Updates to show before exiting.   //刷新次数</span><br><span class="line">-d num Seconds to <span class="built_in">wait</span> between updates.   //刷新间隔时间（默认5秒）</span><br><span class="line">-s col Column to sort by (cpu,vss,rss,thr).  //按哪列排序 </span><br><span class="line">-t Show threads instead of processes.  //显示线程信息而不是进程</span><br><span class="line">-h Display this <span class="built_in">help</span> screen.  //显示帮助文档</span><br><span class="line"></span><br><span class="line">**_*****_** simple selection **_*_** **_*****_** selection by list **_*_**  </span><br><span class="line">-A all processes -C by <span class="built_in">command</span> name  </span><br><span class="line">-N negate selection -G by real group ID (supports names)  </span><br><span class="line">-a all w/ tty except session leaders -U by real user ID (supports names)  </span><br><span class="line">-d all except session leaders -g by session OR by effective group name  </span><br><span class="line">-e all processes -p by process ID  </span><br><span class="line">T all processes on this terminal -s processes <span class="keyword">in</span> the sessions given  </span><br><span class="line">a all w/ tty, including other users -t by tty  </span><br><span class="line">g OBSOLETE – DO NOT USE -u by effective user ID (supports names)  </span><br><span class="line">r only running processes U processes <span class="keyword">for</span> specified users  </span><br><span class="line">x processes w/o controlling ttys t by tty  </span><br><span class="line">**_*****_** output format **_******_** **_\*\*\*_** long options **_*****_**  </span><br><span class="line">-o,o user-defined -f full –Group –User –pid –cols –ppid  </span><br><span class="line">-j,j job control s signal –group –user –sid –rows –info  </span><br><span class="line">-O,O preloaded -o v virtual memory –cumulative –format –deselect  </span><br><span class="line">-l,l long u user-oriented –sort –tty –forest –version  </span><br><span class="line">-F extra full X registers –heading –no-heading –context  </span><br><span class="line">**_*****_** misc options **_*_**  </span><br><span class="line">-V,V show version L list format codes f ASCII art forest  </span><br><span class="line">-m,m,-L,-T,H threads S children <span class="keyword">in</span> sum -y change -l format  </span><br><span class="line">-M,Z security data c <span class="literal">true</span> <span class="built_in">command</span> name -c scheduling class  </span><br><span class="line">-w,w wide output n numeric WCHAN,UID -H process hierarchy</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell top</span><br><span class="line"> </span><br><span class="line">User 13%, System 5%, IOW 0%, IRQ 0%</span><br><span class="line">User 85 + Nice 0 + Sys 37 + Idle 509 + IOW 0 + IRQ 0 + SIRQ 0 = 631   //第一组数据</span><br><span class="line"> </span><br><span class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name    //第二组数据</span></span><br><span class="line">22205  0  13% S    56 423416K  88160K  <span class="built_in">fg</span> u0_a92   com.tmall.wireless</span><br><span class="line">24310  1   2% R     1   1232K    536K     root     top</span><br><span class="line">22600  0   1% S    46 341712K  40872K  <span class="built_in">fg</span> u0_a90   com.wandoujia.phoenix2.usbproxy</span><br><span class="line">31125  1   1% S    31 319976K  33284K  <span class="built_in">fg</span> u0_a74   com.android.Chinpower</span><br><span class="line"> 1533  0   1% S    32  67320K  20552K  <span class="built_in">fg</span> system   /system/bin/surfaceflinger</span><br><span class="line"> 1852  0   1% S   112 445876K  80304K  <span class="built_in">fg</span> system   system_server</span><br><span class="line">    ...</span><br><span class="line">   10  0   0% S     1      0K      0K     root     watchdog/0</span><br><span class="line">   16  1   0% S     1      0K      0K     root     khelper</span><br><span class="line">   22  1   0% S     1      0K      0K     root     suspend_sys_syn</span><br><span class="line">   23  1   0% S     1      0K      0K     root     <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p>第一组数据的含义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User  处于用户态的运行时间，不包含优先值为负进程 </span><br><span class="line">Nice  优先值为负的进程所占用的CPU时间 </span><br><span class="line">Sys   处于核心态的运行时间 </span><br><span class="line">Idle  除IO等待时间以外的其它等待时间 </span><br><span class="line">IOW   IO等待时间 </span><br><span class="line">IRQ   硬中断时间 </span><br><span class="line">SIRQ  软中断时间</span><br></pre></td></tr></table></figure></p><p>第二组数据的含义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PID   进程id</span><br><span class="line">PR    优先级</span><br><span class="line">CPU%  当前瞬时CPU占用率</span><br><span class="line">S     进程状态:D=不可中断的睡眠状态, R=运行, S=睡眠, T=跟踪/停止, Z=僵尸进程</span><br><span class="line"><span class="comment">#THR  程序当前所用的线程数</span></span><br><span class="line">VSS   Virtual Set Size  虚拟耗用内存（包含共享库占用的内存）</span><br><span class="line">RSS   Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span><br><span class="line">PCY   调度策略优先级，SP_BACKGROUND/SP_FOREGROUND</span><br><span class="line">UID   进程所有者的用户id</span><br><span class="line">Name  进程的名称</span><br><span class="line">PID   进程id</span><br><span class="line">PR    优先级</span><br><span class="line">CPU%  当前瞬时CPU占用率</span><br><span class="line">S     进程状态:D=不可中断的睡眠状态, R=运行, S=睡眠, T=跟踪/停止, Z=僵尸进程</span><br><span class="line"><span class="comment">#THR  程序当前所用的线程数</span></span><br><span class="line">VSS   Virtual Set Size  虚拟耗用内存（包含共享库占用的内存）</span><br><span class="line">RSS   Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span><br><span class="line">PCY   调度策略优先级，SP_BACKGROUND/SP_FOREGROUND</span><br><span class="line">UID   进程所有者的用户id</span><br><span class="line">Name  进程的名称</span><br></pre></td></tr></table></figure></p><h1 id="adb-shell-netstat-网络相关"><a href="#adb-shell-netstat-网络相关" class="headerlink" title="adb shell netstat 网络相关"></a>adb shell netstat 网络相关</h1><p>adb shell netstat //查看设备的端口号<br>adb shell netcfg  //查看设备的IP地址</p><p>netstat -ano 查看网络连状态<br>显示协议统计信息和当前 TCP/IP 网络连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NETSTAT \[-a\] \[-b\] \[-e\] \[-n\] \[-o\] \[-p proto\] \[-r\] \[-s\] \[-v\] \[interval\]</span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">-a 显示所有连接和监听端口。  </span><br><span class="line">-b 显示包含于创建每个连接或监听端口的可执行组件。在某些情况下已知可执行组件拥有多个独立组件，并且在这些情况下包含于创建连接或监听端口的组件序列被显示。这种情况下，可执行组件名  </span><br><span class="line">在底部的 \[\] 中，顶部是其调用的组件，等等，直到 TCP/IP 部分。注意此选项 可能需要很长时间，如果没有足够权限可能失败。  </span><br><span class="line">-e 显示以太网统计信息。此选项可以与 -s  选项组合使用。  </span><br><span class="line">-n 以数字形式显示地址和端口号。  </span><br><span class="line">-o 显示与每个连接相关的所属进程 ID。  </span><br><span class="line">-p proto 显示 proto 指定的协议的连接；proto 可以是  </span><br><span class="line">下列协议之一: TCP、UDP、TCPv6 或 UDPv6。  </span><br><span class="line">如果与 -s 选项一起使用以显示按协议统计信息，proto 可以是下列协议之一:  </span><br><span class="line">IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。  </span><br><span class="line">-r 显示路由表。  </span><br><span class="line">-s 显示按协议统计信息。默认地，显示 IP、  </span><br><span class="line">IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；  </span><br><span class="line">-p 选项用于指定默认情况的子集。  </span><br><span class="line">-v 与 -b 选项一起使用时将显示包含于  </span><br><span class="line">为所有可执行组件创建连接或监听端口的  </span><br><span class="line">组件。  </span><br><span class="line">interval 重新显示选定统计信息，每次显示之间  </span><br><span class="line">暂停时间间隔(以秒计)。按 CTRL+C 停止重新  </span><br><span class="line">显示统计信息。如果省略，netstat 显示当前  </span><br><span class="line">配置信息(只显示一次)</span><br></pre></td></tr></table></figure></p><h1 id="adb-shell-pm-包相关"><a href="#adb-shell-pm-包相关" class="headerlink" title="adb shell pm 包相关"></a>adb shell pm 包相关</h1><p><a href="https://blog.csdn.net/yelangjueqi/article/details/52575233" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52575233</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">usage: pm \[list|path|install|uninstall\]  </span><br><span class="line">pm list packages \[-f\]  </span><br><span class="line">pm list permission-groups  </span><br><span class="line">pm list permissions \[-g\] \[-f\] \[-d\] \[-u\] \[GROUP\]  </span><br><span class="line">pm list instrumentation \[-f\] \[TARGET-PACKAGE\]  </span><br><span class="line">pm list features  </span><br><span class="line">pm path PACKAGE  </span><br><span class="line">pm dump PACKAGE</span><br><span class="line">pm install \[-l\] \[-r\] \[-t\] \[-i INSTALLER\_PACKAGE\_NAME\] PATH  </span><br><span class="line">pm uninstall \[-k\] PACKAGE  </span><br><span class="line">pm <span class="built_in">enable</span> PACKAGE\_OR\_COMPONENT  </span><br><span class="line">pm <span class="built_in">disable</span> PACKAGE\_OR\_COMPONENT</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">The list packages <span class="built_in">command</span> prints all packages. Options:  </span><br><span class="line">-f: see their associated file.</span><br><span class="line"></span><br><span class="line">The list permission-groups <span class="built_in">command</span> prints all known  </span><br><span class="line">permission groups.</span><br><span class="line"></span><br><span class="line">The list permissions <span class="built_in">command</span> prints all known  </span><br><span class="line">permissions, optionally only those <span class="keyword">in</span> GROUP. Options:  </span><br><span class="line">-g: organize by group.  </span><br><span class="line">-f: <span class="built_in">print</span> all information.  </span><br><span class="line">-s: short summary.  </span><br><span class="line">-d: only list dangerous permissions.  </span><br><span class="line">-u: list only the permissions users will see.</span><br><span class="line"></span><br><span class="line">The list instrumentation <span class="built_in">command</span> prints all instrumentations,  </span><br><span class="line">or only those that target a specified package. Options:  </span><br><span class="line">-f: see their associated file.</span><br><span class="line"></span><br><span class="line">The list features <span class="built_in">command</span> prints all features of the system.</span><br><span class="line"></span><br><span class="line">The path <span class="built_in">command</span> prints the path to the .apk of a package.</span><br><span class="line"></span><br><span class="line">The install <span class="built_in">command</span> installs a package to the system. Options:  </span><br><span class="line">-l: install the package with FORWARD_LOCK.  </span><br><span class="line">-r: reinstall an exisiting app, keeping its data.  </span><br><span class="line">-t: allow <span class="built_in">test</span> .apks to be installed.  </span><br><span class="line">-i: specify the installer package name.</span><br><span class="line"></span><br><span class="line">The uninstall <span class="built_in">command</span> removes a package from the system. Options:  </span><br><span class="line">-k: keep the data and cache directories around.  </span><br><span class="line">after the package removal.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">enable</span> and <span class="built_in">disable</span> commands change the enabled state of  </span><br><span class="line">a given package or component (written as “package/class”).</span><br></pre></td></tr></table></figure><p>查看stdout 和stderr<br>在默认状态下，Android系统有stdout 和 stderr (System.out和System.err )输出到/dev/null ，<br>在运行Dalvik VM的进程中，有一个系统可以备份日志文件。在这种情况下，系统会用stdout 和stderr 和优先级 I.来记录日志信息</p><p>通过这种方法指定输出的路径，停止运行的模拟器/设备，然后通过用setprop 命令远程输入日志</p><p>adbshellstop adb shell stop adb shell setprop log.redirect-stdio true<br>$ adb shell start系统直到你关闭模拟器/设备前设置会一直保留，可以通过添加/data/local.prop 可以使用模拟器/设备上的默认设置</p><p>UI/软件 试验程序 Monkey<br>当Monkey程序在模拟器或设备运行的时候，如果用户出发了比如点击，触摸，手势或一些系统级别的事件的时候，<br>它就会产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件.<br>最简单的方法就是用用下面的命令来使用Monkey，这个命令将会启动你的软件并且触发500个事件.</p><h1 id="adb-shell-am-相关"><a href="#adb-shell-am-相关" class="headerlink" title="adb shell am 相关"></a>adb shell am 相关</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start ...</span><br><span class="line">adb shell am startservice ...</span><br><span class="line">adb shell am broadcast ...</span><br></pre></td></tr></table></figure><h1 id="adb-shel-monkey-Monkey相关"><a href="#adb-shel-monkey-Monkey相关" class="headerlink" title="adb shel monkey Monkey相关"></a>adb shel monkey Monkey相关</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell monkey -v -p your.package.name 500</span><br></pre></td></tr></table></figure><p>更多的关于命令Monkey的命令的信息，可以查看UI/Application Exerciser Monkey documentation page.</p><h1 id="adb-shell-ps-系列"><a href="#adb-shell-ps-系列" class="headerlink" title="adb shell ps 系列"></a>adb shell ps 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep -rn systemui</span><br><span class="line">ps -e | grep -rn system_server</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!--
修改记录：
1.2016年完成第一版
2.2018年修订
完成目标：分析adb的源码
    --&gt;
&lt;p&gt;ADB (Android Debug Bridge)&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android ADB" scheme="http://yoursite.com/tags/Android-ADB/"/>
    
  </entry>
  
  <entry>
    <title>ActionBar隐藏方法</title>
    <link href="http://yoursite.com/2015/06/29/ActionBar%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2015/06/29/ActionBar隐藏方法/</id>
    <published>2015-06-29T03:26:48.000Z</published>
    <updated>2018-07-04T08:45:20.662Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Android中的ActionBar控件时，如果想要隐藏上面的ActionBar，可以使用如下的代码：<br>getSupportActionBar().hide();//隐藏掉整个ActionBar，包括下面的Tabs<br>上面的代码会将整个ActionBar都隐藏掉，包括ActionBar中的Tab分页标签，如果想要保留分页标签的话，可以使用如下的代码：<br>ActionBar actionBar = getSupportActionBar();//高版本可以换成</p><p>ActionBar actionBar = getActionBar();<br>actionBar.setDisplayShowTitleEnabled(false);<br>actionBar.setDisplayShowHomeEnabled(false);<br>//会保留tab标签</p><p>另外还有一种更简单的方式来移除ActionBar，在setContent()之前调用下面这句，保证没有ActionBar<br>导入包：<br>import android.view.Window;<br>requestWindowFeature(Window.FEATURE_NO_TITLE);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Android中的ActionBar控件时，如果想要隐藏上面的ActionBar，可以使用如下的代码：&lt;br&gt;getSupportActionBar().hide();//隐藏掉整个ActionBar，包括下面的Tabs&lt;br&gt;上面的代码会将整个ActionBar都隐
      
    
    </summary>
    
      <category term="Android Tools" scheme="http://yoursite.com/categories/Android-Tools/"/>
    
    
      <category term="Android ActionBar" scheme="http://yoursite.com/tags/Android-ActionBar/"/>
    
  </entry>
  
  <entry>
    <title>Android面试汇总</title>
    <link href="http://yoursite.com/2015/02/01/Android%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2015/02/01/Android面试汇总/</id>
    <published>2015-01-31T16:00:00.000Z</published>
    <updated>2018-07-04T10:22:00.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java面试题"><a href="#Java面试题" class="headerlink" title="Java面试题"></a>Java面试题</h1><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol><li>集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突以及处理算法，ConcurrentHashMap</li></ol><ol start="2"><li>进程和线程的区别</li></ol><ol start="3"><li><p>Java的并发、多线程、线程模型</p></li><li><p>什么是线程池，如何使用<br>线程池就是事先将多个线程对象放到一个容器中，当使用额时候就不用new线程，而是直接去线程池中拿线程就可以了，节省了开辟子线程的时间，提高代码的执行效率。</p></li><li><p>数据一致性如何保证；Synchronized关键字，类锁，方法锁和重入锁</p></li><li><p>Java中实现多态的机制是什么</p></li><li><p>如何将一个Java对象序列化到文件中</p></li><li><p>说说对Java反射的理解<br>Java中的反射，首先是能够获取到Java中要反射类的字节码，获取字节码有三种方式<br>a)Class.forName(classname)<br>b)类名.class<br>c) this.getClass()<br>然后将字节码中的方法、变量、构造函数等映射成相应的Method、Filed、Constructor等<br>d)同步的方法：多进程开发以及多进程应用场景</p></li><li><p>在Java中wait和sleep方法的不同<br>最大的不同是在等待的时候wait会释放锁，而sleep一直持有锁。wait通常用于线程间的交互，sleep通常用于执行暂停</p></li><li><p>synchronized和volatile关键字的作用<br>1) 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是立即可见的</p></li></ol><ol start="11"><li><p>服务器只提供数据接收接口，在多线程或多线程条件下，如何保证数据的有序到达</p></li><li><p>TheadLocal原理，实现以及如何保证Local属性</p></li><li><p>String、StringBuilder、StringBuffer的对比</p></li><li><p>你所知道的设计模式</p></li><li><p>Java如何调用C、C++语言</p></li><li><p>接口和回调，回调的原理，写一个回调的demo</p></li><li><p>泛型的原理，举例说明；解析与分派</p></li><li><p>抽象类和接口的区别；应用场景，抽象类是否可以没有方法和属性</p></li><li><p>静态属性和静态方法是否可以被继承？是否可以被重写？什么原因</p></li><li><p>修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法</p></li><li><p>说说对泛型的理解</p></li><li><p>Java的异常体系</p></li><li><p>如何控制某个方法运行并发访问线程的个数</p></li><li><p>动态代理的区别，分别在什么场景下使用</p></li></ol><h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><h2 id="Android基础"><a href="#Android基础" class="headerlink" title="Android基础"></a>Android基础</h2><ol><li><p>什么是ANR？如何避免它？<br>看《ANR机制以及问题分析》</p></li><li><p>View的绘制流程？自定义View如何考虑机型适配？ View的事件分发机制？</p></li><li><p>ART和Dalvik的对比，JVM的内存 分配和垃圾回收GC机制,虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)，JVM的内存模型以及类加载机制，内存对象的循环应用以及避免</p></li></ol><ol start="4"><li>DDMS/traceView/systrace</li></ol><ol start="5"><li>内存回收机制与GC算法(各种算法的优缺点以及应用场景)；GC的原理时机以及GC对象；内存泄漏的场景以及解决方法</li></ol><ol start="6"><li>四大组件以及生命周期；ContentProvider的权限管理(读写分离，权限控制-精确到表级，URL控制)，Activity的四种启动模式的对比，Activity状态保存于恢复</li></ol><ol start="7"><li>什么是AIDL，以及如何使用.</li></ol><ol start="8"><li>请解释下在单线程模型中Message、Hanlder、MessageQueue、Looper之间的关系</li></ol><ol start="9"><li>Fragment生命周期，Fragment状态保存,startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用，应该如何解耦</li></ol><ol start="10"><li>AsyncTask 原理以及不足，IntentService的原理</li></ol><ol start="11"><li><p>Activity怎么和Service绑定，怎么在Activity中启动对应的Service</p></li><li><p>AsyncTask + HttpClient 与 AsyncHttpClient有什么区别</p></li><li><p>请描述一下Service的生命周期</p></li></ol><ol start="14"><li><p>如何保证一个后台服务不被杀死；比较省电的方式是什么？</p></li><li><p>如何通过广播拦截和abort一条短信；广播是否可以请求网络，广播引起的ANR的时间限制</p></li><li><p>进程间通信的方式有哪些？ AIDL</p></li><li><p>事件分发中的onTouch和onTouchEvent有什么区别，又该如何使用</p></li></ol><ol start="18"><li><p>说说 ContentProvider/ContentResolver/ContentObservr之间的关系</p></li><li><p>请介绍一下ContentProvider是如何实现数据共享的</p></li><li><p>Handler的机制以及底层的实现</p></li><li><p>Binder机制以及底层的实现</p></li><li><p>ListView中图片错位的问题是如何产生的</p></li><li><p>在manifest和代码中是如何注册和使用广播的</p></li><li><p>说说Activity/Intent/Service是什么关系</p></li><li><p>ApplicationContext和ActivityContext的区别是什么</p></li></ol><ol start="26"><li><p>一张Bitmap所占内存以及内存占用的计算方法</p></li><li><p>Serializable和Parcelable的区别</p></li><li><p>请描述一下BroadcastReceiver</p></li></ol><ol start="29"><li>请描述一下Android的事件分发机制</li></ol><ol start="30"><li><p>请介绍一下NDK</p></li><li><p>什么是NDK库，如何在JNI中注册native函数，有几种注册方式</p></li><li><p>Async如何使用</p></li></ol><ol start="33"><li><p>对于应用更新这块是如何做的？(灰度？强制更新？分区域更新？)</p></li><li><p>混合开发：ReactNative/weex/H5/小程序/Flutter</p></li><li><p>什么情况下会导致内存泄漏</p></li><li><p>如何对Android应用进行性能分析以及优化</p></li><li><p>说一款你认为当前比较火的应用并设计(直播APP)</p></li><li><p>OOM的避免异常以及解决方法</p></li><li><p>屏幕适配的处理技巧有哪些</p></li><li><p>两个Activity之间跳转时必然会执行的是哪几个方法</p></li></ol><ol start="41"><li><p>MVC、MVP、MVVM、常见的设计模式，写出观察者模式代码</p></li><li><p>TCP的三次握手和四次挥手，TCP与UDP的区别</p></li><li><p>HTTP协议；HTTP 1.0与2.0的区别，HTTP报文结构</p></li><li><p>都使用过哪些框架和平台</p></li><li><p>都使用过哪些自定义控件</p></li><li><p>介绍你做过的项目</p></li></ol><h2 id="非技术问题汇总"><a href="#非技术问题汇总" class="headerlink" title="非技术问题汇总"></a>非技术问题汇总</h2><ol><li><p>研究的比较深的领域有哪些</p></li><li><p>对业内信息的关注渠道有哪些</p></li><li><p>最近都读了哪些书</p></li><li><p>自己最擅长的技术点，最感兴趣的技术领域和技术点</p></li><li><p>项目中使用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题</p></li><li><p>实习过程中做了什么，有哪些产出</p></li><li><p>5枚硬币，2正3反，如何划分为两堆然后通过翻转让两堆中正面向上的硬币和反面向上的硬币个数相同</p></li><li><p>时针走一圈，时针和分针重合几次</p></li><li><p>N*N的方格纸，里面有多少个正方形</p></li><li><p>现在下载速度很慢，试从网络协议的角度分析原因，并优化，网络的5层都可以涉及</p></li></ol><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><ol><li><p>堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)</p></li><li><p>最快的排序算法是哪个？给阿里2万多员工按年龄排序应该选择哪个算法？堆和树的区别？写出快排代码，链表逆序代码</p></li><li><p>求1000以内的水仙花数以及40亿以内的水仙花数</p></li><li><p>子串包含问题(KMP算法)写代码实现</p></li><li><p>万亿级别的两个URL文件A和B，如何求出A和B的差集C</p></li><li><p>蚁群算法和蒙特卡洛算法</p></li><li><p>写出你所知道的排序算法以及时空复杂度，稳定性</p></li><li><p>百度POI中如何试下查找最近商家功能(坐标镜像+R树)</p></li><li><p>死锁的四个必要条件</p></li><li><p>常见的编码方式，utf-8变种中文占几个字节，int型占几个字节</p></li></ol><h1 id="HR问题"><a href="#HR问题" class="headerlink" title="HR问题"></a>HR问题</h1><ol><li><p>上家离职的原因</p></li><li><p>讲一件你印象最深的事情</p></li><li><p>介绍一个你影响最深的项目</p></li><li><p>介绍你最热爱最擅长的专业领域</p></li><li><p>公司实习最大的收获是什么</p></li><li><p>与上级意见不一致时，你怎么办</p></li><li><p>自己的优点和缺点是什么，并举例说明</p></li><li><p>你的学习方法是什么样的？实习过程中如何学习？实习过程中遇到的最大困难是什么，以及如何解决的？</p></li><li><p>说一件最能证明你能力的事情</p></li><li><p>针对你申请的这个职位，你认为你还欠缺什么</p></li><li><p>项目中遇到的最大困难时什么，如何解决</p></li><li><p>职业规划以及个人目标，未来发展路线以及求职定位</p></li></ol><ol start="13"><li></li></ol><h1 id="Java-基础-必须要完全的掌握，越熟练越好"><a href="#Java-基础-必须要完全的掌握，越熟练越好" class="headerlink" title="Java 基础 (必须要完全的掌握，越熟练越好)"></a>Java 基础 (必须要完全的掌握，越熟练越好)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  本部分内容主要包含以下知识点，这些内容都是Java中的基础知识，对于Java的学习很有帮助.其中集合、反射、IO等都是面试常问的知识点，是<strong>必须掌握</strong>的。</p><ul><li>Java集合</li><li>Java反射</li><li>Java注解</li><li>Java I/O</li><li>Java泛型</li><li>Cloneable </li><li>Serializable</li><li>Iterator</li></ul><h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><p>  Java集合大致可以分为Set、List、Queue和Map四种体系.</p><p>  其中Set 集合：代表无序，不可重复的集合;<br>  List：代表有序，重复的集合;<br>  Queue:是先进先出的队列集合;<br>  Map：代表映射关系的集合;</p><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>  Java集合就像一种容器，可以把多个对象(实际上是对象的引用，但习惯上都称对象)”丢进”该容器中,从Java 5 增加了泛型之后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮.</p><ol><li><p>Java集合和数组的区别：<br>a)数组长度在初始化的时候指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据，同时可以保存具有映射关系的数据(即关联数组，键值对key-value).<br>b)数组的元素既可以是基本数据类型，也可以是对象.集合中只能保存对象(实际上只是保存对象的引用变量)，基本数据类型的变量要转换成对应的包装类才能放入集合类中.</p></li><li><p>Java集合类之间的继承关系：<br>Java的集合类主要由两个接口派生而出：Collection和Map,Collection 和 Map是Java集合框架的根接口.<br>Collection的派生树 如下：<br><img src="https://camo.githubusercontent.com/b1974bdd58e78c12612907d0ad27b893f8fbdbb9/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d653766656266333634643864383233352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Collection的派生树"><br>图中后面[I]表示是接口，[C]表示是类，[AC]表示是抽象类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection[I]</span><br><span class="line">└── Set[I] </span><br><span class="line">|     └── SortedSet[I]</span><br><span class="line">|     |         └── TreeSet[C]</span><br><span class="line">|     └── HashSet[C]</span><br><span class="line">|     |          └── LinkedHashSet[C]</span><br><span class="line">|     └── EnumSet[C]</span><br><span class="line">└── Queue[I]</span><br><span class="line">|      └── PriorityQueue[C]</span><br><span class="line">|      └── Deque[I]</span><br><span class="line">|              └── ArraryDeque[C]</span><br><span class="line">|              └── LinkedList[C]</span><br><span class="line">└── List[I]</span><br><span class="line">       └── LinkedList[C]</span><br><span class="line">       └── ArraryList[C]</span><br><span class="line">       |           └── AttributList[C]</span><br><span class="line">       └── Vector[C]</span><br><span class="line">               └── Stack[C]</span><br></pre></td></tr></table></figure><p>此图中，ArrayList，HashSet，LinkedList，TreeSet是我们经常会有用到的已实现的集合类.</p></li></ol><p>   Map 类实现用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，<strong>Map里面的key是不可重复的，key用于表示集合里面的每一项数据.</strong>，这是Map和Collection最大的区别.<br>   <img src="https://camo.githubusercontent.com/517258d1f1e996c7a728c8fe067c439722fc61ce/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d303630353231303738343961373630332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Map的派生树"><br>   图中后面[I]表示是接口，[C]表示是类，[AC]表示是抽象类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map</span><br><span class="line">└── SortMap</span><br><span class="line">|       └──  TreeMap</span><br><span class="line">└── WeakHashMap</span><br><span class="line">└── EnumMap</span><br><span class="line">└── HashMap </span><br><span class="line">|       └── LinkedHashMap</span><br><span class="line">└── IdentityHashMapMap</span><br><span class="line">└── HashTable</span><br><span class="line">        └── Properties</span><br></pre></td></tr></table></figure></p><p>   图中，HashMap、TreeMap是我们经常用到的集合类</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>  Collection是 Set、List、Queue的父接口<br>  在接口中定义了多种方法提供给子类进行实现，以实现数据操作.<br>  Collection.java代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Collection&lt;E&gt; extends java.lang.Iterable &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean contains(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;E&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public abstract java.lang.Object[] toArray();</span><br><span class="line">  </span><br><span class="line">  public abstract &lt;T&gt; T[] toArray(T[] arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean add(E arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean containsAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean addAll(java.util.Collection&lt;? extends E&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean removeAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public  boolean removeIf(java.util.function.Predicate&lt;? super E&gt; arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean retainAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.stream.Stream&lt;E&gt; <span class="function"><span class="title">stream</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.stream.Stream&lt;E&gt; <span class="function"><span class="title">parallelStream</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a>可以查看到每个函数的具体作用.</p><p>可以看出Collection用法有：添加元素、删除元素，返回Collection集合个数以及清空集合等.其中重点介绍iterator()方法，该方法的返回值是Iterator.</p><p>从Collection的源码看到，Iterable是Collection的父接口,Iterable的源码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.lang;</span><br><span class="line">public abstract interface Iterable&lt;T&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;T&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public  void forEach(java.util.function.Consumer&lt;? super T&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;T&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">可以看到Iterable接口中有一个抽象方法iterator()</span><br><span class="line">``` bash</span><br><span class="line">public abstract  java.util.Iterator&lt;T&gt; iterator();</span><br></pre></td></tr></table></figure></p><p>iterator()方法的返回类型是Iterator型，我们再看看Iterator的源码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract boolean hasNext();</span><br><span class="line">  </span><br><span class="line">  public abstract  E next();</span><br><span class="line">  </span><br><span class="line">  public void <span class="function"><span class="title">remove</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void forEachRemaining(java.util.function.Consumer&lt;? super E&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从JDK文档中可以看到Iterator 是对 collection 进行迭代的迭代器.主要作用是遍历Collection里面的元素.</p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>  Set集合和Collection集合完全相同，没有提供额外的方法，只是行为略有不同(Set不允许包含重复元素).<br>  我们来看看Set的源码.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Set&lt;E&gt; extends java.util.Collection &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean contains(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Iterator&lt;E&gt; iterator();</span><br><span class="line">  </span><br><span class="line">  public abstract java.lang.Object[] toArray();</span><br><span class="line">  </span><br><span class="line">  public abstract &lt;T&gt; T[] toArray(T[] arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean add(E arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean containsAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean addAll(java.util.Collection&lt;? extends E&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean retainAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  boolean removeAll(java.util.Collection&lt;?&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Set.java也是一个接口，从Set.java和Collection.java的代码来看，几乎一样的.</p><p>通过查看源码，我们发现最后Set集合的类，都是继承自AbstractSet类，实现了Set、Cloneable、Serializable接口<br>以HashSet为例，看下它的源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public class HashSet&lt;E&gt; extends java.util.AbstractSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable &#123;</span><br><span class="line">  </span><br><span class="line">  static final long serialVersionUID = -5024744406713321676L;</span><br><span class="line">  </span><br><span class="line">  private transient java.util.HashMap&lt;E,java.lang.Object&gt; map;</span><br><span class="line">  </span><br><span class="line">  private static final java.lang.Object PRESENT;</span><br><span class="line">  </span><br><span class="line">  public <span class="function"><span class="title">HashSet</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  HashSet(java.util.Collection&lt;? extends E&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public HashSet(int arg0, <span class="built_in">float</span> arg1) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public HashSet(int arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  HashSet(int arg0, <span class="built_in">float</span> arg1, boolean arg2) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Iterator&lt;E&gt; <span class="function"><span class="title">iterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int <span class="function"><span class="title">size</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean <span class="function"><span class="title">isEmpty</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean contains(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean add(E arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean remove(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void <span class="function"><span class="title">clear</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public java.lang.Object <span class="function"><span class="title">clone</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void writeObject(java.io.ObjectOutputStream arg0) throws java.io.IOException &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void readObject(java.io.ObjectInputStream arg0) throws java.io.IOException, java.lang.ClassNotFoundException &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  java.util.Spliterator&lt;E&gt; <span class="function"><span class="title">spliterator</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  static &#123;&#125; &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来看看AbstractSet这个抽象类的源码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> // Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line"> // Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract class AbstractSet&lt;E&gt; extends java.util.AbstractCollection implements java.util.Set &#123;</span><br><span class="line">  </span><br><span class="line">  protected <span class="function"><span class="title">AbstractSet</span></span>() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean equals(java.lang.Object arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int <span class="function"><span class="title">hashCode</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean removeAll(java.util.Collection&lt;?&gt; arg0) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查阅JDK api看到对AbstractSet类的解释是：此类提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。<br>看到这里有点懵了，</p><p>  Map.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// Failed to get sources. Instead, stub sources have been generated by the disassembler.</span><br><span class="line">// Implementation of methods is unavailable.</span><br><span class="line">package java.util;</span><br><span class="line">public abstract interface Map&lt;K,V&gt; &#123;</span><br><span class="line">  </span><br><span class="line">  public abstract int size();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean isEmpty();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean containsKey(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract boolean containsValue(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  V get(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  V put(K arg0, V arg1);</span><br><span class="line">  </span><br><span class="line">  public abstract  V remove(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract  void putAll(java.util.Map&lt;? extends K,? extends V&gt; arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract void clear();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Set&lt;K&gt; keySet();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Collection&lt;V&gt; values();</span><br><span class="line">  </span><br><span class="line">  public abstract  java.util.Set&lt;java.util.Map.Entry&lt;K,V&gt;&gt; entrySet();</span><br><span class="line">  </span><br><span class="line">  public abstract boolean equals(java.lang.Object arg0);</span><br><span class="line">  </span><br><span class="line">  public abstract int hashCode();</span><br><span class="line">  </span><br><span class="line">  public  V getOrDefault(java.lang.Object arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void forEach(java.util.function.BiConsumer&lt;? super K,? super V&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  void replaceAll(java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg0) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V putIfAbsent(K arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean remove(java.lang.Object arg0, java.lang.Object arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  boolean replace(K arg0, V arg1, V arg2) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V replace(K arg0, V arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V computeIfAbsent(K arg0, java.util.function.Function&lt;? super K,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V computeIfPresent(K arg0, java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V compute(K arg0, java.util.function.BiFunction&lt;? super K,? super V,? extends V&gt; arg1) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public  V merge(K arg0, V arg1, java.util.function.BiFunction&lt;? super V,? super V,? extends V&gt; arg2) &#123;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol><li><p>引入泛型的目的<br>了解引入泛型的动机，就先从语法糖开始了解</p><p><strong>语法糖</strong></p><p>语法糖(Synactic Sugar),也称糖衣语法，英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用.</p><p>Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等.虚拟机并不支持这些语法，它们在编译阶段被还原回了简单的基础语法结构，这个过程成为解语法糖.</p><p>泛型的目的：泛型的目的是使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常.</p></li><li><p>泛型初探<br>JDK 1.5 才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型.<br>在泛型（Generic type或Generics）出现之前，是这么写代码的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List list = new ArrayList();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println((String)list.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这是完全允许的，因为List里面的内容是Object类型的，自然任何对象类型都可以放入、都可以取出，但是这么写会有两个问题：</p><p>1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。<br>2、运行时需要人为地强制转换类型到具体目标，实际的程序绝不会这么简单，一个不小心就会出现java.lang.ClassCastException。</p><p>所以，泛型出现之后，上面的代码就改成了大家都熟知的写法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"123"</span>);</span><br><span class="line">    list.add(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list.get(0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是泛型。泛型是对Java语言类型系统的一种扩展，有点类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。引入泛型，是对Java语言一个较大的功能增强，带来了很多的好处。</p></li><li><p>泛型的好处<br>①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。</p><p>②消除了代码中许多的强制类型转换，增强了代码的可读性。</p><p>③为较大的优化带来了可能。</p></li></ol><h3 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h3><ol><li><p>泛型类和泛型接口<br>下面是JDK 1.5 以后，List接口，以及ArrayList类的代码片段.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//定义接口时指定了一个类型形参，该形参名为E</span><br><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;</span><br><span class="line">   //在该接口里，E可以作为类型使用</span><br><span class="line">   public E get(int index) &#123;&#125;</span><br><span class="line">   public void add(E e) &#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义类时指定了一个类型形参，该形参名为E</span><br><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;</span><br><span class="line">   //在该类里，E可以作为类型使用</span><br><span class="line">   public void <span class="built_in">set</span>(E e) &#123;</span><br><span class="line">   .......................</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是<strong>泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。</strong></p><p>下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。</p><p><strong>泛型类</strong></p><p>定义一个容器类，存放键值对key-value，键值对的类型不确定，可以使用泛型来定义，分别指定为K和V。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Container&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private K key;</span><br><span class="line">    private V value;</span><br><span class="line"></span><br><span class="line">    public Container(K k, V v) &#123;</span><br><span class="line">        key = k;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public K <span class="function"><span class="title">getkey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V <span class="function"><span class="title">getValue</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">setKey</span></span>() &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">setValue</span></span>() &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Container&lt;String,String&gt;  c1=new Container&lt;String ,String&gt;(<span class="string">"name"</span>,<span class="string">"hello"</span>);</span><br><span class="line">    Container&lt;String,Integer&gt; c2=new Container&lt;String,Integer&gt;(<span class="string">"age"</span>,22);</span><br><span class="line">    Container&lt;Double,Double&gt;  c3=new Container&lt;Double,Double&gt;(1.1,1.3);</span><br><span class="line">    System.out.println(c1.getKey() + <span class="string">" : "</span> + c1.getValue());      </span><br><span class="line">    System.out.println(c2.getKey() + <span class="string">" : "</span> + c2.getValue());                                                               </span><br><span class="line">    System.out.println(c3.getKey() + <span class="string">" : "</span> + c3.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK 1.7 增加了泛型的“菱形”语法：<strong>Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。</strong><br>如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container&lt;String,String&gt; c1=new Container&lt;&gt;(<span class="string">"name"</span>,<span class="string">"hello"</span>);</span><br><span class="line">Container&lt;String,Integer&gt; c2=new Container&lt;&gt;(<span class="string">"age"</span>,22);</span><br></pre></td></tr></table></figure><p><strong>泛型类派生子类</strong></p><p>当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：<strong>使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。</strong><br>错误的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&lt;K, V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>正确的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&lt;Integer, String&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以不指定具体的类型，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class A extends Container&#123;&#125;</span><br></pre></td></tr></table></figure><p>此时系统会把K,V形参当成Object类型处理。</p></li><li><p>泛型的方法<br>前面在介绍泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 如下面的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Container&lt;K, V&gt;</span><br><span class="line"> &#123;</span><br><span class="line">........................</span><br><span class="line">    public K <span class="function"><span class="title">getkey</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">setKey</span></span>() &#123;</span><br><span class="line">        this.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">  public static &lt;T&gt; void out(T t)&#123;</span><br><span class="line">       System.out.println(t);</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String[] args)&#123;</span><br><span class="line">       out(<span class="string">"hansheng"</span>);</span><br><span class="line">       out(123);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符&lt;T, S&gt; 返回值类型 方法名（形参列表）｛</span><br><span class="line">   方法体</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;  </span><br><span class="line">  public &lt;T&gt; T fun(T t)&#123;   // 可以接收任意类型的数据  </span><br><span class="line">   <span class="built_in">return</span> t ;     // 直接把参数返回  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">public class GenericsDemo26&#123;  </span><br><span class="line">  public static void main(String args[])&#123;  </span><br><span class="line">    Demo d = new Demo() ; // 实例化Demo对象  </span><br><span class="line">    String str = d.fun(<span class="string">"汤姆"</span>) ; // 传递字符串  </span><br><span class="line">    int i = d.fun(30) ;  // 传递数字，自动装箱  </span><br><span class="line">    System.out.println(str) ; // 输出内容  </span><br><span class="line">    System.out.println(i) ;  // 输出内容  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。</p></li><li><p>泛型构造器<br>正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。<br>和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    public &lt;T&gt; Person(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        //隐式</span><br><span class="line">        new Person(22);</span><br><span class="line">        //显示</span><br><span class="line">        new&lt;String&gt; Person(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一需要特殊注明的就是，如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：<br>因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。<br>以下面这个例子为代表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person&lt;E&gt; &#123;</span><br><span class="line">    public &lt;T&gt; Person(T t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&lt;String&gt; a = new &lt;Integer&gt;Person&lt;&gt;(15);</span><br></pre></td></tr></table></figure><p>这种语法不允许，会直接编译报错！</p></li></ol><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p> 顾名思义就是匹配任意类型的类型实参.<br> 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="built_in">test</span>(List&lt;?&gt; c)&#123;</span><br><span class="line">  <span class="keyword">for</span>(int i =0;i&lt;c.size();i++)&#123;</span><br><span class="line">    System.out.println(c.get(i));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 现在可以传入任何类型的List来调用test()方法，程序依然可以访问集合c中的元素，其类型是Object。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; c = new ArrayList&lt;String&gt;();</span><br><span class="line">//编译器报错</span><br><span class="line">c.add(new Object());</span><br></pre></td></tr></table></figure></p><p> 但是并不能把元素加入到其中。因为程序无法确定c集合中元素的类型，所以不能向其添加对象。<br> 下面就该引入带限通配符，来确定集合元素中的类型。</p><p> <strong>带限通配符</strong><br> 单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。<br> 主要分为两类即：<strong>上限通配符</strong>和<strong>下限通配符</strong>。</p><ol><li><p>上限通配符<br>如果想限制使用泛型类别时，只能用某个特定类型或者是其<strong>子类型</strong>才能实例化该类型时，可以在定义类型时，<strong>使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身</strong></p><p>表示集合中的所有元素都是Shape类型或者其子类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Shape&gt;</span><br></pre></td></tr></table></figure><p>这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Circle是其子类</span><br><span class="line">List&lt;? extends Shape&gt; list = new ArrayList&lt;Circle&gt;();</span><br></pre></td></tr></table></figure><p>这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。</p></li><li><p>下限通配符<br>如果想限制使用泛型类别时，只能用某个特定类型或者是其<strong>父类型</strong>才能实例化该类型时，可以在定义类型时，<strong>使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。</strong></p><p>表示集合中的所有元素都是Circle类型或者其父类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List &lt;? super Circle&gt;</span><br></pre></td></tr></table></figure><p>这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Shape是其父类</span><br><span class="line">List&lt;? super Circle&gt; list = new ArrayList&lt;Shape&gt;();</span><br></pre></td></tr></table></figure></li></ol><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class c1=new ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">Class c2=new ArrayList&lt;String&gt;().getClass();</span><br><span class="line">System.out.println(c1==c2);</span><br></pre></td></tr></table></figure><p> 程序输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p><p><strong>在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。</strong></p><h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p> 要理解注解(Annotation)作用，就要先理解Java中的元数据的概念。</p><ol><li><p>元数据概念<br>元数据是关于数据的数据，在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。</p></li><li><p>元数据的作用<br>一般来说，元数据可以用于创建文档(根据程序元素上的注释创建文档),跟踪代码中的依赖性(可声明方法是重载，依赖父类的方法)，执行编译时检查(可声明是否编译期监测)，代码分析。<br>如下：<br>1) 编写文档： 通过代码里标识的元数据生成文档<br>2) 代码分析： 通过代码里标识的元数据对代码进行分析<br>3）编译检查： 通过代码里标识的元数据让编译器能实现基本的编译检查</p></li><li><p>Java平台元数据<br>注解Annotation就是Java平台的元数据，是J2SE5.0新增加的功能，该机制允许在Java代码中添加自定义注释，并允许通过反射(reflection),以编程方式访问元数据注释。通过提供为程序元素(类、方法等)附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。</p></li></ol><h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h3><ol><li><p>注解(Annotation)的概念<br>注解是在JDK1.5之后新增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或者编译工具解析。</p><p>关于注解(Annotation)的作用，其实就是上述元数据的作用。</p><p><strong>注意：Annotation能被用来为程序元素(类、方法、成员变量等)设置元数据。Annotation不影响程序代码的执行，无论增加、删除Annotation，代码始终如一的执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或者编译工具对Annotation中的信息进行解析和处理.</strong></p></li><li><p>内建注解<br>Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppresWarnings以及@FunctionallInterface者四个注解。内建注解主要实现呢了元数据的第二个作用：<strong>编译检查</strong>。</p><p><strong>@Override</strong><br>用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。</p><p>@Override可适用元素为方法，仅仅保留在Java源文件中。</p><p><strong>@Deprecated</strong><br>用途：使用这个注解，用于告知编译器吗，某一程序元素(比如方法，成员变量)不建议使用了(即过时了).<br>例如：<br>Person类中的info()方法使用@Deprecated表示该方法过时了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public void <span class="function"><span class="title">info</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用info()方法会编译器会出现警告，告知该方法已过时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Person person = nre Person();</span><br><span class="line">person.info();//info函数会有一个删除线</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解类型分析：@Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时。</p></li></ol><p><strong>@SuppressWarnings</strong><br> 用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。<br> 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。</p><p> 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SupressWarning(value=&#123;<span class="string">"uncheck"</span>,<span class="string">"deprecation"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p> <img src="https://camo.githubusercontent.com/bd0738100994d5221b0ae2783ae2db6851d0591f/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d323465333963646166306436326337352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="SuppressWarning参数"></p><p> <strong>@FunctionalInterface</strong><br> 用途：用户告知编译器，检查这个接口，保证该接口是函数式接口，即只能包含一个抽象方法，否则就会编译出错。</p><p> 注解类型分析： @FunctionalInterface可适合用于注解类型声明，保留时长为运行时。</p><ol start="3"><li><p>元Annotation<br>JDK除了在java.lang提供了上述内建注解外，还在java.lang.annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。</p><p>我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。</p><p><strong>当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。</strong></p><p><strong>@Documented</strong></p><p>@Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。<br>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">public @interface Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义@Deprecated时使用了@Documented，则任何元素使用@Deprecated修饰时，在生成API文档时，将会包含@Deprecated的说明<br>以下是String的一个过时的构造方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated</span><br><span class="line">public String(byte[] ascii,int hibyte,int offset, int count)</span><br></pre></td></tr></table></figure><p>该注解实现了元数据的第一个功能：<strong>编写文档</strong>。</p><p><strong>@Inherited</strong><br>@Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表：<br><img src="https://camo.githubusercontent.com/6ed7adc069270fc38dc3975727e7c52eb0ef6f05/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d383238666536386663646638333462342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Retention"></p><p><strong> @Target</strong><br>@Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表：<br><img src="https://camo.githubusercontent.com/9dec3ec2d382a6c13ed4f7742e9abf9b8a653c11/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d376234353764663231343366613564642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Target"></p></li></ol><h3 id="自定义注解（Annotation）"><a href="#自定义注解（Annotation）" class="headerlink" title="自定义注解（Annotation）"></a>自定义注解（Annotation）</h3><p> 创建自定义注解，与创建接口有几分相似，但注解需要以@开头。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Inherited</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotataion&#123;</span><br><span class="line">    String name();</span><br><span class="line">    String website() default <span class="string">"hello"</span>;</span><br><span class="line">    int revision() default 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> <strong>自定义注解中定义成员变量的规则：</strong><br> 其定义是以无形参的方法形式来声明的。即：<br> 注解方法不带参数，比如name()，website()；<br> 注解方法返回值类型：基本类型、String、Enums、Annotation以及前面这些类型的数组类型<br> 注解方法可有默认值，比如default “hello”，默认website=”hello”</p><p> <strong>当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationDemo &#123;</span><br><span class="line">    @MyAnnotataion(name=<span class="string">"lvr"</span>, website=<span class="string">"hello"</span>, revision=1)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(<span class="string">"I am main method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&#123; <span class="string">"unchecked"</span>, <span class="string">"deprecation"</span> &#125;)</span><br><span class="line">    @MyAnnotataion(name=<span class="string">"lvr"</span>, website=<span class="string">"hello"</span>, revision=2)</span><br><span class="line">    public void <span class="function"><span class="title">demo</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am demo method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于该注解的保留策略为RetentionPolicy.RUNTIME，故可在运行期通过反射机制来使用，否则无法通过反射机制来获取。这时候注解实现的就是元数据的第二个作用：<strong>代码分析</strong>。<br>下面来具体介绍如何通过反射机制来进行注解解析。</p><h3 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h3><p> 接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：<br> <img src="https://camo.githubusercontent.com/9fc1c7b7bd804977ad256f8b7b8ddf7fb1eddb2a/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d343037376262616566356232376134622e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Reflect"></p><p> 因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationParser &#123;</span><br><span class="line">    public static void main(String[] args) throws SecurityException, ClassNotFoundException &#123;</span><br><span class="line">        String clazz = <span class="string">"com.lvr.annotation.AnnotationDemo"</span>;</span><br><span class="line">        Method[]  demoMethod = AnnotationParser.class</span><br><span class="line">                .getClassLoader().loadClass(clazz).getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : demoMethod) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(MyAnnotataion.class)) &#123;</span><br><span class="line">                 MyAnnotataion annotationInfo = method.getAnnotation(MyAnnotataion.class);</span><br><span class="line">                 System.out.println(<span class="string">"method: "</span>+ method);</span><br><span class="line">                 System.out.println(<span class="string">"name= "</span>+ annotationInfo.name() +</span><br><span class="line">                         <span class="string">" , website= "</span>+ annotationInfo.website()</span><br><span class="line">                        + <span class="string">" , revision= "</span>+annotationInfo.revision());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上仅是一个示例，其实可以根据拿到的注解信息做更多有意义的事。</p><h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ol><li><p>Java反射机制的定义<br>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p></li><li><p>Java反射机制的功能<br>a).在运行时判断任意一个对象所属的类。<br>b).在运行时构造任意一个类的对象。<br>c).在运行时判断任意一个类所具有的成员变量和方法。<br>d).在运行时调用任意一个对象的方法。<br>e).生成动态代理。</p></li><li><p>Java 反射机制的应用场景<br>a).逆向代码  例如反编译<br>b).与注解相结合的框架 例如Retrofit<br>c).单纯的反射机制应用框架 例如EventBus<br>d).动态生成类框架 例如Gson</p></li></ol><h3 id="通过Java反射查看类信息"><a href="#通过Java反射查看类信息" class="headerlink" title="通过Java反射查看类信息"></a>通过Java反射查看类信息</h3><p> 一、 获得Class对象<br> 每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。<br> 在Java程序中获得Class对象通常有如下三种方式：</p><ol><li>使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。</li><li>调用某个类的class属性来获取该类对应的Class对象。</li><li><p>调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//第一种方式 通过Class类的静态方法——forName()来实现</span><br><span class="line">class1 = Class.forName(<span class="string">"com.lvr.reflection.Person"</span>);</span><br><span class="line">//第二种方式 通过类的class属性</span><br><span class="line">class1 = Person.class;</span><br><span class="line">//第三种方式 通过对象getClass方法</span><br><span class="line">Person person = new Person();</span><br><span class="line">Class&lt;?&gt; class1 = person.getClass();</span><br></pre></td></tr></table></figure><p>二、获取class对象的属性、方法、构造函数等</p></li><li><p>获取class对象的成员变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性</span><br><span class="line">Field[] publicFields = class1.getFields();//获取class对象的public属性</span><br><span class="line">Field ageField = class1.getDeclaredField(<span class="string">"age"</span>);//获取class指定属性</span><br><span class="line">Field desField = class1.getField(<span class="string">"des"</span>);//获取class指定的public属性</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法</span><br><span class="line">Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法</span><br><span class="line">Method method = class1.getMethod(<span class="string">"info"</span>, String.class);//返回次Class对象对应类的、带指定形参列表的public方法</span><br><span class="line">Method declaredMethod = class1.getDeclaredMethod(<span class="string">"info"</span>, String.class);//返回次Class对象对应类的、带指定形参列表的方法</span><br></pre></td></tr></table></figure></li><li><p>获取class对象的构造函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数</span><br><span class="line">Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</span><br><span class="line">Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数</span><br></pre></td></tr></table></figure></li><li><p>其他方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解</span><br><span class="line">Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解</span><br><span class="line">Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 Type</span><br><span class="line">Type[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的<span class="built_in">type</span>集合</span><br></pre></td></tr></table></figure><p>三、 获取class对象的信息<br>比较多</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型</span><br><span class="line">boolean isArray = class1.isArray();//判断是否是集合类</span><br><span class="line">boolean isAnnotation = class1.isAnnotation();//判断是否是注解类</span><br><span class="line">boolean isInterface = class1.isInterface();//判断是否是接口类</span><br><span class="line">boolean isEnum = class1.isEnum();//判断是否是枚举类</span><br><span class="line">boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类</span><br><span class="line">boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰</span><br><span class="line">String className = class1.getName();//获取class名字 包含包名路径</span><br><span class="line">Package aPackage = class1.getPackage();//获取class的包信息</span><br><span class="line">String simpleName = class1.getSimpleName();//获取class类名</span><br><span class="line">int modifiers = class1.getModifiers();//获取class访问权限</span><br><span class="line">Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类</span><br><span class="line">Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类</span><br></pre></td></tr></table></figure></li></ol><h3 id="通过Java反射生成并操作对象"><a href="#通过Java反射生成并操作对象" class="headerlink" title="通过Java反射生成并操作对象"></a>通过Java反射生成并操作对象</h3><p> 一、生成类的实例对象</p><ol><li><p>使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p></li><li><p>先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//第一种方式 Class对象调用newInstance()方法生成</span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line">//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数</span><br><span class="line">obj = constructor.newInstance(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></li></ol><p> 二、调用类的方法</p><ol><li><p>通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。</p></li><li><p>调用Method对象中的Object invoke(Object obj, Object… args)方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 生成新的对象：用newInstance()方法</span><br><span class="line"> Object obj = class1.newInstance();</span><br><span class="line">//首先需要获得与该方法对应的Method对象</span><br><span class="line">Method method = class1.getDeclaredMethod(<span class="string">"setAge"</span>, int.class);</span><br><span class="line">//调用指定的函数并传递参数</span><br><span class="line">method.invoke(obj, 28);</span><br></pre></td></tr></table></figure></li></ol><p><strong>当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。<br>setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。</strong></p><p> 三、访问成员变量值</p><ol><li><p>通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。</p></li><li><p>Field提供了两组方法来读取或设置成员变量的值：<br>getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。<br>setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//生成新的对象：用newInstance()方法 </span><br><span class="line">Object obj = class1.newInstance();</span><br><span class="line">//获取age成员变量</span><br><span class="line">Field field = class1.getField(<span class="string">"age"</span>);</span><br><span class="line">//将obj对象的age的值设置为10</span><br><span class="line">field.setInt(obj, 10);</span><br><span class="line">//获取obj对象的age的值</span><br><span class="line">field.getInt(obj);</span><br></pre></td></tr></table></figure></li></ol><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p> 定义：<strong>给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</strong></p><ol><li><p>代理模式的理解<br>代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。<br>在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。</p></li><li><p>代理模式的参与者<br>代理模式的角色分四种：<br><img src="https://camo.githubusercontent.com/1dab04df36af09afb1d73542f9ba66dccc444e8c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d663464333339613639613862396539322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="Proxy"><br><strong>主题接口：</strong>Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。<br><strong>目标对象：</strong>ReaSubject 是原对象，也就是被代理的对象。<br><strong>代理对象：</strong>Proxy 是代理对象，用来封装真是主题类的代理类。<br><strong>客户端 ：</strong>使用代理类和主题接口完成一些工作。</p></li><li><p>代理模式的分类<br>代理的实现分为：</p><p><strong>静态代理：</strong>代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。<br><strong>动态代理：</strong>代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。</p></li><li><p>代理模式的实现思路<br>a).代理对象和目标对象均实现同一个行为接口。<br>b).代理类和目标类分别具体实现接口逻辑。<br>c).在代理类的构造函数中实例化一个目标对象。<br>d).在代理类中调用目标对象的行为接口。<br>e).客户端想要调用目标对象的行为接口，只能通过代理类来操作。</p></li><li><p>静态代理模式的简单实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyDemo &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        RealSubject subject = new RealSubject();</span><br><span class="line">        Proxy p = new Proxy(subject);</span><br><span class="line">        p.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Subject&#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RealSubject implements Subject&#123;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Proxy implements Subject&#123;</span><br><span class="line">    private Subject subject;</span><br><span class="line">    public Proxy(Subject subject)&#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"PreProcess"</span>);</span><br><span class="line">        subject.request();</span><br><span class="line">        System.out.println(<span class="string">"PostProcess"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。</p><p><strong>代理模式的好处：</strong><br>假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。</p><p>这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。</p><p>静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。</p></li></ol><h3 id="Java反射机制与动态代理"><a href="#Java反射机制与动态代理" class="headerlink" title="Java反射机制与动态代理"></a>Java反射机制与动态代理</h3><p> 动态代理的思路和上述思路一致，下面主要讲解如何实现。</p><ol><li><p>动态代理介绍<br>动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。</p><p>①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护；<br>②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。</p></li><li><p>动态代理涉及的主要类<br>主要涉及两个类，这两个类都是java.lang.reflect包下的类，内部主要通过反射来实现的。</p><p><strong>java.lang.reflect.Proxy:</strong>这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。<br>Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。</p><p><strong>java.lang.reflect.InvocationHandler:</strong>这里称他为”调用处理器”，它是一个接口。只有一个invoke方法。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。<br>InvocationHandler.java代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package java.lang.reflect;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@code InvocationHandler&#125; is the interface implemented by</span><br><span class="line"> * the &lt;i&gt;invocation handler&lt;/i&gt; of a proxy instance.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Each proxy instance has an associated invocation handler.</span><br><span class="line"> * When a method is invoked on a proxy instance, the method</span><br><span class="line"> * invocation is encoded and dispatched to the &#123;@code invoke&#125;</span><br><span class="line"> * method of its invocation handler.</span><br><span class="line"> *</span><br><span class="line"> * @author      Peter Jones</span><br><span class="line"> * @see         Proxy</span><br><span class="line"> * @since       1.3</span><br><span class="line"> */</span><br><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Processes a method invocation on a proxy instance and returns</span><br><span class="line">     * the result.  This method will be invoked on an invocation handler</span><br><span class="line">     * when a method is invoked on a proxy instance that it is</span><br><span class="line">     * associated with.</span><br><span class="line">     *</span><br><span class="line">     * @param   proxy the proxy instance that the method was invoked on</span><br><span class="line">     *</span><br><span class="line">     * @param   method the &#123;@code Method&#125; instance corresponding to</span><br><span class="line">     * the interface method invoked on the proxy instance.  The declaring</span><br><span class="line">     * class of the &#123;@code Method&#125; object will be the interface that</span><br><span class="line">     * the method was declared <span class="keyword">in</span>, <span class="built_in">which</span> may be a superinterface of the</span><br><span class="line">     * proxy interface that the proxy class inherits the method through.</span><br><span class="line">     *</span><br><span class="line">     * @param   args an array of objects containing the values of the</span><br><span class="line">     * arguments passed <span class="keyword">in</span> the method invocation on the proxy instance,</span><br><span class="line">     * or &#123;@code null&#125; <span class="keyword">if</span> interface method takes no arguments.</span><br><span class="line">     * Arguments of primitive types are wrapped <span class="keyword">in</span> instances of the</span><br><span class="line">     * appropriate primitive wrapper class, such as</span><br><span class="line">     * &#123;@code java.lang.Integer&#125; or &#123;@code java.lang.Boolean&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @<span class="built_in">return</span>  the value to <span class="built_in">return</span> from the method invocation on the</span><br><span class="line">     * proxy instance.  If the declared <span class="built_in">return</span> <span class="built_in">type</span> of the interface</span><br><span class="line">     * method is a primitive <span class="built_in">type</span>, <span class="keyword">then</span> the value returned by</span><br><span class="line">     * this method must be an instance of the corresponding primitive</span><br><span class="line">     * wrapper class; otherwise, it must be a <span class="built_in">type</span> assignable to the</span><br><span class="line">     * declared <span class="built_in">return</span> <span class="built_in">type</span>.  If the value returned by this method is</span><br><span class="line">     * &#123;@code null&#125; and the interface method<span class="string">'s return type is</span></span><br><span class="line"><span class="string">     * primitive, then a &#123;@code NullPointerException&#125; will be</span></span><br><span class="line"><span class="string">     * thrown by the method invocation on the proxy instance.  If the</span></span><br><span class="line"><span class="string">     * value returned by this method is otherwise not compatible with</span></span><br><span class="line"><span class="string">     * the interface method'</span>s declared <span class="built_in">return</span> <span class="built_in">type</span> as described above,</span><br><span class="line">     * a &#123;@code ClassCastException&#125; will be thrown by the method</span><br><span class="line">     * invocation on the proxy instance.</span><br><span class="line">     *</span><br><span class="line">     * @throws  Throwable the exception to throw from the method</span><br><span class="line">     * invocation on the proxy instance.  The exception<span class="string">'s type must be</span></span><br><span class="line"><span class="string">     * assignable either to any of the exception types declared in the</span></span><br><span class="line"><span class="string">     * &#123;@code throws&#125; clause of the interface method or to the</span></span><br><span class="line"><span class="string">     * unchecked exception types &#123;@code java.lang.RuntimeException&#125;</span></span><br><span class="line"><span class="string">     * or &#123;@code java.lang.Error&#125;.  If a checked exception is</span></span><br><span class="line"><span class="string">     * thrown by this method that is not assignable to any of the</span></span><br><span class="line"><span class="string">     * exception types declared in the &#123;@code throws&#125; clause of</span></span><br><span class="line"><span class="string">     * the interface method, then an</span></span><br><span class="line"><span class="string">     * &#123;@link UndeclaredThrowableException&#125; containing the</span></span><br><span class="line"><span class="string">     * exception that was thrown by this method will be thrown by the</span></span><br><span class="line"><span class="string">     * method invocation on the proxy instance.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @see     UndeclaredThrowableException</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    public Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="string">        throws Throwable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>Proxy提供了如下两个方法来创建动态代理类和动态代理实例。</p><blockquote><p>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。</p></blockquote></li></ol><blockquote><p>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。</p></blockquote><p> 对应上述两种方法创建动态代理对象的方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建一个InvocationHandler对象</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(.args..);</span><br><span class="line">//使用Proxy生成一个动态代理类</span><br><span class="line">Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler);</span><br><span class="line">//获取proxyClass类中一个带InvocationHandler参数的构造器</span><br><span class="line">Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line">//调用constructor的newInstance方法来创建动态实例</span><br><span class="line">RealSubject real = (RealSubject)constructor.newInstance(handler);</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建一个InvocationHandler对象</span><br><span class="line">InvocationHandler handler = new MyInvocationHandler(.args..);</span><br><span class="line">//使用Proxy直接生成一个动态代理对象</span><br><span class="line">RealSubject real =Proxy.newProxyInstance(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler);</span><br></pre></td></tr></table></figure><p> <strong>newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字 节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。</strong></p><p> Proxy 类还有一些静态方法，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。</span><br><span class="line"></span><br><span class="line">Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。</span><br></pre></td></tr></table></figure></p><p>InvocationHandler 接口中有方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(Object proxy, Method method, Object[] args)</span><br></pre></td></tr></table></figure></p><p> 这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。</p><ol start="3"><li><p>动态代理模式的简单实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建目标对象</span><br><span class="line">        RealSubject realSubject = new RealSubject();    </span><br><span class="line">        //2.创建调用处理器对象</span><br><span class="line">        ProxyHandler handler = new ProxyHandler(realSubject);    </span><br><span class="line">       //3.动态生成代理对象</span><br><span class="line">        Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(),</span><br><span class="line">                                                        RealSubject.class.getInterfaces(), handler);   </span><br><span class="line">        //4.通过代理对象调用方法   </span><br><span class="line">        proxySubject.request();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 主题接口</span><br><span class="line"> */</span><br><span class="line">interface Subject&#123;</span><br><span class="line">    void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 目标对象类</span><br><span class="line"> */</span><br><span class="line">class RealSubject implements Subject&#123;</span><br><span class="line">    public void <span class="function"><span class="title">request</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"====RealSubject Request===="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 代理类的调用处理器</span><br><span class="line"> */</span><br><span class="line">class ProxyHandler implements InvocationHandler&#123;</span><br><span class="line">    private Subject subject;</span><br><span class="line">    public ProxyHandler(Subject subject)&#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">            throws Throwable &#123;</span><br><span class="line">        //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作</span><br><span class="line">        System.out.println(<span class="string">"====before===="</span>);</span><br><span class="line">       //调用RealSubject中的方法</span><br><span class="line">        Object result = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">"====after===="</span>);</span><br><span class="line">        <span class="built_in">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。</p></li></ol><h3 id="泛型和Class类"><a href="#泛型和Class类" class="headerlink" title="泛型和Class类"></a>泛型和Class类</h3><p> 从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class<string>。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。</string></p><p> 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectFactory &#123;</span><br><span class="line">    public static Object getInstance(String name)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建指定类对应的Class对象</span><br><span class="line">            Class cls = Class.forName(name);</span><br><span class="line">            //返回使用该Class对象创建的实例</span><br><span class="line">            <span class="built_in">return</span> cls.newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。<br> 如下例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date = (Date) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure></p><p> 又或者如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String string = (String) ObjectFactory.getInstance(<span class="string">"java.util.Date"</span>);</span><br></pre></td></tr></table></figure></p><p> 上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。<br> 但是泛型的出现后，就可以避免这种情况。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectFactory &#123;</span><br><span class="line">    public static &lt;T&gt; T getInstance(Class&lt;T&gt; cls) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 返回使用该Class对象创建的实例</span><br><span class="line">            <span class="built_in">return</span> cls.newInstance();</span><br><span class="line">        &#125; catch (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在上面程序的getInstance()方法中传入一个Class<t>参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String instance = ObjectFactory.getInstance(String.class);</span><br></pre></td></tr></table></figure></t></p><p> 通过传入String.class便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。<br> 当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。</p><h3 id="使用反射来获取泛型信息"><a href="#使用反射来获取泛型信息" class="headerlink" title="使用反射来获取泛型信息"></a>使用反射来获取泛型信息</h3><p> 通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Field 对象 f 的类型</span><br><span class="line">Class&lt;?&gt; a = f.getType();</span><br></pre></td></tr></table></figure></p><p> 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。<br> 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获得 Field 实例的泛型类型</span><br><span class="line">Type <span class="built_in">type</span> = f.getGenericType();</span><br></pre></td></tr></table></figure></p><p> 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。<br> <strong>getRawType()：</strong>返回没有泛型信息的原始类型。<br> <strong>getActualTypeArguments()：</strong>返回泛型参数的类型。<br> 下面是一个获取泛型类型的完整程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest</span><br><span class="line">&#123;</span><br><span class="line">    private Map&lt;String , Integer&gt; score;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">        throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;GenericTest&gt; clazz = GenericTest.class;</span><br><span class="line">        Field f = clazz.getDeclaredField(<span class="string">"score"</span>);</span><br><span class="line">        // 直接使用getType()取出Field类型只对普通类型的Field有效</span><br><span class="line">        Class&lt;?&gt; a = f.getType();</span><br><span class="line">        // 下面将看到仅输出java.util.Map</span><br><span class="line">        System.out.println(<span class="string">"score的类型是:"</span> + a);</span><br><span class="line">        // 获得Field实例f的泛型类型</span><br><span class="line">        Type gType = f.getGenericType();</span><br><span class="line">        // 如果gType类型是ParameterizedType对象</span><br><span class="line">        <span class="keyword">if</span>(gType instanceof ParameterizedType)</span><br><span class="line">        &#123;</span><br><span class="line">            // 强制类型转换</span><br><span class="line">            ParameterizedType pType = (ParameterizedType)gType;</span><br><span class="line">            // 获取原始类型</span><br><span class="line">            Type rType = pType.getRawType();</span><br><span class="line">            System.out.println(<span class="string">"原始类型是："</span> + rType);</span><br><span class="line">            // 取得泛型类型的泛型参数</span><br><span class="line">            Type[] tArgs = pType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"泛型类型是:"</span>);</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; tArgs.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"第"</span> + i + <span class="string">"个泛型类型是："</span> + tArgs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"获取泛型类型出错！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 输出结果：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score 的类型是: interface java.util.Map</span><br><span class="line">原始类型是: interface java.util.Map</span><br><span class="line">泛型类型是:</span><br><span class="line">第 0 个泛型类型是: class java.lang.String</span><br><span class="line">第 1 个泛型类型是：class java.lang.Integer</span><br></pre></td></tr></table></figure></p><p> 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。</p><p> Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。</p><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h2><h3 id="字符和字节"><a href="#字符和字节" class="headerlink" title="字符和字节"></a>字符和字节</h3><p> 在Java中有输入、输出两种I/O流，每种输入、输出流又分为字节流和字符流。关于字节，我们在学习8大基本数据类型中都有了解，每个字节(byte)有8bit组成，每种数据类型又有几个字节组成等，关于字符，我们知道代表一个汉字或者英文字母。</p><p> <strong>但是字节和字符之间的关系是怎么样的呢？</strong></p><p> Java采用Unicode编码，2个字节来表示一个字符，这点与C语言不同，C语言采用ASCII码，在大多数系统中，一个字符通常占一个字节，但是在0~127整数之间的字符映射，Unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节。但如果采用其他编码方式，一个字符占用的字节数则各不相同。可能有点晕，举个例子解释下。</p><p> 例如：Java中的String类是按照unicode进行编码的，当使用String(byte[] bytes, String encoding)构造字符串时，encoding所指的是bytes中的数据是按照那种方式编码的，而不是最后产生的String是什么编码方式，换句话说，是让系统把bytes中的数据由encoding编码方式转换成unicode编码。如果不指明，bytes的编码方式将由jdk根据操作系统决定。</p><p> getBytes(String charsetName)使用指定的编码方式将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。如果不指定将使用操作系统默认的编码方式，我的电脑默认的是GBK编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Hel &#123;  </span><br><span class="line">    public static void main(String[] args)&#123;  </span><br><span class="line">        String str = <span class="string">"你好hello"</span>;  </span><br><span class="line">            int byte_len = str.getBytes().length;  </span><br><span class="line">            int len = str.length();  </span><br><span class="line">            System.out.println(<span class="string">"字节长度为："</span> + byte_len);  </span><br><span class="line">        System.out.println(<span class="string">"字符长度为："</span> + len);  </span><br><span class="line">        System.out.println(<span class="string">"系统默认编码方式："</span> + System.getProperty(<span class="string">"file.encoding"</span>));  </span><br><span class="line">       &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字节长度为：9</span><br><span class="line">字符长度为：7</span><br><span class="line">系统默认编码方式：GBK</span><br></pre></td></tr></table></figure></p><p> 这是因为：在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。</p><p> <strong>简单来讲，一个字符表示一个汉字或英文字母，具体字符与字节之间的大小比例视编码情况而定。有时候读取的数据是乱码，就是因为编码方式不一致，需要进行转换，然后再按照unicode进行编码。</strong></p><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p> File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件或者目录，都可以通过File类来完成。</p><ol><li><p>构造函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//构造函数File(String pathname)</span><br><span class="line">File f1 =new File(<span class="string">"c:\\abc\\1.txt"</span>);</span><br><span class="line">//File(String parent,String child)</span><br><span class="line">File f2 =new File(<span class="string">"c:\\abc"</span>,<span class="string">"2.txt"</span>);</span><br><span class="line">//File(File parent,String child)</span><br><span class="line">File f3 =new File(<span class="string">"c:"</span>+File.separator+<span class="string">"abc"</span>);//separator 跨平台分隔符</span><br><span class="line">File f4 =new File(f3,<span class="string">"3.txt"</span>);</span><br><span class="line">System.out.println(f1);//c:\abc\1.txt</span><br></pre></td></tr></table></figure><p><strong>路径分隔符：</strong><br>windows： “/“ “” 都可以<br>linux/unix： “/“<br>注意:如果windows选择用””做分割符的话,那么请记得替换成”\”,因为Java中””代表转义字符<br>所以推荐都使用”/“，也可以直接使用代码File.separator，表示跨平台分隔符。<br><strong>路径：</strong><br>相对路径：<br>./表示当前路径<br>../表示上一级路径<br>其中当前路径：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。”</p><p>绝对路径：<br>绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件</p></li><li><p>创建与删除方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//如果文件存在返回<span class="literal">false</span>，否则返回<span class="literal">true</span>并且创建文件 </span><br><span class="line">boolean createNewFile();</span><br><span class="line">//创建一个File对象所对应的目录，成功返回<span class="literal">true</span>，否则<span class="literal">false</span>。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。</span><br><span class="line">boolean mkdir();</span><br><span class="line">//创建一个File对象所对应的目录，成功返回<span class="literal">true</span>，否则<span class="literal">false</span>。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录</span><br><span class="line">boolean mkdirs()    ;</span><br><span class="line">//如果文件存在返回<span class="literal">true</span>并且删除文件，否则返回<span class="literal">false</span></span><br><span class="line">boolean delete();</span><br><span class="line">//在虚拟机终止时，删除File对象所表示的文件或目录。</span><br><span class="line">void deleteOnExit();</span><br></pre></td></tr></table></figure></li><li><p>判断方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean canExecute()    ;//判断文件是否可执行</span><br><span class="line">boolean canRead();//判断文件是否可读</span><br><span class="line">boolean canWrite();//判断文件是否可写</span><br><span class="line">boolean exists();//判断文件是否存在</span><br><span class="line">boolean isDirectory();//判断是否是目录</span><br><span class="line">boolean isFile();//判断是否是文件</span><br><span class="line">boolean isHidden();//判断是否是隐藏文件或隐藏目录</span><br><span class="line">boolean isAbsolute();//判断是否是绝对路径 文件不存在也能判断</span><br></pre></td></tr></table></figure></li><li><p>获取方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String getName();//返回文件或者是目录的名称</span><br><span class="line">String getPath();//返回路径</span><br><span class="line">String getAbsolutePath();//返回绝对路径</span><br><span class="line">String getParent();//返回父目录，如果没有父目录则返回null</span><br><span class="line">long lastModified();//返回最后一次修改的时间</span><br><span class="line">long length();//返回文件的长度</span><br><span class="line">File[] listRoots();// 列出所有的根目录（Window中就是所有系统的盘符）</span><br><span class="line">String[] list() ;//返回一个字符串数组，给定路径下的文件或目录名称字符串</span><br><span class="line">String[] list(FilenameFilter filter);//返回满足过滤器要求的一个字符串数组</span><br><span class="line">File[]  listFiles();//返回一个文件对象数组，给定路径下文件或目录</span><br><span class="line">File[] listFiles(FilenameFilter filter);//返回满足过滤器要求的一个文件对象数组</span><br></pre></td></tr></table></figure><p>其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 文件过滤</span><br><span class="line">    File[] files = file.listFiles(new <span class="function"><span class="title">FilenameFilter</span></span>() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean accept(File file, String filename) &#123;</span><br><span class="line">            <span class="built_in">return</span> filename.endsWith(<span class="string">".mp3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p> file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。</p><h3 id="IO流的概念"><a href="#IO流的概念" class="headerlink" title="IO流的概念"></a>IO流的概念</h3><p> Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源抽象表述为”流”。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。<br> <strong>流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。</strong></p><p> IO流的分类:</p><ol><li><p>输入流和输出流<br>根据数据流向不同分为：输入流和输出流。</p><blockquote><p>输入流:只能从中读取数据，而不能向其写入数据。<br>输出流：只能向其写入数据，而不能从中读取数据。</p></blockquote></li><li><p>字节流和字符流<br>字节流和字符流和用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同。<br>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：<br>（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。<br>（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</p><p>只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p></li><li><p>节点流和处理流<br>按照流的角色来分，可以分为节点流和处理流。<br>可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被成为低级流。<br>处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，处理流也被称为高级流。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//节点流，直接传入的参数是IO设备</span><br><span class="line">FileInputStream fis = new FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">//处理流，直接传入的参数是流对象</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fis);</span><br></pre></td></tr></table></figure><p>当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。<br>实际上，Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。</p></li></ol><h3 id="IO流的四大基类"><a href="#IO流的四大基类" class="headerlink" title="IO流的四大基类"></a>IO流的四大基类</h3><p> 根据流的流向以及操作的数据单元不同，将流分为了四种类型，每种类型对应一种抽象基类。这四种抽象基类分别为：InputStream,Reader,OutputStream以及Writer。四种基类下，对应不同的实现类，具有不同的特性。在这些实现类中，又可以分为节点流和处理流。下面就是整个由着四大基类支撑下，整个IO流的框架图。<br> <img src="https://camo.githubusercontent.com/fdb7d34b4c62c0dde7adca91c766e224ee3e11f3/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333938353536332d333863336561343536326436646265332e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="IO流"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">I/O流</span><br><span class="line">└── 字符流</span><br><span class="line">|       └── Reader</span><br><span class="line">|       |      └── BufferReader</span><br><span class="line">|       |      └── InputStreamReader - FileReader</span><br><span class="line">|       |      └── StringReader</span><br><span class="line">|       |      └── PipedReader</span><br><span class="line">|       |      └── ByteArrayReader</span><br><span class="line">|       |      └── FilterReader - PushBackReader</span><br><span class="line">|       └── Writer</span><br><span class="line">|              └── BufferWriter</span><br><span class="line">|              └── OutputStreamWriter - FileWriter</span><br><span class="line">|              └── StringWriter</span><br><span class="line">|              └── PipedWriter</span><br><span class="line">|              └── CharWriter</span><br><span class="line">|              └── FilterWriter</span><br><span class="line">└── 字节流</span><br><span class="line">        └── InputStream </span><br><span class="line">        |      └── FileInputStream</span><br><span class="line">        |      └── FilterInputStream</span><br><span class="line">        |      |          └── BufferInputStream</span><br><span class="line">        |      |          └── DataInputStream</span><br><span class="line">        |      |          └── PushBackInputStream</span><br><span class="line">        |      └── ObjectInputStream</span><br><span class="line">        |      └── PipedInputStream</span><br><span class="line">        |      └── SequenceInputStream</span><br><span class="line">        |      └── StringBufferInputStream</span><br><span class="line">        |      └── ByteArrayInputStream</span><br><span class="line">        └── OutputStream</span><br><span class="line">               └── FileOutputStream</span><br><span class="line">               └── FilterOutputStream</span><br><span class="line">               |          └── BufferOutputStream</span><br><span class="line">               |          └── DataOutputStream</span><br><span class="line">               |          └── PrintOutputStream</span><br><span class="line">               └── ObjectOutputStream</span><br><span class="line">               └── PipedOutputStream</span><br><span class="line">               └── ByteArrayOutputStream</span><br></pre></td></tr></table></figure></p><p> InputStream,Reader,OutputStream以及Writer，这四大抽象基类，本身并不能创建实例来执行输入/输出，但它们将成为所有输入/输出流的模版，所以它们的方法是所有输入/输出流都可以使用的方法。类似于集合中的Collection接口。</p><ol><li><p>InputStream<br>InputStream 是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class="line">int <span class="built_in">read</span>() ； </span><br><span class="line">//读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(byte[] buffer) ； </span><br><span class="line">//读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(byte[] buffer, int off, int len) ；</span><br></pre></td></tr></table></figure></li><li><p>Reader<br>Reader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 </span><br><span class="line">int <span class="built_in">read</span>() ； </span><br><span class="line">//读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(char[] cbuf) ； </span><br><span class="line">//读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 </span><br><span class="line">int <span class="built_in">read</span>(char[] cbuf, int off, int len)</span><br></pre></td></tr></table></figure><p>对比InputStream和Reader所提供的方法，就不难发现两个基类的功能基本一样的，只不过读取的数据单元不同。</p><p><strong>在执行完流操作后，要调用close()方法来关系输入流，因为程序里打开的IO资源不属于内存资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</strong></p><p>除此之外，InputStream和Reader还支持如下方法来移动流中的指针位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在此输入流中标记当前的位置</span><br><span class="line">//readlimit - 在标记位置失效前可以读取字节的最大限制。</span><br><span class="line">void mark(int readlimit)</span><br><span class="line">// 测试此输入流是否支持 mark 方法</span><br><span class="line">boolean markSupported()</span><br><span class="line">// 跳过和丢弃此输入流中数据的 n 个字节/字符</span><br><span class="line">long skip(long n)</span><br><span class="line">//将此流重新定位到最后一次对此输入流调用 mark 方法时的位置</span><br><span class="line">void reset()</span><br></pre></td></tr></table></figure></li><li><p>OutputStream<br>OutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向输出流中写入一个字节数据,该字节数据为参数b的低8位。 </span><br><span class="line">void write(int b) ; </span><br><span class="line">//将一个字节类型的数组中的数据写入输出流。 </span><br><span class="line">void write(byte[] b); </span><br><span class="line">//将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 </span><br><span class="line">void write(byte[] b, int off, int len); </span><br><span class="line">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class="line">void flush();</span><br></pre></td></tr></table></figure></li><li><p>Writer<br>Writer 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//向输出流中写入一个字符数据,该字节数据为参数b的低16位。 </span><br><span class="line">void write(int c); </span><br><span class="line">//将一个字符类型的数组中的数据写入输出流， </span><br><span class="line">void write(char[] cbuf) </span><br><span class="line">//将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 </span><br><span class="line">void write(char[] cbuf, int offset, int length); </span><br><span class="line">//将一个字符串中的字符写入到输出流。 </span><br><span class="line">void write(String string); </span><br><span class="line">//将一个字符串从offset开始的length个字符写入到输出流。 </span><br><span class="line">void write(String string, int offset, int length); </span><br><span class="line">//将输出流中缓冲的数据全部写出到目的地。 </span><br><span class="line">void flush();</span><br></pre></td></tr></table></figure><p>可以看出，Writer比OutputStream多出两个方法，主要是支持写入字符和字符串类型的数据。</p><p><strong>使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，还能将输出流缓冲区的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法）</strong></p><p>以上内容就是整个IO流的框架介绍。</p></li></ol><h2 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><h3 id="RandomAccessFile概述"><a href="#RandomAccessFile概述" class="headerlink" title="RandomAccessFile概述"></a>RandomAccessFile概述</h3><p> RandomAccessFile既可以读取文件内容，也可以向文件输出数据。同时，RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。</p><p> 由于RandomAccessFile可以自由访问文件的任意位置，<strong>所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。</strong></p><p> 与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定义文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。<strong>如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。</strong></p><p> RandomAccessFile的方法虽然多，但它有一个最大的局限，<strong>就是只能读写文件，不能读写其他IO节点。</strong></p><p> RandomAccessFile的一个<strong>重要使用场景就是网络请求中的多线程下载及断点续传。</strong></p><h3 id="RandomAccessFile中的方法"><a href="#RandomAccessFile中的方法" class="headerlink" title="RandomAccessFile中的方法"></a>RandomAccessFile中的方法</h3><ol><li><p>RandomAccessFile的构造函数<br>RandomAccessFile类有两个构造函数，其实这两个构造函数基本相同，只不过是指定文件的形式不同——一个需要使用String参数来指定文件名，一个使用File参数来指定文件本身。除此之外，创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，一共有4种模式。</p><blockquote><p>“r”: 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。<br>“rw”: 打开以便读取和写入。<br>“rws”: 打开以便读取和写入。相对于 “rw”，”rws” 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。<br>“rwd” : 打开以便读取和写入，相对于 “rw”，”rwd” 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。</p></blockquote></li><li><p>RandomAccessFile的重要方法</p><p>RandomAccessFile既可以读文件，也可以写文件，所以类似于InputStream的read()方法，以及类似于OutputStream的write()方法，RandomAccessFile都具备。除此之外，RandomAccessFile具备两个特有的方法，来支持其随机访问的特性。</p><p>RandomAccessFile对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件指针记录位于文件头（也就是0处），当读/写了n个字节后，文件记录指针将会后移n个字节。除此之外，RandomAccessFile还可以自由移动该记录指针。下面就是RandomAccessFile具有的两个特殊方法，来操作记录指针，实现随机访问：</p><blockquote><p>long getFilePointer( )：返回文件记录指针的当前位置<br>void seek(long pos )：将文件指针定位到pos位置</p></blockquote></li></ol><h3 id="RandomAccessFile的使用"><a href="#RandomAccessFile的使用" class="headerlink" title="RandomAccessFile的使用"></a>RandomAccessFile的使用</h3><p> 利用RandomAccessFile实现文件的多线程下载，即多线程下载一个文件时，将文件分成几块，每块用不同的线程进行下载。下面是一个利用多线程在写文件时的例子，其中预先分配文件所需要的空间，然后在所分配的空间中进行分块，然后写入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 测试利用多线程进行文件的写操作 </span><br><span class="line"> */  </span><br><span class="line">public class Test &#123;  </span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;  </span><br><span class="line">        // 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件  </span><br><span class="line">        RandomAccessFile raf = new RandomAccessFile(<span class="string">"D://abc.txt"</span>, <span class="string">"rw"</span>);  </span><br><span class="line">        raf.setLength(1024*1024); // 预分配 1M 的文件空间  </span><br><span class="line">        raf.close();  </span><br><span class="line"></span><br><span class="line">        // 所要写入的文件内容  </span><br><span class="line">        String s1 = <span class="string">"第一个字符串"</span>;  </span><br><span class="line">        String s2 = <span class="string">"第二个字符串"</span>;  </span><br><span class="line">        String s3 = <span class="string">"第三个字符串"</span>;  </span><br><span class="line">        String s4 = <span class="string">"第四个字符串"</span>;  </span><br><span class="line">        String s5 = <span class="string">"第五个字符串"</span>;  </span><br><span class="line"></span><br><span class="line">        // 利用多线程同时写入一个文件  </span><br><span class="line">        new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据  </span><br><span class="line">        new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 利用线程在文件的指定位置写入指定数据  </span><br><span class="line">    static class FileWriteThread extends Thread&#123;  </span><br><span class="line">        private int skip;  </span><br><span class="line">        private byte[] content;  </span><br><span class="line"></span><br><span class="line">        public FileWriteThread(int skip,byte[] content)&#123;  </span><br><span class="line">            this.skip = skip;  </span><br><span class="line">            this.content = content;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>()&#123;  </span><br><span class="line">            RandomAccessFile raf = null;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                raf = new RandomAccessFile(<span class="string">"D://abc.txt"</span>, <span class="string">"rw"</span>);  </span><br><span class="line">                raf.seek(skip);  </span><br><span class="line">                raf.write(content);  </span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; catch (IOException e) &#123;  </span><br><span class="line">                // TODO Auto-generated catch block  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    raf.close();  </span><br><span class="line">                &#125; catch (Exception e) &#123;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>当RandomAccessFile向指定文件中插入内容时，将会覆盖掉原有内容。如果不想覆盖掉，则需要将原有内容先读取出来，然后先把插入内容插入后再把原有内容追加到插入内容后。</strong></p><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><h3 id="NIO-概述"><a href="#NIO-概述" class="headerlink" title="NIO 概述"></a>NIO 概述</h3><p> Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p><p> 所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</p><p> <strong>由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO（非阻塞IO）。</strong></p><p> Java NIO 由以下几个核心部分组成：</p><ul><li>Buffer</li><li>Channel</li><li>Selector<br>传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</li></ul><h3 id="Buffer的使用"><a href="#Buffer的使用" class="headerlink" title="Buffer的使用"></a>Buffer的使用</h3><p> 利用Buffer读写数据，通常遵循四个步骤：</p><ul><li>把数据写入buffer；</li><li>调用flip；</li><li>从Buffer中读取数据；</li><li>调用buffer.clear()</li></ul><p>未完待续</p><h2 id="Java-异常详解"><a href="#Java-异常详解" class="headerlink" title="Java 异常详解"></a>Java 异常详解</h2><h3 id="Java异常概述"><a href="#Java异常概述" class="headerlink" title="Java异常概述"></a>Java异常概述</h3><p> Java异常是Java提供的一种识别及响应错误的一致性机制。</p><p> Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪“抛出，异常信息回答了“为什么“会抛出。</p><p> Java异常机制用到的几个关键字：try、catch、finally、throw、throws。</p><p>  • try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</p><p>  • catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。</p><p>  • finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物理资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</p><p>  • throw – 用于抛出异常。</p><p>  • throws – 用在方法签名中，用于声明该方法可能抛出的异常。</p><p> 下面通过几个示例对这几个关键字进行简单了解。<br> 示例一: 了解try和catch基本用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </span><br><span class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </span><br><span class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </span><br><span class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Caught Exception</span><br><span class="line">e.getMessage(): / by zero</span><br><span class="line">e.toString(): java.lang.ArithmeticException: / by zero</span><br><span class="line">e.printStackTrace():</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Demo1.main(Demo1.java:6)</span><br></pre></td></tr></table></figure></p><p> 结果说明：在try语句块中有除数为0的操作，该操作会抛出java.lang.ArithmeticException异常。通过catch，对该异常进行捕获。</p><p> 观察结果我们发现，并没有执行System.out.println(“i=”+i)。这说明try语句块发生异常之后，try语句块中的剩余内容就不会再被执行了。</p><p> 示例二: 了解finally的基本用法,在”示例一”的基础上，我们添加finally语句。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">              System.out.println(<span class="string">"Caught Exception"</span>); </span><br><span class="line">            System.out.println(<span class="string">"e.getMessage(): "</span> + e.getMessage()); </span><br><span class="line">            System.out.println(<span class="string">"e.toString(): "</span> + e.toString()); </span><br><span class="line">            System.out.println(<span class="string">"e.printStackTrace():"</span>);</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(<span class="string">"run finally"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Caught Exception</span><br><span class="line">e.getMessage(): / by zero</span><br><span class="line">e.toString(): java.lang.ArithmeticException: / by zero</span><br><span class="line">e.printStackTrace():</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at Demo2.main(Demo2.java:6)</span><br><span class="line">run finally</span><br><span class="line">``` </span><br><span class="line"> 结果说明：最终执行了finally语句块。</span><br><span class="line"></span><br><span class="line"> 示例三: 了解throws和throw的基本用法</span><br><span class="line"> **throws**是**用于声明抛出的异常**，而**throw**是**用于抛出异常**。</span><br><span class="line">``` bash</span><br><span class="line">class MyException extends Exception &#123;</span><br><span class="line">    public <span class="function"><span class="title">MyException</span></span>() &#123;&#125;</span><br><span class="line">    public MyException(String msg) &#123;</span><br><span class="line">        super(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Demo3 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">test</span>();</span><br><span class="line">        &#125; catch (MyException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Catch My Exception"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void <span class="built_in">test</span>() throws MyException&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i = 10/0;</span><br><span class="line">              System.out.println(<span class="string">"i="</span>+i); </span><br><span class="line">        &#125; catch (ArithmeticException e) &#123;</span><br><span class="line">            throw new MyException(<span class="string">"This is MyException"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Catch My Exception</span><br><span class="line">MyException: This is MyException</span><br><span class="line">    at Demo3.test(Demo3.java:24)</span><br><span class="line">    at Demo3.main(Demo3.java:13)</span><br></pre></td></tr></table></figure></p><p> 运行结果说明：MyException是继承于Exception的子类。test()的try语句块中产生ArithmeticException异常(除数为0)，并在catch中捕获该异常；接着抛出MyException异常。main()方法对test()中抛出的MyException进行捕获处理。</p><h3 id="Java异常框架"><a href="#Java异常框架" class="headerlink" title="Java异常框架"></a>Java异常框架</h3><p>未完待续</p><h2 id="Java抽象类和接口的区别"><a href="#Java抽象类和接口的区别" class="headerlink" title="Java抽象类和接口的区别"></a>Java抽象类和接口的区别</h2><p> 未完待续</p><h2 id="Java深拷贝和浅拷贝"><a href="#Java深拷贝和浅拷贝" class="headerlink" title="Java深拷贝和浅拷贝"></a>Java深拷贝和浅拷贝</h2><p>未完待续</p><h2 id="Java中transient关键字"><a href="#Java中transient关键字" class="headerlink" title="Java中transient关键字"></a>Java中transient关键字</h2><p>未完待续</p><h2 id="Java中finally和return的执行顺序"><a href="#Java中finally和return的执行顺序" class="headerlink" title="Java中finally和return的执行顺序"></a>Java中finally和return的执行顺序</h2><p>未完代码</p><h2 id="Java-8-新特性"><a href="#Java-8-新特性" class="headerlink" title="Java 8 新特性"></a>Java 8 新特性</h2><h2 id="Java-8-源码"><a href="#Java-8-源码" class="headerlink" title="Java 8 源码"></a>Java 8 源码</h2><p><a href="https://github.com/EricChows/JDK-1.8-sourcecode" target="_blank" rel="noopener">JDk 1.8 Source Code</a></p><h1 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h1><p> 本部分内容是关于Java并发的一些知识总结，既是学习的难点，同时也是面试中几乎必问的知识点。</p><p> 面试中可能会问的一些问题：<br> • 创建线程的方式<br> • Synchronized/ReentrantLock<br> • 生产者/消费者模式<br> • volatile关键字<br> • 乐观锁/悲观锁<br> • 死锁<br> • 了解的并发集合</p><h2 id="Java创建线程的三种方式"><a href="#Java创建线程的三种方式" class="headerlink" title="Java创建线程的三种方式"></a>Java创建线程的三种方式</h2><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="Synchronize-Reentrantlock"><a href="#Synchronize-Reentrantlock" class="headerlink" title="Synchronize/Reentrantlock"></a>Synchronize/Reentrantlock</h2><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><hr><h1 id="Android基础-1"><a href="#Android基础-1" class="headerlink" title="Android基础"></a>Android基础</h1><p> 主要复习Android的一些个基础知识点</p><ul><li>四大组件</li><li>事件分发机制</li><li>消息机制</li><li>binder机制</li><li>线程和进程</li></ul><h2 id="Activity全方位解析"><a href="#Activity全方位解析" class="headerlink" title="Activity全方位解析"></a>Activity全方位解析</h2><p> 先从Activity的功能上复习</p><p> MyQuestion:</p><ol><li>能否从Framework的层面来分析一下，Activity这样设计的原理和机制是什么？</li></ol><ol start="2"><li>如何从Framework代码中看出Activity的设计逻辑</li></ol><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><ol><li><p>Activity生命周期<br>典型的生命周期<br>onCreate -&gt; onRestart -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory<br>onCreate:加载布局资源，初始化Activity所需要的数据，<br>onRestart:从不可见变为可见<br>onStart:表示Activity正在被启动，此时Activity已经出现，但是还没有出现在前台，无法与用户交互，这个时候可以理解为Activity已经显示出来，但是我们看不到。<br>onResume:表示Activity已经可见，且出现在前台<br>onPause:表示Activity正在停止，但是仍可见，正常情况下，紧接着onStop就会被调用。特殊情况下，如果这个时候快速的返回当前Activity，那么onResume就会被调用(极端情况)<br>onStop:表示Activity即将停止，不可见，位于后台，可以做稍微重量级的回收工作，同样不能太耗时。<br>onDestory:表示Activity即将被销毁，这是Activity的最后一个回调，可以做一些回收工作和最终的资源回收。、</p></li><li><p>特殊情况下的生命周期<br>a) 横竖屏切换<br>横竖屏切换的过程中，会发生Activity被销毁和重建的过程。<br>onSaveInstanceState和onRestoreInstanceState</p><p>onSaveInstanceState在onStop之前被调用<br>onRestoreInstanceState在onStart之后调用</p><p>b)资源不足导致优先级低的Activity被杀死</p></li></ol><h3 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h3><p> 从Framework中Activity相关代码可以看到，Activity的管理是通过ActivityStack任务栈的形式来管理。<br> Activity的LaunchMode主要有四种：</p><ol><li>Standard 标准模式：每次启动Activity，都会new一个新的Activity放在栈顶</li><li>SingleTop 栈顶复用：栈顶存在，则直接使用，不用new</li><li>SingleTask 栈内复用</li><li><p>SingleInstance 单例模式</p><p>特殊情况：前台栈和后台栈交互</p></li></ol><h3 id="Activity的Flag"><a href="#Activity的Flag" class="headerlink" title="Activity的Flag"></a>Activity的Flag</h3><p> FLAG_ACTIVITY_NEW_TASK</p><p> FLAG_ACTIVITY_SINGLE_TOP</p><p> FLAG_ACTIVITY_CLEAR_TOP</p><h2 id="Service-全方位解析"><a href="#Service-全方位解析" class="headerlink" title="Service 全方位解析"></a>Service 全方位解析</h2><p> Service是ANdroid中实现程序后台运行的解决方案，它非常适用于执行那些不需要和用户交互而且还要求长期运行的任务。Servcie默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建子线程来完成耗时操作。</p><p> MyQuestion：</p><ol><li>在Android Framework代码中，Service的机制是什么?</li></ol><ol><li><p>Service种类<br>按运行类型分类：</p><pre><code>区别                                    应用</code></pre><p>前台服务   会在通知栏显示onGoing的Notification     服务被终止时，通知栏Notification也会消失，如：音乐播放服务<br>后台服务   默认的服务即为后台服务，不会在通知栏显示  服务被终止时，用户看不到，如：天气更新、日期同步、邮件同步</p><p>按使用方式分类：<br>  类别                          区别<br>startServcie启动的服务       主要用于启动一个服务咨询后台任务，不进行通讯，停止服务，使用stopService<br>bindService启动的服务        可以进行进程通讯.停止服务，使用unbindService<br>同时使用StartServcie和bindService启动的服务    停止服务使用stopService和unbindServcie</p></li><li><p>Service生命周期<br>onCreate -&gt; onStartCommand -&gt; onDestory<br>onCreate -&gt; onBind -&gt; onUnbind -&gt; onDestory<br>onCreate:系统在Service第一次创建时执行此方法，如果service已经运行，此方法不会调用<br>onStartCommand:每次客户端调用startService方法启动该service，都会回调该方法<br>onBind:当调用bindService时，执行该方法，一次调用</p></li></ol><h2 id="BroadcastReceiver全方位解析"><a href="#BroadcastReceiver全方位解析" class="headerlink" title="BroadcastReceiver全方位解析"></a>BroadcastReceiver全方位解析</h2><p> BroadcastReceiver广播接收器，使用了观察者模式来实现。<br> 模型中有三个角色：<br> a)消息订阅者 –广播接收者<br> b)消息发布者 –广播发送者<br> c)消息中心(AMS,即ActivityManagerService)</p><p> 原理描述：<br> i) 广播接受者通过Binder机制在AMS注册<br> ii)广播发送者通过Binder机制向AMS发送广播<br> iii)AMS根据广播发送者要求，在已注册列表中，寻求合适的广播接收者</p><ul><li><p>寻找依据：IntenFilter/Permission<br>iv)AMS将广播发送到合适的广播接收者相应的消息循环队列中<br>v)广播接收者通过消息循环 拿到此广播，并回调onReceive()</p><p>特别注意：广播发送者和广播接收者执行的是 异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底何时才能接收到。</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/broadcastreceiver.md" target="_blank" rel="noopener">参考文章</a></p><p>My Question:<br>需要拿出AMS的源码来详细的分析原理</p></li></ul><h2 id="ContenProvider全方位解析"><a href="#ContenProvider全方位解析" class="headerlink" title="ContenProvider全方位解析"></a>ContenProvider全方位解析</h2><ol><li><p>作用：进程间 数据交互和共享，跨进程通讯<br>ContentProvider只是中间者角色，真正存储&amp;操作数据的数据源还是原来存储数据的方式(数据库、文件、xml、网络)</p></li><li><p>原理：ContentProvider 采用的是Android中Binder机制来实现</p></li><li><p>使用</p></li></ol><ul><li>URL 统一资源标识符</li><li>MIME 数据类型</li><li>ContentProvider类的 使用方法和数据组织方式</li><li><p>辅助工具类：a)ContentResolver类  b)ContentUris 类 c)UriMatcher类  d) ContentObserver类</p><p>3.1 统一资源标识符<br>Uniform Resource Identifier<br>作用：唯一标识ContentProvider 其中的数据<br>具体使用，分两类，系统预制和自定义</p><p>自定义URI = content://com.carson.provider/User/1<br>主题(Schema):URI的前缀，由Android规定<br>授权信息(Authority):唯一标识符，一般是包名<br>表名(Path):指向数据库中的某个表<br>记录(ID):表中的某个记录(若无指定，则返回全部记录)</p><p>3.2 MIME数据类型</p><p>3.3 ContentProvider 类</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/ContentProvider.md" target="_blank" rel="noopener">参考文章</a></p></li></ul><h2 id="Fragment-详解"><a href="#Fragment-详解" class="headerlink" title="Fragment 详解"></a>Fragment 详解</h2><ol><li><p>什么是Fragment<br>简单来说，就是显示在Activity中的Activity</p></li><li><p>Fragment的生命周期<br>由于Fragment是依附于Activity存在的，因此，它的生命周期受到Activity的生命周期的影响<br>onCreate(){ onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onActivityCreated() }<br>onStart(){ onStart() }<br>onResume(){ onResume() }<br>onPause(){ onPause() }<br>onStop(){ onStop() }<br>onDestory(){ onDestoryView() -&gt; onDestory() -&gt; onDetach() }</p><p>PS： 注意：除了onCreateView,其他的所有方法如果重写了，必须调用父类对于该方法的实现</p></li><li><p>Fragment的使用方式<br>静态使用Fragment</p><p>动态使用Fragment</p></li><li><p>什么是Fragment的回退栈？<br>Fragment的回退栈是用来保存每一次Fragment事务发生的变化，如果你将Fragment任务添加到回退栈，当用户点击回退按钮时，将看到上一次保存的Fragment。一旦Fragment完全从回退栈弹出，用户再次点击后退键，则退出当前Activity</p><p>FragmentTransaction.addToBackStack(String)</p></li><li><p>Fragment和Activity之间的通信</p></li><li><p>Fragment与Activity通信的优化</p></li><li><p>如何处理运行时配置发生变化</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/Fragment.md" target="_blank" rel="noopener">参考文章</a></p></li></ol><h2 id="Android消息机制"><a href="#Android消息机制" class="headerlink" title="Android消息机制"></a>Android消息机制</h2><p>  Android中的消息机制，即Handler.</p><ol><li><p>消息机制的模型<br>消息机制主要包含：MessageQueue/Handler/Looper/Message四个模块，现在来一一介绍</p><p><strong>Message:</strong> 需要传递的消息，可以装载数据<br><strong>MessageQueue:</strong> 消息队列，它的内部实现并不是用的队列，实际是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能是向消息池投递消息<br>(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next). <a href="/home/zds/Code/Junior/frameworks/base/core/java/android/os/MessageQueue.java">MessageQueue</a><br><strong>Handler:</strong> 消息辅助类，主要功能是向信息池发送各种消息事件(Handler.sendMessage)和取走处理相应消息事件(Handler.handleMessage).<br><strong>Looper：</strong>不断循环执行(Looper.loop),从MessageQueue中读取消息，按分发机制将消息分发给目标处理.</p></li><li><p>消息机制的架构</p></li></ol><ol start="3"><li><p>消息机制原理<br>frameworks/base/core/java/android/os/MessageQueue.java<br>frameworks/base/core/java/android/os/Message.java<br>frameworks/base/core/java/android/os/Message.aidl<br>frameworks/base/core/java/android/os/Looper.java<br>frameworks/base/core/java/android/os/Handler.java</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/message-mechanism.md" target="_blank" rel="noopener">参考文章</a></p></li></ol><h2 id="Android事件分发机制"><a href="#Android事件分发机制" class="headerlink" title="Android事件分发机制"></a>Android事件分发机制</h2><ol><li><p>事件在哪些对象间进行传递<br>Activity、ViewGroup、View，事件产生后，传递顺序：Activity &gt; ViewGroup &gt; View</p></li><li><p>事件分发的本质，就是Activity/ViewGroup/View三者的事件分发<br>参考资料2中有对源码进行分析</p><p>参考资料[1]:Myblog中的 《Android编程下Touch事件的分发和消费机制》</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/Event-Dispatch.md" target="_blank" rel="noopener">参考资料2</a> </p></li><li><p>onTouch和onTouchEvent的区别</p></li><li><p>Touch事件的后续(Move、up)事件的层级传递</p></li></ol><h2 id="AsyncTask详解"><a href="#AsyncTask详解" class="headerlink" title="AsyncTask详解"></a>AsyncTask详解</h2><ol><li><p>AsyncTask是一个抽象类，是由Android封装的一个轻量级异步类，它可以在线程池中执行后台任务，然后把执行的进度和最终的结果传递给主线程并在主线程中更新UI<br>AsyncTask的内部封装了两个线程池(SerialExecutor和THREAD_POOL_EXECUTOR)和一个Handler(InternalHandler).</p></li><li><p>AsyncTask的使用和源码分析见参考资料1</p></li><li><p>AsyncTask使用不当的后果<br>a) 生命周期<br>AsyncTask 不与任何组件绑定生命周期，所以在Activity或者Fragment中创建执行AsyncTask时，最好在Activity/Fragment的onDestory调用cancel方法</p><p>b)内存泄漏<br>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用.<br>如果Activity已经被销毁，AsyncTask的后台线程还在执行，将继续保留这个引用，导致Activity无法被回收，引起内存泄漏</p><p>c)结果丢失<br>屏幕旋转或者Activity在后台被系统杀掉等情况导致的Activity重建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这是调用onPOSTExecute()再去更新界面将不再生效.</p><p><a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/asynctask.md" target="_blank" rel="noopener">参考资料1</a></p></li></ol><h2 id="HandlerThread详解"><a href="#HandlerThread详解" class="headerlink" title="HandlerThread详解"></a>HandlerThread详解</h2><p>   在Android中执行耗时的操作都需要另外开启子线程来执行，执行完线程以后会自动销毁，如果项目中经常需要执行耗时操作，如果经常开启线程，接着又销毁线程，无疑会消耗性能，解决方法是：<br>   a)使用线程池<br>   b)使用HandlerThread</p><p>   HandlerThread的代码以及在Framework中封装好：/frameworks/base/core/java/android/os/HandlerThread.java，采用的是Handler和Looper来实现</p><p>   HandlerThread的使用，见参考资料1</p><p>   <a href="https://github.com/LRH1993/android_interview/blob/master/android/basis/HandlerThread.md" target="_blank" rel="noopener">参考资料1</a></p><h2 id="IntentServcie详解"><a href="#IntentServcie详解" class="headerlink" title="IntentServcie详解"></a>IntentServcie详解</h2><p>  IntentService是Android里面的一个封装类，继承自四大组件之一的Service.<br>  作用：处理异步请求，实现多线程.</p><h2 id="LruCache详解"><a href="#LruCache详解" class="headerlink" title="LruCache详解"></a>LruCache详解</h2><p>  Android中缓存策略，一般来说，缓存策略主要包含缓存的添加、获取和删除者三类操作.<br>  不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的，当缓存满了之后，再向其添加缓存，这时就需要删除一些旧的缓存并添加新的缓存.</p><p>  LRU(Least Recently Used)是最近最少使用算法，采用LRU算法的缓存有两种：LruCache和DisLruCache，分别是内存缓存和硬盘缓存.</p><ol><li><p>LruCache的使用<br>LruCache是Android3.1提供的一个缓存类.</p></li><li><p>LruCache源码<br>看LruCache源码，发现在Android的framework层的代码，大部分实现都用到Java的基础知识.所以还是要好好掌握下Java的基础知识.</p></li></ol><h2 id="Window、Activity、DecorView以及ViewRoot之间的关系"><a href="#Window、Activity、DecorView以及ViewRoot之间的关系" class="headerlink" title="Window、Activity、DecorView以及ViewRoot之间的关系"></a>Window、Activity、DecorView以及ViewRoot之间的关系</h2><h2 id="View的测量、布局以及绘制原理"><a href="#View的测量、布局以及绘制原理" class="headerlink" title="View的测量、布局以及绘制原理"></a>View的测量、布局以及绘制原理</h2><h2 id="Android虚拟机以及编译过程"><a href="#Android虚拟机以及编译过程" class="headerlink" title="Android虚拟机以及编译过程"></a>Android虚拟机以及编译过程</h2><h2 id="Android进程间通信方式"><a href="#Android进程间通信方式" class="headerlink" title="Android进程间通信方式"></a>Android进程间通信方式</h2><h2 id="Android-Bitmap压缩策略"><a href="#Android-Bitmap压缩策略" class="headerlink" title="Android Bitmap压缩策略"></a>Android Bitmap压缩策略</h2><h2 id="Android-动画总结"><a href="#Android-动画总结" class="headerlink" title="Android 动画总结"></a>Android 动画总结</h2><h2 id="Android-进程优先级"><a href="#Android-进程优先级" class="headerlink" title="Android 进程优先级"></a>Android 进程优先级</h2><h2 id="Android-Contex-详解"><a href="#Android-Contex-详解" class="headerlink" title="Android Contex 详解"></a>Android Contex 详解</h2><h1 id="Android进阶"><a href="#Android进阶" class="headerlink" title="Android进阶"></a>Android进阶</h1><h2 id="Android-多线程断点续传"><a href="#Android-多线程断点续传" class="headerlink" title="Android 多线程断点续传"></a>Android 多线程断点续传</h2><h2 id="Android全局异常处理"><a href="#Android全局异常处理" class="headerlink" title="Android全局异常处理"></a>Android全局异常处理</h2><h2 id="Android-MVP模式详解"><a href="#Android-MVP模式详解" class="headerlink" title="Android MVP模式详解"></a>Android MVP模式详解</h2><h2 id="Android-Binder机制以及AIDL使用"><a href="#Android-Binder机制以及AIDL使用" class="headerlink" title="Android Binder机制以及AIDL使用"></a>Android Binder机制以及AIDL使用</h2><h2 id="Android-Parcelable和Serializable的区别"><a href="#Android-Parcelable和Serializable的区别" class="headerlink" title="Android Parcelable和Serializable的区别"></a>Android Parcelable和Serializable的区别</h2><h2 id="一个APP从启动到主页面显示经历了哪些过程"><a href="#一个APP从启动到主页面显示经历了哪些过程" class="headerlink" title="一个APP从启动到主页面显示经历了哪些过程?"></a>一个APP从启动到主页面显示经历了哪些过程?</h2><h2 id="Android-性能优化总结"><a href="#Android-性能优化总结" class="headerlink" title="Android 性能优化总结"></a>Android 性能优化总结</h2><h2 id="Android-内存泄漏总结"><a href="#Android-内存泄漏总结" class="headerlink" title="Android 内存泄漏总结"></a>Android 内存泄漏总结</h2><h2 id="Android-布局优化之include-merge-ViewStub的使用"><a href="#Android-布局优化之include-merge-ViewStub的使用" class="headerlink" title="Android 布局优化之include/merge/ViewStub的使用"></a>Android 布局优化之include/merge/ViewStub的使用</h2><h2 id="Android-权限处理"><a href="#Android-权限处理" class="headerlink" title="Android 权限处理"></a>Android 权限处理</h2><h2 id="Android热修复原理"><a href="#Android热修复原理" class="headerlink" title="Android热修复原理"></a>Android热修复原理</h2><h2 id="Android-插件化入门指南"><a href="#Android-插件化入门指南" class="headerlink" title="Android 插件化入门指南"></a>Android 插件化入门指南</h2><h2 id="VirtualAPK解析"><a href="#VirtualAPK解析" class="headerlink" title="VirtualAPK解析"></a>VirtualAPK解析</h2><h2 id="Android-推送技术解析"><a href="#Android-推送技术解析" class="headerlink" title="Android 推送技术解析"></a>Android 推送技术解析</h2><h2 id="Android-APK安装过程"><a href="#Android-APK安装过程" class="headerlink" title="Android APK安装过程"></a>Android APK安装过程</h2><h2 id="PopupWindow和Dialog区别"><a href="#PopupWindow和Dialog区别" class="headerlink" title="PopupWindow和Dialog区别"></a>PopupWindow和Dialog区别</h2><h1 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h1><p>《深入理解Java虚拟机》–JVM高级特性与最佳实践<br>      周志明-机械工业出版社</p><p>关于Java虚拟机，重点考察以下三个方面：</p><ul><li>内存区域/内存模型</li><li>类加载机制</li><li>垃圾收集算法/收集器</li></ul><p>MyQuestion：</p><ol><li><p>JVM 开源么？ JVM是包含在JDK里面的么？</p></li><li><p>Dalvik对JVM 做了哪些改进？ </p></li><li><p>ART又对Dalvik做了哪些改进？</p></li></ol><p>虚拟机相关的关键字：<br>JVM：<br>HotSpot：<br>JIT<br>AOT:<br>Heap(堆):<br>Stack(栈):</p><h2 id="对象的创建、内存布局和访问定位"><a href="#对象的创建、内存布局和访问定位" class="headerlink" title="对象的创建、内存布局和访问定位"></a>对象的创建、内存布局和访问定位</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol><li><p>虚拟机遇到一个New指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用；</p></li><li><p>检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行相应的类的加载过程;</p></li><li><p>在类加载检查功能通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。</p></li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>分为三个区域：  对象头，实例数据，对齐填充。</p><ol><li><p>对象头<br>包含两部分信息，第一部分：对象自身的运行时数据，如哈希吗，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。着不放数据的长度在32位和64位虚拟机中分别为32bit和64bit，官方称它为”Mark Word”.</p><p>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据 。</p></li><li><p>实例数据<br>是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p></li><li><p>对齐填充<br>对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐是，就需要通过对齐补充来补全了。</p></li></ol><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p> Java程序需要通过栈上的reference数据来操作堆上的具体对象</p><p> 目前主流的访问方式有使用句柄和直接使用指针两种。</p><ol><li><p>句柄访问<br>Java堆中会划分出一块内存来作为句柄池，reference中存储的事就对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。<br><img src="/2015/02/01/Android面试汇总/" alt="句柄访问"></p></li><li><p>直接指针访问<br>reference中存储的直接就是对象地址<br><img src="/2015/02/01/Android面试汇总/" alt="直接指针访问"></p></li></ol><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><ol><li><p>方法区(公有)</p></li><li><p>堆(公有)</p></li><li><p>虚拟机栈(线程私有)</p></li><li><p>本地方法栈(线程私有)</p></li><li><p>程序计数器(线程私有)</p></li></ol><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p> Java内存模型的目的： 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。</p><p> 主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p> 了解Java内存模型之前需要了解：主内存和工作内存。</p><p> Java内存模型规定了所有的变量都存储在主内存中，每个线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量(这些变量是从主内存中拷贝而来)。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><ol><li><p>定义： 把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。</p><p>在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点来实现的。</p></li><li><p>类的生命周期：  加载、验证、准备、解析、初始化、使用和卸载。其中验证，准备，解析3个部分统称为链接。<br>Loading -&gt; Verification -&gt; Preparation -&gt; Resolution -&gt; Initalization -&gt; Using -&gt; Unloading</p></li></ol><h2 id="类加载器详解"><a href="#类加载器详解" class="headerlink" title="类加载器详解"></a>类加载器详解</h2><p> 通过上述的了解，我们已经知道了类加载机制的大概流程以及各个部分的功能，其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。</p><ol><li><p>类加载器分类<br>不同的类加载器负责加载不同的类。主要分为两类：<br>启动类加载器(Bootstrap ClassLoader):由C++语言实现(针对Hotspot),负责将存放在&lt;JAVA_HOME&gt;/lib目录或者-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类</p><p>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：</p><p>扩展类加载器(Extension ClassLoader)：负责将存放在&lt;JAVA_HOME&gt;/lib/ext目录或者java.ext.dirs系统变量指定的路径中的类库加载到内存中，即负责加载Java扩展的核心类之外的类</p><p>应用程序类加载器(Application ClassLoader): </p></li><li><p>双亲委派模型<br>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有父加载器在它的搜索范围内没有找到所需的类时，即无法完成该加载，子加载才会尝试自己去加载该类。</p></li></ol><ol start="3"><li>双亲委派模型的代码实现<br>ClassLoader中loadClass方法实现了双亲委派模型</li></ol><h2 id="JVM中垃圾收集算法"><a href="#JVM中垃圾收集算法" class="headerlink" title="JVM中垃圾收集算法"></a>JVM中垃圾收集算法</h2><ol><li><p>标记-清除算法<br>最基础的收集算法是”标记-清除”(Mark-Sweep)算法，分为标记和清除两个阶段<br>a)首先标记出所需要回收的对象<br>b)在标记完成之后，统一回收所有被标记的对象</p><p>不足：<br>效率问题： 标记和清除两个过程的效率都不高<br>空间问题：标记清除后产生大量的不连续的内存碎片，空间碎片太多，可能会导致分配大对象时，无法找到足够连续的内存而不得不提前触发另一次垃圾收集动作</p></li><li><p>复制算法<br>目的：为了解决效率问题</p><p>将可用内存按照容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。</p><p>缺点：将内存缩小为了原来的一半</p><p>现代的商业虚拟机都是采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是”朝生夕死”，所以不需要按照1:1来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8:1</p></li><li><p>标记-整理算法<br>复制算法在对象存活率较高的时候，就要进行较多的复制操作，效率就会变低。</p><p>标记过程和标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。</p></li><li><p>分代收集算法<br>一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>对新生代，采用复制算法</p><p>对老年代，采用标记整理算法或者标记清除算法</p></li></ol><p>##垃圾收集器详解</p><h2 id="JVM怎么判断对象是否已死"><a href="#JVM怎么判断对象是否已死" class="headerlink" title="JVM怎么判断对象是否已死"></a>JVM怎么判断对象是否已死</h2><ol><li><p>引用计数法<br>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1.任何时刻计数器为0的对象就是不可能被在使用的。</p><p>主流的JVM里面没有选用引用计数器算法来管理内存，其中最主要的原因是它很难解决对象间的互相循环引用问题。</p></li><li><p>可达性分析算法</p></li><li><p>判断对象是否存活与”引用”相关<br>Strong Reference 强引用<br>Soft Reference 软引用<br>Weak Reference 弱引用<br>Phantom Reference 虚引用<br>引用强度依次减弱</p></li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">Android校招面试指南</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java面试题&quot;&gt;&lt;a href=&quot;#Java面试题&quot; class=&quot;headerlink&quot; title=&quot;Java面试题&quot;&gt;&lt;/a&gt;Java面试题&lt;/h1&gt;&lt;h2 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android匿名共享内存Ashmem解析</title>
    <link href="http://yoursite.com/2015/01/01/A-Ongoing-Android%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98Ashmem%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/01/01/A-Ongoing-Android匿名共享内存Ashmem解析/</id>
    <published>2014-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T13:55:09.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6651971" target="_blank" rel="noopener">Android系统匿名共享内存Ashmem（Anonymous Shared Memory）简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6664554" target="_blank" rel="noopener">Android系统匿名共享内存Ashmem（Anonymous Shared Memory）驱动程序源代码分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6666491" target="_blank" rel="noopener">Android系统匿名共享内存Ashmem（Anonymous Shared Memory）在进程间共享的原理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6939890" target="_blank" rel="noopener">Android系统匿名共享内存（Anonymous Shared Memory）C++调用接口分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="Ashmem" scheme="http://yoursite.com/categories/Android/Ashmem/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Ashmem" scheme="http://yoursite.com/tags/Ashmem/"/>
    
  </entry>
  
  <entry>
    <title>Android中WindowManagerService解析</title>
    <link href="http://yoursite.com/2015/01/01/A-Ongoing-Android%E4%B8%ADWindowManagerService%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/01/01/A-Ongoing-Android中WindowManagerService解析/</id>
    <published>2014-12-31T16:00:00.000Z</published>
    <updated>2018-07-04T13:55:04.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/luoshengyang/article/details/8923485" target="_blank" rel="noopener">那两年炼就的Android内功修养</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8462738" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService的简要介绍和学习计划</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8479101" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8498908" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService对窗口的组织方式分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8526644" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService对输入法窗口（Input Method Window）的管理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8550820" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService对壁纸窗口（Wallpaper Window）的管理分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8570428" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService计算窗口Z轴位置的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8577789" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService显示Activity组件的启动窗口（Starting Window）的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8596449" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService切换Activity窗口（App Transition）的过程分析</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/8611754" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService显示窗口动画的原理分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/luoshengyang/article/details/89
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="WindowManagerService" scheme="http://yoursite.com/categories/Android/WindowManagerService/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="WindowManagerService" scheme="http://yoursite.com/tags/WindowManagerService/"/>
    
      <category term="WMS" scheme="http://yoursite.com/tags/WMS/"/>
    
  </entry>
  
  <entry>
    <title>Myblog</title>
    <link href="http://yoursite.com/2015/01/01/Myblog/"/>
    <id>http://yoursite.com/2015/01/01/Myblog/</id>
    <published>2014-12-31T16:00:00.000Z</published>
    <updated>2018-07-03T04:03:41.374Z</updated>
    
    <content type="html"><![CDATA[<p>This article is for self-summary, Only for myself.</p><h1 id="已经整理完成的文章"><a href="#已经整理完成的文章" class="headerlink" title="已经整理完成的文章"></a>已经整理完成的文章</h1><ol><li>ADB (Android Debug Bridge)常用命令<br>需要做的延伸是：分析adb 的源码</li><li><p>windows批处理 BAT技巧<br>需要延伸的是： 用bat脚本抓所有的Android log<br>在Ubuntu环境下，使用其他脚本抓所有的Android log</p></li><li><p>各类工具使用小技巧<br>需要延伸的是： 日常工作中使用过的工具的小技巧需要随时收录进来</p></li><li><p>问题锦集-速查<br>需要延伸的是： 日常工作中遇到的常见的一些问题，最好都记录下来，保存到这里来</p></li><li><p>Android 编译<br>需要延伸的是： Android编译流程 和 编译过程中各个文件的作用</p></li><li><p>Linux脚本编写基础<br>是一篇学习的文章： 还没有学习完，文章格式乱七八糟，徐继续维护</p></li><li><p>android 开发如何做内存优化</p></li><li><p>Android 编程下 Touch 事件的分发和消费机制<br>需要延伸的是：案例</p></li><li></li></ol><h1 id="重点关注的文章"><a href="#重点关注的文章" class="headerlink" title="重点关注的文章"></a>重点关注的文章</h1><!--Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).## Quick Start### Create a new post<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a><br>–&gt;</p>-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This article is for self-summary, Only for myself.&lt;/p&gt;
&lt;h1 id=&quot;已经整理完成的文章&quot;&gt;&lt;a href=&quot;#已经整理完成的文章&quot; class=&quot;headerlink&quot; title=&quot;已经整理完成的文章&quot;&gt;&lt;/a&gt;已
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Myblog" scheme="http://yoursite.com/tags/Myblog/"/>
    
  </entry>
  
</feed>
