<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android8.0充电图标不显示</title>
      <link href="/2018/06/25/Android8-0%E5%85%85%E7%94%B5%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2018/06/25/Android8-0%E5%85%85%E7%94%B5%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>1.充电图标不显示，问题分析步骤<br>a)找到充电图标的UI，frameworks/base/packages/SystemUI/res/layout/system_icons.xml<br>中找到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.android.systemui.BatteryMeterView android:id=<span class="string">"@+id/battery"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>确定充电图标UI文件，BatteryMeterView.java<br>frameworks/base/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java<br>中充电图标绘制在BatteryMeterDrawableBase.java,查看<br>frameworks/base/packages/SettingsLib/src/com/android/settingslib/graph/BatteryMeterDrawableBase.java可以看到充电的闪电图标的绘制过程。<br>在BatteryMeterView.java中可以看到充电图标的显示与否是由下面决定的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) &#123;</span><br><span class="line">        mDrawable.setBatteryLevel(level);</span><br><span class="line">        mDrawable.setCharging(pluggedIn);//pluggedIn为<span class="literal">true</span>，显示闪电图标，为<span class="literal">false</span>则不显示</span><br><span class="line">        mLevel = level;</span><br><span class="line">        updatePercentText();</span><br><span class="line">        setContentDescription(</span><br><span class="line">                getContext().getString(charging ? R.string.accessibility_battery_level_charging</span><br><span class="line">                        : R.string.accessibility_battery_level, level));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到是由pluggedIn来决定是否显示，这里有个疑问，为何不用charging的值来判断，而要用pluggedIn的值来判断。原因在下面这个代码,<br>onBatteryLevelChanged这个函数，是在<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java里面addCallback回调过去的。<br>mCharging的值是由 mCharged和 BATTERY_STATUS_CHARGING两个值一起判断的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onReceive(final Context context, Intent intent) &#123;</span><br><span class="line">        final String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(Intent.ACTION_BATTERY_CHANGED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTestmode &amp;&amp; !intent.getBooleanExtra(<span class="string">"testmode"</span>, <span class="literal">false</span>)) <span class="built_in">return</span>;</span><br><span class="line">            mHasReceivedBattery = <span class="literal">true</span>;</span><br><span class="line">            mLevel = (int)(100f</span><br><span class="line">                    * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0)</span><br><span class="line">                    / intent.getIntExtra(BatteryManager.EXTRA_SCALE, 100));</span><br><span class="line">            mPluggedIn = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;</span><br><span class="line"></span><br><span class="line">            final int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS,</span><br><span class="line">                    BatteryManager.BATTERY_STATUS_UNKNOWN);</span><br><span class="line">            mCharged = status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line">            mCharging = mCharged || status == BatteryManager.BATTERY_STATUS_CHARGING;</span><br><span class="line"></span><br><span class="line">            fireBatteryLevelChanged();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>为了查看手机中当前的pluggedIn和charging这两个值的状态，从<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java文件中看到了一个Dump 的log打印，刚好打印了这几个值的状态，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123;</span><br><span class="line">        pw.println(<span class="string">"BatteryController state:"</span>);</span><br><span class="line">        pw.print(<span class="string">"  mLevel="</span>); pw.println(mLevel);</span><br><span class="line">        pw.print(<span class="string">"  mPluggedIn="</span>); pw.println(mPluggedIn);</span><br><span class="line">        pw.print(<span class="string">"  mCharging="</span>); pw.println(mCharging);</span><br><span class="line">        pw.print(<span class="string">"  mCharged="</span>); pw.println(mCharged);</span><br><span class="line">        pw.print(<span class="string">"  mPowerSave="</span>); pw.println(mPowerSave);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><pre><code>所以，不需要另外打任何的log，直接连接手机，使用adb shell bugreport &gt; bugreport.txt抓出所有的dump log即可。BatteryController state:  mLevel=86  mPluggedIn=false  mCharging=true  mCharged=false  mPowerSave=false01-01 10:23:19.490  1000  1098  1110 D BatteryService: Sending ACTION_BATTERY_CHANGED.  level:71, scale:100, status:3, health:2, present:true, voltage: 3962, temperature: 375, technology: Li-ion, AC powered:false, USB powered:false, Wireless powered:false, icon:17303429, invalid charger:0, maxChargingCurrent:0, maxChargingVoltage:0, chargeCounter:1714883-------------------------------------------------------------------------------DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57这里有个问题，adb shell bugreport的log在User版本和Userdebug的版本里面抓出来的结果不一样，具体原因，可能是日志的级别限制的，需要查证一下。</code></pre><p>2.mPluggedIn的值是在收到ACTION_BATTERY_CHANGED广播里面带的参数得到的，那么这个广播是哪里发出来的呢？<br>通过使用<a href="http://androidxref.com" target="_blank" rel="noopener">http://androidxref.com</a> 进行全局搜索，找到是在<br>/frameworks/base/services/core/java/com/android/server/BatteryService.java的sendIntentLocked()函数里面发出来的。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="function"><span class="title">sendIntentLocked</span></span>() &#123;</span><br><span class="line">        //  Pack up the values and broadcast them to everyone</span><br><span class="line">        final Intent intent = new Intent(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line"></span><br><span class="line">        int icon = getIconLocked(mBatteryProps.batteryLevel);</span><br><span class="line"></span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_STATUS, mBatteryProps.batteryStatus);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_HEALTH, mBatteryProps.batteryHealth);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PRESENT, mBatteryProps.batteryPresent);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_LEVEL, mBatteryProps.batteryLevel);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_SCALE);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_ICON_SMALL, icon);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PLUGGED, mPlugType);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_VOLTAGE, mBatteryProps.batteryVoltage);    </span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_TEMPERATURE, mBatteryProps.batteryTemperature);  </span><br><span class="line"></span><br><span class="line">        EXTRA_PLUGGED的值是由mPlugType得到的，而mPlugType的值在BatteryService.java中得到方式如下：</span><br><span class="line">    private void processValuesLocked(boolean force) &#123;</span><br><span class="line">        boolean logOutlier = <span class="literal">false</span>;</span><br><span class="line">        long dischargeDuration = 0;</span><br><span class="line"></span><br><span class="line">        mBatteryLevelCritical = (mBatteryProps.batteryLevel &lt;= mCriticalBatteryLevel);</span><br><span class="line">        <span class="keyword">if</span> (mBatteryProps.chargerAcOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_AC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerUsbOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_USB;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerWirelessOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlugType = BATTERY_PLUGGED_NONE;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><pre><code>从中可以看出是根据mBatteryProps.chargerAcOnline或者mBatteryProps.chargerUsbOnline或者mBatteryProps.chargerWirelessOnline的值来判断，在frameworks/base/core/java/android/os/BatteryProperties.java中，可以看到这三个值是通过序列化的方式得到：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private BatteryProperties(Parcel p) &#123;</span><br><span class="line">    chargerAcOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerUsbOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerWirelessOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    maxChargingCurrent = p.readInt();</span><br><span class="line">    maxChargingVoltage = p.readInt();</span><br><span class="line">    batteryStatus = p.readInt();</span><br><span class="line">    batteryHealth = p.readInt();</span><br><span class="line">    batteryPresent = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    batteryLevel = p.readInt();</span><br><span class="line">    batteryVoltage = p.readInt();</span><br><span class="line">    batteryTemperature = p.readInt();</span><br><span class="line">    batteryFullCharge = p.readInt();</span><br><span class="line">    batteryChargeCounter = p.readInt();</span><br><span class="line">    batteryTechnology = p.readString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void writeToParcel(Parcel p, int flags) &#123;</span><br><span class="line">    p.writeInt(chargerAcOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerUsbOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerWirelessOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(maxChargingCurrent);</span><br><span class="line">    p.writeInt(maxChargingVoltage);</span><br><span class="line">    p.writeInt(batteryStatus);</span><br><span class="line">    p.writeInt(batteryHealth);</span><br><span class="line">    p.writeInt(batteryPresent ? 1 : 0);</span><br><span class="line">    p.writeInt(batteryLevel);</span><br><span class="line">    p.writeInt(batteryVoltage);</span><br><span class="line">    p.writeInt(batteryTemperature);</span><br><span class="line">    p.writeInt(batteryFullCharge);</span><br><span class="line">    p.writeInt(batteryChargeCounter);</span><br><span class="line">    p.writeString(batteryTechnology);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final Parcelable.Creator&lt;BatteryProperties&gt; CREATOR</span><br><span class="line">    = new Parcelable.Creator&lt;BatteryProperties&gt;() &#123;</span><br><span class="line">    public BatteryProperties createFromParcel(Parcel p) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BatteryProperties[] newArray(int size) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>再来看看mBatteryProps的赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void update(BatteryProperties props) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mUpdatesStopped) &#123;</span><br><span class="line">            mBatteryProps = props;</span><br><span class="line">            // Process the new values.</span><br><span class="line">            processValuesLocked(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastBatteryProps.set(props);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接着看update()函数的调用，如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class BatteryListener extends IBatteryPropertiesListener.Stub &#123;</span><br><span class="line">    @Override public void batteryPropertiesChanged(BatteryProperties props) &#123;</span><br><span class="line">        final long identity = Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            BatteryService.this.update(props);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(identity);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>可以看到BatteryProperties是在由batteryPropertiesChanged赋值，是通过AIDL实现对C++侧的监听，这个AIDL实现了JAVA侧与C++侧的通讯。这一块关于电池的共有三个AIDL文件,作为客户端和服务端的媒介，具体代码，以及作用分析如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/BatteryProperties.aidl</span><br><span class="line">package android.os;</span><br><span class="line">    parcelable BatteryProperties;</span><br></pre></td></tr></table></figure><pre><code>BatteryProperties.aidl主要用户AIDL跨进程通讯时的数据序列化和反序列化frameworks/base/core/java/android/os/BatteryProperties.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesListener.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.BatteryProperties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* &#123;@hide&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">oneway interface IBatteryPropertiesListener &#123;</span><br><span class="line">    void batteryPropertiesChanged(<span class="keyword">in</span> BatteryProperties props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesListener.aidl主要用于监听</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesRegistrar.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.IBatteryPropertiesListener;</span><br><span class="line">import android.os.BatteryProperty;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@hide&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">interface IBatteryPropertiesRegistrar &#123;</span><br><span class="line">    void registerListener(IBatteryPropertiesListener listener);</span><br><span class="line">    void unregisterListener(IBatteryPropertiesListener listener);</span><br><span class="line">    int getProperty(<span class="keyword">in</span> int id, out BatteryProperty prop);</span><br><span class="line">    oneway void scheduleUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesRegistrar.aidl主要用于注册服务端在BatteryService.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">onStart</span></span>() &#123;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"batteryproperties"</span>);</span><br><span class="line">    final IBatteryPropertiesRegistrar batteryPropertiesRegistrar =</span><br><span class="line">            IBatteryPropertiesRegistrar.Stub.asInterface(b);</span><br><span class="line">    try &#123;</span><br><span class="line">        batteryPropertiesRegistrar.registerListener(new BatteryListener());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Should never happen.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBinderService = new BinderService();</span><br><span class="line">    publishBinderService(<span class="string">"battery"</span>, mBinderService);</span><br><span class="line">    publishLocalService(BatteryManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>对应的native层的代码在frameworks/native/services/batteryservice/编译出libbatteryservice.so库Java侧与C++侧通过AIDL通讯，两边都要写AIDL文件，且两边都要有Parcel序列化。通过查找batteryPropertiesChanged函数system/core/healthd/BatteryPropertiesRegistrar.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "BatteryPropertiesRegistrar.h"</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/BatteryService.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesListener.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesRegistrar.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IPCThreadState.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IServiceManager.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/PermissionCache.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;private/android_filesystem_config.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Errors.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Mutex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/String16.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;healthd/healthd.h&gt;</span></span><br><span class="line"></span><br><span class="line">namespace android &#123;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::publish(</span><br><span class="line">    const sp&lt;BatteryPropertiesRegistrar&gt;&amp; service) &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(String16(<span class="string">"batteryproperties"</span>), service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::notifyListeners(const struct BatteryProperties&amp; props) &#123;</span><br><span class="line">    Vector&lt;sp&lt;IBatteryPropertiesListener&gt; &gt; listenersCopy;</span><br><span class="line"></span><br><span class="line">    // Binder currently may service an incoming oneway transaction whenever an</span><br><span class="line">    // outbound oneway call is made (<span class="keyword">if</span> there is already a pending incoming</span><br><span class="line">    // oneway call waiting).  This is considered a bug and may change <span class="keyword">in</span> the</span><br><span class="line">    // future.  For now, avoid recursive mutex lock <span class="keyword">while</span> making outbound</span><br><span class="line">    // calls by making a <span class="built_in">local</span> copy of the current list of listeners.</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        listenersCopy = mListeners;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; listenersCopy.size(); i++) &#123;</span><br><span class="line">        listenersCopy[i]-&gt;batteryPropertiesChanged(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::registerListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        // check whether this is a duplicate</span><br><span class="line">        <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mListeners.add(listener);</span><br><span class="line">        IInterface::asBinder(listener)-&gt;linkToDeath(this);</span><br><span class="line">    &#125;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::unregisterListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">            IInterface::asBinder(mListeners[i])-&gt;unlinkToDeath(this);</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::getProperty(int id, struct BatteryProperty *val) &#123;</span><br><span class="line">    <span class="built_in">return</span> healthd_get_property(id, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::<span class="function"><span class="title">scheduleUpdate</span></span>() &#123;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::dump(int fd, const Vector&lt;String16&gt;&amp; /*args*/) &#123;</span><br><span class="line">    IPCThreadState* self = IPCThreadState::self();</span><br><span class="line">    const int pid = self-&gt;getCallingPid();</span><br><span class="line">    const int uid = self-&gt;getCallingUid();</span><br><span class="line">    <span class="keyword">if</span> ((uid != AID_SHELL) &amp;&amp;</span><br><span class="line">        !PermissionCache::checkPermission(</span><br><span class="line">                String16(<span class="string">"android.permission.DUMP"</span>), pid, uid))</span><br><span class="line">        <span class="built_in">return</span> PERMISSION_DENIED;</span><br><span class="line"></span><br><span class="line">    healthd_dump_battery_state(fd);</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == who) &#123;</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace android</span><br></pre></td></tr></table></figure><pre><code>再查找notifyListeners函数，在 system/core/healthd/healthd_mode_android.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void healthd_mode_android_battery_update(</span><br><span class="line">    struct android::BatteryProperties *props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gBatteryPropertiesRegistrar != NULL)</span><br><span class="line">        gBatteryPropertiesRegistrar-&gt;notifyListeners(*props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>Healthd是一种中介模型，向下监听来自kernel层的电池事件，向上将电池数据信息传递给Framework层的BatteryService.主要代码在 system/core/healthd 中，对Healthd模块的代码分析如下：参考：Healthd模块编译出来的文件有system/bin/healthd通过在system/core/healthd里面查找chargerUsbOnline，在system/core/healthd/BatteryMonitor.cpp中update函数可以看到赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">bool BatteryMonitor::update(void) &#123;</span><br><span class="line">    bool logthis;</span><br><span class="line"></span><br><span class="line">    initBatteryProperties(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryPresentPath.isEmpty())</span><br><span class="line">        props.batteryPresent = getBooleanField(mHealthdConfig-&gt;batteryPresentPath);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        props.batteryPresent = mBatteryDevicePresent;</span><br><span class="line"></span><br><span class="line">    props.batteryLevel = mBatteryFixedCapacity ?</span><br><span class="line">        mBatteryFixedCapacity :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryCapacityPath);</span><br><span class="line">    props.batteryVoltage = getIntField(mHealthdConfig-&gt;batteryVoltagePath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty())</span><br><span class="line">        props.batteryCurrent = getIntField(mHealthdConfig-&gt;batteryCurrentNowPath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty())</span><br><span class="line">        props.batteryFullCharge = getIntField(mHealthdConfig-&gt;batteryFullChargePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty())</span><br><span class="line">        props.batteryCycleCount = getIntField(mHealthdConfig-&gt;batteryCycleCountPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryChargeCounterPath.isEmpty())</span><br><span class="line">        props.batteryChargeCounter = getIntField(mHealthdConfig-&gt;batteryChargeCounterPath);</span><br><span class="line"></span><br><span class="line">    props.batteryTemperature = mBatteryFixedTemperature ?</span><br><span class="line">        mBatteryFixedTemperature :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryTemperaturePath);</span><br><span class="line"></span><br><span class="line">    // For devices <span class="built_in">which</span> <span class="keyword">do</span> not have battery and are always plugged</span><br><span class="line">    // into power souce.</span><br><span class="line">    <span class="keyword">if</span> (mAlwaysPluggedDevice) &#123;</span><br><span class="line">        props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">        props.batteryPresent = <span class="literal">true</span>;</span><br><span class="line">        props.batteryStatus = BATTERY_STATUS_CHARGING;</span><br><span class="line">        props.batteryHealth = BATTERY_HEALTH_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryStatusPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryStatus = getBatteryStatus(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryHealthPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryHealth = getBatteryHealth(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryTechnologyPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryTechnology = String8(buf.c_str());</span><br><span class="line"></span><br><span class="line">    unsigned int i;</span><br><span class="line">    double MaxPower = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; mChargerNames.size(); i++) &#123;</span><br><span class="line">        String8 path;</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/online"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          mChargerNames[i].string());</span><br><span class="line">        <span class="keyword">if</span> (getIntField(path)) &#123;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/type"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            switch(readPowerSupplyType(path)) &#123;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_AC:</span><br><span class="line">                props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_USB:</span><br><span class="line">                props.chargerUsbOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_WIRELESS:</span><br><span class="line">                props.chargerWirelessOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                KLOG_WARNING(LOG_TAG, <span class="string">"%s: Unknown power supply type\n"</span>,</span><br><span class="line">                             mChargerNames[i].string());</span><br><span class="line">            &#125;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/current_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            int ChargingCurrent =</span><br><span class="line">                    (access(path.string(), R_OK) == 0) ? getIntField(path) : 0;</span><br><span class="line"></span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/voltage_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line"></span><br><span class="line">            int ChargingVoltage =</span><br><span class="line">                (access(path.string(), R_OK) == 0) ? getIntField(path) :</span><br><span class="line">                DEFAULT_VBUS_VOLTAGE;</span><br><span class="line"></span><br><span class="line">            double power = ((double)ChargingCurrent / MILLION) *</span><br><span class="line">                           ((double)ChargingVoltage / MILLION);</span><br><span class="line">            <span class="keyword">if</span> (MaxPower &lt; power) &#123;</span><br><span class="line">                props.maxChargingCurrent = ChargingCurrent;</span><br><span class="line">                props.maxChargingVoltage = ChargingVoltage;</span><br><span class="line">                MaxPower = power;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logthis = !healthd_board_battery_update(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        char dmesgline[256];</span><br><span class="line">        size_t len;</span><br><span class="line">        <span class="keyword">if</span> (props.batteryPresent) &#123;</span><br><span class="line">            snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery l=%d v=%d t=%s%d.%d h=%d st=%d"</span>,</span><br><span class="line">                 props.batteryLevel, props.batteryVoltage,</span><br><span class="line">                 props.batteryTemperature &lt; 0 ? <span class="string">"-"</span> : <span class="string">""</span>,</span><br><span class="line">                 abs(props.batteryTemperature / 10),</span><br><span class="line">                 abs(props.batteryTemperature % 10), props.batteryHealth,</span><br><span class="line">                 props.batteryStatus);</span><br><span class="line"></span><br><span class="line">            len = strlen(dmesgline);</span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" c=%d"</span>, props.batteryCurrent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" fc=%d"</span>, props.batteryFullCharge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" cc=%d"</span>, props.batteryCycleCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery none"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        snprintf(dmesgline + len, sizeof(dmesgline) - len, <span class="string">" chg=%s%s%s"</span>,</span><br><span class="line">                 props.chargerAcOnline ? <span class="string">"a"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerUsbOnline ? <span class="string">"u"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerWirelessOnline ? <span class="string">"w"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        KLOG_WARNING(LOG_TAG, <span class="string">"%s\n"</span>, dmesgline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    healthd_mode_ops-&gt;battery_update(&amp;props);</span><br><span class="line">    <span class="built_in">return</span> props.chargerAcOnline | props.chargerUsbOnline |</span><br><span class="line">            props.chargerWirelessOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   从上面代码可以看到chargerUsbOnline的值是通过读取 sys/class/power_supply文件夹下的USB文件夹下的type里面的值来判断。</p><p>   adb shell进入手机后，cd sys/class/power_supply/USB,cat type发现是USB。</p><h2 id="这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump-log来看如下：的确没有正确的读取到"><a href="#这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump-log来看如下：的确没有正确的读取到" class="headerlink" title="   这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump log来看如下：的确没有正确的读取到"></a>   这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump log来看如下：的确没有正确的读取到</h2><pre><code>DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57现在怀疑是SeAndroid的AVC权限导致的。</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android PMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android</title>
      <link href="/2018/06/23/year-06-23-Android/"/>
      <url>/2018/06/23/year-06-23-Android/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/23/hello-world/"/>
      <url>/2018/06/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 配置 OpenGork 服务</title>
      <link href="/2018/05/31/year-06-23-Ubuntu-%E9%85%8D%E7%BD%AE-OpenGork-%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/05/31/year-06-23-Ubuntu-%E9%85%8D%E7%BD%AE-OpenGork-%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>OpenGork的好处，这里不做介绍了，可以参考<a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24369747</a><br>OpenGork是用Java实现的，源码见 <a href="https://github.com/oracle/opengrok/" target="_blank" rel="noopener">https://github.com/oracle/opengrok/</a><br>OpenGork官网：<a href="http://oracle.github.io/opengrok/" target="_blank" rel="noopener">http://oracle.github.io/opengrok/</a><br>OpenGork下载地址：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a> 这里可以下载编译好的文件，或者下载源码</p><p>配置OpenGork之前需要一些其他的环境：<br>1.Java环境：JDK 以及配置好环境变量<br>—如何实现请自行查找<br>2.Tomcat 服务：需要下载Tomcat服务<br>下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a><br><strong>注意一：Tomcat7.0版本和JDK1.8版本无法兼容</strong><br>3.OpenGork：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a><br>4.遗漏了ctags，如果这个工具没有安装和在Opengork里面配置的话，就算Tomcat和Opengork都配置好了，且都能正常运行，还是无法进行搜索，而且Opengork网站里面也无法打开文件。根本原因是ctags 就是用来建立索引的工具，没了它，后面的搜索就无从说起。<br>Ubuntu 安装ctags命令:sudo apt-get install ctags<br>Ubuntu自带了exuberant ctags,在后面的OpenGork的配置文件中，需要FindExuberanCtags()函数的binary中需要填写为binay=”exuberant ctags”</p><p><strong>注意二：Tomcat 和 Jdk不要直接用sudo apt-get install的命令方式来安装。这样做了，后面改配置文件会很痛苦</strong></p><p>前期准备工作做好了之后，下面来进行安装和配置：<br>1.安装Tomcat<br>1)解压下载下来的Tomcat压缩包<br>进入Tomcat解压目录/bin 下执行sudo ./startup.sh<br>启动Tomcat<br>2).在浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 或者192.168.0.1:8080<br>局域网内其他机器可以输入<a href="http://ip:8080" target="_blank" rel="noopener">http://ip:8080</a>来测试Tomcat服务是否启动成功</p><p>2.安装OpenGork<br>1)在/opt目录下新建opengork目录<br>2)将下载下来的opengork压缩包解压到/opt/opengork目录下<br>3)opengrok/lib目录下的source.war包拷贝到apache-tomcat/webapps目录下<br>4)在浏览器输入<a href="http://localhost:8080/source" target="_blank" rel="noopener">http://localhost:8080/source</a><br>5)能正常看到opengork起来了的界面就Ok了。<br>如果Tomcat版本是7.0，JDK版本是1.8的话，或在这个界面报各种http 400/500等各种乱七八糟的错误</p><p>3.配置OpenGork<br>在/opt/opengrok目录的bin文件下 vim OpenGork文件<br>找到DefaultInstanceConfiguration函数里面的<br>OPENGROK_INSTANCE_BASE=”${OPENGROK_INSTANCE_BASE:-/var/opengrok}”</p><p>这一块<a href="https://blog.csdn.net/tyronne/article/details/34984805" target="_blank" rel="noopener">https://blog.csdn.net/tyronne/article/details/34984805</a> 这篇文章写的蛮好，可以参考</p><p>4.客制化Opengork<br>由于Opengork的代码需要建立索引，一般是在/opt/opengork/有src data等目录<br>其实可以自己克制化这个目录<br>比如：在/home/xxx/Code/目录下新建一个opengork目录<br>在里面再建好src data etc三个目录</p><p>在第三步的/opt/opengork/bin/OpenGork这个配置文件里面和Tomcat的web.xml文件里面<br>把路径都配置成/home/xxx/Code/opengork就可以了</p><p>后面可以把代码放在/home/xxx/Code/src目录下面</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android开发常用网站</title>
      <link href="/2017/04/23/2017-04-23-Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
      <url>/2017/04/23/2017-04-23-Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h1 id="实用的OpenGork网站："><a href="#实用的OpenGork网站：" class="headerlink" title="实用的OpenGork网站："></a>实用的OpenGork网站：</h1><p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a><br><a href="https://www.androidos.net.cn/" target="_blank" rel="noopener">https://www.androidos.net.cn/</a><br><a href="http://android.macpod.net/" target="_blank" rel="noopener">http://android.macpod.net/</a></p><h1 id="Android工具网站："><a href="#Android工具网站：" class="headerlink" title="Android工具网站："></a>Android工具网站：</h1><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a></p><h1 id="Android-开发技术周报"><a href="#Android-开发技术周报" class="headerlink" title="Android 开发技术周报"></a>Android 开发技术周报</h1><p><a href="https://androidweekly.io/" target="_blank" rel="noopener">https://androidweekly.io/</a>  每周一篇最新的技术周报<br><a href="https://androidweekly.cn/" target="_blank" rel="noopener">https://androidweekly.cn/</a><br>Android 开发的技术文章、开源项目、开发工具、视频教程、Android 设计教程、设计资源等</p><h1 id="编程刷题网站："><a href="#编程刷题网站：" class="headerlink" title="编程刷题网站："></a>编程刷题网站：</h1><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a><br><a href="https://www.jiuzhang.com/solutions/" target="_blank" rel="noopener">https://www.jiuzhang.com/solutions/</a><br><a href="http://www.codevs.cn/" target="_blank" rel="noopener">http://www.codevs.cn/</a><br><a href="https://www.hackerrank.com/onboarding/challenge" target="_blank" rel="noopener">https://www.hackerrank.com/onboarding/challenge</a><br><a href="http://www.codeding.com/" target="_blank" rel="noopener">http://www.codeding.com/</a></p><h1 id="语言手册"><a href="#语言手册" class="headerlink" title="语言手册"></a>语言手册</h1><p><a href="https://mirrors.segmentfault.com/" target="_blank" rel="noopener">https://mirrors.segmentfault.com/</a><br>Introduction to Tornado 中文翻译<br>Android 设计指南简体中文版<br>Swift语言指南<br>PHP 中文手册<br>Node.js 手册<br>Golang 手册<br>Python 2.x 手册<br>Python 3.x 手册<br>Laravel 手册<br>Rust 手册<br>React 手册<br>Kotlin 手册</p>]]></content>
      
      <categories>
          
          <category> Android Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View及Viewgroup</title>
      <link href="/2015/08/01/View%E5%8F%8AViewgroup/"/>
      <url>/2015/08/01/View%E5%8F%8AViewgroup/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html</a></p><p>.1.0 View及ViewGroup类关系<br>Android View和ViewGroup从组成架构上看，似乎ViewGroup在View之上，View需要继承ViewGroup，但实际上不是这样的。 View是基类，ViewGroup是它的子类。这就证明了一点，View代表了用户界面组件的一块可绘制的空间块。每一个View在屏幕上占据一个长方 形区域。在这个区域内，这个VIEW对象负责图形绘制和事件处理。View是小控件widgets和ViewGroup的父类。ViewGroup又是 Layout的基类。</p><p>image</p><p>image</p><p>从上面两图的对比中，可以看出，实际上ViewGroup是View的子类，因此，View的行为特征ViewGroup也具备，但同时因为 ViewGroup是Layout的祖先，所以具备了其它一些特点,View所未具有的。通常创建一个View，不论是通过XML还是通过代码创建。对任 何一个View及这个View的子类Widget，需要关注如下几个方面：<br>【1】设置属性，如长、宽、着色等。这些属性的设置通常可以用代码实现，也可以用XML文件。并用这些属性在运行时候也可以通常方法进行修改。<br>ID 属性，Android对每个UI元素的ID名称要求唯一，但也不绝对。同时在不同的Layout中是可以相同的元素名称的。给一个UI元素指定ID，有一个好处就是可以在代码中找得到。</p><p>image</p><p>Tags，同ID不同，这个不用来搜索View,类似于对View的一些描述性数据保存。<br>Animation，对任何一个View，可以使用动画对象进行操作。注意，如果View有子的话，子同样具备这个animation功能<br>Position, Size, padding and margins，对任一个View来说，表达这个View通常是宽和高。也可以设置padding和margins。不是所有的View都设置margins。</p><p>image</p><p>Orientatiion，对ViewGroup的子类Layout来说，设置Orienatation，可用来决定子类的位置<br>FillModel，出现这种情况主要是默认情况，某些元素不能完全占满父区域的空间，这时除非子VIEW已经设置具体和DPI，否则话需要告诉父控件，你所选择填充空间方式，如Fill-parent或者Wrap-content等。<br>Gravity，Gravity与Orientation是不同，Gravaity与Word文档中左对齐，右对齐类似。缺省是左上对齐。<br>Weight,这个在两个控制同时分配剩余空间，需要设置layout-weight决定两者谁的占比。<br>【2】请求焦点，可以通过函数实现焦点转换。不同的焦点可以实现不同的背景变换等功能。焦点在Android里分为几种情况，一种是可以获取焦点，另外一种是不能获取焦点，第三种是可获取焦点，但当前正取触摸状态下。<br>【3】设置事件监听者，所有的View都会在本身发生变化将自身的信息广播出去。比喻点击、焦点失去得到等。通常一个事件来到，Android会将事件传 递到相应的View，然后View将事件传递到相应的Listeners。这时View需要获取焦点，如果需要重新绘制View的话，需要调用 invalidate(0或者reqeustLayout重新绘制整个界面。<br>【4】设置显示与隐藏，还可以对其内容设置scrolling。<br>2.1.1 View、Window、Activity、Dispay之间的关系<br>这些都是组成Android 系统显示的关键元素。我们首先来了解Dispay。Dispay代表了硬件显示屏幕信息。</p><p>image</p><p>通过这些函数可以了解一个屏幕的宽、高及分辨率还有是横屏还坚屏等一些基本情况，透过这些函数，我们开发应用时可以方便的得到当前安装我这个应用的屏幕的 大小，以便调整应用使用户得到更好的用户体验。接下来我们看其它三者之间的关系，我想大家虽然看了前面的View的介绍和SDK中关系UI的基本介绍之后 还是对Android图形窗口十分困惑，看API也是，有WindowMangaer接口和Window类，但是在说明文档中，并未提到如何用这些。但实 际上这里面要去看到Android核心，Android核心底层GDI是SKIA，同chrome是一样的GDI，但是GUI是不一样的。这里面 Android实现的是C/S模式。如下图所示</p><p>image</p><p>从上图，我们可以理出大致的显示过程如下：<br>【1】ActivityManagerService创建Activity线程，激活一个activity<br>【2】系统调用Instrumentation.newActivity创建一个activity<br>【3】Activity创建后，attach到一个新创建的phonewindow中。这样Activity获取一个唯一的WindowManager服务的实例<br>【4】Activity创建过程中使用setcontentView设置用用户UI，这些VIEW被加入到PhoneWindow的ContentParent中。<br>【5】Activity线程继续执行，当执行到Activity.makeVisible是将根view DecoView加入到WindowManger中，WindowManger实全会为每个DecoView创建对应的ViewRoot<br>【6】每个ViewRoot拥有一个Surface，每个Surface将会调用底层库创建图形绘制的内存空间。这个底层库就是SurfaceFlinger。SurfaceFlinger同时也负责将个View绘制的图形合到一块（按照Z轴）显示到用户屏幕。<br>【7】如果用户直接在Canvas上绘制，实际上它直接操作Surface。但对每个View的变更，它是要通知到ViewRoot，然后 ViewRoot获取Canvas。如果绘制完成，surfaceFlinger得到通知，合并Surface成一个Surface到设备屏幕。<br>从上面的图形输出过程分析，我们可以知道真正显示图形的实际上跟Activity没有关系，完全由WindowManager来决定。 WindowManager是一个系统服务，因此可以直接调用这个服务来创建界面，并且更绝的是Dialog、Menu也是有WindowManager 来管理的。另外一个我们也可以看到，最底层都是Surface来，因此，常见开发游戏的人都推荐你使用SurfaceView来创建界面。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android 编程下 Touch 事件的分发和消费机制</title>
      <link href="/2015/08/01/Android-%E7%BC%96%E7%A8%8B%E4%B8%8B-Touch-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2015/08/01/Android-%E7%BC%96%E7%A8%8B%E4%B8%8B-Touch-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html</a></p><p>Android 中与 Touch 事件相关的方法包括：dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)、onTouchEvent(MotionEvent ev)；能够响应这些方法的控件包括：ViewGroup、View、Activity。方法与控件的对应关系如下表所示：</p><p>Touch 事件相关方法 方法功能<br>ViewGroup<br>View<br>Activity<br>public boolean dispatchTouchEvent(MotionEvent ev) 事件分发<br>Yes Yes Yes<br>public boolean onInterceptTouchEvent(MotionEvent ev)<br>事件拦截<br>Yes Yes No<br>public boolean onTouchEvent(MotionEvent ev) 事件响应<br>Yes Yes Yes<br>从这张表中我们可以看到 ViewGroup 和 View 对与 Touch 事件相关的三个方法均能响应，而 Activity 对 onInterceptTouchEvent(MotionEvent ev) 也就是事件拦截不进行响应。另外需要注意的是 View 对 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev) 的响应的前提是可以向该 View 中添加子 View，如果当前的 View 已经是一个最小的单元 View（比如 TextView），那么就无法向这个最小 View 中添加子 View，也就无法向子 View 进行事件的分发和拦截，所以它没有 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev)，只有 onTouchEvent(MotionEvent ev)。</p><p>一、Touch 事件分析</p><p>▐ 事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</p><p>Touch 事件发生时 Activity 的 dispatchTouchEvent(MotionEvent ev) 方法会以隧道方式（从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递）将事件传递给最外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法，并由该 View 的 dispatchTouchEvent(MotionEvent ev) 方法对事件进行分发。dispatchTouchEvent 的事件分发逻辑如下：</p><p>如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；<br>如果 return false，事件分发分为两种情况：<br>如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；<br>如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。<br>如果返回系统默认的 super.dispatchTouchEvent(ev)，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。<br>▐ 事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</p><p>在外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法返回系统默认的 super.dispatchTouchEvent(ev) 情况下，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。onInterceptTouchEvent 的事件拦截逻辑如下：</p><p>如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；<br>如果 onInterceptTouchEvent 返回 false，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；<br>如果 onInterceptTouchEvent 返回 super.onInterceptTouchEvent(ev)，事件默认会被拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理。<br>▐ 事件响应：public boolean onTouchEvent(MotionEvent ev)</p><p>在 dispatchTouchEvent 返回 super.dispatchTouchEvent(ev) 并且 onInterceptTouchEvent 返回 true 或返回 super.onInterceptTouchEvent(ev) 的情况下 onTouchEvent 会被调用。onTouchEvent 的事件响应逻辑如下：</p><p>如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。<br>如果返回了 true 则会接收并消费该事件。<br>如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。<br>到这里，与 Touch 事件相关的三个方法就分析完毕了。下面的内容会通过各种不同的的测试案例来验证上文中三个方法对事件的处理逻辑。</p><p>二、Touch 案例介绍</p><p>同样在开始进行案例分析之前，我需要说明测试案例的结构，因为所有的测试都是针对这一个案例来进行的，测试中只是通过修改每个控件中与 Touch 事件相关的三个方法的返回值来体现不同的情况。先来看张图：</p><p>Touch 事件案例布局 UI</p><p>上面的图为测试案例的布局文件 UI 显示效果，布局文件代码如下：</p><p>复制代码</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2015/08/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/beyond0525/article/details/22814129" target="_blank" rel="noopener">http://blog.csdn.net/beyond0525/article/details/22814129</a></p><p>适配者模式是也是android中应用很广泛的设计模式，如我们常见用 BaseAdpter, ArrayAdapter, CursorAdapter,就是用的适配者模式，看到源码你是不是对这种设计方式很陌生，没事，下面我们通过实际的例子来取理解这种设计模式。</p><p>一、作用</p><p>适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>二、适用场景</p><ol><li><p>业务的接口与工作的类不兼容，（比如：类中缺少实现接口的某些方法）但又需要两者一起工作</p></li><li><p>在现有接口和类的基础上为新的业务需求提供接口</p></li></ol><p>三、常见的使用方式</p><p>还是以Usb接口和Phone手机类的产品举例子，假设设计的Phone类中有 call(), sms(), takeAlong()属性方法，而在设计Usb接口时定义了 store(), takeAlong()的行为。如果现在有新的业务需求，需要生成 Xiaomi手机类具有 Phone类和Usb接口两者功能，假设Phone类和Usb接口已经在业务上投入使用，很显然，去修改原类中的方法和接口的行为去满足现在的新业务需求是不可取的，那么现在适配者模式就派上用场了。</p><p>（1）类适配模式</p><p>大致的意思是新的业务类Xiaomi通过继承旧业务的类Phone并实现接口Usb来满足新的业务的一种适配方式，如下图</p><p>Usb接口</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public interface Usb {</p><pre><code>void store();  void takeAlong();  </code></pre><p>}<br>Phone类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone {</p><pre><code>public void call() {      System.out.println(&quot;Phone call&quot;);  }  public void sms() {      System.out.println(&quot;Phone sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone takeAlong&quot;);  }  </code></pre><p>}<br>适配 Xiaomi 类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 类的适配器模式<br>* phone + Usb<br>* 将Phone的功能扩展到Usb里<br>* @author xuzhaohu  </p><ul><li><p>*/<br>public class Xiaomi extends Phone implements Usb {</p><p> @Override<br> public void store() {  </p><pre><code>// TODO Auto-generated method stub  System.out.println(&quot;store implements usb&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配完后使用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Xiaomi mi1 = new Xiaomi();<br>mi1.takeAlong();<br>mi1.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>这样新的业务需求就可以通过适配的 Xiaomi类去满足了。是不是觉得很简单呢！！:) 有没有其他的方式去实现同样的功能呢？当然有，就是下面要讲的对象适配模式。<br>（2）对象适配模式</p><p>实现的方式很简单，其实就是在适配的时候通过构造函数将旧的业务Phone 当作新的适配类（XiaomiWrapper）一个成员对象去处理，然后适配类只需要实现接口 Usb即可。如下类关系图</p><p>适配类XiaomiWrapper如下，注意takeAlong()方法，是直接调用原类对象（Phone）去执行的。</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 对象的适配器模式  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public class XiaomiWrapper implements Usb {</p><p> /** </p><ul><li>1.创建一个Wrapper类，持有原类的一个实例， </li><li><p>2.在Wrapper类的方法中，调用实例的方法就行<br>*/<br>private Phone phone;  </p><p>public XiaomiWrapper(Phone phone) {  </p><p> this.phone = phone;<br>}  </p><p>@Override<br>public void store() {<br> // TODO Auto-generated method stub<br> System.out.println(“store implements usb”);  </p><p>}  </p><p>@Override<br>public void takeAlong() {<br> // TODO Auto-generated method stub<br> phone.takeAlong();<br>}  </p></li></ul></li></ul><p>}<br>适配完后通过构造函数将原对象传入即可。<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>XiaomiWrapper mi2 = new XiaomiWrapper(new Phone());<br>mi2.takeAlong();<br>mi2.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>或许到这里，你会觉得这种方式很简单吧。但是如果出现这个Usb接口中有很多方法（大于2个），但是新的业务需求中也只需要其中的一两个，而且是需要适配很多这样的业务，这样的话，用上面的方法每次适配一次就会去实现所有Usb接口中的方法，实际上适配的类中有很多是用不到的，没有必要把接口中不使用的类也适配进去，这时候，就轮到下面的接口适配模式出场了。</p><p>（3）接口适配模式</p><p>适配新的业务需求的时候借助抽象实现类（AbsPhone实现Usb接口），也就说，抽象实现类把Usb接口中的行为都实现了，新的适配是需要跟抽象类对话就行，因为抽象实现类就能满足了所有适配的需求，并且做到了只适配业务本身的行为，接口中不需要的行为我根本不需要关注。这就是抽象实现类的作用。类图关系如下：</p><p>抽象类AbsPhone实现</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 接口的适配器模式<br>* 1.借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法<br>* 2.继承类可以选择性的实现接口中的方法  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public abstract class AbsPhone implements Usb {</p><p> public void store() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s store methond&quot;);  </code></pre><p> }  </p><p> public void takeAlong() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s takeAlong methond&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配类只跟AbsPhone打交道，根本不需要关心接口的行为，只显示自己所要关注的。<br>如Phone1适配只需要store()行为</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone1 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone1 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone1 sms&quot;);  }  public void store() {      System.out.println(&quot;Phone1 need usb&apos;s store methond&quot;);  }  </code></pre><p>}<br>Phone2适配只需要takeAlong()行为<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone2 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone2 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone2 sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone2 need usb&apos;s takeAlong methond&quot;);  }  </code></pre><p>}<br>实例化调用<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p2.takeAlong();<br>输出：<br>Phone1 need usb’s store methond<br>Phone2 need usb’s takeAlong methond<br>来一次完整的调用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p1.takeAlong();<br>p2.takeAlong();<br>p2.store();<br>输出：<br>Phone1 need usb’s store methond<br>AbsPhone implements usb’s takeAlong methond<br>Phone2 need usb’s takeAlong methond<br>AbsPhone implements usb’s store methond<br>这样很清晰的知道适配的什么方法了。</p><p>总结：适配者模式在android源码中有很多这样的体现，大家看完这个再去看源码，是不是会感觉看懂了不少呢？</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2015/08/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html</a></p><ol><li><p>概述</p><p>　　有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></li><li><p>解决的问题</p><p>　　将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p></li><li><p>模式中的角色</p><p>　　3.1 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><p>　　3.2 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p><p>　　3.3 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p><p>　　3.4 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p></li><li><p>模式解读</p><p>　　4.1 观察者模式的类图　　</p><p>　　4.2 观察者模式的代码</p></li></ol><p>复制代码<br>///<br>/// 抽象主题类<br>///<br>public abstract class Subject<br>{<br>private IList observers = new List();</p><pre><code>    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(Observer observer)    {        observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(Observer observer)    {        observers.Remove(observer);    }    /// &lt;summary&gt;    /// 向观察者（们）发出通知    /// &lt;/summary&gt;    public void Notify()    {        foreach (Observer o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己/// &lt;/summary&gt;public abstract class Observer{    public abstract void Update();}/// &lt;summary&gt;/// 具体观察者或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。/// &lt;/summary&gt;public class ConcreteSubject : Subject{    private string subjectState;    /// &lt;summary&gt;    /// 具体观察者的状态    /// &lt;/summary&gt;    public string SubjectState    {        get { return subjectState; }        set { subjectState = value; }    }}/// &lt;summary&gt;/// 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调/// &lt;/summary&gt;public class ConcreteObserver : Observer{    private string observerState;    private string name;    private ConcreteSubject subject;    /// &lt;summary&gt;    /// 具体观察者用一个具体主题来实现    /// &lt;/summary&gt;    public ConcreteSubject Subject    {        get { return subject; }        set { subject = value; }    }    public ConcreteObserver(ConcreteSubject subject, string name)    {        this.subject = subject;        this.name = name;    }    /// &lt;summary&gt;    /// 实现抽象观察者中的更新操作    /// &lt;/summary&gt;    public override void Update()    {        observerState = subject.SubjectState;        Console.WriteLine(&quot;The observer&apos;s state of {0} is {1}&quot;, name, observerState);    }}</code></pre><p>复制代码<br>　　4.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{<br>// 具体主题角色通常用具体自来来实现<br>ConcreteSubject subject = new ConcreteSubject();</p><pre><code>        subject.Attach(new ConcreteObserver(subject, &quot;Observer A&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer B&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer C&quot;));        subject.SubjectState = &quot;Ready&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　运行结果</p><ol><li><p>模式总结</p><p>　　5.1 优点</p><p>　　　　5.1.1 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p><p>　　5.2 缺点</p><p>　　　　5.2.1 依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p><p>　　5.3 适用场景</p><p>　　　　5.3.1 当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。</p><p>　　　　5.3.2 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p></li><li><p>模式引申，应用C#中的事件委托来彻底解除通知者和观察者之间的耦合。</p><p>　　　6.1 关于委托的定义：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的。</p><p>　　　6.2 关于事件：事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。</p></li><li><p>下面例子分别用观察者模式，事件机制来实现</p><p>　　7.1 实例描述：客户支付了订单款项，这时财务需要开具发票，出纳需要记账，配送员需要配货。</p><p>　　7.2 观察者模式的实现</p><p>　　　　7.2.1 类图</p><p>　　　　7.2.2 代码实现</p></li></ol><p>复制代码<br>///<br>/// 抽象观察者<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 工作岗位，作为这里的观察者的抽象/// &lt;/summary&gt;public abstract class JobStation{    public abstract void Update();}/// &lt;summary&gt;/// 具体主题，这里是客户/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    private IList&lt;JobStation&gt; observers = new List&lt;JobStation&gt;();    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(JobStation observer)    {        this.observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(JobStation observer)    {        this.observers.Remove(observer);    }    /// &lt;summary&gt;    /// 客户状态    /// &lt;/summary&gt;    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }    public void Notify()    {        foreach (JobStation o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 会计/// &lt;/summary&gt;public class Accountant : JobStation{    private string accountantState;    private Customer customer;    public Accountant(Customer customer)    {        this.customer = customer;    }    /// &lt;summary&gt;    /// 更新状态    /// &lt;/summary&gt;    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);            accountantState = &quot;已开发票&quot;;        }    }}/// &lt;summary&gt;/// 出纳/// &lt;/summary&gt;public class Cashier : JobStation{    private string cashierState;    private Customer customer;    public Cashier(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);            cashierState = &quot;已入账&quot;;        }    }}/// &lt;summary&gt;/// 配送员/// &lt;/summary&gt;public class Dilliveryman : JobStation{    private string dillivierymanState;    private Customer customer;    public Dilliveryman(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是配送员，我来发货。&quot;);            dillivierymanState = &quot;已发货&quot;;        }    }}</code></pre><p>复制代码<br>　　　　7.2.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        subject.Attach(new Accountant(subject));        subject.Attach(new Cashier(subject));        subject.Attach(new Dilliveryman(subject));        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果：</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p><p>　　7.3 事件实现</p><p>　　　　7.3.1 类图</p><p>　　　　通过类图来看，观察者和主题之间已经不存在任何依赖关系了。</p><p>　　　　7.3.2 代码实现</p><p>复制代码<br>///<br>/// 抽象主题<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 声明委托/// &lt;/summary&gt;public delegate void CustomerEventHandler();/// &lt;summary&gt;/// 具体主题/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    // 声明一个委托事件，类型为 CustomerEventHandler    public event CustomerEventHandler Update;    public void Notify()    {        if (Update != null)        {            // 使用事件来通知给订阅者            Update();        }    }    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }}/// &lt;summary&gt;/// 财务，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Accountant{    private string accountantState;    public Accountant()    { }    /// &lt;summary&gt;    /// 开发票    /// &lt;/summary&gt;    public void GiveInvoice()    {        Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);        accountantState = &quot;已开发票&quot;;    }}/// &lt;summary&gt;/// 出纳，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Cashier{    private string cashierState;    public void Recoded()    {        Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);        cashierState = &quot;已入账&quot;;    }}/// &lt;summary&gt;/// 配送员，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Dilliveryman{    private string dillivierymanState;    public void Dilliver()    {        Console.WriteLine(&quot;我是配送员，我来发货。&quot;);        dillivierymanState = &quot;已发货&quot;;    }}</code></pre><p>复制代码<br>　　　　7.3.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        Accountant accountant = new Accountant();        Cashier cashier = new Cashier();        Dilliveryman dilliveryman = new Dilliveryman();        // 注册事件        subject.Update += accountant.GiveInvoice;        subject.Update += cashier.Recoded;        subject.Update += dilliveryman.Dilliver;        /*         * 以上写法也可以用下面代码来替换        subject.Update += new CustomerEventHandler(accountant.GiveInvoice);        subject.Update += new CustomerEventHandler(cashier.Recoded);        subject.Update += new CustomerEventHandler(dilliveryman.Dilliver);         */        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2015/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="noopener">http://cantellow.iteye.com/blog/838473</a></p><p>第一种（懒汉，线程不安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}</p><pre><code>public static Singleton getInstance() {  if (instance == null) {      instance = new Singleton();  }  return instance;  }  </code></pre><p>}</p><p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。<br>第二种（懒汉，线程安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}<br>public static synchronized Singleton getInstance() {<br>if (instance == null) {<br>instance = new Singleton();<br>}<br>return instance;<br>}<br>}</p><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。<br>第三种（饿汉）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance = new Singleton();<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return instance;<br>}<br>}</p><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。<br>第四种（饿汉，变种）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private Singleton instance = null;<br>static {<br>instance = new Singleton();<br>}<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return this.instance;<br>}<br>}</p><p>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance。<br>第五种（静态内部类）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static class SingletonHolder {<br>private static final Singleton INSTANCE = new Singleton();<br>}<br>private Singleton (){}<br>public static final Singleton getInstance() {<br>return SingletonHolder.INSTANCE;<br>}<br>}</p><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。<br>第六种（枚举）：</p><p>Java代码 收藏代码<br>public enum Singleton {<br>INSTANCE;<br>public void whateverMethod() {<br>}<br>}</p><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。<br>第七种（双重校验锁）：<br>Java代码 收藏代码<br>public class Singleton {<br>private volatile static Singleton singleton;<br>private Singleton (){}<br>public static Singleton getSingleton() {<br>if (singleton == null) {<br>synchronized (Singleton.class) {<br>if (singleton == null) {<br>singleton = new Singleton();<br>}<br>}<br>}<br>return singleton;<br>}<br>}</p><p>这个是第二种方式的升级版，俗称双重检查锁定，详细介绍请查看：<a href="http://www.ibm.com/developerworks/cn/java/j-dcl.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-dcl.html</a><br>在JDK1.5之后，双重检查锁定才能够正常达到单例效果。</p><p>总结<br>有两个问题需要注意：<br>1.如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>2.如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>对第一个问题修复的办法是：</p><p>Java代码 收藏代码<br>private static Class getClass(String classname)<br>throws ClassNotFoundException {<br>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</p><pre><code>if(classLoader == null)        classLoader = Singleton.class.getClassLoader();     return (classLoader.loadClass(classname));     </code></pre><p>}<br>}<br>对第二个问题修复的办法是：</p><p>Java代码 收藏代码<br>public class Singleton implements java.io.Serializable {<br>public static Singleton INSTANCE = new Singleton();</p><p>protected Singleton() {</p><p>}<br>private Object readResolve() {<br>return INSTANCE;<br>}<br>}</p><h1 id="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。"><a href="#对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。" class="headerlink" title="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。"></a>对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。</h1><p>superheizai同学总结的很到位：</p><p>不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中堆内存和栈内存详解</title>
      <link href="/2015/07/29/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2015/07/29/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html" target="_blank" rel="noopener">http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html</a></p><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。<br>堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。<br>引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p><p>java中内存分配策略及堆和栈的比较</p><p>　　1 内存分配策略</p><p>　　按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.</p><p>　　静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.</p><p>　　栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。</p><p>　　静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.</p><p>　　2 堆和栈的比较</p><p>　　上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈:</p><p>　　从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的:</p><p>　　在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时.</p><p>　　堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~).</p><p>　　3 JVM中的堆和栈</p><p>　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>　　我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.</p><p>　　从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p><p>　　每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p><p>　　Java 中的堆和栈</p><p>　　Java把内存划分成两种：一种是栈内存，一种是堆内存。</p><p>　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</p><p>　　当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p>　　堆内存用来存放由new创建的对象和数组。</p><p>　　在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p>　　在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。</p><p>　　引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><p>　　具体的说：</p><p>　　栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。</p><p>　　栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p><p>　　int a = 3;</p><p>　　int b = 3;</p><p>　　编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>android数字签名</title>
      <link href="/2015/07/22/android%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2015/07/22/android%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      <content type="html"><![CDATA[<p><a href="http://www.oschina.net/question/157182_45890" target="_blank" rel="noopener">http://www.oschina.net/question/157182_45890</a></p><p>Android系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系,如果一个permission的protectionLevel为signature，那么就只有那些跟该permission所在的程序拥有同一个数字证书的应用程序才能取得该权限。Android使用Java的数字证书相关的机制来给apk加盖数字证书，要理解android的数字证书，需要先了解以下数字证书的概念和java的数字证书机制。Android系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字证书并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。<br>同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。</p><p>(1)有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。</p><p>(2)有利于程序的模块化设计和开发。Android系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。</p><p>(3)可以通过权限(permission)的方式在多个程序间共享数据和代码。Android提供了基于数字证书的权限赋予机制，应用程序可以和其他的程序共享概功能或者数据给那那些与自己拥有相同数字证书的程序。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。</p><p>在签名时，需要考虑数字证书的有效期：</p><p>(1)数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。</p><p>(2)如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。</p><p>(3)Android Market强制要求所有应用程序数字证书的有效期要持续到2033年10月22日以后。</p><p>Android数字证书包含以下几个要点：</p><pre><code>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。(5)Android使用标准的java工具 Keytool and Jarsigner 来生成数字证书，并给应用程序包签名。（6）使用zipalign优化程序。</code></pre><p>Android系统不会安装运行任何一款未经数字签名的apk程序，无论是在模拟器上还是在实际的物理设备上。Android的开发工具(ADT插件和Ant)都可以协助开发者给apk程序签名，它们都有两种模式：调试模式(debug mode)和发布模式(release mode)。</p><p>在调试模式下，android的开发工具会在每次编译时使用调试用的数字证书给程序签名，开发者无须关心。</p><p>当要发布程序时，开发者就需要使用自己的数字证书给apk包签名，可以有两种方法。</p><p>(1)在命令行下使用JDK中的和Keytool(用于生成数字证书)和Jarsigner(用于使用数字证书签名)来给apk包签名。</p><p>(2)使用ADT Export Wizard进行签名(如果没有数字证书可能需要生成数字证书)。</p><p>使用Keytool和Jarsigner给程序签名</p><p>命令：keytool -genkey -v -keystore android.keystore -alias android -keyalg RSA -validity 20000</p><p>该命令中，-keystore ophone.keystore 表示生成的证书，可以加上路径（默认在用户主目录下）；-alias ophone 表示证书的别名是ophone；-keyalg RSA 表示采用的RSA算法；-validity 20000表示证书的有效期是20000天。</p><p>image</p><p>此时，我们会在互用主目录下看到ophone.keystore，即我们刚刚创建的证书。</p><p>接着对程序进行签名：</p><p>jarsigner用法： [选项] jar 文件别名<br>jarsigner -verify [选项] jar 文件</p><p>执行：jarsigner -verbose -keystore android.keystore -signedjar android123_signed.apk android123.apk android 就可以生成签名的apk文件，这里输入文件android123.apk，最终生成android123_signed.apk为Android签名后的APK执行文件。下面提示输入的密码和keytool输入的一样就行了。（不过在我的JDK目录下没有找到jarsigner这个程序，不知道是怎么回事）</p><p>image</p><p>使用ADT Export Wizard进行签名</p><p>应用程序（apk）签名,在EC中，右键单击应用程序工程，如图选择</p><p>image</p><p>选择证书的存放路径，填写相关资料，完成，即可生成被签名的apk文件。如下图所示：</p><p>image</p><p>如上图所示，我们可以看到也可以在这里选择”Create new keystore“来创建一个证书。输入密码，点击下一步，填写相关信息，如下图所示。</p><p>image</p><p>使用zipalign优化APK</p><p>根据官方文档的描述，Android系统中Application的数据都保存在它的APK文件中，同时可以被多个进程访问，安装的过程包括如下几个步骤：</p><p>Installer通过每个apk的manifest文件获取与当前应用程序相关联的permissions信息<br>Home application读取当前APK的Name和Icon等信息。<br>System server将读取一些与Application运行相关信息，例如：获取和处理Application的notifications请求等。<br>最后，APK所包含的内容不仅限于当前Application所使用，而且可以被其它的Application调用，提高系统资源的可复用性。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android的task任务栈</title>
      <link href="/2015/07/22/android%E7%9A%84task%E4%BB%BB%E5%8A%A1%E6%A0%88/"/>
      <url>/2015/07/22/android%E7%9A%84task%E4%BB%BB%E5%8A%A1%E6%A0%88/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/CSU-PL/p/3794280.html" target="_blank" rel="noopener">http://www.cnblogs.com/CSU-PL/p/3794280.html</a></p><p>上次我们讲到Activity的四种启动模式的时候，已经了解到一些关于task的技术，今天我再向大家介绍一下。task是一个具有栈结构的容器，可以放置多个Activity实例。启动一个应用，系统就会为之创建一个task，来放置根Activity；默认情况下，一个Activity启动另一个Activity时，两个Activity是放置在同一个task中的，后者被压入前者所在的task栈，当用户按下后退键，后者从task被弹出，前者又显示在幕前，特别是启动其他应用中的Activity时，两个Activity对用户来说就好像是属于同一个应用；系统task和task之间是互相独立的，当我们运行一个应用时，按下Home键回到主屏，启动另一个应用，这个过程中，之前的task被转移到后台，新的task被转移到前台，其根Activity也会显示到幕前，过了一会之后，在此按下Home键回到主屏，再选择之前的应用，之前的task会被转移到前台，系统仍然保留着task内的所有Activity实例，而那个新的task会被转移到后台，如果这时用户再做后退等动作，就是针对该task内部进行操作了。</p><p>我们今天就讲一下和task相关的知识，主要分一下几点：</p><p>1.Activity的affinity(亲和力)</p><p>2.Intent几种常见的flags</p><p>3.与task相关属性</p><p>affinity：</p><p>task对于Activity来说就好像它的身份证一样，可以告诉所在的task，自己属于这个task中的一员；拥有相同affinity的多个Activity理论同属于一个task，task自身的affinity决定于根Activity的affinity值。affinity在什么场合应用呢？1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合工作）；2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task。我们会在后面进行详细讲解。</p><p>默认情况下，一个应用内的所有Activity都具有相同的affinity，都是从Application（参考的taskAffinity属性）继承而来，而Application默认的affinity是中的包名，我们可以为设置taskAffinity属性值，这样可以应用到下的所有，也可以单独为某个Activity设置taskAffinity。例如：在系统自带的Browser中，package为com.android.browser，但是却自定义一个taskAffinity属性值：</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android 开发如何做内存优化</title>
      <link href="/2015/07/22/android-%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2015/07/22/android-%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/kingOfPointer/archive/2012/12/21/2828018.html" target="_blank" rel="noopener">http://www.cnblogs.com/kingOfPointer/archive/2012/12/21/2828018.html</a></p><p>不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。<br>　　Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。<br>一、引用没释放造成的内存泄露<br>1.1注册没取消造成的内存泄露<br>　　这种Android的内存泄露比纯java的内存泄露还要严重，因为其他一些Android程序可能引用我们的Anroid程序的对象（比如注册机制）。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄露的内存依然不能被垃圾回收。<br>比如示例1:<br>　　假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>　　但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。<br>　　虽然有些系统程序，它本身好像是可以自动取消注册的（当然不及时），但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。<br>1.2集合中对象没清理造成的内存泄露<br>　　我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。<br>二、资源对象没关闭造成的内存泄露<br>　　资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。因为有些资源性对象，比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭），如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>　　程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>三、一些不良代码成内存压力<br>　　有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存，对内存的回收和分配造成很大影响的，容易迫使虚拟机不得不给该应用进程分配更多的内存，造成不必要的内存开支。<br>3.1，Bitmap没调用recycle()<br>　　Bitmap对象在不使用时,我们应该先调用recycle()释放内存，然后才它设置为null.虽然recycle()从源码上看，调用它应该能立即释放Bitmap的主要内存，但是测试结果显示它并没能立即释放内存。但是我它应该还是能大大的加速Bitmap的主要内存的释放。<br>3.2，构造Adapter时，没有使用缓存的 convertView<br>　　以构造ListView的BaseAdapter为例，在BaseAdapter中提共了方法：<br>public View getView(int position, View convertView, ViewGroup parent)来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>　　由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费时间，也造成内存垃圾，给垃圾回收增加压力，如果垃圾回收来不及的话，虚拟机将不得不给该应用进程分配更多的内存，造成不必要的内存开支。ListView回收list item的view对象的过程可以查看:<br>view plaincopy to clipboardprint?<br>android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。</p><p>示例代码：</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = new Xxx(…);<br>4<br>5 … …<br>6<br>7 return view;<br>8<br>9 }<br>复制代码<br>修正示例代码：</p><p>Android内存管理</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = null;<br>4<br>5 if (convertView != null) {<br>6<br>7 view = convertView;<br>8<br>9 populate(view, getItem(position));<br>10<br>11 …<br>12<br>13 } else {<br>14<br>15 view = new Xxx(…);<br>16<br>17 …<br>18<br>19 }<br>20<br>21 return view;<br>22<br>23 }<br>复制代码<br>概述：<br>　　在android的开发中，要时刻主要内存的分配和垃圾回收，因为系统为每一个dalvik虚拟机分配的内存是有限的，在google的G1中，分配的最大堆大小只有16M，后来的机器一般都为24M，实在是少的可怜。这样就需要我们在开发过程中要时刻注意。不要因为自己的代码问题而造成OOM错误。<br>JAVA的内存管理：<br>　　大家都知道，android应用层是由java开发的，android的davlik虚拟机与jvm也类似，只不过它是基于寄存器的。因此要了解android的内存管理就必须得了解java的内存分配和垃圾回收机制。<br>　　在java中，是通过new关键字来为对象分配内存的，而内存的释放是由垃圾收集器（GC）来回收的，工程师在开发的过程中，不需要显式的去管理内存。但是这样有可能在不知不觉中就会浪费了很多内存，最终导致java虚拟机花费很多时间去进行垃圾回收，更严重的是造成JVM的OOM。因此，java工程师还是有必要了解JAVA的内存分配和垃圾回收机制。</p><p>内存结构<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6926.png<br>上面这张图是JVM的结构图，它主要四个部分组成：Class Loader子系统和执行引擎，运行时方法区和本地方法区，我们主要来看下RUNTIME DATA AREA区，也就是我们常说的JVM内存。从图中可以看出，RUNTIMEDATA AREA区主要由5个部分组成：<br>· Method Area:被装载的class的元信息存储在Method Area中，它是线程共享的<br>· Heap(堆)：一个java虚拟机实例中只存在一个堆空间，存放一些对象信息，它是线程共享的<br>· Java栈： java虚拟机直接对java栈进行两种操作，以帧为单位的压栈和出栈（非线程共享）<br>· 程序计数器（非线程共享）<br>· 本地方法栈（非线程共享）</p><p>JVM的垃圾回收（GC）<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-12485.png<br>JVM的垃圾原理是这样的，它把对象分为年轻代（Young）、年老代（Tenured）、持久代（Perm），对不同生命周期的对象使用不同的垃圾回收算法。<br>· 年轻代(Young)<br>年轻代分为三个区，一个eden区，两个Survivor区。程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满了时，此区存活的对象又被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。<br>· 年老代（Tenured）<br>年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的对象生命周期都比较长。<br>· 持久代（Perm）<br>用于存放静态的类和方法，持久代对垃圾回收没有显著的影响。<br>Android中内存泄露监测<br>在了解了JVM的内存管理后，我们再回过头来看看，在android中应该怎样来监测内存，从而看在应用中是否存在内存分配和垃圾回收问题而造成内存泄露情况。<br>在android中，有一个相对来说还不错的工具，可以用来监测内存是否存在泄露情况：DDMS—Heap<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-22715.png<br>使用方法比较简单：<br>· 选择DDMS视图，并打开Devices视图和Heap视图<br>· 点击选择要监控的进程，比如：上图中我选择的是system_process<br>· 选中Devices视图界面上的”update heap” 图标<br>· 点击Heap视图中的”Cause GC” 按钮（相当于向虚拟机发送了一次GC请求的操作）<br>在Heap视图中选择想要监控的Type，一般我们会观察dataobject的 total size的变化，正常情况下total size的值会稳定在一个有限的范围内，也就说程序中的代码良好，没有造成程序中的对象不被回收的情况。如果代码中存在没有释放对象引用的情况，那么data object的total size在每次GC之后都不会有明显的回落，随着操作次数的增加而total size也在不断的增加。（说明：选择好data object后，不断的操作应用，这样才可以看出total size的变化）。如果totalsize确实是在不断增加而没有回落，说明程序中有没有被释放的资源引用。那么我们应该怎么来定位呢？<br>Android中内存泄露定位<br>Mat(memory analyzer tools)是我们常用的用来定位内存泄露的工具，如果你使用ADT，并且安装了MAT的eclipse插件，你需要做的是进入DDMS视图的Devices视图：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-2165.png<br>点击”dump HPROF file”按钮，然后使用MAT分析下载下来的文件。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6565.png</p><p>下面列出了存在的问题，点击detail进去，会列出详细的，可能会存在问题的代码：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-32625.png<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-21158.png<br>关于MAT的使用可以参考：<a href="http://www.blogjava.net/rosen/" target="_blank" rel="noopener">http://www.blogjava.net/rosen/</a> … .html<br>这位兄弟写的比较详细。</p><p>总结</p><p>不管是java还是android，都应该了解内存分配和垃圾回收机制，工程师要做到写的代码中没有bad code很难，关键是在出现问题的时候该怎么去排查Android内存优化<br>一、 Android的内存机制<br>　　Android的程序由Java语言编写，所以Android的内存管理与Java的内存管理相似。程序员通过new为对象分配内存，所有对象在java堆内分配空间；然而对象的释放是由垃圾回收器来完成的。C／C++中的内存机制是“谁污染，谁治理”，java的就比较人性化了，给我们请了一个专门的清洁工（GC）。<br>　　那么GC怎么能够确认某一个对象是不是已经被废弃了呢？Java采用了有向图的原理。Java将引用关系考虑为图的有向边，有向边从引用者指向引用对象。线程对象可以作为有向图的起始顶点，该图就是从起始顶点开始的一棵树，根顶点可以到达的对象都是有效对象，GC不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被GC回收。<br>二、Android的内存溢出<br>Android的内存溢出是如何发生的?<br>　　Android的虚拟机是基于寄存器的Dalvik，它的最大堆大小一般是16M，有的机器为24M。因此我们所能利用的内存空间是有限的。如果我们的内存占用超过了一定的水平就会出现OutOfMemory的错误。<br>为什么会出现内存不够用的情况呢？我想原因主要有两个：</p><p>由于我们程序的失误，长期保持某些资源（如Context）的引用，造成内存泄露，资源造成得不到释放。</p><p>保存了多个耗用内存过大的对象（如Bitmap），造成内存超出限制。</p><p>三、万恶的static<br>　　static是Java中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用static修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context的情况最多），这时就要谨慎对待了。</p><p>复制代码<br>1 public class ClassName {<br>2<br>3 private static Context mContext;<br>4<br>5 //省略<br>6<br>7 }<br>复制代码<br>　　以上的代码是很危险的，如果将Activity赋值到么mContext的话。那么即使该Activity已经onDestroy，但是由于仍有对象保存它的引用，因此该Activity依然不会被释放。<br>我们举Android文档中的一个例子。</p><p>复制代码<br>private static Drawable sBackground;</p><p>@Override</p><p>protected void onCreate(Bundle state) {</p><p>super.onCreate(state);</p><p>TextView label = new TextView(this);</p><p>label.setText(“Leaks are bad”);</p><p>if (sBackground == null) {</p><pre><code>sBackground = getDrawable(R.drawable.large_bitmap);  </code></pre><p>}</p><p>label.setBackgroundDrawable(sBackground);</p><p>setContentView(label);</p><p>}<br>复制代码<br>　　sBackground是一个静态的变量，但是我们发现，我们并没有显式的保存Contex的引用，但是，当Drawable与View连接之后，Drawable就将View设置为一个回调，由于View中是包含Context的引用的，所以，实际上我们依然保存了Context的引用。这个引用链如下：<br>Drawable-&gt;TextView-&gt;Context<br>　　所以，最终该Context也没有得到释放，发生了内存泄露。<br>如何才能有效的避免这种引用的发生呢？</p><p>应该尽量避免static成员变量引用资源耗费过多的实例，比如Context。</p><p>Context尽量使用Application Context，因为Application的Context的生命周期比较长，引用它不会出现内存泄露的问题。</p><p>使用WeakReference代替强引用。比如可以使用WeakReference mContextRef;</p><p>该部分的详细内容也可以参考Android文档中Article部分。<br>四、都是线程惹的祸<br>　　线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。</p><p>复制代码<br>1 public class MyActivity extends Activity {<br>2<br>3 @Override<br>4<br>5 public void onCreate(Bundle savedInstanceState) {<br>6<br>7 super.onCreate(savedInstanceState);<br>8<br>9 setContentView(R.layout.main);<br>10<br>11 new MyThread().start();<br>12<br>13 }<br>14<br>15<br>16 private class MyThread extends Thread{<br>17<br>18 @Override<br>19<br>20 public void run() {<br>21<br>22 super.run();<br>23<br>24 //do somthing<br>25<br>26 }<br>27<br>28 }<br>29<br>30 }<br>复制代码<br>　　这段代码很平常也很简单，是我们经常使用的形式。我们思考一个问题：假设MyThread的run函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏，一般情况下当屏幕转换时会重新创建Activity，按照我们的想法，老的Activity应该会被销毁才对，然而事实上并非如此。<br>　　由于我们的线程是Activity的内部类，所以MyThread中保存了Activity的一个引用，当MyThread的run函数没有结束时，MyThread是不会被销毁的，因此它所引用的老的Activity也不会被销毁，因此就出现了内存泄露的问题。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6439.png<br>　　有些人喜欢用Android提供的AsyncTask，但事实上AsyncTask的问题更加严重，Thread只有在run函数不结束时才出现这种内存泄露问题，然而AsyncTask内部的实现机制是运用了ThreadPoolExcutor,该类产生的Thread对象的生命周期是不确定的，是应用程序无法控制的，因此如果AsyncTask作为Activity的内部类，就更容易出现内存泄露的问题。<br>这种线程导致的内存泄露问题应该如何解决呢？</p><p>将线程的内部类，改为静态内部类。</p><p>在线程内部采用弱引用保存Context引用。</p><p>解决的模型如下：</p><p>复制代码<br>1 public abstract class WeakAsyncTask</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux脚本编写基础</title>
      <link href="/2015/06/29/Linux%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/06/29/Linux%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<ol><li>Linux 脚本编写基础<br>1.1 语法基本介绍<br>1.1.1 开头<br>程序必须以下面的行开始（必须方在文件的第一行）：</li></ol><h1 id="bin-sh"><a href="#bin-sh" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>　　符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>　　当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br>　　要使脚本可执行：<br>编译 chmod +x filename 这样才能用./filename 来运行<br>1.1.2 注释<br>　　以#开头的句子表示注释，直到这一行的结束。<br>1.1.3 变量<br>　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量<br>进行声明。要赋值给一个变量，您可以这样写：</p><h1 id="bin-sh-1"><a href="#bin-sh-1" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="对变量赋值："><a href="#对变量赋值：" class="headerlink" title="对变量赋值："></a>对变量赋值：</h1><p>a=”hello world”</p><h1 id="现在打印变量a的内容："><a href="#现在打印变量a的内容：" class="headerlink" title="现在打印变量a的内容："></a>现在打印变量a的内容：</h1><p>echo “A is:”<br>echo a有时候变量名很容易与其他文字混淆，比如：num=2echo“thisisthea 有时候变量名很容易与其他文字混淆，比如： num=2 echo “this is the numnd”<br>这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，<br>但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：<br>num=2<br>echo “this is the {num}nd”<br>　　这将打印： this is the 2nd<br>1.1.4 环境变量<br>由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录<br>脚本中使用环境变量。<br>1.1.5 Shell命令和流程控制<br>在shell脚本中可以使用三类命令：<br>1)Unix 命令:<br>　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来<br>进行文件和文字操作的。<br>常用命令语法及功能<br>　　echo “some text”: 将文字内容打印在屏幕上<br>　　ls: 文件列表<br>　　wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数<br>　　cp sourcefile destfile: 文件拷贝<br>　　mv oldname newname : 重命名文件或移动文件<br>　　rm file: 删除文件<br>　　grep ‘pattern’ file: 在文件内搜索字符串比如：grep ‘searchstring’ file.txt<br>　　cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出<br>每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，<br>这是两个完全不同的命令<br>　　cat file.txt: 输出文件内容到标准输出设备（屏幕）上<br>　　file somefile: 得到文件类型<br>　　read var: 提示用户输入，并将输入赋值给变量<br>　　sort file.txt: 对file.txt文件中的行进行排序<br>　　uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq<br>　　expr: 进行数学运算Example: add 2 and 3expr 2 “+” 3<br>　　find: 搜索文件比如：根据文件名搜索find . -name filename -print<br>　　tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile<br>　　basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux<br>　　dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin<br>　　head file: 打印文本文件开头几行<br>　　tail file : 打印文本文件末尾几行<br>　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将<br>结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。<br>不要和shell中的通配符相混淆。比如：将linuxfocus 替换为<br>LinuxFocus ：cat text.file | sed ‘s/linuxfocus/LinuxFocus/’ &gt; newtext.file<br>　　awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。<br>cat file.txt | awk -F, ‘{print{num}nd” 　　这将打印： this is the 2nd 1.1.4 环境变量 由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录 脚本中使用环境变量。 1.1.5 Shell命令和流程控制 在shell脚本中可以使用三类命令： 1)Unix 命令: 　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来 进行文件和文字操作的。 常用命令语法及功能 　　echo “some text”: 将文字内容打印在屏幕上 　　ls: 文件列表 　　wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数 　　cp sourcefile destfile: 文件拷贝 　　mv oldname newname : 重命名文件或移动文件 　　rm file: 删除文件 　　grep ‘pattern’ file: 在文件内搜索字符串比如：grep ‘searchstring’ file.txt 　　cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出 每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆， 这是两个完全不同的命令 　　cat file.txt: 输出文件内容到标准输出设备（屏幕）上 　　file somefile: 得到文件类型 　　read var: 提示用户输入，并将输入赋值给变量 　　sort file.txt: 对file.txt文件中的行进行排序 　　uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq 　　expr: 进行数学运算Example: add 2 and 3expr 2 “+” 3 　　find: 搜索文件比如：根据文件名搜索find . -name filename -print 　　tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile 　　basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux 　　dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin 　　head file: 打印文本文件开头几行 　　tail file : 打印文本文件末尾几行 　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将 结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。 不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed ‘s/linuxfocus/LinuxFocus/’ &gt; newtext.file 　　awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。 cat file.txt | awk -F, ‘{print 1 “,” $3 }’这里我们使用，作为字段分割符，同时打印<br>第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA<br>命令输出结果为：Adam Bor, IndiaKerry Miller, USA<br>2) 概念: 管道, 重定向和 backtick<br>　　这些不是系统命令，但是他们真的很重要。<br>　　管道 (|) 将一个命令的输出作为另外一个命令的输入。<br>grep “hello” file.txt | wc -l<br>　　在file.txt中搜索包含有”hello”的行并计算其行数。<br>　　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br>　　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br>　　> 写入文件并覆盖旧文件<br>　　&gt;> 加到文件的尾部，保留旧文件内容。<br>反短斜线<br>　 使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br>命令：<br>find . -mtime -1 -type f -print<br>　　用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您<br>想将所有查找到的文件打一个包，则可以使用以下脚本：</p><h1 id="bin-sh-2"><a href="#bin-sh-2" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="The-ticks-are-backticks-not-normal-quotes-‘"><a href="#The-ticks-are-backticks-not-normal-quotes-‘" class="headerlink" title="The ticks are backticks (`) not normal quotes (‘):"></a>The ticks are backticks (`) not normal quotes (‘):</h1><p>tar -zcvf lastmod.tar.gz <code>find . -mtime -1 -type f -print</code><br>3) 流程控制<br>1.if<br>　　“if” 表达式 如果条件为真则执行then后面的部分：<br>if ….; then<br>　 ….<br>elif ….; then<br>　 ….<br>else<br>　 ….<br>fi<br>大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件<br>是否存在及是否可读等等…<br>　　通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br>[ -f “somefile” ] ：判断是否是一个文件<br>[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限<br>[ -n “var”]：判断var” ] ：判断var变量是否有值<br>[ “a”=”a” = “b” ] ：判断a和a和b是否相等<br>　　执行man test可以查看所有测试表达式可以比较和判断的类型。<br>　　直接执行以下脚本：</p><h1 id="bin-sh-3"><a href="#bin-sh-3" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>if [ “SHELL”=“/bin/bash”];thenecho“yourloginshellisthebash(bourneagainshell)”elseecho“yourloginshellisnotbashbutSHELL” = “/bin/bash” ]; then 　echo “your login shell is the bash (bourne again shell)” else 　echo “your login shell is not bash but SHELL”<br>fi<br>　　变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。<br>快捷操作符<br>熟悉C语言的朋友可能会很喜欢下面的表达式：<br>[ -f “/etc/shadow” ] &amp;&amp; echo “This computer uses shadow passwors”<br>　　这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。<br>您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在<br>则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是<br>可用的。这里有个例子：</p><h1 id="bin-sh-4"><a href="#bin-sh-4" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>mailfolder=/var/spool/mail/james<br>[ -r “mailfolder”]′′echo”Cannotread$mailfolder”;exit1;echo“mailfolder” ]‘ ‘{ echo “Can not read $mailfolder” ; exit 1; } echo “mailfolder has mail from:”<br>grep “^From ” $mailfolder<br>该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读<br>则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：<br>　　-打印错误信息<br>　　-退出程序<br>　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。<br>　　不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。</p><p>2.case<br>case :表达式可以用来匹配一个给定的字符串，而不是数字。<br>case … in<br>…) do something here ;;<br>esac<br>　　让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：<br>file lf.gz<br>　　这将返回：<br>lf.gz: gzip compressed data, deflated, original filename,<br>last modified: Mon Aug 27 23:09:18 2001, os: Unix<br>　我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p><h1 id="bin-sh-5"><a href="#bin-sh-5" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>ftype=<code>file &quot;$1&quot;</code><br>case “ftype”in“ftype” in “1: Zip archive”<em>)<br>　　unzip “1”;;“1” ;; “1: gzip compressed”</em>)<br>　　gunzip “1”;;“1” ;; “1: bzip2 compressed”<em>)<br>　　bunzip2 “1”;;∗)echo“File1” ;; </em>) echo “File 1 can not be uncompressed with smartzip”;;<br>esac<br>　　您可能注意到我们在这里使用了一个特殊的变量1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：smartziparticles.zip1。该变量包含了传递给该程序的第一个参数值。 也就是说，当我们运行： smartzip articles.zip 1 就是字符串 articles.zip<br>3. selsect<br>select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。<br>select var in … ; do<br>　break<br>done<br>…. now $var can be used ….<br>下面是一个例子：</p><h1 id="bin-sh-6"><a href="#bin-sh-6" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>echo “What is your favourite OS?”<br>select var in “Linux” “Gnu Hurd” “Free BSD” “Other”; do<br>　　　　break<br>done<br>echo “You have selected $var”<br>　　下面是该脚本运行的结果：<br>What is your favourite OS?<br>1) Linux<br>2) Gnu Hurd<br>3) Free BSD<br>4) Other</p><h1 id="1"><a href="#1" class="headerlink" title="? 1"></a>? 1</h1><p>You have selected Linux<br>4.loop<br>loop表达式：<br>while …; do<br>….<br>done<br>　　while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true.<br>关键字”break” 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br>　　<br>for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br>for var in ….; do<br>　 ….<br>done<br>在下面的例子中，将分别打印ABC到屏幕上：</p><h1 id="bin-sh-7"><a href="#bin-sh-7" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>for var in A B C ; do<br>　 echo “var is $var”<br>done<br>下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：</p><h1 id="bin-sh-8"><a href="#bin-sh-8" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="list-a-content-summary-of-a-number-of-RPM-packages"><a href="#list-a-content-summary-of-a-number-of-RPM-packages" class="headerlink" title="list a content summary of a number of RPM packages"></a>list a content summary of a number of RPM packages</h1><h1 id="USAGE-showrpm-rpmfile1-rpmfile2-…"><a href="#USAGE-showrpm-rpmfile1-rpmfile2-…" class="headerlink" title="USAGE: showrpm rpmfile1 rpmfile2 …"></a>USAGE: showrpm rpmfile1 rpmfile2 …</h1><h1 id="EXAMPLE-showrpm-cdrom-RedHat-RPMS-rpm"><a href="#EXAMPLE-showrpm-cdrom-RedHat-RPMS-rpm" class="headerlink" title="EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm"></a>EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</h1><p>for rpmpackage in ∗;doif[−r“<em>; do 　if [ -r “rpmpackage” ];then<br>　　echo “=============== rpmpackage==============”rpm−qi−prpmpackage ==============” 　　rpm -qi -p rpmpackage<br>　else<br>　　echo “ERROR: cannot read file rpmpackage”fidone这里出现了第二个特殊的变量rpmpackage” 　fi done 　　这里出现了第二个特殊的变量</em>，该变量包含了所有输入的命令行参数值。<br>如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br>此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.</p><ol><li>引号<br>在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符<br>（比如*）替换成合适的文件名，它变量替换成变量值。为了防 止程序作这种替换，您可以使用<br>引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。<br>1.2 编译SHELL脚本</li></ol><h1 id="ch-bin-sh-mod-x-filename"><a href="#ch-bin-sh-mod-x-filename" class="headerlink" title="ch#!/bin/sh mod +x filename"></a>ch#!/bin/sh mod +x filename</h1><p>　cho *.jpg ∪缓螅梢酝ü淙耄?./filename 来执行您的脚本。<br>　　这将打印出”mail.jpg tux.jpg”的结果。<br>　 　　引号 (单引号和双引号) 将防止这种通配符扩展：</p><h1 id="bin-sh-9"><a href="#bin-sh-9" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>echo “<em>.jpg”<br>echo ‘</em>.jpg’<br>　　这将打印”*.jpg” 两次。<br>　　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。</p><h1 id="bin-sh-10"><a href="#bin-sh-10" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>echo SHELLecho“SHELL echo “SHELL”<br>echo ‘SHELL′运行结果为：/bin/bash/bin/bashSHELL’ 　　运行结果为： /bin/bash /bin/bash SHELL<br>　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：<br>echo <em>.jpg<br>echo SHELL这将输出：∗.jpgSHELL 　　这将输出： </em>.jpg SHELL<br>6. Here documents<br>当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译）<br>一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents<br>就不必用echo函数一行行输出。 一个 “Here document” 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串<br>还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且<br>使用here documents打印帮助：</p><h1 id="bin-sh-11"><a href="#bin-sh-11" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="we-have-less-than-3-arguments-Print-the-help-text"><a href="#we-have-less-than-3-arguments-Print-the-help-text" class="headerlink" title="we have less than 3 arguments. Print the help text:"></a>we have less than 3 arguments. Print the help text:</h1><p>if [ $# -lt 3 ] ; then<br>cat &lt;<br>ren – renames a number of files using sed regular expressions<br>USAGE: ren ‘regexp’ ‘replacement’ files…<br>EXAMPLE: rename all <em>.HTM files in</em> .html:<br>　ren ‘HTM′‘html′∗.HTMHELPexit0fiOLD=”’ ‘html’ *.HTM HELP 　exit 0 fi OLD=”1”<br>NEW=”$2”</p><h1 id="The-shift-command-removes-one-argument-from-the-list-of"><a href="#The-shift-command-removes-one-argument-from-the-list-of" class="headerlink" title="The shift command removes one argument from the list of"></a>The shift command removes one argument from the list of</h1><h1 id="command-line-arguments"><a href="#command-line-arguments" class="headerlink" title="command line arguments."></a>command line arguments.</h1><p>shift<br>shift</p><h1 id="contains-now-all-the-files"><a href="#contains-now-all-the-files" class="headerlink" title="$* contains now all the files:"></a>$* contains now all the files:</h1><p>for file in ∗;doif[−f“<em>; do 　　if [ -f “file” ] ; then<br>　　　newfile=<code>echo &quot;$file&quot; | sed &quot;s/${OLD}/${NEW}/g&quot;</code><br>　　　if [ -f “newfile”];thenecho“ERROR:newfile” ]; then 　　　　echo “ERROR: newfile exists already”<br>　　　else<br>　　　　echo “renaming filetofile to newfile …”<br>　　　　mv “file””file” “newfile”<br>　　　fi<br>　　fi<br>done<br>　这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是<br>否小于3个 (特殊变量# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递<br>给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等<br>于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我<br>们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参<br>数列表# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递 给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等 于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我 们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参 数列表</em>的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。<br>接着我 们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后<br>将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目 的：得到了旧文件名和新<br>文件名。然后使用mv命令进行重命名。</p><p>4)函数<br>如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，<br>并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：<br>functionname()<br>{</p><h1 id="inside-the-body-1-is-the-first-argument-given-to-the-function"><a href="#inside-the-body-1-is-the-first-argument-given-to-the-function" class="headerlink" title="inside the body $1 is the first argument given to the function"></a>inside the body $1 is the first argument given to the function</h1><h1 id="2-the-second-…"><a href="#2-the-second-…" class="headerlink" title="$2 the second …"></a>$2 the second …</h1><p>body<br>}<br>您需要在每个程序的开始对函数进行声明。<br>　　下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。<br>这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。</p><h1 id="bin-sh-12"><a href="#bin-sh-12" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et"><a href="#vim-set-sw-4-ts-4-et" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　　cat &lt;<br>xtitlebar – change the name of an xterm, gnome-terminal or kde konsole<br>USAGE: xtitlebar [-h] “string_for_titelbar”<br>OPTIONS: -h help text<br>EXAMPLE: xtitlebar “cvs”<br>HELP<br>　　exit 0<br>}</p><h1 id="in-case-of-error-or-if-h-is-given-we-call-the-function-help"><a href="#in-case-of-error-or-if-h-is-given-we-call-the-function-help" class="headerlink" title="in case of error or if -h is given we call the function help:"></a>in case of error or if -h is given we call the function help:</h1><p>[ -z “1” ] &amp;&amp; help<br>[ “1” ] &amp;&amp; help [ “1” = “-h” ] &amp;&amp; help</p><h1 id="send-the-escape-sequence-to-change-the-xterm-titelbar"><a href="#send-the-escape-sequence-to-change-the-xterm-titelbar" class="headerlink" title="send the escape sequence to change the xterm titelbar:"></a>send the escape sequence to change the xterm titelbar:</h1><p>echo -e “33]0;107”     </p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br>命令行参数<br>　　我们已经见过107” # 在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。 命令行参数 　　我们已经见过* 和 1,1, 2 … $9 等特殊变量，这些特殊变量包含了用户从命令<br>行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的<br>参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的<br>自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (<br>比如文件名)。<br>有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p><h1 id="bin-sh-13"><a href="#bin-sh-13" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>help()<br>{<br>　cat &lt;<br>This is a generic command line parser demo.<br>USAGE EXAMPLE: cmdparser -l hello -f – -somefile1 somefile2<br>HELP<br>　exit 0<br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　-f) opt_f=1;shift 1;; # variable opt_f is set<br>　　-l) opt_l=2;shift 2;; # -l takes an argument -&gt; shift by 2<br>　　–) shift;break;; # end of options<br>　　-<em>) echo “error: no such option2;shift 2;; # -l takes an argument -&gt; shift by 2 　　–) shift;break;; # end of options 　　-</em>) echo “error: no such option 1. -h for help”;exit 1;;<br>　　*) break;;<br>esac<br>done<br>echo “opt_f is optf”echo“optlisopt_f” echo “opt_l is opt_l”<br>echo “first arg is 1”echo“2ndargis1” echo “2nd arg is 2”<br>　　您可以这样运行该脚本：<br>cmdparser -l hello -f – -somefile1 somefile2<br>　　返回的结果是：<br>opt_f is 1<br>opt_l is hello<br>first arg is -somefile1<br>2nd arg is somefile2<br>　　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数<br>与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，<br>首先输入的应该是包含减号的参数.<br>第2部分 实例<br>现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br>cp framework.sh myscript<br>　然后再插入自己的函数。<br>　　让我们再看两个例子：<br>　　二进制到十进制的转换<br>　　脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p><h1 id="bin-sh-14"><a href="#bin-sh-14" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-1"><a href="#vim-set-sw-4-ts-4-et-1" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　cat &lt;<br>b2h – convert binary to decimal<br>USAGE: b2h [-h] binarynum<br>OPTIONS: -h help text<br>EXAMPLE: b2h 111010<br>will return 58<br>HELP<br>　exit 0<br>}<br>error()<br>{<br>　　# print an error and exit<br>　　echo “1”<br>　　exit 1<br>}<br>lastchar()<br>{<br>　　# return the last character of a string in1” 　　exit 1 } lastchar() { 　　# return the last character of a string in rval<br>　　if [ -z “$1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　# now cut out the last char<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b $numofchar</code><br>}<br>chop()<br>{<br>　　# remove the last character in string and return it in rvalif[−z“rval 　　if [ -z “1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　if [ “$numofchar” = “1” ]; then<br>　　　　# only one char in string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　numofcharminus1=<code>expr $numofchar &quot;-&quot; 1</code><br>　　# now cut all but the last char:<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b 0-${numofcharminus1}</code><br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　–) shift;break;; # end of options<br>　　-<em>) error “error: no such option $1. -h for help”;;  　　</em>) break;;<br>esac<br>done</p><h1 id="The-main-program"><a href="#The-main-program" class="headerlink" title="The main program"></a>The main program</h1><p>sum=0<br>weight=1</p><h1 id="one-arg-must-be-given"><a href="#one-arg-must-be-given" class="headerlink" title="one arg must be given:"></a>one arg must be given:</h1><p>[ -z “1” ] &amp;&amp; help<br>binnum=”1” ] &amp;&amp; help binnum=”1”<br>binnumorig=”1”while[−n“1” while [ -n “binnum” ]; do<br>　　lastchar “binnum”if[“binnum” 　　if [ “rval” = “1” ]; then<br>　　　　sum=<code>expr &quot;$weight&quot; &quot;+&quot; &quot;$sum&quot;</code><br>　　fi<br>　　# remove the last position in binnumchop“binnum 　　chop “binnum”<br>　　binnum=”$rval”<br>　　weight=<code>expr &quot;$weight&quot; &quot;*&quot; 2</code><br>done<br>echo “binary binnumorigisdecimalbinnumorig is decimal sum”<br>　该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制”10”可<br>以这样转换成十进制：<br>0 <em> 1 + 1 </em> 2 = 2<br>　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，<br>然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br>文件循环程序<br>　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月<br>以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的 脚本rotatefile<br>可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，<br>而对于outmail.1就变成了outmail.2 等等等等…</p><h1 id="bin-sh-15"><a href="#bin-sh-15" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-2"><a href="#vim-set-sw-4-ts-4-et-2" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>ver=”0.1”<br>help()<br>{<br>　　cat &lt;<br>rotatefile – rotate the file name<br>USAGE: rotatefile [-h] filename<br>OPTIONS: -h help text<br>EXAMPLE: rotatefile out<br>This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1<br>and create an empty out-file<br>The max number is 10<br>version ver<br>HELP<br>　　exit 0<br>}<br>error()<br>{<br>　　echo “$1”<br>　　exit 1<br>}<br>while [ -n “ver HELP 　　exit 0 } error() { 　　echo “$1” 　　exit 1 } while [ -n “1” ]; do<br>case 1in−h)help;shift1;;–)break;;−∗)echo“error:nosuchoption1 in 　　-h) help;shift 1;; 　　–) break;; 　　-<em>) echo “error: no such option 1. -h for help”;exit 1;;  　　</em>) break;;<br>esac<br>done</p><h1 id="input-check"><a href="#input-check" class="headerlink" title="input check:"></a>input check:</h1><p>if [ -z “1”];thenerror“ERROR:youmustspecifyafile,use−hforhelp”fifilen=”1” ] ; then error “ERROR: you must specify a file, use -h for help” fi filen=”1”</p><h1 id="rename-any-1-2-etc-file"><a href="#rename-any-1-2-etc-file" class="headerlink" title="rename any .1 , .2 etc file:"></a>rename any .1 , .2 etc file:</h1><p>for n in 9 8 7 6 5 4 3 2 1; do<br>　　if [ -f “filen.filen.n” ]; then<br>　　　　p=<code>expr $n + 1</code><br>　　　　echo “mv filen.filen.n filen.filen.p”<br>　　　　mv filen.filen.n filen.filen.p<br>　　fi<br>done</p><h1 id="rename-the-original-file"><a href="#rename-the-original-file" class="headerlink" title="rename the original file:"></a>rename the original file:</h1><p>if [ -f “filen”];thenecho“mvfilen” ]; then 　　echo “mv filen filen.1”mvfilen.1” 　　mv filen filen.1fiechotouchfilen.1 fi echo touch filen<br>touch $filen<br>　　这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。<br>调试<br>　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br>　　shell也有一个真实的调试模式。如果在脚本”strangescript” 中有错误，您可以这样来进行调试：<br>sh -x strangescript<br>　　这将执行该脚本并显示所有变量的值。<br>　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br>sh -n your_script<br>　　这将返回所有语法错误</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Android.mk</title>
      <link href="/2015/06/29/Android-mk/"/>
      <url>/2015/06/29/Android-mk/</url>
      <content type="html"><![CDATA[<p>一个Android.mk file用来向编译系统描述你的源代码。具体来说：该文件是GNU Makefile的一小部分，会被编译系统解析一次或多次。你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。每个模块属下列类型之一：<br>1）APK程序，一般的Android程序，编译打包生成apk文件<br>2）JAVA库，java类库，编译打包生成jar文件<br>3) C\C++应用程序，可执行的C\C++应用程序<br>4）C\C++静态库，编译生成C\C++静态库，并打包成.a文件<br>5）C\C++共享库， 编译生成共享库（动态链接库），并打包成.so， 有且只有共享库才能被安装/复制到您的应用软件（APK）包中。<br>（1）先看一个简单的例子：一个简单的”hello world”，比如下面的文件：<br>sources/helloworld/helloworld.c<br>sources/helloworld/Android.mk<br>相应的Android.mk文件会像下面这样：<br>———- cut here ——————<br>[cpp] view plaincopyprint?<br>1. LOCAL_PATH := (callmy−dir)2.include(call my-dir) 2. include (CLEAR_VARS)<br>3. LOCAL_MODULE<br>4. := helloworld<br>5. LOCAL_SRC_FILES := helloworld.c<br>6. include (BUILDSHAREDLIBRARY)———cuthere——————我们来解释一下这几行代码：1，LOCALPATH:=(BUILD_SHARED_LIBRARY) ——— cut here —————— 我们来解释一下这几行代码： 1，LOCAL_PATH := (call my-dir) ，一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数‘my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。<br>2，include (CLEARVARS)，CLEARVARS由编译系统提供（(可以在android安装目录下的/build/core/config.mk文件看到其定义，为CLEARVARS:=( CLEAR_VARS)，CLEAR_VARS由编译系统提供（(可以在 android 安装目录下的/build/core/config.mk 文件看到其定义，为 CLEAR_VARS:= (BUILD_SYSTEM)/clear_vars.mk)），指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…),除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。<br>3，LOCAL_MODULE := helloworld，LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。<br>4，LOCAL_SRC_FILES := helloworld.c，LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。<br>此处虽没用到其他常用的还有：<br>5，LOCAL_C_INCLUDES：可选变量，表示头文件的搜索路径。默认的头文件的搜索路径是LOCAL_PATH目录。示例：LOCAL_C_INCLUDES := sources/foo或LOCAL_C_INCLUDES := (LOCALPATH)/../foo6，TARGETARCH：目标CPU平台的名字；TARGETPLATFORM：Android.mk解析的时候，目标Android平台的名字；ARGETARCHABI：暂时只支持两个value，armeabi和armeabi−v7a7，LOCALSTATICLIBRARIES:表示该模块需要使用哪些静态库，以便在编译时进行链接。8，LOCALSHAREDLIBRARIES:表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。9，LOCALLDLIBS:编译模块时要使用的附加的链接器选项。10，LOCALARMMODE:默认情况下，arm目标二进制会以thumb的形式生成(16位)，你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式11，LOCALCFLAGS:可选的编译器选项，在编译C代码文件的时候使用12，include(LOCAL_PATH)/../foo 6，TARGET_ARCH：目标 CPU平台的名字；TARGET_PLATFORM：Android.mk 解析的时候，目标 Android 平台的名字；ARGET_ARCH_ABI：暂时只支持两个 value，armeabi 和 armeabi-v7a 7，LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接。 8，LOCAL_SHARED_LIBRARIES: 表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。 9，LOCAL_LDLIBS: 编译模块时要使用的附加的链接器选项。 10，LOCAL_ARM_MODE: 默认情况下， arm目标二进制会以 thumb 的形式生成(16 位)，你可以通过设置这个变量为 arm如果你希望你的 module 是以 32 位指令的形式 11，LOCAL_CFLAGS: 可选的编译器选项，在编译 C 代码文件的时候使用 12，include (call all-subdir-makefiles)：返回一个位于当前’my-dir’路径的子目录中的所有Android.mk的列表。<br>（2）在Android中增加本地程序或者库，这些程序和库与其所载路径没有任何关系，只和它们的Android.mk文件有关系。Android.mk和普通的Makefile有所不同，它具有统一的写法，主要包含一些系统公共的宏。在一个Android.mk中可以生成多个可执行程序、动态库和静态库。<br>A，编译C/C++应用程序的模板：  </p><p>#Test Exe<br>LOCAL_PATH := (call my-dir)    </p><pre><code>#include(call my-dir) #include (CLEAR_VARS)  </code></pre><p>LOCAL_SRC_FILES:= main.c<br>LOCAL_MODULE:= test_exe  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILDEXECUTABLE)（菜鸟级别解释：:=是赋值的意思，+=是追加的意思，(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，+=是追加的意思，是引用某变量的值）BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。补充说明：include (BUILDPACKAGE)则是编译出一个apk，include(BUILD_PACKAGE)则是编译出一个apk，include (BUILD_STATIC_JAVA_LIBRARY)则是编译出jar包。<br>B，编译静态库的模板：  </p><p>#Test Static Lib<br>LOCAL_PATH := (callmy−dir)include(call my-dir) include (CLEAR_VARS)<br>LOCAL_SRC_FILES:= /<br>helloworld.c<br>LOCAL_MODULE:= libtest_static  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILD_STATIC_LIBRARY)<br>一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。<br>C，编译动态库的模板：    </p><pre><code>#Test Shared Lib    LOCAL_PATH :=(BUILD\_STATIC\_LIBRARY) 一般的和上面相似，BUILD\_STATIC\_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。 C，编译动态库的模板： #Test Shared Lib LOCAL_PATH := (call my-dir)  </code></pre><p>include (CLEAR_VARS)<br>     LOCAL_SRC_FILES:= /<br>               helloworld.c<br>     LOCAL_MODULE:= libtest_shared<br>     TARGET_PRELINK_MODULES := false    </p><pre><code>#LOCAL\_C\_INCLUDES :=    #LOCAL\_STATIC\_LIBRARIES :=    #LOCAL\_SHARED\_LIBRARIES :=     include(CLEAR\_VARS) LOCAL\_SRC\_FILES:= / helloworld.c LOCAL\_MODULE:= libtest\_shared TARGET\_PRELINK\_MODULES := false #LOCAL\_C\_INCLUDES := #LOCAL\_STATIC\_LIBRARIES := #LOCAL\_SHARED_LIBRARIES := include (BUILD\_SHARED\_LIBRARY)  </code></pre><p>一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个动态库。<br>以上三者的生成结果分别在如下，generic依具体target会变：<br>out/target/product/generic/obj/EXECUTABLE<br>out/target/product/generic/obj/STATIC_LIBRARY<br>out/target/product/generic/obj/SHARED_LIBRARY<br>每个模块的目标文件夹分别为：<br>可执行程序：XXX_intermediates<br>静态库： XXX_static_intermediates<br>动态库： XXX_shared_intermediates<br>另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择：<br>TARGET_ROOT_OUT：表示根文件系统out/target/product/generic/root。<br>TARGET_OUT：表示system文件系统out/target/product/generic/system。<br>TARGET_OUT_DATA：表示data文件系统out/target/product/generic/data。<br>OUT_DIR：代码工程编译时的out生成目录<br>PRODUCT_OUT：映象生成目录</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android-mk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>问题速查</title>
      <link href="/2015/06/29/%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/"/>
      <url>/2015/06/29/%E9%97%AE%E9%A2%98%E9%80%9F%E6%9F%A5/</url>
      <content type="html"><![CDATA[<p>1, 无法下载问题：<br>1、确认主板中是否有download过软件——直接接电源开机，如可以开机，可以断定此主板已经down过版本了；如果无法开机，尝试焊接串口线，抓一下log，看看在哪一步停下来走不下去了。<br>一般而言，可以开机但是不能下载的，存在两种可能：<br>①新软件中未兼容主板上的Memory物料；<br>②分区表更新了。<br>对于这第一种情况，可以通过查配置表，找到Memory物料型号，然后跟软件开发人员核对，是否有兼容；或者查看flash download工具的log，发给开发人员，通过Memory ID来确认是否兼容该物料。<br>对于第二种情况，通常可以选择upgrade的升级方式，如实在不行，可以导出校准参数，然后格式化下载新软件，最后重新导入校准参数。<br>2、如果遇到无法开机，又无法下载的，可能有三种种情况：<br>①软件中未兼容主板上的Memory物料；<br>②下载工具版本过旧，不支持当前平台的下载；<br>③主板有异常，尤其Memory可能有损坏。<br>第一种情况跟上面类似，不再赘述。第二种情况，可以先直接换一个新版本工具试试能否下载，如可以下载，说明工具需要更新，如仍然无法下载，说明跟工具无关。第三种情况，可以多找几块主板，如果有一块可以下载软件，基本就可以判断无法下载的主板存在硬件上的损坏。<br>2, 不开机问题：<br>1、按开机键没有反应，屏幕不亮，用电源连接时发现电流无变化。这种情况，有两种可能：<br>①主板开机键或电池连接异常；<br>②单块主板损坏；<br>第一种情况，可以直接使用电源，然后用镊子连接主板power key测试点与地，如可以开机，说明开机键或电池异常；<br>第二种情况通常需要硬件同事介入分析。<br>2、开机到某个阶段停止不动。类似这样的情况，可以直接抓log分析。<br>比较实用的方法：①抓取不开机的uart log，部分手机不开机，同时抓取正常开机的uart log对比分析；②如果开机到android界面，可使用adb logcat -v time &gt; log.txt获取上层log信息。</p><p>3部分手机开机时间非常长：<br>此类问题很大可能性是由于外设在读ID导致的，直接抓log查看即可。最方便的方式就是直接抓串口log来分析。此外还可以用adb shell logcat –v time &gt; 123.txt来抓取上层log来分析。</p><p>4开机背光亮，有开机铃声，屏幕没有显示：<br>一般而言，问题在于屏没有兼容或者屏/主板单体损坏。如果是单体问题，我们可以做交叉实验，分析问题是主板还是屏导致的。如果全部显示都不对，可以跟软件开发同事确认是否软件不对，或者抓串口log，确认屏ID是否读到。</p><p>5 Camera应用丢失，Camera切换按钮丢失：<br>在MTK平台上，Camera的识别是在开机过程中完成的。如果开机时没有识别到任何Camera，开机之后Camera应用就会直接影藏；如果只识别到一个Camera，Camera切换按钮就是影藏。<br>1、如果有发现手机开机之后，Camera应用丢失，可以通过以下步骤去：<br>①将手机恢复出厂设置，然后重新开机，此时如果Camera应用显示出来，且多次使用都正常了，说明之前该机器很有可能是先开机过，然后再安装Camera的。<br>②如果恢复出厂设置还是无法显示Camera应用，首先需要确认此问题是单体（或小概率）问题还是大批量问题。单体问题的话，就需要去排查Camera焊接/连接是否正常。如焊接/连接正常，接着做交叉实验，确认是模组问题还是主板问题。模组问题就安排模组厂分析，主板问题就合硬件沟通解决。如果是大批量问题，一方面需要让模组厂参与进来分析，另一方面需要排查软件/硬件。软件上可以抓串口log给软件同事分析，硬件上排查走线、供电是否有异常。<br>③如果切换异常，通常是某个Camera的ID没有读到。可以在拨号界面输入“_#<em>#9375#</em>#_”（仅适用于MTK平台），确认下是否是没有读到ID，如确实ID没有读到，一方面检查Camera焊接/连接是否正常，另一方面抓下串口log给软件同事分析。</p><p>6 Camera花屏/闪绿线：<br>遇到Camera使用过程中花屏/闪绿线的问题，我们可以从两个方向去排查问题。首先还是按照惯例统计花屏的概率，如果是单体问题，需要去确认Camera数据线是否有问题，直接测量数据线信号即可，将波形发生给硬件同事检查。然后做交叉实验，确认是模组问题还是主板问题。模组问题让模组厂来分析，主板问题可以跟硬件沟通处理。<br>如果大批量都有问题，需要软件和硬件同事介入分析。软件上尝试修改Camera驱动能力，优化一个最好的组合，硬件上尝试包导电布、做接地处理。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>工具小技巧</title>
      <link href="/2015/06/29/%E5%B7%A5%E5%85%B7%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2015/06/29/%E5%B7%A5%E5%85%B7%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p><strong>1—-</strong>.VIM配置鼠标和显示行号<br>服务器在安装了加密之后，vim无法使用鼠标，也无法显示行号了，可以通过如下方法修改：<br>1、 在~路径下创建.vimrc，然后加入两行<br>set mouse=a<br>set nu<br>修改完之后保存退出。<br>2、 关闭bash窗口，或者source .vimrc，接下来vim就可以使用鼠标和显示行号了。</p><p><strong>2—–</strong><br>shell脚本注意事项<br>有些情况下，我们会碰到一个问题，在编译时，有些shell脚本会无法执行。相信大家会第一时间去检查脚本的权限，看看脚本是否有可执行权限——ls查看下。如果权限不对，使用chmod指令修改下就好了。<br>但是有些时候，发现权限对了，脚本执行仍然不对，如这种提示——bad interpreter:No such file or directory。这种情况，其实是脚本的文件结尾符是dos格式的，而非unix标准编码。<br>碰到这种情况，可以通过如下方式定位、解决。<br>1、 使用vim打开文件，然后进入命令模式，输入set: ff（ ）并回车，此时，文件下方会有提示 或者 如果是第二种，那么恭喜你中招了，这个文件的格式是dos的（也就是windows一系列系统的格式），这种格式的脚本，是无法在shell中执行的。<br>2、 想要修改，也非常简单。输入命令 ，然后回车，问题搞定了。保存文件，会发现该脚本已经可以执行了。</p><p><strong>3—–</strong><br>Putty实现输入中文和log行数增加<br>1， 在Translation标签页，将putty的字符集修改为UTF-8。<br>2， 将字体设置成Fixedsys。<br>3，在Window标签页，将Lines of Scrollback设置成为20000。<br>4，将Session中的IP地址和Saved Session填写好。选择Save。<br>5，下次登录的时候，只要选择存储的Session就可以了。</p>]]></content>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>批处理 BAT</title>
      <link href="/2015/06/29/%E6%89%B9%E5%A4%84%E7%90%86-BAT/"/>
      <url>/2015/06/29/%E6%89%B9%E5%A4%84%E7%90%86-BAT/</url>
      <content type="html"><![CDATA[<p>用批处理命令批量获取指定文件夹内的文件名<br>dir /s /w &gt;&gt;catalog.txt<br>::/s 表示只显示系统文件<br>::/w 表示只显示文件名，至于文件大小以及建立的日期和时间都省略<br>::dir *.doc /s /w &gt;&gt; catalog.txt 表示仅生成后缀为.doc文件</p><p>::BAT文件注释符<br>:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>rem 注释内容（不能出现重定向符号和管道符号）<br>:注释内容（注释文本不能与已有标签重名）<br>%注释内容(可以用作行间注释，不能出现重定向符号和管道符号)%</p><p>rem 指定存放文件的目录<br>set originPath=C:\Documents and Settings\zhoudeshui\Desktop\临时文件</p><p>:@echo<br>:　　dir c:<em>.</em> &gt;a.txt　　　　　　　<br>:　　call c:\ucdos\ucdos.bat　　　　<br>:　　echo 你好 　　　　　　　　　　<br>:　　pause 　　　　　　　　　　　　</p><p>@echo off<br>for /f “delims=\” %%a in (‘dir /b /a-d /o-d “%originPath%<em>.</em>”’) do (<br>echo %%a &gt; aa.txt<br>)<br>pause</p>]]></content>
      
      <categories>
          
          <category> BAT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ADB (Android Debug Bridge)常用命令</title>
      <link href="/2015/06/29/ADB-Android-Debug-Bridge-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2015/06/29/ADB-Android-Debug-Bridge-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>ADB (Android Debug Bridge)</p><p>说明：下面一些命令需要有root权限才能执行成功<br>快速启动dos窗口执行adb：<br>1. adb.exe所在路径添加到系统环境变量中<br>2. 配置快捷键启动dos<br>进入C:\WINDOWS\system32目录下，找到cmd.exe.<br>右击菜单 “发送到” -> 桌面快捷方式。<br>在桌面上右击”快捷方式 到 cmd.exe” -&gt; “属性” -&gt; “快捷方式”页<br>-&gt; 光标高亮”快捷键” -> 按下自定义快捷键 (如：Ctrl + Alt + Z)</p><p>任何情况下，按下Ctrl + Alt + Z启动dos窗口就可以执行adb命令了</p><p>———–查看设备连接状态 系列———–<br>adb get-serialno 获取设备的ID和序列号serialNumber<br>adb devices 查询当前计算机上连接那些设备（包括模拟器和手机），输出格式: [serialNumber] [state]<br>adb get-state 查看模拟器/设施的当前状态.</p><p>说明：<br>序列号[serialNumber]——由adb创建的一个字符串，这个字符串通过自己的控制端口-<br>唯一地识别一个模拟器/设备实例。一个序列号的例子： emulator-5554</p><p>———–发送命令到设备 系列———–<br>adb [-d|-e|-s ]<br>-d 发送命令给usb连接的设备<br>-e 发送命令到模拟器设备<br>-s 发送命令到指定设备</p><p>如启动手机设备shell: adb -d shell</p><p>adb forward 发布端口,可以设置任意的端口号，<br>做为主机向模拟器或设备的请求端口。如：adb forward tcp:5555 tcp:8000</p><p>adb reboot 重启手机<br>adb remount 将system分区重新挂载为可读写分区<br>adb kill-server 终止adb服务进程<br>adb start-server 重启adb服务进程<br>adb root 已root权限重启adb服务<br>adb wait-for-device 在模拟器/设备连接之前把命令转载在adb的命令器中<br>adb jdwp 查看指定的设施的可用的JDWP信息.<br>可以用 forward jdwp: 端口映射信息来连接指定的JDWP进程.例如：<br>adb forward tcp:8000 jdwp:472<br>jdb -attach localhost:8000</p><p>adb shell am 命令可以启动应用程序</p><p>adb shell input text 向设备输入文本（光标所在的文本框）<br>adb shell input keyevent 向设备发送按键事件<br>如：<br>在编辑短信时，往文本框输入文本：adb shell input text “hello”<br>向手机发送键值回Home：adb shell input keyevent 3<br>event_code 参考view/KeyEvent.java中的 KEYCODE_*<br>public static final int KEYCODE_SOFT_LEFT = 1;<br>public static final int KEYCODE_SOFT_RIGHT = 2;<br>public static final int KEYCODE_HOME = 3;<br>public static final int KEYCODE_BACK = 4;<br>public static final int KEYCODE_CALL = 5;<br>public static final int KEYCODE_ENDCALL = 6;</p><p>———–安装卸载 系列———–<br>adb install [-l] [-r] - push this package file to the device and install it<br>(‘-l’ means forward-lock the app)<br>(‘-r’ means reinstall the app, keeping its data)<br>adb uninstall [-k] - remove this app package from the device<br>(‘-k’ means keep the data and cache directories)<br>如：<br>adb install d:\hello.apk<br>adb unstall com.huawei.hello<br>说明：如果带-r选项重新安装apk时，安装在 /data/local/tmp/目录下，手机重启后还是使用原来的apk.</p><p>———–文件操作 系列———–<br>adb push - copy file/dir to device<br>adb pull - copy file/dir from device</p><p>———–基本linux shell命令 系列———–<br>adb shell [command]<br>ls 列出目录下的文件和文件夹<br>cd 切换目录<br>rm 删除目录和文件<br>cat 查看文件内容<br>ps 可以看那个进程再跑<br>ps -x [PID] 查看单个进程的状态<br>top 可以看那个进程的占用率最高<br>su 切换到root用户<br>kill [pid] 杀死一个进程<br>chmod 777 修改该文件为可执行权限</p><p>详细使用情况可以登录一台Linux服务器在shell下查看帮助手册, man</p><p>———–查看系统状态和信息 系列———–<br>adb shell procrank 查询各进程内存使用情况<br>adb shell service list 查看services信息<br>adb shell cat /proc/meminfo 查看当前的内存情况<br>adb shell cat /proc/cpuinfo 查看CPU信息（硬件）<br>adb shell cat /proc/iomem 查看IO内存分区</p><p>adb shell getprop 列出系统所有属性<br>adb shell getprop | findstr “gsm” 列出包含gsm的属性<br>adb shell setprop 修改系统属性</p><p>adb shell sqlite3 可以执行sql语句查看数据库信息， 具体使用情况待调查</p><p>———–Log 系列———–<br>adb logcat [ ] - View device log</p><p>1<del>~</del><del>~</del>~查看可用日志缓冲区:<br>adb logcat -b radio — 查看缓冲区的相关的信息.<br>adb logcat -b events — 查看和事件相关的的缓冲区.<br>adb logcat -b main — 查看主要的日志缓冲区</p><p>2<del>~</del><del>~</del>~过滤日志输出:<br>过滤器语句按照下面的格式描tag:priority … , tag 表示是标签, priority 是表示标签的报告的最低等级<br>adb logcat <em>:W 显示优先级为warning或更高的日志信息<br>adb logcat ActivityManager:I MyApp:D </em>:S</p><p>日志的标签是系统部件原始信息的一个简要的标志。（比如：“View”就是查看系统的标签）.<br>优先级有下列集中，是按照从低到高顺利排列的:<br>V — Verbose (lowest priority)<br>D — Debug<br>I — Info<br>W — Warning<br>E — Error<br>F — Fatal<br>S — Silent (highest priority, on which nothing is ever printed)</p><p>如果你电脑上运行logcat ，相比在远程adbshell端，你还可以为环境变量ANDROID_LOG_TAGS :输入一个参数来设置默认的过滤<br>export ANDROID_LOG_TAGS=”ActivityManager:I MyApp:D *:S”<br>需要注意的是ANDROID_LOG_TAGS 过滤器如果通过远程shell运行logcat 或用adb shell logcat 来运行模拟器/设备不能输出日志.</p><p>3<del>~</del><del>~</del>~控制日志输出格式:<br>日志信息包括了许多元数据域包括标签和优先级。可以修改日志的输出格式，所以可以显示出特定的元数据域。可以通过 -v 选项得到格式化输出日志的相关信息.</p><p>brief — Display priority/tag and PID of originating process (the default format).<br>process — Display PID only.<br>tag — Display the priority/tag only.<br>thread — Display process:thread and priority/tag only.<br>raw — Display the raw log message, with no other metadata fields.<br>time — Display the date, invocation time, priority/tag, and PID of the originating process.<br>long — Display all metadata fields and separate messages with a blank lines.<br>当启动了logcat ，你可以通过-v 选项来指定输出格式:</p><p>[adb] logcat [-v ]<br>下面是用 thread 来产生的日志格式:</p><p>adb logcat -v thread<br>需要注意的是你只能-v 选项来规定输出格式 option.</p><p>4<del>~</del><del>~</del>~Logcat命令列表<br>-b 加载一个可使用的日志缓冲区供查看，比如event 和radio . 默认值是main 。具体查看Viewing Alternative Log Buffers.<br>-c 清楚屏幕上的日志.<br>-d 输出日志到屏幕上.<br>-f 指定输出日志信息的 ，默认是stdout .<br>-g 输出指定的日志缓冲区，输出后退出.<br>-n 设置日志的最大数目 .，默认值是4，需要和 -r 选项一起使用。<br>-r 每 时输出日志，默认值为16，需要和-f 选项一起使用.<br>-s 设置默认的过滤级别为silent.<br>-v 设置日志输入格式，默认的是brief 格式，要知道更多的支持的格式，参看Controlling Log Output Format</p><p>adb bugreport - return all information from the device<br>that should be included in a bug report.</p><p>adb shell dmesg 查询内核缓冲区信息<br>adb shell dumpstate 各类信息，比如进程信息，内存信息，进程是否异常，kernnel的log等<br>adb shell dumpcrash<br>adb shell dumpsys 查询所有service的状态</p><p>———–其他 ———–</p><p>模拟器使用镜像sdcard<br>用SDK里的mksdcard工具来创建FAT32磁盘镜像并在模拟器启动时加载它。这样创建镜像：? mksdcard ,<br>比如我要创建一个64M的SD卡模拟文件，文件路径是在D:\workspace\sdcard.img<br>mksdcard 64000000 D:\workspace\sdcard.img</p><p>Emulator –sdcard D:\workspace\sdcard.img<br>或者在eclipse的run菜单的open run dialog对话框中配置启动参数。</p><h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ]<br>-m num Maximum number of processes to display.<br>-n num Updates to show before exiting.<br>-d num Seconds to wait between updates.<br>-s col Column to sort by (cpu,vss,rss,thr).<br>-t Show threads instead of processes.<br>-h Display this help screen.</p><p><strong>_***</strong><em><strong> simple selection </strong></em><em><em><strong> </strong></em><em>**</em></em><em><strong> selection by list </strong></em><em><em><strong><br>-A all processes -C by command name<br>-N negate selection -G by real group ID (supports names)<br>-a all w/ tty except session leaders -U by real user ID (supports names)<br>-d all except session leaders -g by session OR by effective group name<br>-e all processes -p by process ID<br>T all processes on this terminal -s processes in the sessions given<br>a all w/ tty, including other users -t by tty<br>g OBSOLETE – DO NOT USE -u by effective user ID (supports names)<br>r only running processes U processes for specified users<br>x processes w/o controlling ttys t by tty  </strong></em><em>**</em></em><em><strong> output format </strong></em><strong>**</strong><em><strong> </strong></em>***<em><strong> long options </strong></em><strong>*</strong><em><strong><br>-o,o user-defined -f full –Group –User –pid –cols –ppid<br>-j,j job control s signal –group –user –sid –rows –info<br>-O,O preloaded -o v virtual memory –cumulative –format –deselect<br>-l,l long u user-oriented –sort –tty –forest –version<br>-F extra full X registers –heading –no-heading –context  </strong></em><strong>*</strong><em><strong> misc options </strong></em>*_**<br>-V,V show version L list format codes f ASCII art forest<br>-m,m,-L,-T,H threads S children in sum -y change -l format<br>-M,Z security data c true command name -c scheduling class<br>-w,w wide output n numeric WCHAN,UID -H process hierarchy</p><p>netstat -ano 查看网络连状态<br>显示协议统计信息和当前 TCP/IP 网络连接。</p><p>NETSTAT [-a] [-b] [-e] [-n] [-o] [-p proto] [-r] [-s] [-v] [interval]</p><p>-a 显示所有连接和监听端口。<br>-b 显示包含于创建每个连接或监听端口的<br>可执行组件。在某些情况下已知可执行组件<br>拥有多个独立组件，并且在这些情况下<br>包含于创建连接或监听端口的组件序列<br>被显示。这种情况下，可执行组件名<br>在底部的 [] 中，顶部是其调用的组件，<br>等等，直到 TCP/IP 部分。注意此选项<br>可能需要很长时间，如果没有足够权限<br>可能失败。<br>-e 显示以太网统计信息。此选项可以与 -s<br>选项组合使用。<br>-n 以数字形式显示地址和端口号。<br>-o 显示与每个连接相关的所属进程 ID。<br>-p proto 显示 proto 指定的协议的连接；proto 可以是<br>下列协议之一: TCP、UDP、TCPv6 或 UDPv6。<br>如果与 -s 选项一起使用以显示按协议统计信息，proto 可以是下列协议之一:<br>IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。<br>-r 显示路由表。<br>-s 显示按协议统计信息。默认地，显示 IP、<br>IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；<br>-p 选项用于指定默认情况的子集。<br>-v 与 -b 选项一起使用时将显示包含于<br>为所有可执行组件创建连接或监听端口的<br>组件。<br>interval 重新显示选定统计信息，每次显示之间<br>暂停时间间隔(以秒计)。按 CTRL+C 停止重新<br>显示统计信息。如果省略，netstat 显示当前<br>配置信息(只显示一次)</p><p>pm<br>usage: pm [list|path|install|uninstall]<br>pm list packages [-f]<br>pm list permission-groups<br>pm list permissions [-g] [-f] [-d] [-u] [GROUP]<br>pm list instrumentation [-f] [TARGET-PACKAGE]<br>pm list features<br>pm path PACKAGE<br>pm install [-l] [-r] [-t] [-i INSTALLER_PACKAGE_NAME] PATH<br>pm uninstall [-k] PACKAGE<br>pm enable PACKAGE_OR_COMPONENT<br>pm disable PACKAGE_OR_COMPONENT</p><p>The list packages command prints all packages. Options:<br>-f: see their associated file.</p><p>The list permission-groups command prints all known<br>permission groups.</p><p>The list permissions command prints all known<br>permissions, optionally only those in GROUP. Options:<br>-g: organize by group.<br>-f: print all information.<br>-s: short summary.<br>-d: only list dangerous permissions.<br>-u: list only the permissions users will see.</p><p>The list instrumentation command prints all instrumentations,<br>or only those that target a specified package. Options:<br>-f: see their associated file.</p><p>The list features command prints all features of the system.</p><p>The path command prints the path to the .apk of a package.</p><p>The install command installs a package to the system. Options:<br>-l: install the package with FORWARD_LOCK.<br>-r: reinstall an exisiting app, keeping its data.<br>-t: allow test .apks to be installed.<br>-i: specify the installer package name.</p><p>The uninstall command removes a package from the system. Options:<br>-k: keep the data and cache directories around.<br>after the package removal.</p><p>The enable and disable commands change the enabled state of<br>a given package or component (written as “package/class”).</p><p>查看stdout 和stderr<br>在默认状态下，Android系统有stdout 和 stderr (System.out和System.err )输出到/dev/null ，<br>在运行Dalvik VM的进程中，有一个系统可以备份日志文件。在这种情况下，系统会用stdout 和stderr 和优先级 I.来记录日志信息</p><p>通过这种方法指定输出的路径，停止运行的模拟器/设备，然后通过用setprop 命令远程输入日志</p><p>adbshellstop adb shell stop adb shell setprop log.redirect-stdio true<br>$ adb shell start系统直到你关闭模拟器/设备前设置会一直保留，可以通过添加/data/local.prop 可以使用模拟器/设备上的默认设置</p><p>UI/软件 试验程序 Monkey<br>当Monkey程序在模拟器或设备运行的时候，如果用户出发了比如点击，触摸，手势或一些系统级别的事件的时候，<br>它就会产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件.<br>最简单的方法就是用用下面的命令来使用Monkey，这个命令将会启动你的软件并且触发500个事件.</p><p>$ adb shell monkey -v -p your.package.name 500<br>更多的关于命令Monkey的命令的信息，可以查看UI/Application Exerciser Monkey documentation page.</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ActionBar隐藏方法</title>
      <link href="/2015/06/29/ActionBar%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/"/>
      <url>/2015/06/29/ActionBar%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>当使用Android中的ActionBar控件时，如果想要隐藏上面的ActionBar，可以使用如下的代码：<br>getSupportActionBar().hide();//隐藏掉整个ActionBar，包括下面的Tabs<br>上面的代码会将整个ActionBar都隐藏掉，包括ActionBar中的Tab分页标签，如果想要保留分页标签的话，可以使用如下的代码：<br>ActionBar actionBar = getSupportActionBar();//高版本可以换成</p><p>ActionBar actionBar = getActionBar();<br>actionBar.setDisplayShowTitleEnabled(false);<br>actionBar.setDisplayShowHomeEnabled(false);<br>//会保留tab标签</p><p>另外还有一种更简单的方式来移除ActionBar，在setContent()之前调用下面这句，保证没有ActionBar<br>导入包：<br>import android.view.Window;<br>requestWindowFeature(Window.FEATURE_NO_TITLE);</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
