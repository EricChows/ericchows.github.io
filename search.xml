<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android中广播注册和发送机制分</title>
      <link href="/2018/06/28/Android%E4%B8%AD%E5%B9%BF%E6%92%AD%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/28/Android%E4%B8%AD%E5%B9%BF%E6%92%AD%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li>Android Broadcast广播注册和发布方式以及机制流程 <a href="https://blog.csdn.net/liu_3262296/article/details/51935316" target="_blank" rel="noopener">https://blog.csdn.net/liu_3262296/article/details/51935316</a></li><li>Android广播之发送广播的源码分析 <a href="https://blog.csdn.net/zhangyongfeiyong/article/details/52022935" target="_blank" rel="noopener">https://blog.csdn.net/zhangyongfeiyong/article/details/52022935</a></li><li>Android广播机制实现源码浅析（一） <a href="https://blog.csdn.net/hehui1860/article/details/30726609" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30726609</a></li><li>Android广播机制实现源码浅析（二） <a href="https://blog.csdn.net/hehui1860/article/details/30727075" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30727075</a></li><li>Android广播机制实现源码浅析（三）<a href="https://blog.csdn.net/hehui1860/article/details/30727537" target="_blank" rel="noopener">https://blog.csdn.net/hehui1860/article/details/30727537</a></li><li>BroadcastReceiver源码解析(一)  <a href="https://blog.csdn.net/tiefeng0606/article/details/51354381" target="_blank" rel="noopener">https://blog.csdn.net/tiefeng0606/article/details/51354381</a></li><li>BroadcastReceiver源码解析（二） <a href="https://blog.csdn.net/tiefeng0606/article/details/51381221" target="_blank" rel="noopener">https://blog.csdn.net/tiefeng0606/article/details/51381221</a></li></ol><p>Android 解读main log和event log日志信息<br><a href="https://blog.csdn.net/yelangjueqi/article/details/52621903" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52621903</a></p><p>Log中’main’, ‘system’, ‘radio’, ‘events’以及android log分析<br><a href="https://www.cnblogs.com/zhengtu2015/p/5134012.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengtu2015/p/5134012.html</a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Broadcast </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android的Log机制分析</title>
      <link href="/2018/06/27/Android%E7%9A%84Log%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/27/Android%E7%9A%84Log%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><p>Android 解读main log和event log日志信息<br><a href="https://blog.csdn.net/yelangjueqi/article/details/52621903" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52621903</a></p><p>Log中’main’, ‘system’, ‘radio’, ‘events’以及android log分析<br><a href="https://www.cnblogs.com/zhengtu2015/p/5134012.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengtu2015/p/5134012.html</a></p><p>关于Android Log的一些思考<br><a href="https://droidyue.com/blog/2015/11/01/thinking-about-android-log/" target="_blank" rel="noopener">https://droidyue.com/blog/2015/11/01/thinking-about-android-log/</a></p><p><a href="https://blog.csdn.net/fishmai/article/details/52398537" target="_blank" rel="noopener">https://blog.csdn.net/fishmai/article/details/52398537</a></p><p>手机的默认的日志目录：</p><p> /data/local/tmp/*</p><p>/data/tmp/*</p><p>/data/system/usagestats/*</p><p>/data/system/appusagestates/*</p><p>/data/system/dropbox/*</p><p>/data/tombstones/*</p><p>/data/anr/*</p><p>logcat的日志在</p><p>/dev/log/main</p><p>有/data/local/log目录的，可以保存3-4天的log。</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Log </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android8.0充电图标不显示</title>
      <link href="/2018/06/25/Android8-0%E5%85%85%E7%94%B5%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2018/06/25/Android8-0%E5%85%85%E7%94%B5%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      <content type="html"><![CDATA[<p>1.充电图标不显示，问题分析步骤<br>a)找到充电图标的UI，frameworks/base/packages/SystemUI/res/layout/system_icons.xml<br>中找到<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.android.systemui.BatteryMeterView android:id=<span class="string">"@+id/battery"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        /&gt;</span><br></pre></td></tr></table></figure></p><p>确定充电图标UI文件，BatteryMeterView.java<br>frameworks/base/packages/SystemUI/src/com/android/systemui/BatteryMeterView.java<br>中充电图标绘制在BatteryMeterDrawableBase.java,查看<br>frameworks/base/packages/SettingsLib/src/com/android/settingslib/graph/BatteryMeterDrawableBase.java可以看到充电的闪电图标的绘制过程。<br>在BatteryMeterView.java中可以看到充电图标的显示与否是由下面决定的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) &#123;</span><br><span class="line">        mDrawable.setBatteryLevel(level);</span><br><span class="line">        mDrawable.setCharging(pluggedIn);//pluggedIn为<span class="literal">true</span>，显示闪电图标，为<span class="literal">false</span>则不显示</span><br><span class="line">        mLevel = level;</span><br><span class="line">        updatePercentText();</span><br><span class="line">        setContentDescription(</span><br><span class="line">                getContext().getString(charging ? R.string.accessibility_battery_level_charging</span><br><span class="line">                        : R.string.accessibility_battery_level, level));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到是由pluggedIn来决定是否显示，这里有个疑问，为何不用charging的值来判断，而要用pluggedIn的值来判断。原因在下面这个代码,<br>onBatteryLevelChanged这个函数，是在<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java里面addCallback回调过去的。<br>mCharging的值是由 mCharged和 BATTERY_STATUS_CHARGING两个值一起判断的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onReceive(final Context context, Intent intent) &#123;</span><br><span class="line">        final String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(Intent.ACTION_BATTERY_CHANGED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mTestmode &amp;&amp; !intent.getBooleanExtra(<span class="string">"testmode"</span>, <span class="literal">false</span>)) <span class="built_in">return</span>;</span><br><span class="line">            mHasReceivedBattery = <span class="literal">true</span>;</span><br><span class="line">            mLevel = (int)(100f</span><br><span class="line">                    * intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0)</span><br><span class="line">                    / intent.getIntExtra(BatteryManager.EXTRA_SCALE, 100));</span><br><span class="line">            mPluggedIn = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, 0) != 0;</span><br><span class="line"></span><br><span class="line">            final int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS,</span><br><span class="line">                    BatteryManager.BATTERY_STATUS_UNKNOWN);</span><br><span class="line">            mCharged = status == BatteryManager.BATTERY_STATUS_FULL;</span><br><span class="line">            mCharging = mCharged || status == BatteryManager.BATTERY_STATUS_CHARGING;</span><br><span class="line"></span><br><span class="line">            fireBatteryLevelChanged();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>为了查看手机中当前的pluggedIn和charging这两个值的状态，从<br>frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/BatteryControllerImpl.java文件中看到了一个Dump 的log打印，刚好打印了这几个值的状态，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) &#123;</span><br><span class="line">        pw.println(<span class="string">"BatteryController state:"</span>);</span><br><span class="line">        pw.print(<span class="string">"  mLevel="</span>); pw.println(mLevel);</span><br><span class="line">        pw.print(<span class="string">"  mPluggedIn="</span>); pw.println(mPluggedIn);</span><br><span class="line">        pw.print(<span class="string">"  mCharging="</span>); pw.println(mCharging);</span><br><span class="line">        pw.print(<span class="string">"  mCharged="</span>); pw.println(mCharged);</span><br><span class="line">        pw.print(<span class="string">"  mPowerSave="</span>); pw.println(mPowerSave);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><pre><code>所以，不需要另外打任何的log，直接连接手机，使用adb shell bugreport &gt; bugreport.txt抓出所有的dump log即可。BatteryController state:  mLevel=86  mPluggedIn=false  mCharging=true  mCharged=false  mPowerSave=false01-01 10:23:19.490  1000  1098  1110 D BatteryService: Sending ACTION_BATTERY_CHANGED.  level:71, scale:100, status:3, health:2, present:true, voltage: 3962, temperature: 375, technology: Li-ion, AC powered:false, USB powered:false, Wireless powered:false, icon:17303429, invalid charger:0, maxChargingCurrent:0, maxChargingVoltage:0, chargeCounter:1714883-------------------------------------------------------------------------------DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57这里有个问题，adb shell bugreport的log在User版本和Userdebug的版本里面抓出来的结果不一样，具体原因，可能是日志的级别限制的，需要查证一下。</code></pre><p>2.mPluggedIn的值是在收到ACTION_BATTERY_CHANGED广播里面带的参数得到的，那么这个广播是哪里发出来的呢？<br>通过使用<a href="http://androidxref.com" target="_blank" rel="noopener">http://androidxref.com</a> 进行全局搜索，找到是在<br>/frameworks/base/services/core/java/com/android/server/BatteryService.java的sendIntentLocked()函数里面发出来的。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="function"><span class="title">sendIntentLocked</span></span>() &#123;</span><br><span class="line">        //  Pack up the values and broadcast them to everyone</span><br><span class="line">        final Intent intent = new Intent(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                | Intent.FLAG_RECEIVER_REPLACE_PENDING);</span><br><span class="line"></span><br><span class="line">        int icon = getIconLocked(mBatteryProps.batteryLevel);</span><br><span class="line"></span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SEQUENCE, mSequence);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_STATUS, mBatteryProps.batteryStatus);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_HEALTH, mBatteryProps.batteryHealth);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PRESENT, mBatteryProps.batteryPresent);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_LEVEL, mBatteryProps.batteryLevel);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_SCALE);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_ICON_SMALL, icon);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_PLUGGED, mPlugType);</span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_VOLTAGE, mBatteryProps.batteryVoltage);    </span><br><span class="line">        intent.putExtra(BatteryManager.EXTRA_TEMPERATURE, mBatteryProps.batteryTemperature);  </span><br><span class="line"></span><br><span class="line">        EXTRA_PLUGGED的值是由mPlugType得到的，而mPlugType的值在BatteryService.java中得到方式如下：</span><br><span class="line">    private void processValuesLocked(boolean force) &#123;</span><br><span class="line">        boolean logOutlier = <span class="literal">false</span>;</span><br><span class="line">        long dischargeDuration = 0;</span><br><span class="line"></span><br><span class="line">        mBatteryLevelCritical = (mBatteryProps.batteryLevel &lt;= mCriticalBatteryLevel);</span><br><span class="line">        <span class="keyword">if</span> (mBatteryProps.chargerAcOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_AC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerUsbOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_USB;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBatteryProps.chargerWirelessOnline) &#123;</span><br><span class="line">            mPlugType = BatteryManager.BATTERY_PLUGGED_WIRELESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlugType = BATTERY_PLUGGED_NONE;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><pre><code>从中可以看出是根据mBatteryProps.chargerAcOnline或者mBatteryProps.chargerUsbOnline或者mBatteryProps.chargerWirelessOnline的值来判断，在frameworks/base/core/java/android/os/BatteryProperties.java中，可以看到这三个值是通过序列化的方式得到：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private BatteryProperties(Parcel p) &#123;</span><br><span class="line">    chargerAcOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerUsbOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    chargerWirelessOnline = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    maxChargingCurrent = p.readInt();</span><br><span class="line">    maxChargingVoltage = p.readInt();</span><br><span class="line">    batteryStatus = p.readInt();</span><br><span class="line">    batteryHealth = p.readInt();</span><br><span class="line">    batteryPresent = p.readInt() == 1 ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    batteryLevel = p.readInt();</span><br><span class="line">    batteryVoltage = p.readInt();</span><br><span class="line">    batteryTemperature = p.readInt();</span><br><span class="line">    batteryFullCharge = p.readInt();</span><br><span class="line">    batteryChargeCounter = p.readInt();</span><br><span class="line">    batteryTechnology = p.readString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void writeToParcel(Parcel p, int flags) &#123;</span><br><span class="line">    p.writeInt(chargerAcOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerUsbOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(chargerWirelessOnline ? 1 : 0);</span><br><span class="line">    p.writeInt(maxChargingCurrent);</span><br><span class="line">    p.writeInt(maxChargingVoltage);</span><br><span class="line">    p.writeInt(batteryStatus);</span><br><span class="line">    p.writeInt(batteryHealth);</span><br><span class="line">    p.writeInt(batteryPresent ? 1 : 0);</span><br><span class="line">    p.writeInt(batteryLevel);</span><br><span class="line">    p.writeInt(batteryVoltage);</span><br><span class="line">    p.writeInt(batteryTemperature);</span><br><span class="line">    p.writeInt(batteryFullCharge);</span><br><span class="line">    p.writeInt(batteryChargeCounter);</span><br><span class="line">    p.writeString(batteryTechnology);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final Parcelable.Creator&lt;BatteryProperties&gt; CREATOR</span><br><span class="line">    = new Parcelable.Creator&lt;BatteryProperties&gt;() &#123;</span><br><span class="line">    public BatteryProperties createFromParcel(Parcel p) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BatteryProperties[] newArray(int size) &#123;</span><br><span class="line">        <span class="built_in">return</span> new BatteryProperties[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>再来看看mBatteryProps的赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void update(BatteryProperties props) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mUpdatesStopped) &#123;</span><br><span class="line">            mBatteryProps = props;</span><br><span class="line">            // Process the new values.</span><br><span class="line">            processValuesLocked(<span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLastBatteryProps.set(props);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>接着看update()函数的调用，如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final class BatteryListener extends IBatteryPropertiesListener.Stub &#123;</span><br><span class="line">    @Override public void batteryPropertiesChanged(BatteryProperties props) &#123;</span><br><span class="line">        final long identity = Binder.clearCallingIdentity();</span><br><span class="line">        try &#123;</span><br><span class="line">            BatteryService.this.update(props);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(identity);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>可以看到BatteryProperties是在由batteryPropertiesChanged赋值，是通过AIDL实现对C++侧的监听，这个AIDL实现了JAVA侧与C++侧的通讯。这一块关于电池的共有三个AIDL文件,作为客户端和服务端的媒介，具体代码，以及作用分析如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/BatteryProperties.aidl</span><br><span class="line">package android.os;</span><br><span class="line">    parcelable BatteryProperties;</span><br></pre></td></tr></table></figure><pre><code>BatteryProperties.aidl主要用户AIDL跨进程通讯时的数据序列化和反序列化frameworks/base/core/java/android/os/BatteryProperties.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesListener.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.BatteryProperties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* &#123;@hide&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">oneway interface IBatteryPropertiesListener &#123;</span><br><span class="line">    void batteryPropertiesChanged(<span class="keyword">in</span> BatteryProperties props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesListener.aidl主要用于监听</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/os/IBatteryPropertiesRegistrar.aidl</span><br><span class="line">package android.os;</span><br><span class="line">import android.os.IBatteryPropertiesListener;</span><br><span class="line">import android.os.BatteryProperty;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * &#123;@hide&#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">interface IBatteryPropertiesRegistrar &#123;</span><br><span class="line">    void registerListener(IBatteryPropertiesListener listener);</span><br><span class="line">    void unregisterListener(IBatteryPropertiesListener listener);</span><br><span class="line">    int getProperty(<span class="keyword">in</span> int id, out BatteryProperty prop);</span><br><span class="line">    oneway void scheduleUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>IBatteryPropertiesRegistrar.aidl主要用于注册服务端在BatteryService.java</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">onStart</span></span>() &#123;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"batteryproperties"</span>);</span><br><span class="line">    final IBatteryPropertiesRegistrar batteryPropertiesRegistrar =</span><br><span class="line">            IBatteryPropertiesRegistrar.Stub.asInterface(b);</span><br><span class="line">    try &#123;</span><br><span class="line">        batteryPropertiesRegistrar.registerListener(new BatteryListener());</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        // Should never happen.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBinderService = new BinderService();</span><br><span class="line">    publishBinderService(<span class="string">"battery"</span>, mBinderService);</span><br><span class="line">    publishLocalService(BatteryManagerInternal.class, new LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>对应的native层的代码在frameworks/native/services/batteryservice/编译出libbatteryservice.so库Java侧与C++侧通过AIDL通讯，两边都要写AIDL文件，且两边都要有Parcel序列化。通过查找batteryPropertiesChanged函数system/core/healthd/BatteryPropertiesRegistrar.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "BatteryPropertiesRegistrar.h"</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/BatteryService.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesListener.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;batteryservice/IBatteryPropertiesRegistrar.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IPCThreadState.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/IServiceManager.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;binder/PermissionCache.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;private/android_filesystem_config.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Errors.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/Mutex.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;utils/String16.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;healthd/healthd.h&gt;</span></span><br><span class="line"></span><br><span class="line">namespace android &#123;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::publish(</span><br><span class="line">    const sp&lt;BatteryPropertiesRegistrar&gt;&amp; service) &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(String16(<span class="string">"batteryproperties"</span>), service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::notifyListeners(const struct BatteryProperties&amp; props) &#123;</span><br><span class="line">    Vector&lt;sp&lt;IBatteryPropertiesListener&gt; &gt; listenersCopy;</span><br><span class="line"></span><br><span class="line">    // Binder currently may service an incoming oneway transaction whenever an</span><br><span class="line">    // outbound oneway call is made (<span class="keyword">if</span> there is already a pending incoming</span><br><span class="line">    // oneway call waiting).  This is considered a bug and may change <span class="keyword">in</span> the</span><br><span class="line">    // future.  For now, avoid recursive mutex lock <span class="keyword">while</span> making outbound</span><br><span class="line">    // calls by making a <span class="built_in">local</span> copy of the current list of listeners.</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        listenersCopy = mListeners;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; listenersCopy.size(); i++) &#123;</span><br><span class="line">        listenersCopy[i]-&gt;batteryPropertiesChanged(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::registerListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">        // check whether this is a duplicate</span><br><span class="line">        <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mListeners.add(listener);</span><br><span class="line">        IInterface::asBinder(listener)-&gt;linkToDeath(this);</span><br><span class="line">    &#125;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::unregisterListener(const sp&lt;IBatteryPropertiesListener&gt;&amp; listener) &#123;</span><br><span class="line">    <span class="keyword">if</span> (listener == NULL)</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == IInterface::asBinder(listener)) &#123;</span><br><span class="line">            IInterface::asBinder(mListeners[i])-&gt;unlinkToDeath(this);</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::getProperty(int id, struct BatteryProperty *val) &#123;</span><br><span class="line">    <span class="built_in">return</span> healthd_get_property(id, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::<span class="function"><span class="title">scheduleUpdate</span></span>() &#123;</span><br><span class="line">    healthd_battery_update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t BatteryPropertiesRegistrar::dump(int fd, const Vector&lt;String16&gt;&amp; /*args*/) &#123;</span><br><span class="line">    IPCThreadState* self = IPCThreadState::self();</span><br><span class="line">    const int pid = self-&gt;getCallingPid();</span><br><span class="line">    const int uid = self-&gt;getCallingUid();</span><br><span class="line">    <span class="keyword">if</span> ((uid != AID_SHELL) &amp;&amp;</span><br><span class="line">        !PermissionCache::checkPermission(</span><br><span class="line">                String16(<span class="string">"android.permission.DUMP"</span>), pid, uid))</span><br><span class="line">        <span class="built_in">return</span> PERMISSION_DENIED;</span><br><span class="line"></span><br><span class="line">    healthd_dump_battery_state(fd);</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BatteryPropertiesRegistrar::binderDied(const wp&lt;IBinder&gt;&amp; who) &#123;</span><br><span class="line">    Mutex::Autolock _l(mRegistrationLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = 0; i &lt; mListeners.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (IInterface::asBinder(mListeners[i]) == who) &#123;</span><br><span class="line">            mListeners.removeAt(i);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  // namespace android</span><br></pre></td></tr></table></figure><pre><code>再查找notifyListeners函数，在 system/core/healthd/healthd_mode_android.cpp</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void healthd_mode_android_battery_update(</span><br><span class="line">    struct android::BatteryProperties *props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (gBatteryPropertiesRegistrar != NULL)</span><br><span class="line">        gBatteryPropertiesRegistrar-&gt;notifyListeners(*props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>Healthd是一种中介模型，向下监听来自kernel层的电池事件，向上将电池数据信息传递给Framework层的BatteryService.主要代码在 system/core/healthd 中，对Healthd模块的代码分析如下：参考：Healthd模块编译出来的文件有system/bin/healthd通过在system/core/healthd里面查找chargerUsbOnline，在system/core/healthd/BatteryMonitor.cpp中update函数可以看到赋值：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">bool BatteryMonitor::update(void) &#123;</span><br><span class="line">    bool logthis;</span><br><span class="line"></span><br><span class="line">    initBatteryProperties(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryPresentPath.isEmpty())</span><br><span class="line">        props.batteryPresent = getBooleanField(mHealthdConfig-&gt;batteryPresentPath);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        props.batteryPresent = mBatteryDevicePresent;</span><br><span class="line"></span><br><span class="line">    props.batteryLevel = mBatteryFixedCapacity ?</span><br><span class="line">        mBatteryFixedCapacity :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryCapacityPath);</span><br><span class="line">    props.batteryVoltage = getIntField(mHealthdConfig-&gt;batteryVoltagePath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty())</span><br><span class="line">        props.batteryCurrent = getIntField(mHealthdConfig-&gt;batteryCurrentNowPath) / 1000;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty())</span><br><span class="line">        props.batteryFullCharge = getIntField(mHealthdConfig-&gt;batteryFullChargePath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty())</span><br><span class="line">        props.batteryCycleCount = getIntField(mHealthdConfig-&gt;batteryCycleCountPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryChargeCounterPath.isEmpty())</span><br><span class="line">        props.batteryChargeCounter = getIntField(mHealthdConfig-&gt;batteryChargeCounterPath);</span><br><span class="line"></span><br><span class="line">    props.batteryTemperature = mBatteryFixedTemperature ?</span><br><span class="line">        mBatteryFixedTemperature :</span><br><span class="line">        getIntField(mHealthdConfig-&gt;batteryTemperaturePath);</span><br><span class="line"></span><br><span class="line">    // For devices <span class="built_in">which</span> <span class="keyword">do</span> not have battery and are always plugged</span><br><span class="line">    // into power souce.</span><br><span class="line">    <span class="keyword">if</span> (mAlwaysPluggedDevice) &#123;</span><br><span class="line">        props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">        props.batteryPresent = <span class="literal">true</span>;</span><br><span class="line">        props.batteryStatus = BATTERY_STATUS_CHARGING;</span><br><span class="line">        props.batteryHealth = BATTERY_HEALTH_GOOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryStatusPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryStatus = getBatteryStatus(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryHealthPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryHealth = getBatteryHealth(buf.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readFromFile(mHealthdConfig-&gt;batteryTechnologyPath, &amp;buf) &gt; 0)</span><br><span class="line">        props.batteryTechnology = String8(buf.c_str());</span><br><span class="line"></span><br><span class="line">    unsigned int i;</span><br><span class="line">    double MaxPower = 0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; mChargerNames.size(); i++) &#123;</span><br><span class="line">        String8 path;</span><br><span class="line">        path.appendFormat(<span class="string">"%s/%s/online"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                          mChargerNames[i].string());</span><br><span class="line">        <span class="keyword">if</span> (getIntField(path)) &#123;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/type"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            switch(readPowerSupplyType(path)) &#123;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_AC:</span><br><span class="line">                props.chargerAcOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_USB:</span><br><span class="line">                props.chargerUsbOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ANDROID_POWER_SUPPLY_TYPE_WIRELESS:</span><br><span class="line">                props.chargerWirelessOnline = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            default:</span><br><span class="line">                KLOG_WARNING(LOG_TAG, <span class="string">"%s: Unknown power supply type\n"</span>,</span><br><span class="line">                             mChargerNames[i].string());</span><br><span class="line">            &#125;</span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/current_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line">            int ChargingCurrent =</span><br><span class="line">                    (access(path.string(), R_OK) == 0) ? getIntField(path) : 0;</span><br><span class="line"></span><br><span class="line">            path.clear();</span><br><span class="line">            path.appendFormat(<span class="string">"%s/%s/voltage_max"</span>, POWER_SUPPLY_SYSFS_PATH,</span><br><span class="line">                              mChargerNames[i].string());</span><br><span class="line"></span><br><span class="line">            int ChargingVoltage =</span><br><span class="line">                (access(path.string(), R_OK) == 0) ? getIntField(path) :</span><br><span class="line">                DEFAULT_VBUS_VOLTAGE;</span><br><span class="line"></span><br><span class="line">            double power = ((double)ChargingCurrent / MILLION) *</span><br><span class="line">                           ((double)ChargingVoltage / MILLION);</span><br><span class="line">            <span class="keyword">if</span> (MaxPower &lt; power) &#123;</span><br><span class="line">                props.maxChargingCurrent = ChargingCurrent;</span><br><span class="line">                props.maxChargingVoltage = ChargingVoltage;</span><br><span class="line">                MaxPower = power;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logthis = !healthd_board_battery_update(&amp;props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        char dmesgline[256];</span><br><span class="line">        size_t len;</span><br><span class="line">        <span class="keyword">if</span> (props.batteryPresent) &#123;</span><br><span class="line">            snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery l=%d v=%d t=%s%d.%d h=%d st=%d"</span>,</span><br><span class="line">                 props.batteryLevel, props.batteryVoltage,</span><br><span class="line">                 props.batteryTemperature &lt; 0 ? <span class="string">"-"</span> : <span class="string">""</span>,</span><br><span class="line">                 abs(props.batteryTemperature / 10),</span><br><span class="line">                 abs(props.batteryTemperature % 10), props.batteryHealth,</span><br><span class="line">                 props.batteryStatus);</span><br><span class="line"></span><br><span class="line">            len = strlen(dmesgline);</span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCurrentNowPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" c=%d"</span>, props.batteryCurrent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryFullChargePath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" fc=%d"</span>, props.batteryFullCharge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHealthdConfig-&gt;batteryCycleCountPath.isEmpty()) &#123;</span><br><span class="line">                len += snprintf(dmesgline + len, sizeof(dmesgline) - len,</span><br><span class="line">                                <span class="string">" cc=%d"</span>, props.batteryCycleCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = snprintf(dmesgline, sizeof(dmesgline),</span><br><span class="line">                 <span class="string">"battery none"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        snprintf(dmesgline + len, sizeof(dmesgline) - len, <span class="string">" chg=%s%s%s"</span>,</span><br><span class="line">                 props.chargerAcOnline ? <span class="string">"a"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerUsbOnline ? <span class="string">"u"</span> : <span class="string">""</span>,</span><br><span class="line">                 props.chargerWirelessOnline ? <span class="string">"w"</span> : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        KLOG_WARNING(LOG_TAG, <span class="string">"%s\n"</span>, dmesgline);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    healthd_mode_ops-&gt;battery_update(&amp;props);</span><br><span class="line">    <span class="built_in">return</span> props.chargerAcOnline | props.chargerUsbOnline |</span><br><span class="line">            props.chargerWirelessOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   从上面代码可以看到chargerUsbOnline的值是通过读取 sys/class/power_supply文件夹下的USB文件夹下的type里面的值来判断。</p><p>   adb shell进入手机后，cd sys/class/power_supply/USB,cat type发现是USB。<br>   这下懵逼了，这个值是对的呀，为何log里面读取出来的值不对呢？而且从之前抓的dump log来看如下：的确没有正确的读取到</p><pre><code>-------------------------------------------------------------------------------DUMP OF SERVICE batteryproperties:ac: 0 usb: 0 wireless: 0 current_max: 0 voltage_max: 0status: 2 health: 2 present: 1level: 86 voltage: 4234 temp: 297current now: -77209charge counter: 2089873current now: -376Full charge: 2444000--------- 0.003s was the duration of dumpsys batteryproperties, ending at: 2018-06-15 16:17:57现在怀疑是SeAndroid的AVC权限导致的。</code></pre>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android PMS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android</title>
      <link href="/2018/06/23/year-06-23-Android/"/>
      <url>/2018/06/23/year-06-23-Android/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ANR 机制以及问题分析</title>
      <link href="/2018/06/21/ANR-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/21/ANR-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文目标讲解Android中的ANR原理以及如何分析ANR问题</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>   ANR(Application Not Responding),应用程序无响应，简单的一个定义，却涵盖了很多AAndroid系统的设计思想。</p><p>   首先，ANR属于应用程序范畴，不同于SNR(System Not Responding),SNR反映的问题是系统进程(system_server)失去了响应能力，而ANR明确将问题圈定在应用程序。SNR是有Watchdog机制保证，具体可查阅<strong>Watchdog机制以及问题分析</strong>;ANR由消息处理机制保证，Android在系统层实现了一套机制来发现ANR,核心原理是消息调度和超时处理。</p><p>   其次，ANR机制的主体实现在系统层。所有与ANR相关的消息，都会经过系统进程(system_server)调度，然后派发发哦应用进程完成对消息的实际处理，同时，系统进程设计了不同的超时限制来跟踪消息的处理。一旦应用程序处理消息不当，超时限制就起了作用了，它收集一些系统状态，比如CPU/IO使用情况、进程函数调用栈，并报告用户进程无响应(弹出ANR对话框).</p><p>   然后，ANR问题本质是一个性能问题和稳定性的问题。ANR机制实际上对应用程序主线程的限制，要求主线程在限定的时间内处理完一些常见的操作(启动服务、处理广播、处理输入)，如果超时，则任务主线程已经失去了响应其他操作的能力。主线程中的耗时操作，比如密集CPU运算、大量IO、复杂界面布局等，都会降低应用程序的响应能力。当系统中的ANR问题太多的时候，就影响到了系统的稳定性。</p><p>   最后，部分ANR问题时很难分析的，有时候由于系统底层的一些影响，导致消息调度失败，比如说Binder资源耗尽，nativepollonce等，出现问题的场景又难以复现。这类ANR问题往往需要花费大量的事件去了解系统的一些行为，超出了ANR机制本省的范畴。</p><p>   出现ANR的场景主要有以下几种：</p><blockquote><ul><li><strong>Service Timeout:</strong>服务在20s内未执行完成；</li><li><strong>BroadcastQueue Timeout：</strong>比如前台广播在10s内执行完成</li><li><strong>ContentProvider Timeout：</strong>内容提供者执行超时</li><li><strong>inputDispatching Timeout:</strong> 输入事件分发超时5s，包括按键分发事件的超时</li></ul></blockquote><h2 id="Google-官方关于ANR的介绍"><a href="#Google-官方关于ANR的介绍" class="headerlink" title="Google 官方关于ANR的介绍"></a>Google 官方关于ANR的介绍</h2><p>   Google官方关于ANR的介绍是在介绍使用Android Vitals工具时提到：<a href="https://developer.android.com/topic/performance/vitals/anr" target="_blank" rel="noopener">https://developer.android.com/topic/performance/vitals/anr</a></p><h3 id="查找ANR根因"><a href="#查找ANR根因" class="headerlink" title="查找ANR根因"></a>查找ANR根因</h3><p>查找ANR根因的方法有</p><ol><li><p>使用StrictMode<br>具体请参照： StrictMode 机制以及性能调优</p></li><li><p>启动ANR 背景对话框<br>Enable background ANR dialogs</p><p>Android shows ANR dialogs for apps that take too long to process the broadcast message only if Show all ANRs is enabled in the device’s Developer options. For this reason, background ANR dialogs are not always displayed to the user, but the app could still be experiencing performance issues.</p><p> 打开 开发者模式 –&gt; 打开 Show All ANR</p></li><li><p>使用TraceView</p></li><li><p>adb pull data/anr</p></li></ol><h3 id="解决ANR问题的方式"><a href="#解决ANR问题的方式" class="headerlink" title="解决ANR问题的方式"></a>解决ANR问题的方式</h3><pre><code>There are some common patterns to look for when diagnosing ANRs:1. The app is doing slow operations involving I/O on the main thread.2. The app is doing a long calculation on the main thread.3. The main thread is doing a synchronous binder call to another process, and that other process is taking a long time to return.4. The main thread is blocked waiting for a synchronized block for a long operation that is happening on another thread.5. The main thread is in a deadlock with another thread, either in your process or via a binder call. The main thread is not just waiting for a long operation to finish, but is in a deadlock situation. For more information, see Deadlock on Wikipedia.</code></pre><p>翻译如下:<br>    在诊断ANR时有一些常见的模式需要查找：</p><pre><code>1. 该应用程序在主线程上执行涉及I / O的缓慢操作。2. 该应用程序正在对主线程进行长时间计算。3. 主线程正在对另一个进程执行同步绑定程序调用，而其他进程需要很长时间才能返回。4. 主线程被阻塞，等待正在另一个线程上发生的长操作的同步块。5. 主线程与另一个线程处于死锁状态，无论是在您的进程中还是通过联编程序调用。主线不仅仅是等待长时间的操作才能完成，而是处于死锁状态。有关更多信息，请参阅 维基百科上的死锁。</code></pre><ol><li><p>主线程执行超时<br>定位到是主线程超时时，需要找到对应的代码，将超时操作移到<a href="https://developer.android.com/topic/performance/threads#helper" target="_blank" rel="noopener">Handler</a>里面去处理，或者使用AsyncTask(<a href="https://developer.android.com/reference/android/os/AsyncTask" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/AsyncTask</a>) 异步任务的方式来处理。</p></li><li><p>主线程I/O超时<br>I/O超时，将超时操作移动到线程中处理,使用Handler或者AsyncTask.如果I/O是网络操作的或者存储操作的话，<a href="https://developer.android.com/training/basics/network-ops/" target="_blank" rel="noopener">网络操作</a>使用<a href="https://developer.android.com/training/volley/" target="_blank" rel="noopener">Volly</a>的方式来实现,数据存储的话，参照Android提供的几种存储方式<a href="https://developer.android.com/guide/topics/data/data-storage" target="_blank" rel="noopener">https://developer.android.com/guide/topics/data/data-storage</a></p></li><li><p>互斥锁<br>当前工作线程持有了UI线程所需要的资源太长时间，导致UI线程一直处于Wait状态.UI线程被阻塞住。可以使用<a href="https://developer.android.com/reference/java/util/concurrent/Semaphore" target="_blank" rel="noopener">Semaphore</a>(计数信号量)或者线程<a href="https://developer.android.com/reference/java/util/concurrent/locks/Lock" target="_blank" rel="noopener">锁</a>等其他的互斥机制来解决。 </p></li><li><p>死锁<br>UI线程和其他线程互相持有对方所需要的资源，导致死锁。双方都在等待对方释放资源。<br>解决死锁的方式：</p></li><li><p>广播超时<br>广播OnReceiver方法中耗时太久，比如前台广播超过10s未完成等<br>如果广播中需要执行复杂的操作，可以通过<a href="">IntenService</a>来实现。</p></li><li><p>服务超时/内容提供者超时/输入事件超时<br>都是用Handler或者AsyncTask来处理</p></li><li><p>CPU负载过高<br>一般CPU负载过高，只有在进行压力测试的时候才能出现，出现CPU负载过高之后，会使得很多事件得不到响应。一般CPU负载过高的ANR问题都不解。   </p></li></ol><h2 id="ANR-机制"><a href="#ANR-机制" class="headerlink" title="ANR 机制"></a>ANR 机制</h2><p>   分析一些初级的ANR问题，只需要简单理解最终输出的日志即可，但对于一些系统问题(比如CPU负载过高、进程卡死) 发的ANR，就需要对整个ANR机制有所了解，才能定位出问题的原因。</p><p>   ANR机制可以分为两部分：</p><blockquote><ul><li><strong>ANR的监测。</strong> Android对不同的ANR类型(Broadcase/Service/InputEvent)都有一套监测机制。</li></ul></blockquote><blockquote><ul><li><strong>ANR的报告。</strong> 在监测到ANR以后，需要显示ANR对话框、输出日志(发生ANR时的进程函数调用栈、CPU使用情况等)。</li></ul></blockquote><p>   整个ANR机制的代码也是横跨了Android的几个层：</p><blockquote><ul><li><strong>App层：</strong>应用主线程的处理逻辑</li></ul></blockquote><blockquote><ul><li><strong>Framework层：</strong>  ANR机制的核心</li></ul></blockquote><blockquote><ul><li>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</li><li>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</li><li>frameworks/base/services/core/java/com/android/server/am/ActiveServices.java</li><li>frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</li><li>frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java</li><li>frameworks/base/core/java/android/view/InputChannel</li><li>frameworks/base/services/core/java/com/android/internal/os/ProcessCpuTracker</li></ul></blockquote><blockquote><ul><li><strong>Native层：</strong> 输入事件派发机制。针对InputEvent类型的ANR</li></ul></blockquote><blockquote><ul><li>frameworks/base//services/core/jni/com_android_server_input_InputManagerService.cpp</li><li>frameworks/native/services/inputflinger/InputDispatcher.cpp</li></ul></blockquote><p>   下面我们会深入源码，分析ANR的监测和报告过程。</p><h3 id="ANR检测机制"><a href="#ANR检测机制" class="headerlink" title="ANR检测机制"></a>ANR检测机制</h3><h4 id="Service-处理超时"><a href="#Service-处理超时" class="headerlink" title="Service 处理超时"></a>Service 处理超时</h4><p>   Service运行在应用程序的主线程，如果Service的执行时间超过20秒，则会引发ANR。</p><p>   当发生Service ANR时，一般可以先排查一下在Service的生命周期函数中(onCreate(), onStartCommand()等)有没有做耗时的操作，譬如复杂的运算、IO操作等。如果应用程序的代码逻辑查不出问题，就需要深入检查当前系统的状态：CPU的使用情况、系统服务的状态等，判断当时发生ANR进程是否受到系统运行异常的影响。</p><p>   如何检测Service超时呢？Android是通过设置定时消息实现的。定时消息是由AMS的消息队列处理的(system_server的ActivityManager线程)。 AMS有Service运行的上下文信息，所以在AMS中设置一套超时检测机制也是合情合理的。</p><p>   Service ANR机制相对最为简单，简单说就是AMS中的mHandler收到SERVICE_TIMEOUT_MSG消息时触发。<br>   主体实现在<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActiveServices.java" target="_blank" rel="noopener">ActiveServices.java</a>中。 当Service的生命周期开始时，bumpServiceExecutingLocked()会被调用，紧接着会调用scheduleServiceTimeoutLocked()：</p><p>   StartService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void realStartServiceLocked(ServiceRecord r,</span><br><span class="line">            ProcessRecord app, boolean execInFg) throws RemoteException &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread == null) &#123;</span><br><span class="line">            throw new RemoteException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">        r.app = app;</span><br><span class="line">        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        final boolean newService = app.services.add(r);</span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);//执行bumpServiceExecutingLocked</span><br><span class="line">        mAm.updateLruProcessLocked(app, <span class="literal">false</span>, null);</span><br><span class="line">        updateServiceForegroundLocked(r.app, /* oomAdj= */ <span class="literal">false</span>);</span><br><span class="line">        mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        boolean created = <span class="literal">false</span>;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">                String nameTerm;</span><br><span class="line">                int lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                nameTerm = lastPeriod &gt;= 0 ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">                EventLogTags.writeAmCreateService(</span><br><span class="line">                        r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">            &#125;</span><br><span class="line">            ........</span><br></pre></td></tr></table></figure></p><p>   BindService的时候：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i,</span><br><span class="line">            boolean execInFg, boolean rebind) throws TransactionTooLargeException &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app == null || r.app.thread == null) &#123;</span><br><span class="line">            // If service is not currently running, can<span class="string">'t yet bind.</span></span><br><span class="line"><span class="string">            return false;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if (DEBUG_SERVICE) Slog.d(TAG_SERVICE, "requestBind " + i + ": requested=" + i.requested</span></span><br><span class="line"><span class="string">                + " rebind=" + rebind);</span></span><br><span class="line"><span class="string">        if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123;</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                bumpServiceExecutingLocked(r, execInFg, "bind");//执行bumpServiceExecutingLocked</span></span><br><span class="line"><span class="string">                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span></span><br><span class="line"><span class="string">                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span></span><br><span class="line"><span class="string">                        r.app.repProcState);</span></span><br><span class="line"><span class="string">                if (!rebind) &#123;</span></span><br><span class="line"><span class="string">                    i.requested = true;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                i.hasBound = true;</span></span><br><span class="line"><span class="string">                i.doRebind = false;</span></span><br><span class="line"><span class="string">            &#125; catch (TransactionTooLargeException e) &#123;</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r, e);</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                throw e;</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_SERVICE) Slog.v(TAG_SERVICE, "Crashed while binding " + r);</span></span><br><span class="line"><span class="string">                // Keep the executeNesting count accurate.</span></span><br><span class="line"><span class="string">                final boolean inDestroying = mDestroyingServices.contains(r);</span></span><br><span class="line"><span class="string">                serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span></span><br><span class="line"><span class="string">                return false;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>调用bumpServiceExecutingLocked</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private final void bumpServiceExecutingLocked(ServiceRecord r, boolean <span class="built_in">fg</span>, String why) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r + <span class="string">" in app "</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r.shortName);</span><br><span class="line">    long now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == 0) &#123;</span><br><span class="line">        r.executeFg = <span class="built_in">fg</span>;</span><br><span class="line">        ServiceState stracker = r.getTracker();</span><br><span class="line">        <span class="keyword">if</span> (stracker != null) &#123;</span><br><span class="line">            stracker.setExecuting(<span class="literal">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |= <span class="built_in">fg</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == 1) &#123;</span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != null &amp;&amp; <span class="built_in">fg</span> &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line">        r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);//</span><br><span class="line">    &#125;</span><br><span class="line">    r.executeFg |= <span class="built_in">fg</span>;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    r.executingStart = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着调用scheduleServiceTimeoutLocked<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void scheduleServiceTimeoutLocked(ProcessRecord proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    mAm.mHandler.sendMessageDelayed(msg,</span><br><span class="line">            proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法通过AMS.MainHandler抛出一个定时消息SERVICE_TIMEOUT_MSG：</p><blockquote><ul><li><strong>前台进程中执行Service</strong>，超时时间是SERVICE_TIMEOUT(20秒)</li><li><strong>后台进程中执行Service</strong>，超时时间是SERVICE_BACKGROUND_TIMEOUT(200秒)</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_TIMEOUT = 20*1000;</span><br><span class="line"></span><br><span class="line">// How long we <span class="built_in">wait</span> <span class="keyword">for</span> a service to finish executing.</span><br><span class="line">static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;</span><br><span class="line"></span><br><span class="line">// How long the startForegroundService() grace period is to get around to</span><br><span class="line">// calling startForeground() before we ANR + stop it.</span><br><span class="line">static final int SERVICE_START_FOREGROUND_TIMEOUT = 5*1000;</span><br></pre></td></tr></table></figure><p>当Service的生命周期结束时，会调用serviceDoneExecutingLocked()方法，之前抛出的SERVICE_TIMEOUT_MSG消息在这个方法中会被清除。 如果在超时时间内，SERVICE_TIMEOUT_MSG没有被清除，那么，AMS.MainHandler就会响应这个消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void serviceDoneExecutingLocked(ServiceRecord r, boolean inDestroying,</span><br><span class="line">            boolean finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">                + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">                + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line">        r.executeNesting--;</span><br><span class="line">        <span class="keyword">if</span> (r.executeNesting &lt;= 0) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">                r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">                r.app.executingServices.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.app.executingServices.size() == 0) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                            <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                    mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);//清除SERVICE_TIMEOUT_MSG消息</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">                    // Need to re-evaluate whether the app still needs to be <span class="keyword">in</span> the foreground.</span><br><span class="line">                    <span class="keyword">for</span> (int i=r.app.executingServices.size()-1; i&gt;=0; i--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                            r.app.execServicesFg = <span class="literal">true</span>;</span><br><span class="line">                            <span class="built_in">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                .....</span><br></pre></td></tr></table></figure><p>AMS.MainHandler就会响应这个消息:<br>见<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">ActivityManagerService</a><br>本文是基于Android8.0的代码分析，与<a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a> 这篇文章这里的代码不一样。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final class MainHandler extends Handler &#123;</span><br><span class="line">       public MainHandler(Looper looper) &#123;</span><br><span class="line">           super(looper, null, <span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           switch (msg.what) &#123;</span><br><span class="line">           <span class="keyword">case</span> UPDATE_CONFIGURATION_MSG: &#123;</span><br><span class="line">               final ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">               Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj,</span><br><span class="line">                       msg.arg1);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> GC_BACKGROUND_PROCESSES_MSG: &#123;</span><br><span class="line">               synchronized (ActivityManagerService.this) &#123;</span><br><span class="line">                   performAppGcsIfAppropriateLocked();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;  </span><br><span class="line">               mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_TIMEOUT_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundTimeout((ServiceRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> SERVICE_FOREGROUND_CRASH_MSG: &#123;</span><br><span class="line">               mServices.serviceForegroundCrash((ProcessRecord)msg.obj);</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           <span class="keyword">case</span> DISPATCH_PENDING_INTENT_CANCEL_MSG: &#123;</span><br><span class="line">               RemoteCallbackList&lt;IResultReceiver&gt; callbacks</span><br><span class="line">                       = (RemoteCallbackList&lt;IResultReceiver&gt;)msg.obj;</span><br><span class="line">               int N = callbacks.beginBroadcast();</span><br><span class="line">               <span class="keyword">for</span> (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       callbacks.getBroadcastItem(i).send(Activity.RESULT_CANCELED, null);</span><br><span class="line">                   &#125; catch (RemoteException e) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               callbacks.finishBroadcast();</span><br><span class="line">           &#125; <span class="built_in">break</span>;</span><br><span class="line">           ......</span><br></pre></td></tr></table></figure></p><p>mServices是ActiveServices，又返回到ActiveService中进行处理:<br>serviceTimeout 的处理如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void serviceTimeout(ProcessRecord proc) &#123;</span><br><span class="line">    String anrMessage = null;</span><br><span class="line">    synchronized(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == 0 || proc.thread == null) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        final long now = SystemClock.uptimeMillis();</span><br><span class="line">        final long maxTime =  now -</span><br><span class="line">                (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line">        ServiceRecord timeout = null;</span><br><span class="line">        long nextTime = 0;</span><br><span class="line">        <span class="keyword">for</span> (int i=proc.executingServices.size()-1; i&gt;=0; i--) &#123;// 寻找运行超时的Service</span><br><span class="line">            ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeout != null &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123; // 判断执行Service超时的进程是否在最近运行进程列表，如果在，则输出<span class="built_in">log</span>到logcat和dumplog中，并记录anrMessage供弹框使用</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timeout executing service: "</span> + timeout);</span><br><span class="line">            StringWriter sw = new StringWriter();</span><br><span class="line">            PrintWriter pw = new FastPrintWriter(sw, <span class="literal">false</span>, 1024);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">"    "</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  //其他的三种情况分别如下，则继续等待监测20s或者200s</span><br><span class="line">        //a)如果Service超时，但是不在最近运行进程列表中</span><br><span class="line">        //b)如果Service不超时，且不在最近运行进程列表中</span><br><span class="line">        //c)如果Service不超时，且在最近运进程列表中</span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">        mAm.mAppErrors.appNotResponding(proc, null, null, <span class="literal">false</span>, anrMessage);//ANR的弹框处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述方法会找到当前进程已经超时的Service，经过一些判定后，决定要报告ANR，最终调用AMS.appNotResponding()方法。 走到这一步，ANR机制已经完成了监测报告任务，剩下的任务就是ANR结果的输出，我们称之为ANR的报告机制。 ANR的报告机制是通过AMS.appNotResponding()完成的，Broadcast和InputEvent类型的ANR最终也都会调用这个方法，我们后文再详细展开。</p><p>至此，我们分析了Service的ANR机制：</p><p>通过定时消息跟踪Service的运行，当定时消息被响应时，说明Service还没有运行完成，这就意味着Service ANR。</p><h4 id="Broadcast处理超时"><a href="#Broadcast处理超时" class="headerlink" title="Broadcast处理超时"></a>Broadcast处理超时</h4><p>应用程序可以注册广播接收器，实现BroadcastReceiver.onReceive()方法来完成对广播的处理。通常，这个方法是在主线程执行的，Android限定它执行时间不能超过10秒，否则，就会引发ANR。</p><p>onReceive()也可以调度在其他线程执行，通过Context.registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)这个方法注册广播接收器， 可以指定一个处理的Handler，将onReceive()调度在非主线程执行。</p><p>这里先把问题抛出来了：</p><blockquote><p>Android如何将广播投递给各个应用程序？<br>Android如何检测广播处理超时？</p></blockquote><p>广播消息的调度<br>AMS维护了两个广播队列BroadcastQueue:</p><blockquote><p> foreground queue，前台队列的超时时间是10秒<br> background queue，后台队列的超时时间是60秒</p></blockquote><p>之所以有两个，就是因为要区分的不同超时时间。所有发送的广播都会进入到队列中等待调度，在发送广播时，可以通过Intent.FLAG_RECEIVER_FOREGROUND参数将广播投递到前台队列。 AMS线程会不断地从队列中取出广播消息派发到各个接收器(BroadcastReceiver)。当要派发广播时，AMS会调用BroadcastQueue.scheduleBroadcastsLocked()方法：</p><p><strong> 参见 Android中广播注册和发送机制分析 </strong></p><p>frameworks/base/services/core/java/com/android/server/am/BroadcastQueue.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">scheduleBroadcastsLocked</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this));</span><br><span class="line">    mBroadcastsScheduled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，往AMS线程的消息队列发送BROADCAST_INTENT_MSG消息，由此也可以看到真正派发广播的是AMS线程(system_server进程中的ActivityManager线程)。 由于上述方法可能被并发调用，所以通过mBroadcastsScheduled这个变量来标识BROADCAST_INTENT_MSG是不是已经被AMS线程接收了，当已经抛出的消息还未被接受时，不需要重新抛出。 该消息被接收后的处理逻辑如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static final int BROADCAST_INTENT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG;</span><br><span class="line">static final int BROADCAST_TIMEOUT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG + 1;</span><br><span class="line"></span><br><span class="line">final BroadcastHandler mHandler;</span><br><span class="line"></span><br><span class="line">private final class BroadcastHandler extends Handler &#123;</span><br><span class="line">    public BroadcastHandler(Looper looper) &#123;</span><br><span class="line">        super(looper, null, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleMessage(Message msg) &#123;</span><br><span class="line">        switch (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                processNextBroadcast(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                synchronized (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 直接调用BroadcastQueue.processNextBroadcast()方法，fromMsg参数为true表示这是一次来自BROADCAST_INTENT_MSG消息的派发请求。 BroadcastQueue.processNextBroadcast()是派发广播消息最为核心的函数，代码量自然也不小，我们分成几个部分来分析：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分1：处理非串行广播消息</span><br><span class="line">final ActivityManagerService mService;//mService是ActivityManagerService</span><br><span class="line">   .....</span><br><span class="line">final void processNextBroadcast(boolean fromMsg) &#123;</span><br><span class="line">       synchronized(mService) &#123;</span><br><span class="line">           BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                   + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                   + mParallelBroadcasts.size() + <span class="string">" parallel broadcasts, "</span></span><br><span class="line">                   + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">           mService.updateCpuStats();//更新CPU状态信息</span><br><span class="line"></span><br><span class="line">           //1. 更新mBroadcastsScheduled 标志状态</span><br><span class="line">           <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">               mBroadcastsScheduled = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // First, deliver any non-serialized broadcasts right away.</span><br><span class="line">           //2. 处理并行广播</span><br><span class="line">           <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; 0) &#123;</span><br><span class="line">               r = mParallelBroadcasts.remove(0);</span><br><span class="line">               r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">               r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                   Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">                   Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                       createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                       System.identityHashCode(r));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final int N = r.receivers.size();</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">               <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                   Object target = r.receivers.get(i);</span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                           <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                           + target + <span class="string">": "</span> + r);</span><br><span class="line">                   deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="literal">false</span>, i);</span><br><span class="line">               &#125;</span><br><span class="line">               addBroadcastToHistoryLocked(r);</span><br><span class="line">               <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                       + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // Now take care of the next serialized one...</span><br><span class="line"></span><br><span class="line">           // If we are waiting <span class="keyword">for</span> a process to come up to handle the next</span><br><span class="line">           // broadcast, <span class="keyword">then</span> <span class="keyword">do</span> nothing at this point.  Just <span class="keyword">in</span> <span class="keyword">case</span>, we</span><br><span class="line">           // check that the process we<span class="string">'re waiting for still exists.</span></span><br><span class="line"><span class="string">           //3. 处理阻塞广播</span></span><br><span class="line"><span class="string">           if (mPendingBroadcast != null) &#123;</span></span><br><span class="line"><span class="string">               if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                       "processNextBroadcast [" + mQueueName + "]: waiting for "</span></span><br><span class="line"><span class="string">                       + mPendingBroadcast.curApp);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               boolean isDead; // isDead表示当前广播消息的进程的存活状态</span></span><br><span class="line"><span class="string">               synchronized (mService.mPidsSelfLocked) &#123;</span></span><br><span class="line"><span class="string">                   ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span></span><br><span class="line"><span class="string">                   isDead = proc == null || proc.crashing;</span></span><br><span class="line"><span class="string">               &#125;</span></span><br><span class="line"><span class="string">               if (!isDead) &#123;</span></span><br><span class="line"><span class="string">                   // It'</span>s still alive, so keep waiting// 如果还活着，则返回该函数，继续等待下次派发</span><br><span class="line">                   <span class="built_in">return</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                           + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                           + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                   mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                   mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                   mPendingBroadcast = null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //未完待续</span><br></pre></td></tr></table></figure></p><p>第一个部分是处理非”串行广播消息”，有以下几个步骤：</p><ol><li><p>设置mBroadcastsScheduled。该变量在前文说过，是对BROADCAST_INTENT_MSG进行控制。 如果是响应BROADCAST_INTENT_MSG 的派发调用，则将mBroadcastsScheduled设为false， 表示本次 BROADCAST_INTENT_MSG 已经处理完毕，可以继续抛出下一次 BROADCAST_INTENT_MSG消息了</p></li><li><p>处理”并行广播消息”。广播接受器有”动态”和”静态”之分，通过Context.registerReceiver()注册的广播接收器为”动态”的，通过AndroidManifest.xml注册的广播接收器为”静态”的。 广播消息有”并行”和”串行”之分，”并行广播消息”都会派发到”动态”接收器，”串行广播消息”则会根据实际情况派发到两种接收器。 我们先不去探究Android为什么这么设计，只关注这两种广播消息派发的区别。在BroadcastQueue维护着两个队列：</p></li></ol><blockquote><p> mParallelBroadcasts，”并行广播消息”都会进入到此队列中排队。”并行广播消息”可以一次性派发完毕，即在一个循环中将广播派发到所有的”动态”接收器</p></blockquote><blockquote><p> mOrderedBroadcasts，”串行广播消息”都会进入到此队列中排队。”串行广播消息”需要轮侯派发，当一个接收器处理完毕后，会再抛出BROADCAST_INTENT_MSG消息， 再次进入BroadcastQueue.processNextBroadcast()处理下一个</p></blockquote><ol start="3"><li>处理阻塞的广播消息。有时候会存在一个广播消息派发不出去的情况，这个广播消息会保存在mPendingBroadcast变量中。新一轮的派发启动时，会判断接收该消息的进程是否还活着， 如果接收进程还活着，那么就继续等待。否则，就放弃这个广播消息</li></ol><p>接下来是最为复杂的一部分，处理”串行广播消息”，ANR监测机制只在这一类广播消息中才发挥作用，也就是说”并行广播消息”是不会发生ANR的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分2：从队列中取出“串行广播消息”</span><br><span class="line">            boolean looped = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">do</span> &#123;//处理有序广播</span><br><span class="line">                <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;//有序广播都处理完了时</span><br><span class="line">                    // No more broadcasts pending, so all <span class="keyword">done</span>!</span><br><span class="line">                    mService.scheduleAppGcsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                        // If we had finished the last ordered broadcast, <span class="keyword">then</span></span><br><span class="line">                        // make sure all processes have correct oom and <span class="built_in">sched</span></span><br><span class="line">                        // adjustments.</span><br><span class="line">                        mService.updateOomAdjLocked();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                r = mOrderedBroadcasts.get(0);</span><br><span class="line">                boolean forceReceive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                // 1. 广播消息的第一个ANR监测机制</span><br><span class="line">                // Ensure that even <span class="keyword">if</span> something goes awry with the timeout</span><br><span class="line">                // detection, we catch <span class="string">"hung"</span> broadcasts here, discard them,</span><br><span class="line">                // and <span class="built_in">continue</span> to make progress.</span><br><span class="line">                //</span><br><span class="line">                // This is only <span class="keyword">done</span> <span class="keyword">if</span> the system is ready so that PRE_BOOT_COMPLETED</span><br><span class="line">                // receivers don<span class="string">'t get executed with timeouts. They'</span>re intended <span class="keyword">for</span></span><br><span class="line">                // one time heavy lifting after system upgrades and can take</span><br><span class="line">                // significant amounts of time.</span><br><span class="line">                int numReceivers = (r.receivers != null) ? r.receivers.size() : 0;</span><br><span class="line">                <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; 0) &#123;</span><br><span class="line">                    long now = SystemClock.uptimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> ((numReceivers &gt; 0) &amp;&amp;</span><br><span class="line">                            (now &gt; r.dispatchTime + (2*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                                + <span class="string">" now="</span> + now</span><br><span class="line">                                + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                                + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                                + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                                + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                                + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                                + <span class="string">" state="</span> + r.state);</span><br><span class="line">                        broadcastTimeoutLocked(<span class="literal">false</span>); // forcibly finish this broadcast</span><br><span class="line">                        forceReceive = <span class="literal">true</span>;</span><br><span class="line">                        r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"processNextBroadcast("</span></span><br><span class="line">                            + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                            + r.state + <span class="string">")"</span>);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 2. 判断该广播消息是否处理完毕</span><br><span class="line">                <span class="keyword">if</span> (r.receivers == null || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                        || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                    // No more receivers <span class="keyword">for</span> this broadcast!  Send the final</span><br><span class="line">                    // result <span class="keyword">if</span> requested...</span><br><span class="line">                    <span class="keyword">if</span> (r.resultTo != null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                    <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                    + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                            performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                                new Intent(r.intent), r.resultCode,</span><br><span class="line">                                r.resultData, r.resultExtras, <span class="literal">false</span>, <span class="literal">false</span>, r.userId);</span><br><span class="line">                            // Set this to null so that the reference</span><br><span class="line">                            // (<span class="built_in">local</span> and remote) isn<span class="string">'t kept in the mBroadcastHistory.</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">                            r.resultTo = null;</span></span><br><span class="line"><span class="string">                            Slog.w(TAG, "Failure ["</span></span><br><span class="line"><span class="string">                                    + mQueueName + "] sending broadcast result of "</span></span><br><span class="line"><span class="string">                                    + r.intent, e);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        &#125;</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Cancelling BROADCAST_TIMEOUT_MSG");</span></span><br><span class="line"><span class="string">                    cancelBroadcastTimeoutLocked();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                            "Finished with ordered broadcast " + r);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    // ... and on to the next...</span></span><br><span class="line"><span class="string">                    addBroadcastToHistoryLocked(r);</span></span><br><span class="line"><span class="string">                    if (r.intent.getComponent() == null &amp;&amp; r.intent.getPackage() == null</span></span><br><span class="line"><span class="string">                            &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) &#123;</span></span><br><span class="line"><span class="string">                        // This was an implicit broadcast... let'</span>s record it <span class="keyword">for</span> posterity.</span><br><span class="line">                        mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                                r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mOrderedBroadcasts.remove(0);</span><br><span class="line">                    r = null;</span><br><span class="line">                    looped = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (r == null);</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure><p>这部分是一个do-while循环，每次都从mOrderedBroadcasts队列中取出第一条广播消息进行处理。第一个Broadcast ANR监测机制千呼万唤总算是出现了：</p><p>判定当前时间是否已经超过了r.dispatchTime + 2×mTimeoutPeriod×numReceivers:</p><p>dispatchTime表示这一系列广播消息开始派发的时间。“串行广播消息”是逐个接收器派发的，一个接收器处理完毕后，才开始处理下一个消息派发。 开始派发到第一个接收器的时间就是dispatchTime。dispatchTime需要开始等广播消息派发以后才会设定，也就是说，第一次进入processNextBroadcast()时， dispatchTime=0,并不会进入该条件判断</p><p>mTimeoutPeriod由当前BroadcastQueue的类型决定(forground为10秒，background为60秒)。这个时间在初始化BroadcastQueue的时候就设置好了， 本意是限定每一个Receiver处理广播的时间，这里利用它做了一个超时计算</p><p>假设一个广播消息有2个接受器，mTimeoutPeriod是10秒，当2×10×2=40秒后，该广播消息还未处理完毕，就调用broadcastTimeoutLocked()方法， 这个方法会判断当前是不是发生了ANR，我们后文再分析。</p><p>如果广播消息是否已经处理完毕，则从mOrderedBroadcasts中移除，重新循环，处理下一条;否则，就会跳出循环。</p><p>以上代码块完成的主要任务是从队列中取一条“串行广播消息”，接下来就准备派发了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分3：串行广播消息的第二个ANR监测机制</span><br><span class="line">            // Get the next receiver...</span><br><span class="line">            int recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">            // Keep track of when this receiver started, and make sure there</span><br><span class="line">            // is a timeout message pending to <span class="built_in">kill</span> it <span class="keyword">if</span> need be.</span><br><span class="line">            r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (recIdx == 0) &#123;</span><br><span class="line">                r.dispatchTime = r.receiverTime;</span><br><span class="line">                r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                    Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),</span><br><span class="line">                        System.identityHashCode(r));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">                long timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">                setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p><p>取出“串行广播消息”后，一旦要开始派发，第二个ANR检测机制就出现了。mPendingBroadcastTimeoutMessage变量用于标识当前是否有阻塞的超时消息， 如果没有则调用BroadcastQueue.setBroadcastTimeoutLocked()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final void setBroadcastTimeoutLocked(long timeoutTime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过设置一个定时消息BROADCAST_TIMEOUT_MSG来跟踪当前广播消息的执行情况，这种超时监测机制跟Service ANR很类似，也是抛到AMS线程的消息队列。 如果所有的接收器都处理完毕了，则会调用cancelBroadcastTimeoutLocked()清除该消息;否则，该消息就会响应，并调用broadcastTimeoutLocked()， 这个方法在第一种ANR监测机制的时候调用过，第二种ANR监测机制也会调用，我们留到后文分析。</p><p>继续分析processNextBroadcast函数<br>设置完定时消息后，就开始派发广播消息了，首先是“动态”接收器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分4： 向“动态”接收器派发广播消息</span><br><span class="line">            final BroadcastOptions brOptions = r.options;</span><br><span class="line">            final Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">            // 动态接收器的类型都是BroadcastFilter</span><br><span class="line">            <span class="keyword">if</span> (nextReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">                // Simple <span class="keyword">case</span>: this is a registered receiver who gets</span><br><span class="line">                // a direct call.</span><br><span class="line">                BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering ordered ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + filter + <span class="string">": "</span> + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line">                <span class="keyword">if</span> (r.receiver == null || !r.ordered) &#123;</span><br><span class="line">                    // The receiver has already finished, so schedule to</span><br><span class="line">                    // process the next one.</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                            + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                        scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                                brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //未完待续</span><br></pre></td></tr></table></figure></p><p>“动态”接收器的载体进程一般是处于运行状态的，所以向这种类型的接收器派发消息相对简单，调用BroadcastQueue.deliverToRegisteredReceiverLocked()完成接下来的工作。 但“静态”接收器是在AndroidManifest.xml中注册的，派发的时候，可能广播接收器的载体进程还没有启动，所以，这种场景会复杂很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><span class="line">// processNextBroadcast部分5： 向“静态”接收器派发广播消息</span><br><span class="line">            // Hard <span class="keyword">case</span>: need to instantiate the receiver, possibly</span><br><span class="line">            // starting its application process to host it.</span><br><span class="line">            //// 静态接收器的类型都是 ResolveInfo</span><br><span class="line">            ResolveInfo info =</span><br><span class="line">                (ResolveInfo)nextReceiver;</span><br><span class="line">            ComponentName component = new ComponentName(</span><br><span class="line">                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                    info.activityInfo.name);</span><br><span class="line"></span><br><span class="line">            boolean skip = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp;</span><br><span class="line">                    (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">                    info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                            &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            // 1. 权限检查</span><br><span class="line">            int perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                    r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                    info.activityInfo.exported);</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                            + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">                &#125;</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.permission != null) &#123;</span><br><span class="line">                final int opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line">                <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                                r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                            + r.intent.toString()</span><br><span class="line">                            + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                            + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                    info.activityInfo.permission)</span><br><span class="line">                            + <span class="string">" due to registered receiver "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">                r.requiredPermissions != null &amp;&amp; r.requiredPermissions.length &gt; 0) &#123;</span><br><span class="line">                <span class="keyword">for</span> (int i = 0; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                    String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                    try &#123;</span><br><span class="line">                        perm = AppGlobals.getPackageManager().</span><br><span class="line">                                checkPermission(requiredPermission,</span><br><span class="line">                                        info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                        UserHandle</span><br><span class="line">                                                .getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                    <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                            &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString()</span><br><span class="line">                                + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                requiredPermission)</span><br><span class="line">                                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent + <span class="string">" to "</span></span><br><span class="line">                        + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                        r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isSingleton = <span class="literal">false</span>;</span><br><span class="line">            try &#123;</span><br><span class="line">                isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                        info.activityInfo.applicationInfo,</span><br><span class="line">                        info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">            &#125; catch (SecurityException e) &#123;</span><br><span class="line">                Slog.w(TAG, e.getMessage());</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                        android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid)</span><br><span class="line">                                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                            + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.isInstantApp()</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" Instant Apps do not support manifest receivers"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip &amp;&amp; r.callerInstantApp</span><br><span class="line">                    &amp;&amp; (info.activityInfo.flags &amp; ActivityInfo.FLAG_VISIBLE_TO_INSTANT_APP) == 0</span><br><span class="line">                    &amp;&amp; r.callingUid != info.activityInfo.applicationInfo.uid) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Instant App Denial: receiving "</span></span><br><span class="line">                        + r.intent</span><br><span class="line">                        + <span class="string">" to "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requires receiver have visibleToInstantApps set"</span></span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                r.manifestCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.manifestSkipCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r.curApp != null &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">                // If the target process is crashing, just skip it.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                        + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">                skip = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                boolean isAvailable = <span class="literal">false</span>;</span><br><span class="line">                try &#123;</span><br><span class="line">                    isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                            info.activityInfo.packageName,</span><br><span class="line">                            UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // all such failures mean we skip this receiver</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                            + info.activityInfo.packageName, e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!isAvailable) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                            <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                            + info.activityInfo.applicationInfo.uid</span><br><span class="line">                            + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // If permissions need a review before any of the app components can run, we drop</span><br><span class="line">            // the broadcast and <span class="keyword">if</span> the calling app is <span class="keyword">in</span> the foreground and the broadcast is</span><br><span class="line">            // explicit we launch the review UI passing it a pending intent to send the skipped</span><br><span class="line">            // broadcast.</span><br><span class="line">            <span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; !skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">                        info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                                info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">                    skip = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // This is safe to <span class="keyword">do</span> even <span class="keyword">if</span> we are skipping the broadcast, and we need</span><br><span class="line">            // this information now to evaluate whether it is going to be allowed to run.</span><br><span class="line">            final int receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line">            // If it<span class="string">'s a singleton, it needs to be the same app or a special app</span></span><br><span class="line"><span class="string">            if (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span></span><br><span class="line"><span class="string">                    &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span></span><br><span class="line"><span class="string">                info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, 0);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 2. 获取接收器所在的进程</span></span><br><span class="line"><span class="string">            String targetProcess = info.activityInfo.processName;</span></span><br><span class="line"><span class="string">            ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span></span><br><span class="line"><span class="string">                    info.activityInfo.applicationInfo.uid, false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            if (!skip) &#123;</span></span><br><span class="line"><span class="string">                final int allowed = mService.getAppStartModeLocked(</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName,</span></span><br><span class="line"><span class="string">                        info.activityInfo.applicationInfo.targetSdkVersion, -1, true, false);</span></span><br><span class="line"><span class="string">                if (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span></span><br><span class="line"><span class="string">                    // We won'</span>t allow this receiver to be launched <span class="keyword">if</span> the app has been</span><br><span class="line">                    // completely disabled from launches, or it was not explicitly sent</span><br><span class="line">                    // to it and the app is <span class="keyword">in</span> a state that should not receive it</span><br><span class="line">                    // (depending on how getAppStartModeLocked has determined that).</span><br><span class="line">                    <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != 0)</span><br><span class="line">                            || (r.intent.getComponent() == null</span><br><span class="line">                                &amp;&amp; r.intent.getPackage() == null</span><br><span class="line">                                &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                                        &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == 0)</span><br><span class="line">                                &amp;&amp; !isSignaturePerm(r.requiredPermissions))) &#123;</span><br><span class="line">                        mService.addBackgroundCheckViolationLocked(r.intent.getAction(),</span><br><span class="line">                                component.getPackageName());</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                                + r.intent + <span class="string">" to "</span></span><br><span class="line">                                + component.flattenToShortString());</span><br><span class="line">                        skip = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">                skip = !mService.isAutoStartAllowed(info.activityInfo.applicationInfo.uid, info.activityInfo.applicationInfo.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                        + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line">                r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">                r.receiver = null;</span><br><span class="line">                r.curFilter = null;</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">            r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">            r.curComponent = component;</span><br><span class="line">            r.curReceiver = info.activityInfo;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">                Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                        + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (brOptions != null &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; 0) &#123;</span><br><span class="line">                scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                        brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Broadcast is being executed, its package can<span class="string">'t be stopped.</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                AppGlobals.getPackageManager().setPackageStoppedState(</span></span><br><span class="line"><span class="string">                        r.curComponent.getPackageName(), false, UserHandle.getUserId(r.callingUid));</span></span><br><span class="line"><span class="string">            &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            &#125; catch (IllegalArgumentException e) &#123;</span></span><br><span class="line"><span class="string">                Slog.w(TAG, "Failed trying to unstop package "</span></span><br><span class="line"><span class="string">                        + r.curComponent.getPackageName() + ": " + e);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // 3. 进程已经启动</span></span><br><span class="line"><span class="string">            // Is this receiver'</span>s application already running?</span><br><span class="line">            <span class="keyword">if</span> (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                            info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                    processCurBroadcastLocked(r, app);</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                          + r.curComponent, e);</span><br><span class="line">                &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                    Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                            + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line">                    // If some unexpected exception happened, just skip</span><br><span class="line">                    // this broadcast.  At this point we are not <span class="keyword">in</span> the call</span><br><span class="line">                    // from a client, so throwing an exception out from here</span><br><span class="line">                    // will crash the entire system instead of just whoever</span><br><span class="line">                    // sent the broadcast.</span><br><span class="line">                    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                            r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                    scheduleBroadcastsLocked();</span><br><span class="line">                    // We need to reset the state <span class="keyword">if</span> we failed to start the receiver.</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                    <span class="built_in">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // If a dead object exception was thrown -- fall through to</span><br><span class="line">                // restart the application.</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 进程还未启动</span><br><span class="line">            // Not running -- get it started, to be executed when the app comes up.</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Need to start app ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                    info.activityInfo.applicationInfo, <span class="literal">true</span>,</span><br><span class="line">                    r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                    <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                    (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, <span class="literal">false</span>, <span class="literal">false</span>))</span><br><span class="line">                            == null) &#123;</span><br><span class="line">                // Ah, this recipient is unavailable.  Finish it <span class="keyword">if</span> necessary,</span><br><span class="line">                // and mark the broadcast record as ready <span class="keyword">for</span> the next.</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                        + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="built_in">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 5. 进程启动失败</span><br><span class="line">            mPendingBroadcast = r;</span><br><span class="line">            mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // processNextBroadcast完</span><br></pre></td></tr></table></figure><blockquote><p>1.“静态”接收器是ResolveInfo，需要通过PackageManager获取包信息，进行权限检查。权限检查的内容非常庞大，此处不表。</p></blockquote><blockquote><p>2.经过一系列复杂的权限检查后，终于可以向目标接收器派发了。通过AMS.getProcessRecordLocked()获取广播接收器的进程信息</p></blockquote><blockquote><p>3.如果app.thread ！= null，则进程已经启动，就可以调用BroadcastQueue.processCurBroadcastLocked()进行接下来的派发处理了</p></blockquote><blockquote><p>4.如果进程还没有启动，则需要通过AMS.startProcessLocked()来启动进程，当前消息并未派发，调用BroadcastQueue.scheduleBroadcastsLocked()进入下一次的调度</p></blockquote><blockquote><p>5.如果进程启动失败了，则当前消息记录成mPendingBroadcast，即阻塞的广播消息，等待下一次调度时处理</p></blockquote><p>庞大的processNextBroadcast()终于完结了，它的功能就是对广播消息进行调度，该方法被设计得十分复杂而精巧，用于应对不同的广播消息和接收器的处理。</p><p>广播消息的跨进程传递调度是完成了，接下来，我们就来分析被调度广播消息如何到达应用程序。上文的分析中，最终有两个方法将广播消息派发出去： BroadcastQueue.deliverToRegisteredReceiverLocked() 和BroadcastQueue.processCurBroadcastLocked()。</p><p>我们先不展开这两个函数的逻辑，试想要将广播消息的从AMS线程所在的system_server进程传递到应用程序的进程，该怎么实现？ 自然需要用到跨进程调用，Android中最常规的手段就是Binder机制。没错，广播消息派发到应用进程就是这么玩的。</p><p>对于应用程序已经启动(app.thread != null)的情况，会通过IApplicationThread发起跨进程调用， 调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.ApplicationThread.scheduleReceiver()</span><br><span class="line">└── ActivityThread.handleReceiver()</span><br><span class="line">    └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure></p><pre><code>对于应用程序还未启动的情况，会调用IIntentReceiver发起跨进程调用，应用进程的实现在LoadedApk.ReceiverDispatcher.IntentReceiver 中， 调用关系如下：</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoadedApk.ReceiverDispatcher.IntentReceiver.performReceive()</span><br><span class="line">└── LoadedApk.ReceiverDispatcher.performReceiver()</span><br><span class="line">    └── LoadedApk.ReceiverDispatcher.Args.run()</span><br><span class="line">        └── BroadcastReceiver.onReceive()</span><br></pre></td></tr></table></figure><p>最终，都会调用到BroadcastReceiver.onReceive()，在应用进程执行接收广播消息的具体动作。 对于“串行广播消息”而言，执行完了以后，还需要通知system_server进程，才能继续将广播消息派发到下一个接收器，这又需要跨进程调用了。 应用进程在处理完广播消息后，即在BroadcastReceiver.onReceive()执行完毕后，会调用BroadcastReceiver.PendingResult.finish()， 接下来的调用关系如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReceiver.PendingResult.finish()</span><br><span class="line">└── BroadcastReceiver.PendingResult.sendFinished()</span><br><span class="line">    └── IActivityManager.finishReceiver()</span><br><span class="line">        └── ActivityManagerService.finishReceiver()</span><br><span class="line">            └── BroadcastQueue.processNextBroadcat()</span><br></pre></td></tr></table></figure></p><p>通过IActivityManager发起了一个从应用进程到system_server进程的调用，最终在AMS线程中，又走到了BroadcastQueue.processNextBroadcat(), 开始下一轮的调度。</p><p>broadcastTimeoutLocked()方法<br>前文说过，两种ANR机制最终都会调用BroadcastQueue.broadcastTimeoutLocked()方法， 第一种ANR监测生效时，会将fromMsg设置为false;第二种ANR监测生效时，会将fromMsg参数为True时，表示当前正在响应BROADCAST_TIMEOUT_MSG消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">final void broadcastTimeoutLocked(boolean fromMsg) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;// 1. 设置mPendingBroadcastTimeoutMessage</span><br><span class="line">            mPendingBroadcastTimeoutMessage = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOrderedBroadcasts.size() == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 判断第二种ANR机制是否超时</span><br><span class="line">        long now = SystemClock.uptimeMillis();</span><br><span class="line">        BroadcastRecord r = mOrderedBroadcasts.get(0);</span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">                // Only process broadcast timeouts <span class="keyword">if</span> the system is ready. That way</span><br><span class="line">                // PRE_BOOT_COMPLETED broadcasts can<span class="string">'t timeout as they are intended</span></span><br><span class="line"><span class="string">                // to do heavy lifting for system up.</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            long timeoutTime = r.receiverTime + mTimeoutPeriod;</span></span><br><span class="line"><span class="string">            if (timeoutTime &gt; now) &#123;</span></span><br><span class="line"><span class="string">                // We can observe premature timeouts because we do not cancel and reset the</span></span><br><span class="line"><span class="string">                // broadcast timeout message after each receiver finishes.  Instead, we set up</span></span><br><span class="line"><span class="string">                // an initial timeout then kick it down the road a little further as needed</span></span><br><span class="line"><span class="string">                // when it expires.</span></span><br><span class="line"><span class="string">                if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span></span><br><span class="line"><span class="string">                        "Premature timeout ["</span></span><br><span class="line"><span class="string">                        + mQueueName + "] @ " + now + ": resetting BROADCAST_TIMEOUT_MSG for "</span></span><br><span class="line"><span class="string">                        + timeoutTime);</span></span><br><span class="line"><span class="string">                setBroadcastTimeoutLocked(timeoutTime);</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        BroadcastRecord br = mOrderedBroadcasts.get(0);</span></span><br><span class="line"><span class="string">        if (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span></span><br><span class="line"><span class="string">            // In this case the broadcast had already finished, but we had decided to wait</span></span><br><span class="line"><span class="string">            // for started services to finish as well before going on.  So if we have actually</span></span><br><span class="line"><span class="string">            // waited long enough time timeout the broadcast, let'</span>s give up on the whole thing</span><br><span class="line">            // and just move on to the next.</span><br><span class="line">            Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + (br.curComponent != null</span><br><span class="line">                    ? br.curComponent.flattenToShortString() : <span class="string">"(null)"</span>));</span><br><span class="line">            br.curComponent = null;</span><br><span class="line">            br.state = BroadcastRecord.IDLE;</span><br><span class="line">            processNextBroadcast(<span class="literal">false</span>);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Timeout of broadcast "</span> + r + <span class="string">" - receiver="</span> + r. receiver</span><br><span class="line">                + <span class="string">", started "</span> + (now - r.receiverTime) + <span class="string">"ms ago"</span>);</span><br><span class="line">        r.receiverTime = now;</span><br><span class="line">        r.anrCount++;</span><br><span class="line"></span><br><span class="line">        ProcessRecord app = null;</span><br><span class="line">        String anrMessage = null;</span><br><span class="line"></span><br><span class="line">        Object curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &gt; 0) &#123;</span><br><span class="line">            curReceiver = r.receivers.get(r.nextReceiver-1);</span><br><span class="line">            r.delivery[r.nextReceiver-1] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curReceiver = r.curReceiver;</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Receiver during timeout of "</span> + r + <span class="string">" : "</span> + curReceiver);</span><br><span class="line">        logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (curReceiver != null &amp;&amp; curReceiver instanceof BroadcastFilter) &#123;</span><br><span class="line">            BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">            <span class="keyword">if</span> (bf.receiverList.pid != 0</span><br><span class="line">                    &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">                synchronized (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                    app = mService.mPidsSelfLocked.get(</span><br><span class="line">                            bf.receiverList.pid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app = r.curApp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != null) &#123;</span><br><span class="line">            anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast == r) &#123;</span><br><span class="line">            mPendingBroadcast = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 已经超时，则结束对当前接收器，开始新一轮调度</span><br><span class="line">        // Move on to the next receiver.</span><br><span class="line">        finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                r.resultExtras, r.resultAbort, <span class="literal">false</span>);</span><br><span class="line">        scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">        // 4. 抛出绘制ANR对话框的消息</span><br><span class="line">        <span class="keyword">if</span> (anrMessage != null) &#123;</span><br><span class="line">            // Post the ANR to the handler since we <span class="keyword">do</span> not want to process ANRs <span class="keyword">while</span></span><br><span class="line">            // potentially holding our lock.</span><br><span class="line">            mHandler.post(new AppNotResponding(app, anrMessage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 1.mPendingBroadcastTimeoutMessage 标识是否存在未处理的BROADCAST_TIMEOUT_MSG 消息， 将其设置成false，允许继续抛出BROADCAST_TIMEOUT_MSG 消息</p></blockquote><blockquote><p> 2.每次将广播派发到接收器，都会将r.receiverTime 更新，如果判断当前还未超时，则又抛出一个 BROADCAST_TIMEOUT_MSG 息。正常情况下，所有接收器处理完毕后，才会清除 BROADCAST_TIMEOUT_MSG ;否则，每进行一次广播消息的调度，都会抛出 BROADCAST_TIMEOUT_MSG 消息</p></blockquote><blockquote><p> 3.判断已经超时了，说明当前的广播接收器还未处理完毕，则结束掉当前的接收器，开始新一轮广播调度</p></blockquote><blockquote><p> 4.最终，发出绘制ANR对话框的消息</p></blockquote><p>至此，我们回答了前文提出的两个问题:</p><p>AMS维护着广播队列BroadcastQueue，AMS线程不断从队列中取出消息进行调度，完成广播消息的派发。 在派发“串行广播消息”时，会抛出一个定时消息 BROADCAST_TIMEOUT_MSG ，在广播接收器处理完毕后，AMS会将定时消息清除。 如果BROADCAST_TIMEOUT_MSG得到了响应，就会判断是否广播消息处理超时，最终通知ANR的发生。</p><h4 id="Input处理超时"><a href="#Input处理超时" class="headerlink" title="Input处理超时"></a>Input处理超时</h4><p>应用程序可以接收输入事件(按键、触屏、轨迹球等)，当5秒内没有处理完毕时，则会引发ANR。</p><p>如果Broadcast ANR一样，我们抛出Input ANR的几个问题：</p><blockquote><ol><li>输入事件经历了一些什么工序才能被派发到应用的界面？</li><li>如何检测到输入时间处理超时</li></ol></blockquote><p>输入事件最开始由硬件设备(譬如按键或触摸屏幕)发起，Android有一套输入子系统来发现各种输入事件， 这些事件最终都会被<a href="https://android.googlesource.com/platform/frameworks/native/+/master/services/inputflinger/InputDispatcher.cpp" target="_blank" rel="noopener">InputDispatcher</a>分发到各个需要接收事件的窗口。 那么，窗口如何告之InputDispatcher自己需要处理输入事件呢？Android通过InputChannel 连接InputDispatcher和窗口，InputChannel其实是封装后的Linux管道(Pipe)。 每一个窗口都会有一个独立的InputChannel，窗口需要将这个InputChannel注册到InputDispatcher中:</p><blockquote><p>frameworks/native/services/inputflinger/InputDispatcher.cpp</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_REGISTRATION</span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ registerInputChannel - monitor=%s"</span>, inputChannel-&gt;getName().string(),</span><br><span class="line">            toString(monitor));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getConnectionIndexLocked(inputChannel) &gt;= 0) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Attempted to register already registered input channel '%s'"</span>,</span><br><span class="line">                    inputChannel-&gt;getName().string());</span><br><span class="line">            <span class="built_in">return</span> BAD_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        int fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</span><br><span class="line">    &#125; // release lock</span><br><span class="line"></span><br><span class="line">    // Wake the looper because some connections have changed.</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="built_in">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于InputDispatcher而言，每注册一个InputChannel都被视为一个Connection，通过文件描述符来区别。InputDispatcher是一个消息处理循环，当有新的Connection时，就需要唤醒消息循环队列进行处理。</p><p>输入事件的类型有很多，按键、轨迹球、触屏等，Android对这些事件进行了分类，处理这些事件的窗口也被赋予了一个类型 (targetType)：Foucused或Touched ，如果当前输入事件是按键类型，则寻找 Focused类型的窗口;如果当前输入事件类型是触摸类型，则寻找Touched类型的窗口。 InputDispatcher需要经过以下复杂的调用关系，才能把一个输入事件派发出去(调用关系以按键事件为例，触屏事件的调用关系类似)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcherThread::threadLoop()</span><br><span class="line">└── InputDispatcher::dispatchOnce()</span><br><span class="line">    └── InputDispatcher::dispatchOnceInnerLocked()</span><br><span class="line">        └── InputDispatcher::dispatchKeyLocked()</span><br><span class="line">            └── InputDispatcher::dispatchEventLocked()</span><br><span class="line">                └── InputDispatcher::prepareDispatchCycleLocked()</span><br><span class="line">                    └── InputDispatcher::enqueueDispatchEntriesLocked()</span><br><span class="line">                        └── InputDispatcher::startDispatchCycleLocked()</span><br><span class="line">                            └── InputPublisher::publishKeyEvent()</span><br></pre></td></tr></table></figure><p>具体每个函数的实现逻辑此处不表。我们提炼出几个关键点：</p><blockquote><ol><li>InputDispatcherThread是一个线程，它处理一次消息的派发</li><li>输入事件作为一个消息，需要排队等待派发，每一个Connection都维护两个队列：<br>outboundQueue: 等待发送给窗口的事件。每一个新消息到来，都会先进入到此队列<br>waitQueue: 已经发送给窗口的事件</li><li>publishKeyEvent完成后，表示事件已经派发了，就将事件从outboundQueue挪到了waitQueue</li></ol></blockquote><p>事件经过这么一轮处理，就算是从InputDispatcher派发出去了，但事件是不是被窗口收到了，还需要等待接收方的“finished”通知。 在向InputDispatcher 注册InputChannel 的时候，同时会注册一个回调函数handleReceiveCallback():</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">int InputDispatcher::handleReceiveCallback(int fd, int events, void* data) &#123;</span><br><span class="line">    InputDispatcher* d = static_cast&lt;InputDispatcher*&gt;(data);</span><br><span class="line"></span><br><span class="line">    &#123; // acquire lock</span><br><span class="line">        AutoMutex _l(d-&gt;mLock);</span><br><span class="line"></span><br><span class="line">        ssize_t connectionIndex = d-&gt;mConnectionsByFd.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &lt; 0) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Received spurious receive callback for unknown input channel.  "</span></span><br><span class="line">                    <span class="string">"fd=%d, events=0x%x"</span>, fd, events);</span><br><span class="line">            <span class="built_in">return</span> 0; // remove the callback</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bool notify;</span><br><span class="line">        sp&lt;Connection&gt; connection = d-&gt;mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        <span class="keyword">if</span> (!(events &amp; (ALOOPER_EVENT_ERROR | ALOOPER_EVENT_HANGUP))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(events &amp; ALOOPER_EVENT_INPUT)) &#123;</span><br><span class="line">                ALOGW(<span class="string">"channel '%s' ~ Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                        <span class="string">"events=0x%x"</span>, connection-&gt;getInputChannelName(), events);</span><br><span class="line">                <span class="built_in">return</span> 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nsecs_t currentTime = now();</span><br><span class="line">            bool gotOne = <span class="literal">false</span>;</span><br><span class="line">            status_t status;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                uint32_t seq;</span><br><span class="line">                bool handled;</span><br><span class="line">                status = connection-&gt;inputPublisher.receiveFinishedSignal(&amp;seq, &amp;handled);</span><br><span class="line">                <span class="keyword">if</span> (status) &#123;</span><br><span class="line">                    <span class="built_in">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;finishDispatchCycleLocked(currentTime, connection, seq, handled);</span><br><span class="line">                gotOne = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gotOne) &#123;</span><br><span class="line">                d-&gt;runCommandsLockedInterruptible();</span><br><span class="line">                <span class="keyword">if</span> (status == WOULD_BLOCK) &#123;</span><br><span class="line">                    <span class="built_in">return</span> 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notify = status != DEAD_OBJECT || !connection-&gt;monitor;</span><br><span class="line">            <span class="keyword">if</span> (notify) &#123;</span><br><span class="line">                ALOGE(<span class="string">"channel '%s' ~ Failed to receive finished signal.  status=%d"</span>,</span><br><span class="line">                        connection-&gt;getInputChannelName(), status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            // Monitor channels are never explicitly unregistered.</span><br><span class="line">            // We <span class="keyword">do</span> it automatically when the remote endpoint is closed so don<span class="string">'t warn</span></span><br><span class="line"><span class="string">            // about them.</span></span><br><span class="line"><span class="string">            notify = !connection-&gt;monitor;</span></span><br><span class="line"><span class="string">            if (notify) &#123;</span></span><br><span class="line"><span class="string">                ALOGW("channel '</span>%s<span class="string">' ~ Consumer closed input channel or an error occurred.  "</span></span><br><span class="line"><span class="string">                        "events=0x%x", connection-&gt;getInputChannelName(), events);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Unregister the channel.</span></span><br><span class="line"><span class="string">        d-&gt;unregisterInputChannelLocked(connection-&gt;inputChannel, notify);</span></span><br><span class="line"><span class="string">        return 0; // remove the callback</span></span><br><span class="line"><span class="string">    &#125; // release lock</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>当收到的status为OK时，会调用finishDispatchCycleLocked()来完成一个消息的处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::finishDispatchCycleLocked()</span><br><span class="line">└── InputDispatcher::onDispatchCycleFinishedLocked()</span><br><span class="line">    └── InputDispatcher::doDispatchCycleFinishedLockedInterruptible()</span><br><span class="line">        └── InputDispatcher::startDispatchCycleLocked()</span><br></pre></td></tr></table></figure><p>调用到doDispatchCycleFinishedLockedInterruptible() 方法时，会将已经成功派发的消息从waitQueue中移除， 进一步调用会 startDispatchCycleLocked开始派发新的事件。</p><p>至此，我们回答了第一个问题：</p><p>一个正常的输入事件会经过从outboundQueue挪到waitQueue的过程，表示消息已经派发出去;再经过从waitQueue中移除的过程，表示消息已经被窗口接收。InputDispatcher作为中枢，不停地在递送着输入事件，当一个事件无法得到处理的时候，InputDispatcher不能就此死掉啊，否则系统也太容易崩溃了。 InputDispatcher 的策略是放弃掉处理不过来的事件， 并发出通知(这个通知机制就是ANR)，继续进行下一轮消息的处理。</p><blockquote><p>理解输入事件分发模型，我们可以举一个生活中的例子：<br>每一个输入事件可以比做一个快递，InputDispatcher就像一个快递中转站，窗口就像是收件人，InputChannel就像是快递员。 所有快递都会经过中转站中处理，中转站需要知道每一个快递的收件人是谁，通过快递员将快递发送到具体的收件人。 这其中有很多场景导致快递不能及时送到：譬如联系不到收件人;快递很多，快递员会忙不过来;快递员受伤休假了等等… 这时候快递员就需要告知中转站：有快递无法及时送到了。中转站在收到快递员的通知后，一边继续派发其他快递，一边报告上级。</p></blockquote><p>在了解输入事件分发模型之后，我们可以见识一下ANR机制了。在派发事件时，dispatchKeyLocked()和dispatchMotionLocked()， 需要找到当前的焦点窗口 ,焦点窗口才是最终接收事 件的地方，找窗口的过程就会判断是否已经发生了ANR：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::findFocusedWindowTargetsLocked()</span><br><span class="line">InputDispatcher::findTouchedWindowTargetsLocked()</span><br><span class="line">└── InputDispatcher::handleTargetsNotReadyLocked()</span><br><span class="line">    └── InputDispatcher::onANRLocked()</span><br><span class="line">        └── InputDispatcher::doNotifyANRLockedInterruptible()</span><br><span class="line">            └── NativeInputManager::notifyANR()</span><br></pre></td></tr></table></figure><ul><li><p>首先，会调用findFocusedWindowTargetsLocked()或findTouchedWindowTargetsLocked()寻找接收输入事件的窗口。在找到窗口以后，会调用checkWindowReadyForMoreInputLocked() 检查窗口是否有能力再接收新的输入事件，会有一系列的场景阻碍事件的继续派发：</p><ul><li><p><strong>场景1:</strong> 窗口处于paused状态，不能处理输入事件“Waiting because the [targetType] window is paused.”</p></li><li><p><strong>场景2:</strong> 窗口还未向InputDispatcher注册，无法将事件派发到窗口“Waiting because the [targetType] window’s input channel is not registered with the input dispatcher. The window may be in the process of being removed.”</p></li><li><p><strong>场景3:</strong> 窗口和InputDispatcher的连接已经中断，即InputChannel不能正常工作“Waiting because the [targetType] window’s input connection is [status]. The window may be in the process of being removed.”</p></li><li><p><strong>场景4:</strong> InputChannel已经饱和，不能再处理新的事件“Waiting because the [targetType] window’s input channel is full. Outbound queue length: %d. Wait queue length: %d.”</p></li><li><p><strong>场景5:</strong> 对于按键类型(KeyEvent)的输入事件，需要等待上一个事件处理完毕“Waiting to send key event because the [targetType] window has not finished processing all of the input events that were previously delivered to it. Outbound queue length: %d. Wait queue length: %d.”</p></li><li><p><strong>场景6:</strong> 对于触摸类型(TouchEvent)的输入事件，可以立即派发到当前的窗口，因为TouchEvent都是发生在用户当前可见的窗口。但有一种情况，如果当前应用由于队列有太多的输入事件等待派发，导致发生了ANR，那TouchEvent事件就需要排队等待派发。“Waiting to send non-key event because the %s window has not finished processing certain input events that were delivered to it over %0.1fms ago. Wait queue length: %d. Wait queue head age: %0.1fms.”</p></li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">String8 InputDispatcher::checkWindowReadyForMoreInputLocked(nsecs_t currentTime,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle, const EventEntry* eventEntry,</span><br><span class="line">        const char* targetType) &#123;</span><br><span class="line">    // If the window is paused <span class="keyword">then</span> keep waiting.</span><br><span class="line">    <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;paused) &#123;</span><br><span class="line">        <span class="built_in">return</span> String8::format(<span class="string">"Waiting because the %s window is paused."</span>, targetType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the window<span class="string">'s connection is not registered then keep waiting.</span></span><br><span class="line"><span class="string">    ssize_t connectionIndex = getConnectionIndexLocked(windowHandle-&gt;getInputChannel());</span></span><br><span class="line"><span class="string">    if (connectionIndex &lt; 0) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is not <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>registered with the input dispatcher.  The window may be <span class="keyword">in</span> the process <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>of being removed.<span class="string">", targetType);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is dead then keep waiting.</span></span><br><span class="line"><span class="string">    sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span></span><br><span class="line"><span class="string">    if (connection-&gt;status != Connection::STATUS_NORMAL) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("</span>Waiting because the %s window<span class="string">'s input connection is %s."</span></span><br><span class="line"><span class="string">                "The window may be in the process of being removed.", targetType,</span></span><br><span class="line"><span class="string">                connection-&gt;getStatusLabel());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // If the connection is backed up then keep waiting.</span></span><br><span class="line"><span class="string">    if (connection-&gt;inputPublisherBlocked) &#123;</span></span><br><span class="line"><span class="string">        return String8::format("Waiting because the %s window'</span>s input channel is full.  <span class="string">"</span></span><br><span class="line"><span class="string">                "</span>Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // Ensure that the dispatch queues aren't too far backed up for this event.</span></span><br><span class="line"><span class="string">    if (eventEntry-&gt;type == EventEntry::TYPE_KEY) &#123;</span></span><br><span class="line"><span class="string">        // If the event is a key event, then we must wait for all previous events to</span></span><br><span class="line"><span class="string">        // complete before delivering it because previous events may have the</span></span><br><span class="line"><span class="string">        // side-effect of transferring focus to a different window and we want to</span></span><br><span class="line"><span class="string">        // ensure that the following keys are sent to the new window.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Suppose the user touches a button in a window then immediately presses "</span>A<span class="string">".</span></span><br><span class="line"><span class="string">        // If the button causes a pop-up window to appear then we want to ensure that</span></span><br><span class="line"><span class="string">        // the "</span>A<span class="string">" key is delivered to the new pop-up window.  This is because users</span></span><br><span class="line"><span class="string">        // often anticipate pending UI changes when typing on a keyboard.</span></span><br><span class="line"><span class="string">        // To obtain this behavior, we must serialize key events with respect to all</span></span><br><span class="line"><span class="string">        // prior input events.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;outboundQueue.isEmpty() || !connection-&gt;waitQueue.isEmpty()) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing all of the input events that were previously <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>delivered to it.  Outbound queue length: %d.  Wait queue length: %d.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, connection-&gt;outboundQueue.count(), connection-&gt;waitQueue.count());</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Touch events can always be sent to a window immediately because the user intended</span></span><br><span class="line"><span class="string">        // to touch whatever was visible at the time.  Even if focus changes or a new</span></span><br><span class="line"><span class="string">        // window appears moments later, the touch event was meant to be delivered to</span></span><br><span class="line"><span class="string">        // whatever window happened to be on screen at the time.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // Generic motion events, such as trackball or joystick events are a little trickier.</span></span><br><span class="line"><span class="string">        // Like key events, generic motion events are delivered to the focused window.</span></span><br><span class="line"><span class="string">        // Unlike key events, generic motion events don't tend to transfer focus to other</span></span><br><span class="line"><span class="string">        // windows and it is not important for them to be serialized.  So we prefer to deliver</span></span><br><span class="line"><span class="string">        // generic motion events as soon as possible to improve efficiency and reduce lag</span></span><br><span class="line"><span class="string">        // through batching.</span></span><br><span class="line"><span class="string">        //</span></span><br><span class="line"><span class="string">        // The one case where we pause input event delivery is when the wait queue is piling</span></span><br><span class="line"><span class="string">        // up with lots of events because the application is not responding.</span></span><br><span class="line"><span class="string">        // This condition ensures that ANRs are detected reliably.</span></span><br><span class="line"><span class="string">        if (!connection-&gt;waitQueue.isEmpty()</span></span><br><span class="line"><span class="string">                &amp;&amp; currentTime &gt;= connection-&gt;waitQueue.head-&gt;deliveryTime</span></span><br><span class="line"><span class="string">                        + STREAM_AHEAD_EVENT_TIMEOUT) &#123;</span></span><br><span class="line"><span class="string">            return String8::format("</span>Waiting to send non-key event because the %s window has not <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>finished processing certain input events that were delivered to it over <span class="string">"</span></span><br><span class="line"><span class="string">                    "</span>%0.1fms ago.  Wait queue length: %d.  Wait queue head age: %0.1fms.<span class="string">",</span></span><br><span class="line"><span class="string">                    targetType, STREAM_AHEAD_EVENT_TIMEOUT * 0.000001f,</span></span><br><span class="line"><span class="string">                    connection-&gt;waitQueue.count(),</span></span><br><span class="line"><span class="string">                    (currentTime - connection-&gt;waitQueue.head-&gt;deliveryTime) * 0.000001f);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return String8::empty();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>然后，上述有任何一个场景发生了，则输入事件需要继续等待，紧接着就会调用handleTargetsNotReadyLocked()来判断是不是已经的等待超时了：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime,</span><br><span class="line">        const EventEntry* entry,</span><br><span class="line">        const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t* nextWakeupTime, const char* reason) &#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationHandle == NULL &amp;&amp; windowHandle == NULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for system to become ready for input.  Reason: %s"</span>, reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_SYSTEM_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = LONG_LONG_MAX;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_FOCUS</span></span><br><span class="line">            ALOGD(<span class="string">"Waiting for application to become ready for input: %s.  Reason: %s"</span>,</span><br><span class="line">                    getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">                    reason);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">            nsecs_t timeout;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationHandle != NULL) &#123;</span><br><span class="line">                timeout = applicationHandle-&gt;getDispatchingTimeout(</span><br><span class="line">                        DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;</span><br><span class="line">            mInputTargetWaitStartTime = currentTime;</span><br><span class="line">            mInputTargetWaitTimeoutTime = currentTime + timeout;</span><br><span class="line">            mInputTargetWaitTimeoutExpired = <span class="literal">false</span>;</span><br><span class="line">            mInputTargetWaitApplicationHandle.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitApplicationHandle == NULL &amp;&amp; applicationHandle != NULL) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = applicationHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputTargetWaitTimeoutExpired) &#123;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;</span><br><span class="line">        onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                entry-&gt;eventTime, mInputTargetWaitStartTime, reason);</span><br><span class="line"></span><br><span class="line">        // Force poll loop to wake up immediately on next iteration once we get the</span><br><span class="line">        // ANR response back from the policy.</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // Force poll loop to wake up when timeout is due.</span><br><span class="line">        <span class="keyword">if</span> (mInputTargetWaitTimeoutTime &lt; *nextWakeupTime) &#123;</span><br><span class="line">            *nextWakeupTime = mInputTargetWaitTimeoutTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后，如果当前事件派发已经超时，则说明已经检测到了ANR，调用onANRLocked()方法，然后将nextWakeupTime设置为最小值，马上开始下一轮调度。 在onANRLocked()方法中， 会保存ANR的一些状态信息，调用doNotifyANRLockedInterruptible()，进一步会调用到JNI层的 NativeInputManager::notifyANR()方法， 它的主要功能就是衔接Native层和  Java层，直接调用Java层的InputManagerService.notifyANR()方法。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::onANRLocked(</span><br><span class="line">        nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span><br><span class="line">        nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) &#123;</span><br><span class="line">    <span class="built_in">float</span> dispatchLatency = (currentTime - eventTime) * 0.000001f;</span><br><span class="line">    <span class="built_in">float</span> waitDuration = (currentTime - waitStartTime) * 0.000001f;</span><br><span class="line">    ALOGI(<span class="string">"Application is not responding: %s.  "</span></span><br><span class="line">            <span class="string">"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string(),</span><br><span class="line">            dispatchLatency, waitDuration, reason);</span><br><span class="line"></span><br><span class="line">    // Capture a record of the InputDispatcher state at the time of the ANR.</span><br><span class="line">    time_t t = time(NULL);</span><br><span class="line">    struct tm tm;</span><br><span class="line">    localtime_r(&amp;t, &amp;tm);</span><br><span class="line">    char timestr[64];</span><br><span class="line">    strftime(timestr, sizeof(timestr), <span class="string">"%F %T"</span>, &amp;tm);</span><br><span class="line">    mLastANRState.clear();</span><br><span class="line">    mLastANRState.append(INDENT <span class="string">"ANR:\n"</span>);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Time: %s\n"</span>, timestr);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Window: %s\n"</span>,</span><br><span class="line">            getApplicationWindowLabelLocked(applicationHandle, windowHandle).string());</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"DispatchLatency: %0.1fms\n"</span>, dispatchLatency);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"WaitDuration: %0.1fms\n"</span>, waitDuration);</span><br><span class="line">    mLastANRState.appendFormat(INDENT2 <span class="string">"Reason: %s\n"</span>, reason);</span><br><span class="line">    dumpDispatchStateLocked(mLastANRState);</span><br><span class="line"></span><br><span class="line">    CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">            &amp; InputDispatcher::doNotifyANRLockedInterruptible);</span><br><span class="line">    commandEntry-&gt;inputApplicationHandle = applicationHandle;</span><br><span class="line">    commandEntry-&gt;inputWindowHandle = windowHandle;</span><br><span class="line">    commandEntry-&gt;reason = reason;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void InputDispatcher::doNotifyANRLockedInterruptible(</span><br><span class="line">        CommandEntry* commandEntry) &#123;</span><br><span class="line">    mLock.unlock();</span><br><span class="line"></span><br><span class="line">    nsecs_t newTimeout = mPolicy-&gt;notifyANR(</span><br><span class="line">            commandEntry-&gt;inputApplicationHandle, commandEntry-&gt;inputWindowHandle,</span><br><span class="line">            commandEntry-&gt;reason);</span><br><span class="line"></span><br><span class="line">    mLock.lock();</span><br><span class="line"></span><br><span class="line">    resumeAfterTargetsNotReadyTimeoutLocked(newTimeout,</span><br><span class="line">            commandEntry-&gt;inputWindowHandle != NULL</span><br><span class="line">                    ? commandEntry-&gt;inputWindowHandle-&gt;getInputChannel() : NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputDispatcher::InputDispatcher(const sp&lt;InputDispatcherPolicyInterface&gt;&amp; policy) :</span><br><span class="line">    mPolicy(policy),</span><br><span class="line">    mPendingEvent(NULL), mLastDropReason(DROP_REASON_NOT_DROPPED),</span><br><span class="line">    mAppSwitchSawKeyDown(<span class="literal">false</span>), mAppSwitchDueTime(LONG_LONG_MAX),</span><br><span class="line">    mNextUnblockedEvent(NULL),</span><br><span class="line">    mDispatchEnabled(<span class="literal">false</span>), mDispatchFrozen(<span class="literal">false</span>), mInputFilterEnabled(<span class="literal">false</span>),</span><br><span class="line">    mInputTargetWaitCause(INPUT_TARGET_WAIT_CAUSE_NONE) &#123;</span><br><span class="line">    mLooper = new Looper(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    mKeyRepeatState.lastKeyEntry = NULL;</span><br><span class="line"></span><br><span class="line">    policy-&gt;getDispatcherConfiguration(&amp;mConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到mPolicy是InputDispatcherPolicyInterface,对应的在JNI层frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class NativeInputManager : public virtual RefBase,</span><br><span class="line">    public virtual InputReaderPolicyInterface,</span><br><span class="line">    public virtual InputDispatcherPolicyInterface,</span><br><span class="line">    public virtual PointerControllerPolicyInterface &#123;</span><br><span class="line">protected:</span><br><span class="line">    virtual ~NativeInputManager();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper);</span><br><span class="line"></span><br><span class="line">    inline sp&lt;InputManager&gt; getInputManager() const &#123; <span class="built_in">return</span> mInputManager; &#125;</span><br><span class="line"></span><br><span class="line">    void dump(String8&amp; dump);</span><br><span class="line"></span><br><span class="line">    void setVirtualDisplayViewports(JNIEnv* env, jobjectArray viewportObjArray);</span><br><span class="line">    void setDisplayViewport(int32_t viewportType, const DisplayViewport&amp; viewport);</span><br><span class="line"></span><br><span class="line">    status_t registerInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor);</span><br><span class="line">    status_t unregisterInputChannel(JNIEnv* env, const sp&lt;InputChannel&gt;&amp; inputChannel);</span><br><span class="line"></span><br><span class="line">    void setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray);</span><br><span class="line">    void setFocusedApplication(JNIEnv* env, jobject applicationHandleObj);</span><br><span class="line">    void setInputDispatchMode(bool enabled, bool frozen);</span><br><span class="line">    void setSystemUiVisibility(int32_t visibility);</span><br><span class="line">    void setPointerSpeed(int32_t speed);</span><br><span class="line">    void setInputDeviceEnabled(uint32_t deviceId, bool enabled);</span><br><span class="line">    void setShowTouches(bool enabled);</span><br><span class="line">    void setInteractive(bool interactive);</span><br><span class="line">    void reloadCalibration();</span><br><span class="line">    void setPointerIconType(int32_t iconId);</span><br><span class="line">    void reloadPointerIcons();</span><br><span class="line">    void setCustomPointerIcon(const SpriteIcon&amp; icon);</span><br><span class="line">    void setPointerCapture(bool enabled);</span><br><span class="line"></span><br><span class="line">    /* --- InputReaderPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void getReaderConfiguration(InputReaderConfiguration* outConfig);</span><br><span class="line">    virtual sp&lt;PointerControllerInterface&gt; obtainPointerController(int32_t deviceId);</span><br><span class="line">    virtual void notifyInputDevicesChanged(const Vector&lt;InputDeviceInfo&gt;&amp; inputDevices);</span><br><span class="line">    virtual sp&lt;KeyCharacterMap&gt; getKeyboardLayoutOverlay(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual String8 getDeviceAlias(const InputDeviceIdentifier&amp; identifier);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(JNIEnv *env,</span><br><span class="line">            jfloatArray matrixArr);</span><br><span class="line">    virtual TouchAffineTransformation getTouchAffineTransformation(</span><br><span class="line">            const String8&amp; inputDeviceDescriptor, int32_t surfaceRotation);</span><br><span class="line"></span><br><span class="line">    /* --- InputDispatcherPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void notifySwitch(nsecs_t when, uint32_t switchValues, uint32_t switchMask,</span><br><span class="line">            uint32_t policyFlags);</span><br><span class="line">    virtual void notifyConfigurationChanged(nsecs_t when);</span><br><span class="line">    virtual nsecs_t notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const String8&amp; reason);</span><br><span class="line">    virtual void notifyInputChannelBroken(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle);</span><br><span class="line">    virtual bool filterInputEvent(const InputEvent* inputEvent, uint32_t policyFlags);</span><br><span class="line">    virtual void getDispatcherConfiguration(InputDispatcherConfiguration* outConfig);</span><br><span class="line">    virtual void interceptKeyBeforeQueueing(const KeyEvent* keyEvent, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual void interceptMotionBeforeQueueing(nsecs_t when, uint32_t&amp; policyFlags);</span><br><span class="line">    virtual nsecs_t interceptKeyBeforeDispatching(</span><br><span class="line">            const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags);</span><br><span class="line">    virtual bool dispatchUnhandledKey(const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle,</span><br><span class="line">            const KeyEvent* keyEvent, uint32_t policyFlags, KeyEvent* outFallbackKeyEvent);</span><br><span class="line">    virtual void pokeUserActivity(nsecs_t eventTime, int32_t eventType);</span><br><span class="line">    virtual bool checkInjectEventsPermissionNonReentrant(</span><br><span class="line">            int32_t injectorPid, int32_t injectorUid);</span><br><span class="line"></span><br><span class="line">    /* --- PointerControllerPolicyInterface implementation --- */</span><br><span class="line"></span><br><span class="line">    virtual void loadPointerIcon(SpriteIcon* icon);</span><br><span class="line">    virtual void loadPointerResources(PointerResources* outResources);</span><br><span class="line">    virtual void loadAdditionalMouseResources(std::map&lt;int32_t, SpriteIcon&gt;* outResources,</span><br><span class="line">            std::map&lt;int32_t, PointerAnimation&gt;* outAnimationResources);</span><br><span class="line">    virtual int32_t getDefaultPointerIconId();</span><br><span class="line">    virtual int32_t getCustomPointerIconId();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>JNI层中notifyANR的实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">nsecs_t NativeInputManager::notifyANR(const sp&lt;InputApplicationHandle&gt;&amp; inputApplicationHandle,</span><br><span class="line">        const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, const String8&amp; reason) &#123;</span><br><span class="line"><span class="comment">#if DEBUG_INPUT_DISPATCHER_POLICY</span></span><br><span class="line">    ALOGD(<span class="string">"notifyANR"</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = jniEnv();</span><br><span class="line"></span><br><span class="line">    // 将应用程序句柄、窗口句柄、ANR原因字符串，转化为Java层的对象</span><br><span class="line">    jobject inputApplicationHandleObj =</span><br><span class="line">            getInputApplicationHandleObjLocalRef(env, inputApplicationHandle);</span><br><span class="line">    jobject inputWindowHandleObj =</span><br><span class="line">            getInputWindowHandleObjLocalRef(env, inputWindowHandle);</span><br><span class="line">    jstring reasonObj = env-&gt;NewStringUTF(reason.string());</span><br><span class="line"></span><br><span class="line">    // 调用Java层的InputManagerService.notifyANR()方法</span><br><span class="line">    jlong newTimeout = env-&gt;CallLongMethod(mServiceObj,</span><br><span class="line">                gServiceClassInfo.notifyANR, inputApplicationHandleObj, inputWindowHandleObj,</span><br><span class="line">                reasonObj);</span><br><span class="line">    <span class="keyword">if</span> (checkAndClearExceptionFromCallback(env, <span class="string">"notifyANR"</span>)) &#123;</span><br><span class="line">        newTimeout = 0; // abort dispatch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(newTimeout &gt;= 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;DeleteLocalRef(reasonObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputWindowHandleObj);</span><br><span class="line">    env-&gt;DeleteLocalRef(inputApplicationHandleObj);</span><br><span class="line">    <span class="built_in">return</span> newTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，ANR的处理逻辑转交到了Java层。底层(Native)发现一旦有输入事件派发超时，就会通知上层(Java)，上层收到ANR通知后，决定是否终止当前输入事件的派发。</p><p>发生ANR时，Java层最开始的入口是InputManagerService.notifyANR()，它是直接被Native层调用的。我们先把ANR的Java层调用关系列出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputManagerService.notifyANR()</span><br><span class="line">└── InputMonitor.notifyANR()</span><br><span class="line">    ├── IApplicationToken.keyDispatchingTimedOut()</span><br><span class="line">    │   └── ActivityRecord.keyDispatchingTimedOut()</span><br><span class="line">    │       └── AMS.inputDispatchingTimedOut()</span><br><span class="line">    │           └── AMS.appNotResponding()</span><br><span class="line">    │</span><br><span class="line">    └── AMS.inputDispatchingTimedOut()</span><br><span class="line">        └── AMS.appNotResponding()</span><br></pre></td></tr></table></figure><p>在Java层的InputManagerService代码: frameworks/base/services/core/java/com/android/server/input/InputManagerService.java</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private WindowManagerCallbacks mWindowManagerCallbacks;</span><br><span class="line">....</span><br><span class="line"> // Native callback.</span><br><span class="line"> private long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">         InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">     <span class="built_in">return</span> mWindowManagerCallbacks.notifyANR(</span><br><span class="line">             inputApplicationHandle, inputWindowHandle, reason);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>WindowManagerCallbacks由 InputMonitor.java实现： frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java<br>InputManagerService.notifyANR()只是为Native层定义了一个接口，它直接调用InputMonitor.notifyANR()。 如果该方法的返回值等于0, 则放弃本次输入事件;如果大于0, 则表示 需要继续等待的时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">final class InputMonitor implements InputManagerService.WindowManagerCallbacks &#123;</span><br><span class="line">    private final WindowManagerService mService;</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line">    /* Notifies the window manager about an application that is not responding.</span><br><span class="line">     * Returns a new timeout to <span class="built_in">continue</span> waiting <span class="keyword">in</span> nanoseconds, or 0 to abort dispatch.</span><br><span class="line">     *</span><br><span class="line">     * Called by the InputManager.</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public long notifyANR(InputApplicationHandle inputApplicationHandle,</span><br><span class="line">            InputWindowHandle inputWindowHandle, String reason) &#123;</span><br><span class="line">        AppWindowToken appWindowToken = null;</span><br><span class="line">        WindowState windowState = null;</span><br><span class="line">        boolean aboveSystem = <span class="literal">false</span>;</span><br><span class="line">        synchronized (mService.mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputWindowHandle != null) &#123;</span><br><span class="line">                windowState = (WindowState) inputWindowHandle.windowState;</span><br><span class="line">                <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                    appWindowToken = windowState.mAppToken;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (appWindowToken == null &amp;&amp; inputApplicationHandle != null) &#123;</span><br><span class="line">                appWindowToken = (AppWindowToken)inputApplicationHandle.appWindowToken;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to "</span> + windowState.mAttrs.getTitle()</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">                // Figure out whether this window is layered above system windows.</span><br><span class="line">                // We need to <span class="keyword">do</span> this here to <span class="built_in">help</span> the activity manager know how to</span><br><span class="line">                // layer its ANR dialog.</span><br><span class="line">                int systemAlertLayer = mService.mPolicy.getWindowLayerFromTypeLw(</span><br><span class="line">                        TYPE_APPLICATION_OVERLAY, windowState.mOwnerCanAddInternalSystemWindow);</span><br><span class="line">                aboveSystem = windowState.mBaseLayer &gt; systemAlertLayer;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appWindowToken != null) &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">"sending to application "</span> + appWindowToken.stringName</span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.i(TAG_WM, <span class="string">"Input event dispatching timed out "</span></span><br><span class="line">                        + <span class="string">".  Reason: "</span> + reason);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mService.saveANRStateLocked(appWindowToken, windowState, reason);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // All the calls below need to happen without the WM lock held since they call into AM.</span><br><span class="line">        mService.mAmInternal.saveANRState(reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appWindowToken != null &amp;&amp; appWindowToken.appToken != null) &#123;</span><br><span class="line">        // appToken实际上就是当前的ActivityRecord。</span><br><span class="line">            // 如果发生ANR的Activity还存在，则直接通过ActivityRecord通知事件派发超时</span><br><span class="line">            // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">            // to abort dispatching or keep waiting.</span><br><span class="line">            final AppWindowContainerController controller = appWindowToken.getController();</span><br><span class="line">            final boolean abort = controller != null</span><br><span class="line">                    &amp;&amp; controller.keyDispatchingTimedOut(reason,</span><br><span class="line">                            (windowState != null) ? windowState.mSession.mPid : -1);</span><br><span class="line">            <span class="keyword">if</span> (!abort) &#123;</span><br><span class="line">                // The activity manager declined to abort dispatching.</span><br><span class="line">                // Wait a bit longer and timeout again later.</span><br><span class="line">                <span class="built_in">return</span> appWindowToken.mInputDispatchingTimeoutNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowState != null) &#123;</span><br><span class="line">        // 如果发生ANR的Activity已经销毁了，则通过AMS通知事件派发超时</span><br><span class="line">            try &#123;</span><br><span class="line">                // Notify the activity manager about the timeout and <span class="built_in">let</span> it decide whether</span><br><span class="line">                // to abort dispatching or keep waiting.</span><br><span class="line">                long timeout = ActivityManager.getService().inputDispatchingTimedOut(</span><br><span class="line">                        windowState.mSession.mPid, aboveSystem, reason);</span><br><span class="line">                <span class="keyword">if</span> (timeout &gt;= 0) &#123;</span><br><span class="line">                    // The activity manager declined to abort dispatching.</span><br><span class="line">                    // Wait a bit longer and timeout again later.</span><br><span class="line">                    <span class="built_in">return</span> timeout * 1000000L; // nanoseconds</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> 0; // abort dispatching</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法中有两种不同的调用方式，但最终都会交由AMS.inputDispatchingTimedOut()处理。AMS有重载的inputDispatchingTimedOut()方法，他们的参数不一样。 ActivityRecord 调用时，可以传入的信息更多一点(当前发生ANR的界面是哪一个)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public long inputDispatchingTimedOut(int pid, final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord proc;</span><br><span class="line">        long timeout;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">                proc = mPidsSelfLocked.get(pid);// 1. 根据进程号获取到ProcessRecord</span><br><span class="line">            &#125;</span><br><span class="line">            // 2. 获取超时时间</span><br><span class="line">            // 测试环境下的超时时间是INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT(60秒)，</span><br><span class="line">            // 正常环境下的超时时间是KEY_DISPATCHING_TIMEOUT(5秒)</span><br><span class="line">            timeout = getInputDispatchingTimeoutLocked(proc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 调用重载的函数，如果返回True，则表示需要中断当前的事件派发;</span><br><span class="line">        <span class="keyword">if</span> (inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) &#123;</span><br><span class="line">            <span class="built_in">return</span> -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 返回继续等待的时间，这个值会传递到Native层</span><br><span class="line">        <span class="built_in">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Handle input dispatching timeouts.</span><br><span class="line">     * Returns whether input dispatching should be aborted or not.</span><br><span class="line">     */</span><br><span class="line">    public boolean inputDispatchingTimedOut(final ProcessRecord proc,</span><br><span class="line">            final ActivityRecord activity, final ActivityRecord parent,</span><br><span class="line">            final boolean aboveSystem, String reason) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            throw new SecurityException(<span class="string">"Requires permission "</span></span><br><span class="line">                    + android.Manifest.permission.FILTER_EVENTS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final String annotation;</span><br><span class="line">        <span class="keyword">if</span> (reason == null) &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            annotation = <span class="string">"Input dispatching timed out ("</span> + reason + <span class="string">")"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proc != null) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                <span class="keyword">if</span> (proc.debugging) &#123;// 1. 发生ANR进程正处于调试状态，不需要中断事件</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 2. 发生ANR的进程是测试进程，需要中断，但不在UI界面显示ANR信息判断</span><br><span class="line">                <span class="keyword">if</span> (proc.instr != null) &#123;</span><br><span class="line">                    Bundle info = new Bundle();</span><br><span class="line">                    info.putString(<span class="string">"shortMsg"</span>, <span class="string">"keyDispatchingTimedOut"</span>);</span><br><span class="line">                    info.putString(<span class="string">"longMsg"</span>, annotation);</span><br><span class="line">                    finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);</span><br><span class="line">                    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 3. 通知UI界面显示ANR信息</span><br><span class="line">            mHandler.post(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                    mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至此，我们回答了第二个问题：</p><p>在InputDispatcher派发输入事件时，会寻找接收事件的窗口，如果无法正常派发，则可能会导致当前需要派发的事件超时(默认是5秒)。 Native层发现超时了，会通知Java层，Java层经过一些处理后，会反馈给Native层，是继续等待还是丢弃当前派发的事件。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>ANR监测机制包含三种：</p><blockquote><ul><li>Service ANR，前台进程中Service生命周期不能超过20秒，后台进程中Service的生命周期不能超过200秒。 在启动Service时，抛出定时消息SERVICE_TIMEOUT_MSG或SERVICE_BACKGOURND_TIMEOUT_MSG，如果定时消息响应了，则说明发生了ANR</li></ul></blockquote><blockquote><ul><li>Broadcast ANR，前台的“串行广播消息”必须在10秒内处理完毕，后台的“串行广播消息”必须在60秒处理完毕， 每派发串行广播消息到一个接收器时，都会抛出一个定时消息BROADCAST_TIMEOUT_MSG，如果定时消息响应，则判断是否广播消息处理超时，超时就说明发生了ANR</li></ul></blockquote><blockquote><ul><li>Input ANR，输入事件必须在5秒内处理完毕。在派发一个输入事件时，会判断当前输入事件是否需要等待，如果需要等待，则判断是否等待已经超时，超时就说明发生了ANR</li></ul></blockquote><p>ANR监测机制实际上是对应用程序主线程的要求，要求主线成必须在限定的时间内，完成对几种操作的响应;否则，就可以认为应用程序主线程失去响应能力。</p><p>从ANR的三种监测机制中，我们看到不同超时机制的设计：</p><p>Service和Broadcast都是由AMS调度，利用Handler和Looper，设计了一个TIMEOUT消息交由AMS线程来处理，整个超时机制的实现都是在Java层； InputEvent由InputDispatcher调度，待处理的输入事件都会进入队列中等待，设计了一个等待超时的判断，超时机制的实现在Native层。</p><h3 id="ANR的报告机制"><a href="#ANR的报告机制" class="headerlink" title="ANR的报告机制"></a>ANR的报告机制</h3><p>无论哪种类型的ANR发生以后，最终都会调用 AMS.appNotResponding() 方法，所谓“殊途同归”。这个方法的职能就是向用户或开发者报告ANR发生了。 最终的表现形式是：弹出一个对话框，告诉用户当前某个程序无响应;输入一大堆与ANR相关的日志，便于开发者解决问题。</p><p>最终形式我们见过很多，但输出日志的原理是什么，未必所有人都了解，下面我们就来认识一下是如何输出ANR日志的。</p><p>在  <a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/am/AppErrors.java" target="_blank" rel="noopener">AppErrors.java</a>  frameworks/base/services/core/java/com/android/server/am/AppErrors.java中处理ANR的弹框<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">final void appNotResponding(ProcessRecord app, ActivityRecord activity,</span><br><span class="line">        ActivityRecord parent, boolean aboveSystem, final String annotation) &#123;</span><br><span class="line">        // app: 当前发生ANR的进程</span><br><span class="line">// activity: 发生ANR的界面</span><br><span class="line">// parent: 发生ANR的界面的上一级界面</span><br><span class="line">// aboveSystem:</span><br><span class="line">// annotation: 发生ANR的原因</span><br><span class="line">    ArrayList&lt;Integer&gt; firstPids = new ArrayList&lt;Integer&gt;(5);</span><br><span class="line">    SparseArray&lt;Boolean&gt; lastPids = new SparseArray&lt;Boolean&gt;(20);</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 0 == <span class="built_in">continue</span>, -1 = <span class="built_in">kill</span> process immediately</span><br><span class="line">            int res = mService.mController.appEarlyNotResponding(</span><br><span class="line">                    app.processName, app.pid, annotation);</span><br><span class="line">            <span class="keyword">if</span> (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">                app.kill(<span class="string">"anr"</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            mService.mController = null;</span><br><span class="line">            Watchdog.getInstance().setActivityController(null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    long anrTime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;// 1. 更新CPU使用信息。ANR的第一次CPU信息采样</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">    &#125;</span><br><span class="line">    // Unless configured otherwise, swallow ANRs <span class="keyword">in</span> background processes &amp; <span class="built_in">kill</span> the process.</span><br><span class="line">    boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(),</span><br><span class="line">            Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;</span><br><span class="line">    boolean isSilentANR;</span><br><span class="line">    synchronized (mService) &#123;</span><br><span class="line">        // PowerManager.reboot() can block <span class="keyword">for</span> a long time, so ignore ANRs <span class="keyword">while</span> shutting down.</span><br><span class="line">        <span class="keyword">if</span> (mService.mShuttingDown) &#123;//正在关机过程中的ANR，直接忽视掉</span><br><span class="line">            Slog.i(TAG, <span class="string">"During shutdown skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.notResponding) &#123;//重复的ANR，直接忽略掉，不重复弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping duplicate ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.crashing) &#123;//APP crash 引起的ANR，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Crashing app skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killedByAm) &#123;// APP 已经被 AM <span class="built_in">kill</span>掉的，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"App already killed by AM skipping ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.killed) &#123;//APP 已经挂掉了，不弹框</span><br><span class="line">            Slog.i(TAG, <span class="string">"Skipping died app ANR: "</span> + app + <span class="string">" "</span> + annotation);</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        // In <span class="keyword">case</span> we come through here <span class="keyword">for</span> the same app before completing</span><br><span class="line">        // this one, mark as anring now so we will bail out.</span><br><span class="line">        app.notResponding = <span class="literal">true</span>;</span><br><span class="line">        // Log the ANR to the event <span class="built_in">log</span>.</span><br><span class="line">        //2.将ANR 信息写入event <span class="built_in">log</span>中</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_ANR, app.userId, app.pid,</span><br><span class="line">                app.processName, app.info.flags, annotation);</span><br><span class="line">        // Dump thread traces as quickly as we can, starting with <span class="string">"interesting"</span> processes.</span><br><span class="line">        // 3. 填充firstPids和lastPids数组。从最近运行进程(Last Recently Used)中挑选：</span><br><span class="line">//    firstPids用于保存ANR进程及其父进程，system_server进程和persistent的进程(譬如Phone进程)</span><br><span class="line">//    lastPids用于保存除firstPids外的其他进程</span><br><span class="line">        firstPids.add(app.pid);</span><br><span class="line">        // Don<span class="string">'t dump other PIDs if it'</span>s a background ANR</span><br><span class="line">        isSilentANR = !showBackground &amp;&amp; !isInterestingForBackgroundTraces(app);</span><br><span class="line">        <span class="keyword">if</span> (!isSilentANR) &#123;</span><br><span class="line">            int parentPid = app.pid;</span><br><span class="line">            <span class="keyword">if</span> (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid &gt; 0) &#123;</span><br><span class="line">                parentPid = parent.app.pid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid != app.pid) firstPids.add(parentPid);</span><br><span class="line">            <span class="keyword">if</span> (MY_PID != app.pid &amp;&amp; MY_PID != parentPid) firstPids.add(MY_PID);</span><br><span class="line">            <span class="keyword">for</span> (int i = mService.mLruProcesses.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                ProcessRecord r = mService.mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (r != null &amp;&amp; r.thread != null) &#123;</span><br><span class="line">                    int pid = r.pid;</span><br><span class="line">                    <span class="keyword">if</span> (pid &gt; 0 &amp;&amp; pid != app.pid &amp;&amp; pid != parentPid &amp;&amp; pid != MY_PID) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (r.persistent) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding persistent proc: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.treatLikeActivity) &#123;</span><br><span class="line">                            firstPids.add(pid);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding likely IME: "</span> + r);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastPids.put(pid, Boolean.TRUE);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_ANR) Slog.i(TAG, <span class="string">"Adding ANR proc: "</span> + r);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Log the ANR to the main <span class="built_in">log</span>. </span><br><span class="line">    //4. 将ANR信息输出到 main <span class="built_in">log</span>中</span><br><span class="line">    StringBuilder info = new StringBuilder();</span><br><span class="line">    info.setLength(0);</span><br><span class="line">    info.append(<span class="string">"ANR in "</span>).append(app.processName);</span><br><span class="line">    <span class="keyword">if</span> (activity != null &amp;&amp; activity.shortComponentName != null) &#123;</span><br><span class="line">        info.append(<span class="string">" ("</span>).append(activity.shortComponentName).append(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(<span class="string">"\n"</span>);</span><br><span class="line">    info.append(<span class="string">"PID: "</span>).append(app.pid).append(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (annotation != null) &#123;</span><br><span class="line">        info.append(<span class="string">"Reason: "</span>).append(annotation).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parent != null &amp;&amp; parent != activity) &#123;</span><br><span class="line">        info.append(<span class="string">"Parent: "</span>).append(parent.shortComponentName).append(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ProcessCpuTracker processCpuTracker = new ProcessCpuTracker(<span class="literal">true</span>);</span><br><span class="line">    // don<span class="string">'t dump native PIDs for background ANRs unless it is the process of interest</span></span><br><span class="line"><span class="string">    String[] nativeProcs = null;</span></span><br><span class="line"><span class="string">    if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">        for (int i = 0; i &lt; NATIVE_STACKS_OF_INTEREST.length; i++) &#123;</span></span><br><span class="line"><span class="string">            if (NATIVE_STACKS_OF_INTEREST[i].equals(app.processName)) &#123;</span></span><br><span class="line"><span class="string">                nativeProcs = new String[] &#123; app.processName &#125;;</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        nativeProcs = NATIVE_STACKS_OF_INTEREST;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    int[] pids = nativeProcs == null ? null : Process.getPidsForCommands(nativeProcs);</span></span><br><span class="line"><span class="string">    ArrayList&lt;Integer&gt; nativePids = null;</span></span><br><span class="line"><span class="string">    if (pids != null) &#123;</span></span><br><span class="line"><span class="string">        nativePids = new ArrayList&lt;Integer&gt;(pids.length);</span></span><br><span class="line"><span class="string">        for (int i : pids) &#123;</span></span><br><span class="line"><span class="string">            nativePids.add(i);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // For background ANRs, don'</span>t pass the ProcessCpuTracker to</span><br><span class="line">    // avoid spending 1/2 second collecting stats to rank lastPids.</span><br><span class="line">    File tracesFile = ActivityManagerService.dumpStackTraces(</span><br><span class="line">            <span class="literal">true</span>, firstPids,</span><br><span class="line">            (isSilentANR) ? null : processCpuTracker,</span><br><span class="line">            (isSilentANR) ? null : lastPids,</span><br><span class="line">            nativePids);</span><br><span class="line">    String cpuInfo = null;</span><br><span class="line">    <span class="keyword">if</span> (ActivityManagerService.MONITOR_CPU_USAGE) &#123;</span><br><span class="line">        mService.updateCpuStatsNow();</span><br><span class="line">        synchronized (mService.mProcessCpuTracker) &#123;</span><br><span class="line">            cpuInfo = mService.mProcessCpuTracker.printCurrentState(anrTime);</span><br><span class="line">        &#125;</span><br><span class="line">        info.append(processCpuTracker.printCurrentLoad());</span><br><span class="line">        info.append(cpuInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    info.append(processCpuTracker.printCurrentState(anrTime));</span><br><span class="line">    Slog.e(TAG, info.toString());//将上面拿到的所有信息，打印到main <span class="built_in">log</span>中</span><br><span class="line">    <span class="keyword">if</span> (tracesFile == null) &#123;//5.将<span class="built_in">log</span>打印到 traces.txt中</span><br><span class="line">        // There is no trace file, so dump (only) the alleged culprit<span class="string">'s threads to the log</span></span><br><span class="line"><span class="string">        Process.sendSignal(app.pid, Process.SIGNAL_QUIT);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    mService.addErrorToDropBox("anr", app, app.processName, activity, parent, annotation,</span></span><br><span class="line"><span class="string">            cpuInfo, tracesFile, null);// 6.将log打印到dropbox</span></span><br><span class="line"><span class="string">    if (mService.mController != null) &#123;</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            // 0 == show dialog, 1 = keep waiting, -1 = kill process immediately</span></span><br><span class="line"><span class="string">            int res = mService.mController.appNotResponding(</span></span><br><span class="line"><span class="string">                    app.processName, app.pid, info.toString());</span></span><br><span class="line"><span class="string">            if (res != 0) &#123;</span></span><br><span class="line"><span class="string">                if (res &lt; 0 &amp;&amp; app.pid != MY_PID) &#123;</span></span><br><span class="line"><span class="string">                    app.kill("anr", true);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">                        mService.mServices.scheduleServiceTimeoutLocked(app);</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">                return;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125; catch (RemoteException e) &#123;</span></span><br><span class="line"><span class="string">            mService.mController = null;</span></span><br><span class="line"><span class="string">            Watchdog.getInstance().setActivityController(null);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    // 弹框处理</span></span><br><span class="line"><span class="string">    synchronized (mService) &#123;</span></span><br><span class="line"><span class="string">        mService.mBatteryStatsService.noteProcessAnr(app.processName, app.uid);</span></span><br><span class="line"><span class="string">        if (isSilentANR) &#123;</span></span><br><span class="line"><span class="string">            app.kill("bg anr", true);</span></span><br><span class="line"><span class="string">            return;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        // Set the app'</span>s notResponding state, and look up the errorReportReceiver</span><br><span class="line">        makeAppNotRespondingLocked(app,</span><br><span class="line">                activity != null ? activity.shortComponentName : null,</span><br><span class="line">                annotation != null ? <span class="string">"ANR "</span> + annotation : <span class="string">"ANR"</span>,</span><br><span class="line">                info.toString());</span><br><span class="line">        // Bring up the infamous App Not Responding dialog</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG;</span><br><span class="line">        msg.obj = map;</span><br><span class="line">        msg.arg1 = aboveSystem ? 1 : 0;</span><br><span class="line">        map.put(<span class="string">"app"</span>, app);</span><br><span class="line">        <span class="keyword">if</span> (activity != null) &#123;</span><br><span class="line">            map.put(<span class="string">"activity"</span>, activity);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mUiHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的主体逻辑可以分成五个部分来看：</p><ol><li>更新CPU的统计信息。这是发生ANR时，第一次CPU使用信息的采样，采样数据会保存在mProcessStats这个变量中</li><li>将Log信息，写入Event log中</li><li>填充firstPids和lastPids数组。当前发生ANR的应用会首先被添加到firstPids中，这样打印函数栈的时候，当前进程总是在trace文件的最前面打印函数调用栈(StackTrace)。具体实现由dumpStackTraces()函数完成更新CPU的统计信息。这是发生ANR时，第二次CPU使用信息的采样，两次采样的数据分别对应ANR发生前后的CPU使用情况</li><li>准备main log需要的参数，将ANR信息输出到main log中</li><li>将log打印到trace.txt文件中</li><li>将log打印到dropbox中</li><li>弹框处理，显示ANR对话框。抛出SHOW_NOT_RESPONDING_MSG消息，AMS.MainHandler会处理这条消息，显示AppNotRespondingDialog</li></ol><p>当然，除了主体逻辑，发生ANR时还会输出各种类别的日志：</p><blockquote><p>event log，通过检索”am_anr”关键字，可以找到发生ANR的应用<br>main log，通过检索”ANR in “关键字，可以找到ANR的信息，日志的上下文会包含CPU的使用情况<br>dropbox，通过检索”anr”类型，可以找到ANR的信息,log位于/data/system/dropbox<br>traces, 发生ANR时，各进程的函数调用栈信息，log位于/data/anr<br>我们分析ANR问题，往往是从main log中的CPU使用情况和traces中的函数调用栈开始。所以，更新CPU的使用信息updateCpuStatsNow()方法和打印函数栈dumpStackTraces()方法，是系统报告ANR问题关键所在。</p></blockquote><h4 id="CPU的使用情况"><a href="#CPU的使用情况" class="headerlink" title="CPU的使用情况"></a>CPU的使用情况</h4><p>AMS.updateCpuStatsNow()方法的实现见下面的代码，更新CPU使用信息的间隔最小是5秒，即如果5秒内连续调用updateCpuStatsNow()方法，其实是没有更新CPU使用信息的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="title">updateCpuStatsNow</span></span>() &#123;</span><br><span class="line">        synchronized (mProcessCpuTracker) &#123;</span><br><span class="line">            mProcessCpuMutexFree.set(<span class="literal">false</span>);</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            boolean haveNewCpuStats = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MONITOR_CPU_USAGE &amp;&amp;</span><br><span class="line">                    mLastCpuTime.get() &lt; (now-MONITOR_CPU_MIN_TIME)) &#123;</span><br><span class="line">                mLastCpuTime.set(now);</span><br><span class="line">                mProcessCpuTracker.update();</span><br><span class="line">                <span class="keyword">if</span> (mProcessCpuTracker.hasGoodLastStats()) &#123;</span><br><span class="line">                    haveNewCpuStats = <span class="literal">true</span>;</span><br><span class="line">                    //Slog.i(TAG, mProcessCpu.printCurrentState());</span><br><span class="line">                    //Slog.i(TAG, <span class="string">"Total CPU usage: "</span></span><br><span class="line">                    //        + mProcessCpu.getTotalCpuPercent() + <span class="string">"%"</span>);</span><br><span class="line"></span><br><span class="line">                    // Slog the cpu usage <span class="keyword">if</span> the property is <span class="built_in">set</span>.</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"true"</span>.equals(SystemProperties.get(<span class="string">"events.cpu"</span>))) &#123;</span><br><span class="line">                        int user = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                        int system = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                        int iowait = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                        int irq = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                        int softIrq = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                        int idle = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line"></span><br><span class="line">                        int total = user + system + iowait + irq + softIrq + idle;</span><br><span class="line">                        <span class="keyword">if</span> (total == 0) total = 1;</span><br><span class="line"></span><br><span class="line">                        EventLog.writeEvent(EventLogTags.CPU,</span><br><span class="line">                                ((user+system+iowait+irq+softIrq) * 100) / total,</span><br><span class="line">                                (user * 100) / total,</span><br><span class="line">                                (system * 100) / total,</span><br><span class="line">                                (iowait * 100) / total,</span><br><span class="line">                                (irq * 100) / total,</span><br><span class="line">                                (softIrq * 100) / total);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final BatteryStatsImpl bstats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">            synchronized(bstats) &#123;</span><br><span class="line">                synchronized(mPidsSelfLocked) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (haveNewCpuStats) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bstats.startAddingCpuLocked()) &#123;</span><br><span class="line">                            int totalUTime = 0;</span><br><span class="line">                            int totalSTime = 0;</span><br><span class="line">                            final int N = mProcessCpuTracker.countStats();</span><br><span class="line">                            <span class="keyword">for</span> (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                                ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);</span><br><span class="line">                                <span class="keyword">if</span> (!st.working) &#123;</span><br><span class="line">                                    <span class="built_in">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                ProcessRecord pr = mPidsSelfLocked.get(st.pid);</span><br><span class="line">                                totalUTime += st.rel_utime;</span><br><span class="line">                                totalSTime += st.rel_stime;</span><br><span class="line">                                <span class="keyword">if</span> (pr != null) &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = pr.curProcBatteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        pr.curProcBatteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                pr.info.uid, pr.processName);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                    pr.curCpuTime += st.rel_utime + st.rel_stime;</span><br><span class="line">                                    <span class="keyword">if</span> (pr.lastCpuTime == 0) &#123;</span><br><span class="line">                                        pr.lastCpuTime = pr.curCpuTime;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    BatteryStatsImpl.Uid.Proc ps = st.batteryStats;</span><br><span class="line">                                    <span class="keyword">if</span> (ps == null || !ps.isActive()) &#123;</span><br><span class="line">                                        st.batteryStats = ps = bstats.getProcessStatsLocked(</span><br><span class="line">                                                bstats.mapUid(st.uid), st.name);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    ps.addCpuTimeLocked(st.rel_utime, st.rel_stime);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            final int userTime = mProcessCpuTracker.getLastUserTime();</span><br><span class="line">                            final int systemTime = mProcessCpuTracker.getLastSystemTime();</span><br><span class="line">                            final int iowaitTime = mProcessCpuTracker.getLastIoWaitTime();</span><br><span class="line">                            final int irqTime = mProcessCpuTracker.getLastIrqTime();</span><br><span class="line">                            final int softIrqTime = mProcessCpuTracker.getLastSoftIrqTime();</span><br><span class="line">                            final int idleTime = mProcessCpuTracker.getLastIdleTime();</span><br><span class="line">                            bstats.finishAddingCpuLocked(totalUTime, totalSTime, userTime,</span><br><span class="line">                                    systemTime, iowaitTime, irqTime, softIrqTime, idleTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mLastWriteTime &lt; (now-BATTERY_STATS_TIME)) &#123;</span><br><span class="line">                    mLastWriteTime = now;</span><br><span class="line">                    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CPU使用信息由ProcessCpuTracker这个类维护， 每次调用ProcessCpuTracker.update()方法，就会读取设备节点 /proc 下的文件，来更新CPU使用信息，具体有以下几个维度：</p><blockquote><p>CPU的使用时间: 读取 /proc/stat</p><blockquote><p>user： 用户进程的CPU使用时间<br>nice： 降低过优先级进程的CPU使用时间。Linux进程都有优先级，这个优先级可以进行动态调整，譬如进程初始优先级的值设为10,运行时降低为8,那么，修正值-2就定义为nice。 Android将user和nice这两个时间归类成user<br>sys： 内核进程的CPU使用时间<br>idle： CPU空闲的时间<br>wait： CPU等待IO的时间<br>hw irq： 硬件中断的时间。如果外设（譬如硬盘）出现故障，需要通过硬件终端通知CPU保存现场，发生上下文切换的时间就是CPU的硬件中断时间<br>sw irg： 软件中断的时间。同硬件中断一样，如果软件要求CPU中断，则上下文切换的时间就是CPU的软件中断时间</p></blockquote></blockquote><blockquote><p>CPU负载: 读取 /proc/loadavg, 统计最近1分钟，5分钟，15分钟内，CPU的平均活动进程数。 CPU的负载可以比喻成超市收银员负载，如果有1个人正在买单，有2个人在排队，那么该收银员的负载就是3。 在收银员工作时，不断会有人买单完成，也不断会有人排队，可以在固定的时间间隔内(譬如，每隔5秒)统计一次负载，那么，就可以统计出一段时间内的平均负载。</p></blockquote><blockquote><p>页错误信息： 进程的CPU使用率最后输出的“faults: xxx minor/major”部分表示的是页错误次数，当次数为0时不显示。 major是指Major Page Fault(主要页错误，简称MPF)，内核在读取数据时会先后查找CPU的高速缓存和物理内存，如果找不到会发出一个MPF信息，请求将数据加载到内存。 minor是指Minor Page Fault(次要页错误，简称MnPF)，磁盘数据被加载到内存后，内核再次读取时，会发出一个MnPF信息。 一个文件第一次被读写时会有很多的MPF，被缓存到内存后再次访问MPF就会很少，MnPF反而变多，这是内核为减少效率低下的磁盘I/O操作采用的缓存技术的结果。</p></blockquote><h4 id="堆栈调用"><a href="#堆栈调用" class="headerlink" title="堆栈调用"></a>堆栈调用</h4><p>AMS.dumpStackTraces()方法用于打印进程的函数调用栈，该方法的主体逻辑如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * If a stack trace dump file is configured, dump process stack traces.</span><br><span class="line"> * @param clearTraces causes the dump file to be erased prior to the new</span><br><span class="line"> *    traces being written, <span class="keyword">if</span> <span class="literal">true</span>; when <span class="literal">false</span>, the new traces will be</span><br><span class="line"> *    appended to any existing file content.</span><br><span class="line"> * @param firstPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> first</span><br><span class="line"> * @param lastPids of dalvik VM processes to dump stack traces <span class="keyword">for</span> last</span><br><span class="line"> * @param nativePids optional list of native pids to dump stack crawls</span><br><span class="line"> */</span><br><span class="line">public static File dumpStackTraces(boolean clearTraces, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ProcessCpuTracker processCpuTracker, SparseArray&lt;Boolean&gt; lastPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; extraPids = null;</span><br><span class="line"></span><br><span class="line">    // Measure CPU usage as soon as we<span class="string">'re called in order to get a realistic sampling</span></span><br><span class="line"><span class="string">    // of the top users at the time of the request.</span></span><br><span class="line"><span class="string">    if (processCpuTracker != null) &#123;</span></span><br><span class="line"><span class="string">        processCpuTracker.init();</span></span><br><span class="line"><span class="string">        try &#123;</span></span><br><span class="line"><span class="string">            Thread.sleep(200);</span></span><br><span class="line"><span class="string">        &#125; catch (InterruptedException ignored) &#123;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        processCpuTracker.update();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // We'</span>ll take the stack crawls of just the top apps using CPU.</span><br><span class="line">        final int N = processCpuTracker.countWorkingStats();</span><br><span class="line">        extraPids = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; N &amp;&amp; extraPids.size() &lt; 5; i++) &#123;</span><br><span class="line">            ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);</span><br><span class="line">            <span class="keyword">if</span> (lastPids.indexOfKey(stats.pid) &gt;= 0) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_ANR) Slog.d(TAG, <span class="string">"Collecting stacks for extra pid "</span> + stats.pid);</span><br><span class="line"></span><br><span class="line">                extraPids.add(stats.pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_ANR) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Skipping next CPU consuming process, not a java proc: "</span></span><br><span class="line">                        + stats.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean useTombstonedForJavaTraces = <span class="literal">false</span>;</span><br><span class="line">    File tracesFile;</span><br><span class="line"></span><br><span class="line">    final String tracesDirProp = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-dir"</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (tracesDirProp.isEmpty()) &#123;</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is not <span class="built_in">set</span>, we are using the <span class="string">"old"</span> trace</span><br><span class="line">        // dumping scheme. All traces are written to a global trace file (usually</span><br><span class="line">        // <span class="string">"/data/anr/traces.txt"</span>) so the code below must take care to unlink and recreate</span><br><span class="line">        // the file <span class="keyword">if</span> requested.</span><br><span class="line">        //</span><br><span class="line">        // This mode of operation will be removed <span class="keyword">in</span> the near future.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String globalTracesPath = SystemProperties.get(<span class="string">"dalvik.vm.stack-trace-file"</span>, null);</span><br><span class="line">        <span class="keyword">if</span> (globalTracesPath.isEmpty()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"dumpStackTraces: no trace path configured"</span>);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tracesFile = new File(globalTracesPath);</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">if</span> (clearTraces &amp;&amp; tracesFile.exists()) &#123;</span><br><span class="line">                tracesFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tracesFile.createNewFile();</span><br><span class="line">            FileUtils.setPermissions(globalTracesPath, 0666, -1, -1); // -rw-rw-rw-</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to prepare ANR traces file: "</span> + tracesFile, e);</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        File tracesDir = new File(tracesDirProp);</span><br><span class="line">        // When dalvik.vm.stack-trace-dir is <span class="built_in">set</span>, we use the <span class="string">"new"</span> trace dumping scheme.</span><br><span class="line">        // Each <span class="built_in">set</span> of ANR traces is written to a separate file and dumpstate will process</span><br><span class="line">        // all such files and add them to a captured bug report <span class="keyword">if</span> they<span class="string">'re recent enough.</span></span><br><span class="line"><span class="string">        maybePruneOldTraces(tracesDir);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // NOTE: We should consider creating the file in native code atomically once we'</span>ve</span><br><span class="line">        // gotten rid of the old scheme of dumping and lot of the code that deals with paths</span><br><span class="line">        // can be removed.</span><br><span class="line">        tracesFile = createAnrDumpFile(tracesDir);</span><br><span class="line">        <span class="keyword">if</span> (tracesFile == null) &#123;</span><br><span class="line">            <span class="built_in">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        useTombstonedForJavaTraces = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids,</span><br><span class="line">            useTombstonedForJavaTraces);</span><br><span class="line">    <span class="built_in">return</span> tracesFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void dumpStackTraces(String tracesFile, ArrayList&lt;Integer&gt; firstPids,</span><br><span class="line">        ArrayList&lt;Integer&gt; nativePids, ArrayList&lt;Integer&gt; extraPids,</span><br><span class="line">        boolean useTombstonedForJavaTraces) &#123;</span><br><span class="line"></span><br><span class="line">    // We don<span class="string">'t need any sort of inotify based monitoring when we'</span>re dumping traces via</span><br><span class="line">    // tombstoned. Data is piped to an <span class="string">"intercept"</span> FD installed <span class="keyword">in</span> tombstoned so we<span class="string">'re in full</span></span><br><span class="line"><span class="string">    // control of all writes to the file in question.</span></span><br><span class="line"><span class="string">    final DumpStackFileObserver observer;</span></span><br><span class="line"><span class="string">    if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">        observer = null;</span></span><br><span class="line"><span class="string">    &#125; else &#123;</span></span><br><span class="line"><span class="string">        // Use a FileObserver to detect when traces finish writing.</span></span><br><span class="line"><span class="string">        // The order of traces is considered important to maintain for legibility.</span></span><br><span class="line"><span class="string">        observer = new DumpStackFileObserver(tracesFile);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // We must complete all stack dumps within 20 seconds.</span></span><br><span class="line"><span class="string">    long remainingTime = 20 * 1000;</span></span><br><span class="line"><span class="string">    try &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.startWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // First collect all of the stacks of the most important pids.</span></span><br><span class="line"><span class="string">        if (firstPids != null) &#123;</span></span><br><span class="line"><span class="string">            int num = firstPids.size();</span></span><br><span class="line"><span class="string">            for (int i = 0; i &lt; num; i++) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for pid "</span></span><br><span class="line"><span class="string">                        + firstPids.get(i));</span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(firstPids.get(i), tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(firstPids.get(i), remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current firstPid=" + firstPids.get(i) +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Next collect the stacks of the native pids</span></span><br><span class="line"><span class="string">        if (nativePids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : nativePids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for native pid " + pid);</span></span><br><span class="line"><span class="string">                final long nativeDumpTimeoutMs = Math.min(NATIVE_DUMP_TIMEOUT_MS, remainingTime);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long start = SystemClock.elapsedRealtime();</span></span><br><span class="line"><span class="string">                Debug.dumpNativeBacktraceToFileTimeout(</span></span><br><span class="line"><span class="string">                        pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));</span></span><br><span class="line"><span class="string">                final long timeTaken = SystemClock.elapsedRealtime() - start;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current native pid=" + pid +</span></span><br><span class="line"><span class="string">                        "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with native pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        // Lastly, dump stacks for all extra PIDs from the CPU tracker.</span></span><br><span class="line"><span class="string">        if (extraPids != null) &#123;</span></span><br><span class="line"><span class="string">            for (int pid : extraPids) &#123;</span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) Slog.d(TAG, "Collecting stacks for extra pid " + pid);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                final long timeTaken;</span></span><br><span class="line"><span class="string">                if (useTombstonedForJavaTraces) &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = dumpJavaTracesTombstoned(pid, tracesFile, remainingTime);</span></span><br><span class="line"><span class="string">                &#125; else &#123;</span></span><br><span class="line"><span class="string">                    timeTaken = observer.dumpWithTimeout(pid, remainingTime);</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                remainingTime -= timeTaken;</span></span><br><span class="line"><span class="string">                if (remainingTime &lt;= 0) &#123;</span></span><br><span class="line"><span class="string">                    Slog.e(TAG, "Aborting stack trace dump (current extra pid=" + pid +</span></span><br><span class="line"><span class="string">                            "); deadline exceeded.");</span></span><br><span class="line"><span class="string">                    return;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                if (DEBUG_ANR) &#123;</span></span><br><span class="line"><span class="string">                    Slog.d(TAG, "Done with extra pid " + pid + " in " + timeTaken + "ms");</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        if (observer != null) &#123;</span></span><br><span class="line"><span class="string">            observer.stopWatching();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="问题分析方法"><a href="#问题分析方法" class="headerlink" title="问题分析方法"></a>问题分析方法</h2><p>分析ANR问题，有三大利器：Logcat，traces和StrictMode。 在StrictMode机制一文中，有介绍StrictMode的实现机制以及用途，本文中不讨论利用StrictMode来解决ANR问题，但各位读者需要有这个意识。 在Watchdog机制以及问题分析一文中，我们介绍过logcat和traces这两种日志的用途。 分析ANR问题同Watchdog问题一样，都需要经过日志获取、问题定位和场景还原三个步骤。</p><h3 id="日志的获取"><a href="#日志的获取" class="headerlink" title="日志的获取"></a>日志的获取</h3><p>分析ANR问题最主要的途径就是通过log来分析。Android中log的获取见，Android的log机制分析一问中log的存储位置章节。</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><p>通过在event log中检索 am_anr 关键字，就可以找到发生ANR的进程，譬如以下日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:27 820 907 I am_anr: [0,29533,com.android.systemui,1082670605,Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;]</span><br></pre></td></tr></table></figure></p><p>表示在 10-16 00:48:27 这个时刻，PID为 29533 进程发生了ANR，进程名是 com.android.systemui<br>接下来可以在system log检索 ANR in 关键字，找到发生ANR前后的CPU使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:50:10 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.systemui, time=130090695</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Load: 30.4 / 22.34 / 19.94</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: Android time :[2015-10-16 00:50:05.76] [130191,266]</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: CPU usage from 6753ms to -4ms ago:</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   47% 320/netd: 3.1% user + 44% kernel / faults: 14886 minor 3 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   15% 10007/com.sohu.sohuvideo: 2.8% user + 12% kernel / faults: 1144 minor</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   13% 10654/hif_thread: 0% user + 13% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   11% 175/mmcqd/0: 0% user + 11% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   5.1% 12165/app_process: 1.6% user + 3.5% kernel / faults: 9703 minor 540 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.3% 29533/com.android.systemui: 2.6% user + 0.7% kernel / faults: 8402 minor 343 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   3.2% 820/system_server: 0.8% user + 2.3% kernel / faults: 5120 minor 523 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   2.5% 11817/com.netease.pomelo.push.l.messageservice_V2: 0.7% user + 1.7% kernel / faults: 7728 minor 687 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.6% 11887/com.android.email: 0.5% user + 1% kernel / faults: 6259 minor 587 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11854/com.android.settings: 0.7% user + 0.7% kernel / faults: 5404 minor 471 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.4% 11869/android.process.acore: 0.7% user + 0.7% kernel / faults: 6131 minor 561 major</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:   1.3% 11860/com.tencent.mobileqq: 0.1% user + 1.1% kernel / faults: 5542 minor 470 major</span><br><span class="line">...</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 12832/cat: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager:  +0% 13211/zygote64: 0% user + 0% kernel</span><br><span class="line">10-16 00:50:10 820 907 E ActivityManager: 87% TOTAL: 3% user + 18% kernel + 64% iowait + 0.5% softirq</span><br></pre></td></tr></table></figure></p><p>这一段日志对于Android开发人员而言，实在太熟悉不过了，它包含的信息量巨大：</p><ul><li><strong>发生ANR的时间。</strong>event log中，ANR的时间是 00：48：27，因为AMS.appNotResponding()首先会打印event log，然后再打印system log， 所以，在system log中，找到ANR的时间是 00:50:10。可以从这个时间点之前的日志中，还原ANR出现时系统的运行状态</li><li><strong>打印ANR日志的进程。</strong>ANR日志都是在system_server进程的AMS线程打印的，在event log和system log中，都能看到 820 和 907， 所以system_server的PID是 802，AMS线程的TID是 907。ANR的监测机制实现在AMS线程，分析一些受系统影响的ANR，需要知道system_server进程的运行状态</li><li><strong>发生ANR的进程。</strong>ANR in关键字就表明了当前ANR的进程是com.android.system.ui，通过event log，知道进程的PID是 29533</li><li><strong>发生ANR的原因。</strong>Reason关键字表明了当前发生ANR的原因是，处理TIME_TICK广播消息超时。 隐含的意思是TIME_TICK是一个串行广播消息，在 29533 的主线程中，执行BroadcastReceiver.onReceive()方法已经超过10秒</li><li><strong>CPU负载。</strong>Load关键字表明了最近1分钟、5分钟、15分钟内的CPU负载分别是30.4、22.3、19.94。CPU最近1分钟的负载最具参考价值，因为ANR的超时限制基本都是1分钟以内， 这可以近似的理解为CPU最近1分钟平均有30.4个任务要处理，这个负载值是比较高的</li><li><strong>CPU使用统计时间段。</strong>CPU usage from XX to XX ago关键字表明了这是在ANR发生之前一段时间内的CPU统计。 类似的还有CPU usage from XX to XX after关键字，表明是ANR发生之后一段时间内的CPU统计</li><li><strong>各进程的CPU使用率。</strong>我们以com.android.systemui进程的CPU使用率为例，它包含以下信息：<br>  1）<strong>总的CPU使用率:</strong> 3.3%，其中systemui进程在用户态的CPU使用率是2.6%，在内核态的使用率是0.7%<br>  2) <strong>缺页次数fault：</strong>8402 minor表示高速缓存中的缺页次数，343 major表示内存的缺页次数。minor可以理解为进程在做内存访问，major可以理解为进程在做IO操作。 当前minor和major值都是比较高的，从侧面反映了发生ANR之前，systemui进程有有较多的内存访问操作，引发的IO次数也会较多<br>  3) <strong>CPU使用率前面的 “+”。</strong>部分进程的CPU使用率前面有 “+” 号，譬如cat和zygote64，表示在上一次CPU统计的时间片段内，还没有这些进程，而这一次CPU统计的时间片段内，运行了这些进程。 类似的还有 “-” 号，表示两次CPU统计时间片段时，这些进程消亡了</li><li><strong>CPU使用汇总。</strong>TOTAL关键字表明了CPU使用的汇总，87%是总的CPU使用率，其中有一项iowait表明CPU在等待IO的时间，占到64%，说明发生ANR以前，有大量的IO操作。app_process、 system_server, com.android.systemui这几个进程的major值都比较大，说明这些进程的IO操作较为频繁，从而拉升了整个iowait的时间</li></ul><p>信息量是如此的庞大，以致于我们都要下结论了：CPU大量的时间都在等待IO，导致systemui进程分配不到CPU时间，从而主线程处理广播消息超时，发生了ANR。<br>对于一个严谨的开发人员而言，这种结论下得有点早，因为还有太多的疑问：</p><ul><li>systemui进程也分到了一些CPU时间(3.3%)，难道BroadcastReceiver.onReceive()方法就一直无法执行吗？</li><li>为什么iowait的时间会这么多，而且多个进程的major值都很高？<br>接下来还是需要从其他日志中还原ANR出现的场景。</li></ul><h3 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h3><h4 id="第一个假设和验证"><a href="#第一个假设和验证" class="headerlink" title="第一个假设和验证"></a>第一个假设和验证</h4><p>带着上文提出来的第一个疑问，我们先来做一个假设：如果systemui进程正在执行BroadcatReceiver.onReceive()方法，那么从traces.txt文件中，应该可以看到主线程的函数调用栈正在执行这个方法。<br>接下来，我们首先从traces文件中，找到发生ANR时(00:48:27)，sysemtui进程的函数调用栈信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">----- pid 29533 at 2015-10-16 00:48:06 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (53):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 288625433917 93454573244 903419 ) utm=20570 stm=8292 core=3 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00060b0c  /system/lib64/libc.so (__epoll_pwait+8)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0001bb54  /system/lib64/libc.so (epoll_pwait+32)</span></span><br><span class="line">  native: <span class="comment">#02 pc 0001b3d8  /system/lib64/libutils.so (android::Looper::pollInner(int)+144)</span></span><br><span class="line">  native: <span class="comment">#03 pc 0001b75c  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+76)</span></span><br><span class="line">  native: <span class="comment">#04 pc 000d7194  /system/lib64/libandroid_runtime.so (android::NativeMessageQueue::pollOnce(_JNIEnv*, int)+48)</span></span><br><span class="line">  at android.os.MessageQueue.nativePollOnce(Native method)</span><br><span class="line">  at android.os.MessageQueue.next(MessageQueue.java:148)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:151)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line"></span><br><span class="line">----- pid 29533 at 2015-10-16 00:48:29 -----</span><br><span class="line">Cmd line: com.android.systemui</span><br><span class="line"></span><br><span class="line">DALVIK THREADS (54):</span><br><span class="line"><span class="string">"main"</span> prio=5 tid=1 Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x75bd5818 self=0x7f8549a000</span><br><span class="line">  | sysTid=29533 nice=0 cgrp=bg_non_interactive <span class="built_in">sched</span>=0/0 handle=0x7f894bbe58</span><br><span class="line">  | state=S schedstat=( 289080040422 93461978317 904874 ) utm=20599 stm=8309 core=0 HZ=100</span><br><span class="line">  | stack=0x7fdffda000-0x7fdffdc000 stackSize=8MB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.println(SourceFile:77)</span><br><span class="line">  - waiting to lock &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger) held by thread 49</span><br><span class="line">  at android.os.Looper.loop(Looper.java:195)</span><br><span class="line">  at android.app.ActivityThread.main(ActivityThread.java:5718)</span><br><span class="line">  at java.lang.reflect.Method.invoke!(Native method)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">  at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:975)</span><br><span class="line">  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:770)</span><br><span class="line">...</span><br><span class="line"><span class="string">"Binder_5"</span> prio=5 tid=49 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x136760a0 self=0x7f7e453000</span><br><span class="line">  | sysTid=6945 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f6e3ce000</span><br><span class="line">  | state=S schedstat=( 5505571091 4567508913 30743 ) utm=264 stm=286 core=4 HZ=100</span><br><span class="line">  | stack=0x7f6b83f000-0x7f6b841000 stackSize=1008KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  native: <span class="comment">#00 pc 00019d14  /system/lib64/libc.so (syscall+28)</span></span><br><span class="line">  native: <span class="comment">#01 pc 0005b5d8  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#02 pc 002c6f18  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  native: <span class="comment">#03 pc 00032c40  /system/lib64/libaoc.so (???)</span></span><br><span class="line">  at libcore.io.Posix.getpid(Native method)</span><br><span class="line">  at libcore.io.ForwardingOs.getpid(ForwardingOs.java:83)</span><br><span class="line">  at android.system.Os.getpid(Os.java:176)</span><br><span class="line">  at android.os.Process.myPid(Process.java:754)</span><br><span class="line">  at com.mediatek.anrappmanager.MessageLogger.dump(SourceFile:219)</span><br><span class="line">  - locked &lt;0x26b337a3&gt; (a com.mediatek.anrappmanager.MessageLogger)</span><br><span class="line">  at com.mediatek.anrappmanager.ANRAppManager.dumpMessageHistory(SourceFile:65)</span><br><span class="line">  at android.app.ActivityThread<span class="variable">$ApplicationThread</span>.dumpMessageHistory(ActivityThread.java:1302)</span><br><span class="line">  at android.app.ApplicationThreadNative.onTransact(ApplicationThreadNative.java:682)</span><br><span class="line">  at android.os.Binder.execTransact(Binder.java:451)</span><br></pre></td></tr></table></figure><p>最终，我们找到systemui进程ANR时刻(00:48:27)附近的两个函数调用栈:</p><ul><li>在ANR发生之前(00:48:06)，主线程的函数调用栈处于正常状态：消息队列中，循环中处理消息</li><li>在ANR发生之后2秒(00:48:29)，主线程处于Blocked状态，在等待一个被49号线程持有的锁。而49号线程是一个Binder线程，anrappmanager正在做dump操作。</li></ul><blockquote><p>笔者分析的日志是MTK平台产生的，所以从函数调用栈中看到com.mediatek.anrappmanager.MessageLogger这样的类，它是MTK在AOSP上的扩展，用于打印ANR日志。</p></blockquote><p>至此，systemui进程发生ANR的直接原因我们已经找到了，systemui进程正在打印traces，存在较长时间的IO操作，导致主线程阻塞，从而无法处理TIME_TICK广播消息，所以发生了ANR。</p><p>要避免这种场景下的ANR，我们就需要打破主线程中Blocked的逻辑。其实本例是由于MTK在AOSP的android.os.Looper.loop()扩展了打印消息队列的功能，该功能存在设计缺陷，会导致锁等待的情况。</p><h4 id="第二个假设和验证"><a href="#第二个假设和验证" class="headerlink" title="第二个假设和验证"></a>第二个假设和验证</h4><p>我们进一步挖掘在systemui还没有发生ANR时，就在打印traces的原因。带着上文提出的第二个疑问，我们来做另一个假设： iowait较高，而且多个进程的major都很高，可能是由于当前正在调用AMS.dumpStackTraces()方法，很多进程都需要将自己的函数调用栈写到traces文件，所以IO就会较高。 如果当前正在调用AMS.dumpStackTraces()方法，那说明当时系统已经发生了异常，要么已经有ANR发生，要么有SNR发生</p><p>从event log中，我们检索到了另一个ANR：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:47:58 820 907 I am_anr  : [0,10464,com.android.settings,1086864965,Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)]</span><br></pre></td></tr></table></figure></p><p>在 00:47:58 这个时刻，com.android.settings进程发生了ANR，而且ANR的时间在systemui之前(00:48:27)。这一下，我们就找到佐证了，正是因为settings进程先发生了ANR，调用AMS.dumpStackTraces()， 从而很多进程都开始了打印traces的操作，所以系统的整个iowait比较高，大量进程的major值也比较高，systemui就在其列。在MTK逻辑的影响下，打印ANR日志会导致主线程阻塞，从而就连带引发了其他应用的ANR。</p><p>在system log中，我们检索到了settings进程ANR的CPU使用信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10-16 00:48:12 820 907 E ActivityManager: ANR <span class="keyword">in</span> com.android.settings (com.android.settings/.SubSettings), time=130063718</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Reason: Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.  Outbound queue length: 0.  Wait queue length: 1.)</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Load: 21.37 / 19.25 / 18.84</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: Android time :[2015-10-16 00:48:12.24] [130077,742]</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager: CPU usage from 0ms to 7676ms later:</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   91% 820/system_server: 16% user + 75% kernel / faults: 13192 minor 167 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   3.2% 175/mmcqd/0: 0% user + 3.2% kernel</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.9% 29533/com.android.systemui: 2.3% user + 0.6% kernel / faults: 1352 minor 10 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 1736/com.android.phone: 0.9% user + 1.3% kernel / faults: 1225 minor 1 major</span><br><span class="line">10-16 00:48:12 820 907 E ActivityManager:   2.2% 10464/com.android.settings: 0.7% user + 1.4% kernel / faults: 2801 minor 105 major</span><br></pre></td></tr></table></figure></p><p>具体的涵义我们不再赘述了，只关注一下ANR的原因:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input dispatching timed out (Waiting to send key event because the focused window has not finished processing all of the input events that were previously delivered to it.</span><br><span class="line">Outbound queue length: 0. Wait queue length: 1.)</span><br></pre></td></tr></table></figure></p><p>之前对Input ANR机制的分析派上用长了，我们轻松知道这种ANR的原因是什么。 Wait queue length： 1表示之前的输入事件已经派发到Settings进程了，但Settings进程还没有处理完毕，新来的KeyEvent事件已经等待超过了5秒，所以ANR产生了。<br>接下来，又需要找到Settings的traces，分析Settings主线程处理输入事件超时的原因，我们点到为止。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对Android ANR机制进行了深入的分析：</p><ul><li><strong>ANR的监测机制</strong>，从Service，Broadcast，InputEvent三种不同的ANR监测机制的源码实现开始，分析了Android如何发现各类ANR。在启动服务、派发广播消息和输入事件时，植入超时检测，用于发现ANR</li><li><strong>ANR的报告机制</strong>，分析Android如何输出ANR日志。当ANR被发现后，两个很重要的日志输出是：CPU使用情况和进程的函数调用栈，这两类日志是我们解决ANR问题的利器</li></ul><p>ANR的解决方法，通过一个案例，对ANR日志进行了深入解读，梳理了分析ANR问题的思路和途径<br>最后，致各位读者，从日志出发解决ANR问题，理解ANR机制背后的实现原理，碰到再难的ANR问题也无需惊慌。</p><p> <strong>Android中的各种log机制以及分析。</strong></p><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol><li>ANR机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-ANR-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-ANR-Analysis</a></li><li>ANR问题分析流程  <a href="https://blog.csdn.net/mathcompfrac/article/details/53862441" target="_blank" rel="noopener">https://blog.csdn.net/mathcompfrac/article/details/53862441</a></li><li>StrictMode 机制以及使用场景 <a href="http://duanqz.github.io/2015-11-04-StrictMode-Analysis" target="_blank" rel="noopener">http://duanqz.github.io/2015-11-04-StrictMode-Analysis</a></li><li>Watchdog机制以及问题分析 <a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2" target="_blank" rel="noopener">http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2</a></li></ol>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android ANR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android8.1.0 DeskClock横屏滑动冲突</title>
      <link href="/2018/06/20/Android8-1-0-DeskClock%E6%A8%AA%E5%B1%8F%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
      <url>/2018/06/20/Android8-1-0-DeskClock%E6%A8%AA%E5%B1%8F%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</url>
      <content type="html"><![CDATA[<h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>【Android版本】:Android 8.1.0<br>【预置条件】在时钟界面添加多个不同国家世界时钟<br>【操作步骤】<br> 1.竖屏下滑动查看<br> 2.切换至横屏滑动查看<br>【实际结果】<br>  2.横屏下出现滑动条不动，时钟界面自己在不停的更新，见视频<br>【期望结果】<br> 横屏下可正常滑动查看</p><h2 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h2><p><strong> 1）</strong> 找到滑动的View的布局代码在<br>竖屏是布局：packages/apps/DeskClock/res/layout/clock_fragment.xml<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.RecyclerView</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:id=<span class="string">"@+id/cities"</span></span><br><span class="line">    android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_weight=<span class="string">"1"</span></span><br><span class="line">    android:clickable=<span class="string">"false"</span></span><br><span class="line">    android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">    android:paddingBottom=<span class="string">"@dimen/fab_height"</span></span><br><span class="line">    android:scrollbarStyle=<span class="string">"outsideOverlay"</span></span><br><span class="line">    android:scrollbars=<span class="string">"vertical"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>横屏的布局：packages/apps/DeskClock/res/layout-land/clock_fragment.xml<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Left gutter. --&gt;</span><br><span class="line">    &lt;Space</span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_weight=<span class="string">"@integer/gutter_width_percent"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Clock: 62% of total width (4% given to right gutter). --&gt;</span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">        android:layout_weight=<span class="string">"62"</span></span><br><span class="line">        android:gravity=<span class="string">"center"</span></span><br><span class="line">        android:paddingBottom=<span class="string">"@dimen/fab_height"</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;include</span><br><span class="line">            android:id=<span class="string">"@+id/main_clock_left_pane"</span></span><br><span class="line">            layout=<span class="string">"@layout/main_clock_frame"</span></span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">            android:layout_weight=<span class="string">"29"</span> /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Right gutter. --&gt;</span><br><span class="line">        &lt;Space</span><br><span class="line">            android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">            android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">            android:layout_weight=<span class="string">"2"</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- World Clock List: 33% of total width. Right gutter is applied <span class="keyword">in</span> world_clock_item. --&gt;</span><br><span class="line">    &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">        android:id=<span class="string">"@+id/cities"</span></span><br><span class="line">        android:layout_width=<span class="string">"0dp"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_gravity=<span class="string">"center"</span></span><br><span class="line">        android:layout_weight=<span class="string">"33"</span></span><br><span class="line">        android:clickable=<span class="string">"false"</span></span><br><span class="line">        android:clipToPadding=<span class="string">"false"</span></span><br><span class="line">        android:paddingBottom=<span class="string">"@dimen/fab_height"</span></span><br><span class="line">        android:paddingTop=<span class="string">"16dp"</span></span><br><span class="line">        android:scrollbarStyle=<span class="string">"outsideOverlay"</span></span><br><span class="line">        android:scrollbars=<span class="string">"vertical"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><p>Java代码实现滑动：packages/apps/DeskClock/src/com/android/deskclock/ClockFragment.java</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android DeskClock View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>StrictMode 机制以及性能调优</title>
      <link href="/2018/06/10/StrictMode-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
      <url>/2018/06/10/StrictMode-%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
      <content type="html"><![CDATA[<p>作为Android开发，日常的开发工作中或多或少要接触到性能问题，比如我的Android程序运行缓慢卡顿，并且常常出现ANR对话框等等问题。既然有性能问题，就需要进行性能优化。正所谓工欲善其事，必先利其器。一个好的工具，可以帮助我们发现并定位问题，进而有的放矢进行解决。本文主要介绍StrictMode 在Android 应用开发中的应用和一些问题。</p><p>Google 官方的StrictMode文档： <a href="https://developer.android.com/reference/android/os/StrictMode" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/StrictMode</a></p><hr><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>StrictMode，严苛模式，是Android提供的一种运行时检测机制，用于检测代码运行时的一些不规范的操作，最常见的场景是用于发现主线程的IO操作和网络读写等耗时的操作。</p><p>StrictMode包含两个维度的概念：</p><ul><li><p><strong>Policy(策略):</strong> 是指StrictMode对一些违规操作的发现策略，分为两类：<br> 一类是针对一个具体的线程(<strong>ThreadPolicy</strong>)。<br> 线程策略检测的内容有</p><ul><li>自定义的耗时调用 使用detectCustomSlowCalls()开启</li><li>磁盘读取操作 使用detectDiskReads()开启</li><li>磁盘写入操作 使用detectDiskWrites()开启</li><li><p>网络操作 使用detectNetwork()开启</p><p>另一类是针对虚拟机的所有对象(<strong>VMPolicy</strong>)。<br>虚拟机策略检测的内容有</p></li><li>Activity泄露 使用detectActivityLeaks()开启</li><li>未关闭的Closable对象泄露 使用detectLeakedClosableObjects()开启</li><li>泄露的Sqlite对象 使用detectLeakedSqlLiteObjects()开启</li><li>检测实例数量 使用setClassInstanceLimit()开启</li></ul></li><li><p><strong>Penalty(惩罚)：</strong>是指StrictMode发现违规操作后进行惩罚的方式，譬如绘制红框、打印日志、显示对话框、杀掉进程等。</p></li></ul><p>Android在很多关键的代码路径上都植入了StrictMode，譬如磁盘读写、网络访问、系统进程启动等。StrictMode会根据设置的策略进行检查，如果某个进程在代码运行时出现了违规操作，那么就会受到”惩罚”。</p><p>应用程序可以利用StrictMode尽可能的发现一些编码的疏漏， Android在 packages/experimental/StrictModeTest 这个APK中提供了常见违规操作的样例， 谨作为大家的反面教材。</p><p>本文深入分析StrictMode背后的实现原理以及使用场景。</p><h1 id="StrictMode机制"><a href="#StrictMode机制" class="headerlink" title="StrictMode机制"></a>StrictMode机制</h1><p>StrictMode的实现涉及到以下源码：</p><ul><li><a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/BlockGuard.java" target="_blank" rel="noopener">libcore/dalvik/src/main/java/dalvik/system/BlockGuard.java</a></li><li><a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/CloseGuard.java" target="_blank" rel="noopener">libcore/dalvik/src/main/java/dalvik/system/CloseGuard.java</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/StrictMode.java" target="_blank" rel="noopener">frameworks/base/core/java/android/os/StrictMode.java</a></li><li><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/os/StrictMode.aidl" target="_blank" rel="noopener">StrictMode.aidl</a></li></ul><p>总体而言，StrictMode机制所涉及到的代码量并不大，但Android中植入StrictMode的地方都是一些重要的关口，StrictMode所体现的面向接口编程的思想以及设计模式的应用，值得我们好好学习。 下面，我们就深入源码，分析一下StrictMode机制的内部实现。</p><h2 id="BlockGuard和CloseGuard"><a href="#BlockGuard和CloseGuard" class="headerlink" title="BlockGuard和CloseGuard"></a>BlockGuard和CloseGuard</h2><p>StrictMode针对单个线程和虚拟机的所有对象都定义了检查策略，用来发现一些违规操作，譬如：主线程中的磁盘读/写、网络访问、未关闭cursor，这些操作都能够被StrictMode检查出来。 怎么做到的呢？在做这些操作时，植入StrictMode的检查代码就可以了。有一部分植入代码是建立在BlockGuard和CloseGuard之上的，可以说，StrictMode是建立在BlockGuard和CloseGuard之上的机制。</p><p><strong>Guard</strong>有“守卫”的意思，<strong>Block</strong>是阻塞的意思，在进行一些耗时操作时，譬如磁盘读写、网络操作，有一个守卫在监测着，它就是BlockGuard，如果这些耗时的操作导致主线程阻塞，BlockGuard就会发出通知; <strong>Close</strong>对应到可打开的文件，在文件被打开后，也有一个守卫在监测着，它就是CloseGuard，如果没有关闭文件，则CloseGuard就会发出通知。</p><p>对应的来看一下 <a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/BlockGuard.java" target="_blank" rel="noopener">BlockGuard.java</a>的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">import java.io.FileDescriptor;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">import java.net.SocketException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Mechanism to <span class="built_in">let</span> threads <span class="built_in">set</span> restrictions on what code is allowed</span><br><span class="line"> * to <span class="keyword">do</span> <span class="keyword">in</span> their thread.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is meant <span class="keyword">for</span> applications to prevent certain blocking</span><br><span class="line"> * operations from running on their main event loop (or <span class="string">"UI"</span>) threads.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that this is all best-effort to catch most accidental mistakes</span><br><span class="line"> * and isn<span class="string">'t intended to be a perfect mechanism, nor provide any sort of</span></span><br><span class="line"><span class="string"> * security.</span></span><br><span class="line"><span class="string"> *</span></span><br><span class="line"><span class="string"> * @hide</span></span><br><span class="line"><span class="string"> */</span></span><br><span class="line"><span class="string">public final class BlockGuard &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // TODO: refactor class name to something more generic, since its scope is</span></span><br><span class="line"><span class="string">    // growing beyond just blocking/logging.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static final int DISALLOW_DISK_WRITE = 0x01;//不允许磁盘盘写</span></span><br><span class="line"><span class="string">    public static final int DISALLOW_DISK_READ = 0x02;//不允许从磁盘读</span></span><br><span class="line"><span class="string">    public static final int DISALLOW_NETWORK = 0x04;//不允许有网络操作</span></span><br><span class="line"><span class="string">    public static final int PASS_RESTRICTIONS_VIA_RPC = 0x08;</span></span><br><span class="line"><span class="string">    public static final int PENALTY_LOG = 0x10;//惩罚的log</span></span><br><span class="line"><span class="string">    public static final int PENALTY_DIALOG = 0x20;//惩罚的dialog</span></span><br><span class="line"><span class="string">    public static final int PENALTY_DEATH = 0x40;//惩罚kill</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public interface Policy &#123;</span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on disk writes.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onWriteToDisk();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on disk reads.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onReadFromDisk();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on network operations.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onNetwork();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Called on unbuffered input/ouput operations.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        void onUnbufferedIO();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        /**</span></span><br><span class="line"><span class="string">         * Returns the policy bitmask, for shipping over Binder calls</span></span><br><span class="line"><span class="string">         * to remote threads/processes and reinstantiating the policy</span></span><br><span class="line"><span class="string">         * there.  The bits in the mask are from the DISALLOW_* and</span></span><br><span class="line"><span class="string">         * PENALTY_* constants.</span></span><br><span class="line"><span class="string">         */</span></span><br><span class="line"><span class="string">        int getPolicyMask();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    public static class BlockGuardPolicyException extends RuntimeException &#123;</span></span><br><span class="line"><span class="string">        // bitmask of DISALLOW_*, PENALTY_*, etc flags</span></span><br><span class="line"><span class="string">        private final int mPolicyState;</span></span><br><span class="line"><span class="string">        private final int mPolicyViolated;</span></span><br><span class="line"><span class="string">        private final String mMessage;   // may be null</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public BlockGuardPolicyException(int policyState, int policyViolated) &#123;</span></span><br><span class="line"><span class="string">            this(policyState, policyViolated, null);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public BlockGuardPolicyException(int policyState, int policyViolated, String message) &#123;</span></span><br><span class="line"><span class="string">            mPolicyState = policyState;</span></span><br><span class="line"><span class="string">            mPolicyViolated = policyViolated;</span></span><br><span class="line"><span class="string">            mMessage = message;</span></span><br><span class="line"><span class="string">            fillInStackTrace();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public int getPolicy() &#123;</span></span><br><span class="line"><span class="string">            return mPolicyState;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public int getPolicyViolation() &#123;</span></span><br><span class="line"><span class="string">            return mPolicyViolated;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        public String getMessage() &#123;</span></span><br><span class="line"><span class="string">            // Note: do not change this format casually.  It'</span>s</span><br><span class="line">            // somewhat unfortunately Parceled and passed around</span><br><span class="line">            // Binder calls and parsed back into an Exception by</span><br><span class="line">            // Android<span class="string">'s StrictMode.  This was the least invasive</span></span><br><span class="line"><span class="string">            // option and avoided a gross mix of Java Serialization</span></span><br><span class="line"><span class="string">            // combined with Parcels.</span></span><br><span class="line"><span class="string">            return "policy=" + mPolicyState + " violation=" + mPolicyViolated +</span></span><br><span class="line"><span class="string">                    (mMessage == null ? "" : (" msg=" + mMessage));</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /**</span></span><br><span class="line"><span class="string">     * The default, permissive policy that doesn'</span>t prevent any operations.</span><br><span class="line">     */</span><br><span class="line">    public static final Policy LAX_POLICY = new <span class="function"><span class="title">Policy</span></span>() &#123;</span><br><span class="line">            public void <span class="function"><span class="title">onWriteToDisk</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onReadFromDisk</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onNetwork</span></span>() &#123;&#125;</span><br><span class="line">            public void <span class="function"><span class="title">onUnbufferedIO</span></span>() &#123;&#125;</span><br><span class="line">            public int <span class="function"><span class="title">getPolicyMask</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Policy&gt; threadPolicy = new ThreadLocal&lt;Policy&gt;() &#123;</span><br><span class="line">        @Override protected Policy <span class="function"><span class="title">initialValue</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> LAX_POLICY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get the current thread<span class="string">'s policy.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @return the current thread'</span>s policy.  Never returns null.</span><br><span class="line">     *     Will <span class="built_in">return</span> the LAX_POLICY instance <span class="keyword">if</span> nothing <span class="keyword">else</span> is <span class="built_in">set</span>.</span><br><span class="line">     */</span><br><span class="line">    public static Policy <span class="function"><span class="title">getThreadPolicy</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> threadPolicy.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the current thread<span class="string">'s block guard policy.</span></span><br><span class="line"><span class="string">     *</span></span><br><span class="line"><span class="string">     * @param policy policy to set.  May not be null.  Use the public LAX_POLICY</span></span><br><span class="line"><span class="string">     *   if you want to unset the active policy.</span></span><br><span class="line"><span class="string">     */</span></span><br><span class="line"><span class="string">    public static void setThreadPolicy(Policy policy) &#123;</span></span><br><span class="line"><span class="string">        if (policy == null) &#123;</span></span><br><span class="line"><span class="string">            throw new NullPointerException("policy == null");</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        threadPolicy.set(policy);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    private BlockGuard() &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>从BlockGuard的代码来看，很简单，就定义了一些类型和方法接口。</p><p>同样的看看<a href="https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system/CloseGuard.java" target="_blank" rel="noopener">CloseGuard.java</a>方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line">package dalvik.system;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CloseGuard is a mechanism <span class="keyword">for</span> flagging implicit finalizer cleanup of</span><br><span class="line"> * resources that should have been cleaned up by explicit close</span><br><span class="line"> * methods (aka <span class="string">"explicit termination methods"</span> <span class="keyword">in</span> Effective Java).</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * A simple example: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   class Foo &#123;</span><br><span class="line"> *</span><br><span class="line"> *       private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"> *</span><br><span class="line"> *       ...</span><br><span class="line"> *</span><br><span class="line"> *       public <span class="function"><span class="title">Foo</span></span>() &#123;</span><br><span class="line"> *           ...;</span><br><span class="line"> *           guard.open(<span class="string">"cleanup"</span>);</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line"> *          guard.close();</span><br><span class="line"> *          ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       protected void finalize() throws Throwable &#123;</span><br><span class="line"> *           try &#123;</span><br><span class="line"> *               // Note that guard could be null <span class="keyword">if</span> the constructor threw.</span><br><span class="line"> *               <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line"> *                   guard.warnIfOpen();</span><br><span class="line"> *               &#125;</span><br><span class="line"> *               cleanup();</span><br><span class="line"> *           &#125; finally &#123;</span><br><span class="line"> *               super.finalize();</span><br><span class="line"> *           &#125;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * In usage <span class="built_in">where</span> the resource to be explicitly cleaned up are</span><br><span class="line"> * allocated after object construction, CloseGuard protection can</span><br><span class="line"> * be deferred. For example: &lt;pre&gt;   &#123;@code</span><br><span class="line"> *   class Bar &#123;</span><br><span class="line"> *</span><br><span class="line"> *       private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"> *</span><br><span class="line"> *       ...</span><br><span class="line"> *</span><br><span class="line"> *       public <span class="function"><span class="title">Bar</span></span>() &#123;</span><br><span class="line"> *           ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">connect</span></span>() &#123;</span><br><span class="line"> *          ...;</span><br><span class="line"> *          guard.open(<span class="string">"cleanup"</span>);</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       public void <span class="function"><span class="title">cleanup</span></span>() &#123;</span><br><span class="line"> *          guard.close();</span><br><span class="line"> *          ...;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *</span><br><span class="line"> *       protected void finalize() throws Throwable &#123;</span><br><span class="line"> *           try &#123;</span><br><span class="line"> *               // Note that guard could be null <span class="keyword">if</span> the constructor threw.</span><br><span class="line"> *               <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line"> *                   guard.warnIfOpen();</span><br><span class="line"> *               &#125;</span><br><span class="line"> *               cleanup();</span><br><span class="line"> *           &#125; finally &#123;</span><br><span class="line"> *               super.finalize();</span><br><span class="line"> *           &#125;</span><br><span class="line"> *       &#125;</span><br><span class="line"> *   &#125;</span><br><span class="line"> * &#125;&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * When used <span class="keyword">in</span> a constructor calls to &#123;@code open&#125; should occur at</span><br><span class="line"> * the end of the constructor since an exception that would cause</span><br><span class="line"> * abrupt termination of the constructor will mean that the user will</span><br><span class="line"> * not have a reference to the object to cleanup explicitly. When used</span><br><span class="line"> * <span class="keyword">in</span> a method, the call to &#123;@code open&#125; should occur just after</span><br><span class="line"> * resource acquisition.</span><br><span class="line"> *</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">public final class CloseGuard &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Instance used when CloseGuard is disabled to avoid allocation.</span><br><span class="line">     */</span><br><span class="line">    private static final CloseGuard NOOP = new CloseGuard();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Enabled by default so we can catch issues early <span class="keyword">in</span> VM startup.</span><br><span class="line">     * Note, however, that Android disables this early <span class="keyword">in</span> its startup,</span><br><span class="line">     * but enables it with DropBoxing <span class="keyword">for</span> system apps on debug builds.</span><br><span class="line">     */</span><br><span class="line">    private static volatile boolean ENABLED = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Hook <span class="keyword">for</span> customizing how CloseGuard issues are reported.</span><br><span class="line">     */</span><br><span class="line">    private static volatile Reporter REPORTER = new DefaultReporter();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The default &#123;@link Tracker&#125;.</span><br><span class="line">     */</span><br><span class="line">    private static final DefaultTracker DEFAULT_TRACKER = new DefaultTracker();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Hook <span class="keyword">for</span> customizing how CloseGuard issues are tracked.</span><br><span class="line">     */</span><br><span class="line">    private static volatile Tracker currentTracker = DEFAULT_TRACKER;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a CloseGuard instance. If CloseGuard is enabled, &#123;@code</span><br><span class="line">     * <span class="comment">#open(String)&#125; can be used to set up the instance to warn on</span></span><br><span class="line">     * failure to close. If CloseGuard is disabled, a non-null no-op</span><br><span class="line">     * instance is returned.</span><br><span class="line">     */</span><br><span class="line">    public static CloseGuard <span class="function"><span class="title">get</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span> NOOP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> new CloseGuard();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Used to <span class="built_in">enable</span> or <span class="built_in">disable</span> CloseGuard. Note that CloseGuard only</span><br><span class="line">     * warns <span class="keyword">if</span> it is enabled <span class="keyword">for</span> both allocation and finalization.</span><br><span class="line">     */</span><br><span class="line">    public static void setEnabled(boolean enabled) &#123;</span><br><span class="line">        ENABLED = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * True <span class="keyword">if</span> CloseGuard mechanism is enabled.</span><br><span class="line">     */</span><br><span class="line">    public static boolean <span class="function"><span class="title">isEnabled</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> ENABLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Used to replace default Reporter used to warn of CloseGuard</span><br><span class="line">     * violations. Must be non-null.</span><br><span class="line">     */</span><br><span class="line">    public static void setReporter(Reporter reporter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reporter == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"reporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        REPORTER = reporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns non-null CloseGuard.Reporter.</span><br><span class="line">     */</span><br><span class="line">    public static Reporter <span class="function"><span class="title">getReporter</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> REPORTER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sets the &#123;@link Tracker&#125; that is notified when resources are allocated and released.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     *</span><br><span class="line">     * @throws NullPointerException <span class="keyword">if</span> tracker is null</span><br><span class="line">     */</span><br><span class="line">    public static void setTracker(Tracker tracker) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tracker == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"tracker == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentTracker = tracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &#123;@link <span class="comment">#setTracker(Tracker) last Tracker that was set&#125;, or otherwise a default</span></span><br><span class="line">     * Tracker that does nothing.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     */</span><br><span class="line">    public static Tracker <span class="function"><span class="title">getTracker</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> currentTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">CloseGuard</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * If CloseGuard is enabled, &#123;@code open&#125; initializes the instance</span><br><span class="line">     * with a warning that the <span class="built_in">caller</span> should have explicitly called the</span><br><span class="line">     * &#123;@code closer&#125; method instead of relying on finalization.</span><br><span class="line">     *</span><br><span class="line">     * @param closer non-null name of explicit termination method</span><br><span class="line">     * @throws NullPointerException <span class="keyword">if</span> closer is null, regardless of</span><br><span class="line">     * whether or not CloseGuard is enabled</span><br><span class="line">     */</span><br><span class="line">    public void open(String closer) &#123;</span><br><span class="line">        // always perform the check <span class="keyword">for</span> valid API usage...</span><br><span class="line">        <span class="keyword">if</span> (closer == null) &#123;</span><br><span class="line">            throw new NullPointerException(<span class="string">"closer == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        // ...but avoid allocating an allocationSite <span class="keyword">if</span> disabled</span><br><span class="line">        <span class="keyword">if</span> (this == NOOP || !ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String message = <span class="string">"Explicit termination method '"</span> + closer + <span class="string">"' not called"</span>;</span><br><span class="line">        allocationSite = new Throwable(message);</span><br><span class="line">        currentTracker.open(allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Throwable allocationSite;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Marks this CloseGuard instance as closed to avoid warnings on</span><br><span class="line">     * finalization.</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">close</span></span>() &#123;</span><br><span class="line">        currentTracker.close(allocationSite);</span><br><span class="line">        allocationSite = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * If CloseGuard is enabled, logs a warning <span class="keyword">if</span> the <span class="built_in">caller</span> did not</span><br><span class="line">     * properly cleanup by calling an explicit close method</span><br><span class="line">     * before finalization. If CloseGuard is disabled, no action is</span><br><span class="line">     * performed.</span><br><span class="line">     */</span><br><span class="line">    public void <span class="function"><span class="title">warnIfOpen</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (allocationSite == null || !ENABLED) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String message =</span><br><span class="line">                (<span class="string">"A resource was acquired at attached stack trace but never released. "</span></span><br><span class="line">                 + <span class="string">"See java.io.Closeable for information on avoiding resource leaks."</span>);</span><br><span class="line"></span><br><span class="line">        REPORTER.report(message, allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Interface to allow customization of tracking behaviour.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is only intended <span class="keyword">for</span> use by &#123;@code dalvik.system.CloseGuardSupport&#125; class and so</span><br><span class="line">     * MUST NOT be used <span class="keyword">for</span> any other purposes.</span><br><span class="line">     */</span><br><span class="line">    public interface Tracker &#123;</span><br><span class="line">        void open(Throwable allocationSite);</span><br><span class="line">        void close(Throwable allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default tracker <span class="built_in">which</span> does nothing special and simply leaves it up to the GC to detect a</span><br><span class="line">     * leak.</span><br><span class="line">     */</span><br><span class="line">    private static final class DefaultTracker implements Tracker &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void open(Throwable allocationSite) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void close(Throwable allocationSite) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Interface to allow customization of reporting behavior.</span><br><span class="line">     */</span><br><span class="line">    public interface Reporter &#123;</span><br><span class="line">        void report (String message, Throwable allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Default Reporter <span class="built_in">which</span> reports CloseGuard violations to the <span class="built_in">log</span>.</span><br><span class="line">     */</span><br><span class="line">    private static final class DefaultReporter implements Reporter &#123;</span><br><span class="line">        @Override public void report (String message, Throwable allocationSite) &#123;</span><br><span class="line">            System.logW(message, allocationSite);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android在很多代码中植入了BlockGuard，以BlockGuardOs为例，这个类代理大部分POSIX系统调用接口，所谓代理，从代码角度，就是在一个类外层再做一层封装。 BlockGuardOs代理了Os类，并植入了BlockGuard，譬如BlockGuardOs.read()这个系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int <span class="built_in">read</span>(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount) throws ErrnoException, InterruptedIOException &#123;</span><br><span class="line">    BlockGuard.getThreadPolicy().onReadFromDisk();</span><br><span class="line">    <span class="built_in">return</span> os.read(fd, bytes, byteOffset, byteCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过BlockGuard的一层封装，在每次进行read()系统调用时，都会通过BlockGuard通知发生了读磁盘的操作：BlockGuard.getThreadPolicy().onReadFromDisk()<br>这里用到了BlockGuard的getThreadPolicy()方法，其实BlockGuard内部有一个Policy，定义了可能导致阻塞的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Policy &#123;</span><br><span class="line">    void onWriteToDisk();</span><br><span class="line">    void onReadFromDisk();</span><br><span class="line">    void onNetwork();</span><br><span class="line">    int getPolicyMask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个Policy只是一个接口定义，专门暴露给外部的 ，StrictMode就实现了BlockGuard.Policy：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static class AndroidBlockGuardPolicy implements BlockGuard.Policy &#123;</span><br><span class="line">    private int mPolicyMask;</span><br><span class="line"></span><br><span class="line">    // Map from violation stacktrace hashcode -&gt; uptimeMillis of</span><br><span class="line">    // last violation.  No locking needed, as this is only</span><br><span class="line">    // accessed by the same thread.</span><br><span class="line">    private ArrayMap&lt;Integer, Long&gt; mLastViolationTime;</span><br><span class="line"></span><br><span class="line">    public AndroidBlockGuardPolicy(final int policyMask) &#123;</span><br><span class="line">        mPolicyMask = policyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"AndroidBlockGuardPolicy; mPolicyMask="</span> + mPolicyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Part of BlockGuard.Policy interface:</span><br><span class="line">    public int <span class="function"><span class="title">getPolicyMask</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> mPolicyMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Part of BlockGuard.Policy interface:</span><br><span class="line">    public void <span class="function"><span class="title">onWriteToDisk</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mPolicyMask &amp; DETECT_DISK_WRITE) == 0) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tooManyViolationsThisLoop()) &#123;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        BlockGuard.BlockGuardPolicyException e = new StrictModeDiskWriteViolation(mPolicyMask);</span><br><span class="line">        e.fillInStackTrace();</span><br><span class="line">        startHandlingViolationException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure></p><p>StrictMode不仅针对BlockGuard.Policy实现了自身的处理逻辑，还扩展了一个方法onCustomSlowCall()，通过BlockGuard.setThreadPolicy()就能够将AndroidBlockGuardPolicy植入到BlockGuard中。</p><p>再来看CloseGuard，与BlockGuard一样，Android在很多代码中也植入了CloseGuard，以FileInputStream为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FileInputStream extends InputStream &#123;</span><br><span class="line">    // 1. 新建CloseGuard全局变量</span><br><span class="line">    private final CloseGuard guard = CloseGuard.get();</span><br><span class="line"></span><br><span class="line">    public FileInputStream(File file) throws FileNotFoundException &#123;</span><br><span class="line">        ...</span><br><span class="line">        // 2. 设置CloseGuard标志</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void close() throws IOException &#123;</span><br><span class="line">        // 3. 清除CloseGuard标志</span><br><span class="line">        guard.close();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void finalize() throws IOException &#123;</span><br><span class="line">        // 4. 判断Close标志是否被清除</span><br><span class="line">        <span class="keyword">if</span> (guard != null) &#123;</span><br><span class="line">            guard.warnIfOpen();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CloseGuard的植入逻辑很清晰，一共分为4部分：</p><ul><li>1)新建一个CloseGuard全局变量</li><li>2)在对象初始化时，设置一个标志，表示需要调用close()方法关闭该对象</li><li>3)在关闭方法中，调用CloseGuard.close()方法，清除标志</li><li>4)在对象销毁时，调用CloaseGuard.warnIfOpen()方法，判断标志是否被清除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">warnIfOpen</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (allocationSite == null || !ENABLED) &#123;</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String message =</span><br><span class="line">        (<span class="string">"A resource was acquired at attached stack trace but never released. "</span></span><br><span class="line">        + <span class="string">"See java.io.Closeable for information on avoiding resource leaks."</span>);</span><br><span class="line"></span><br><span class="line">    REPORTER.report(message, allocationSite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从CloseGuard.warnIfOpen()方法中，可以看到，设置的标志就是allocationSite变量，如果该变量已经置空了，表示已经被清除过了; 否则，就会通过REPORTER报告违规操作。</p><p>REPORTER是CloseGuard暴露一个接口，StrictMode就实现了这个接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static class AndroidCloseGuardReporter implements CloseGuard.Reporter &#123;</span><br><span class="line">    public void report (String message, Throwable allocationSite) &#123;</span><br><span class="line">        onVmPolicyViolation(message, allocationSite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当StrictMode启用时，REPORTER就被设置成了AndroidCloseGuardReporter对象，如此一来，StrictMode就能够收集到CloseGuard报告的未关闭文件。</p><p>至此，我们揭开了StrictMode的面纱：Android通过BlockGuard和CloseGuard在一些执行路径中埋入了一些切点，譬如磁盘读写时BlockGuard会收到通知，对象销毁时CloseGuard就会收到通知。 BlockGuard和CloseGuard都设计了一套接口：BlockGuard.Policy和CloseGuard.Reporter，其实就是切点的不同分类，StrictMode正是利用这两个接口所定义的一些切点，切入了自已的处理逻辑。</p><blockquote><p>题外话: 得益于面向接口的设计，我们可以另起炉灶，完全独立于StrictMode再实现其他BlockGuard.Policy和CloseGuard.Reporter的处理逻辑; 也可以对BlockGuard.Policy和CloseGuard.Reporter进行扩展，StrictMode只需要实现新的处理逻辑即可，这都不会影响已有的架构。 接口定义和接口实现分离，两者可以独立变化，适应新的需求，这是桥接模式(Bridge Pattern)的精髓，它降低了Guard和StrictMode两者之间的耦合度。<br>从BlockGuardOs的设计中，我们也看到了代理模式(Proxy Pattern)，BlockGuardOs对被代理的Os类进行了简单控制，植入了BlockGuard的逻辑，作为一个中间者，处于调用者和被调用实体中间，能够降低两者的耦合度。</p></blockquote><h2 id="StrictMode-Policy"><a href="#StrictMode-Policy" class="headerlink" title="StrictMode Policy"></a>StrictMode Policy</h2><p>StrictMode利用了BlockGuard和CloseGuard，不仅实现了两者定义的一些策略(Policy)，还进行了扩展。 这些策略，在StrictMode看来，就是一些违规操作，下面我们深入介绍StrictMode定义的每一项违规操作。</p><h3 id="ThreadPolicy"><a href="#ThreadPolicy" class="headerlink" title="ThreadPolicy"></a>ThreadPolicy</h3><p>ThreadPolicy细分为以下几种：</p><ul><li>Disk Write：实现了BlockGuard的策略，写磁盘操作</li><li>Disk Read：实现了BlockGuard的策略，读磁盘操作</li><li>Network Access：实现了BlockGuard的策略，网络访问操作</li><li>Custom Slow Code：StrictMode扩展的策略，目前只有Webview中植入了这项检查<br>前三项的植入都是通过BlockGuard完成的，StrictMode只是实现了处理逻辑;最后一项是StrictMode扩展的， 如果一个方法执行的时间较长，可以调用StrictMode.noteSlowCall()方法来发出通知。 当这些操作发生后，最终都会调用StrictMode.handleViolation()方法进行处理，后文再展开讨论这个方法。</li></ul><p>StrictMode通过标志位来区别以上几项，为此还特意封装了一个内部类StrictMode.ThreadPlicy，目的是为了方便标志位的设定。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final class ThreadPolicy &#123;</span><br><span class="line">    // ThreadPolicy标志位</span><br><span class="line">    final int mask;</span><br><span class="line">    private ThreadPolicy(int mask) &#123;</span><br><span class="line">            this.mask = mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 利用Builder完成标志位的初始化</span><br><span class="line">    public static final class Builder &#123;</span><br><span class="line">        private int mMask = 0;</span><br><span class="line"></span><br><span class="line">        public Builder <span class="function"><span class="title">detectDiskReads</span></span>() &#123;</span><br><span class="line">            <span class="built_in">return</span> <span class="built_in">enable</span>(DETECT_DISK_READ);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadPolicy的初始化采用了构建者模式(Builder Pattern)，这样一来，调用者在使用起来就会更加自然一点，不用记住各个标志位的意义。 为了完成标志位的设定，StrictMode提供setThreadPolicy()方法，接收ThreadPolicy类型的对象作为参数，该方法的实现就是直接调用setThreadPolicyMask()：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void setThreadPolicy(final ThreadPolicy policy) &#123;</span><br><span class="line">    setThreadPolicyMask(policy.mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pivate static void setThreadPolicyMask(final int policyMask) &#123;</span><br><span class="line">    setBlockGuardPolicy(policyMask);</span><br><span class="line">    Binder.setThreadStrictModePolicy(policyMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里完成了两个层面的ThreadPolicy设定：</p><ul><li><p><strong>Java层</strong>，通过StrictMode.setBlockGuardPolicy()完成，最终会调用BlockGuard.setThreadPolicy()方法， 将AndroidBlockGuardPolicy对象设定为BlockGuard的Policy;</p></li><li><p><strong>Native层</strong>，通过Binder.setThreadStrictModePolicy()完成，看到这里，想必各位读者心中有了疑问，为什么还会有Native层的ThreadPolicy设置？ 其实，看到Binder，就很容易联想到这是用作跨进程调用的，当进程A发起跨进程调用进入到进程B后，那进程B中的违规操作怎么判定呢？当然也需要一个ThreadPolicy， Binder.setThreadStrictModePolicy()就是用来设置其他进程的ThreadPolicy。进程B中的违规异常也会通过Binder再传回进程A中，如此一来， 一个方法执行路径上的所有违规操作都会被StrictMode发现。</p></li></ul><h3 id="VMPolicy"><a href="#VMPolicy" class="headerlink" title="VMPolicy"></a>VMPolicy</h3><p>ThreadPolicy主要用于发现一些容易导致主线程阻塞的操作，所以它针对的对象是单个线程; 而VMPolicy主要用于发现Java层的内存泄漏，所以它针对的是虚拟机的所有对象。 VMPolicy细分为以下几种：</p><ul><li><strong>Cursor Leak：</strong> 如果注册SQlite Cursor后没有调用close()，则发生了泄漏。</li><li><strong>Closable Leak：</strong>这一项是CloseGuard的实现。如果存在未关闭的对象，则发生了泄漏。</li><li><strong>Activity Leak：</strong> 如果Activity在销毁后，其对象引用还被持有，则发生了泄漏。</li><li><strong>Instance Leak：</strong> StrictMode允许设置一个类的对象数量上限，在系统闲时，Strict会统计虚拟机中实际的对象数量，如果超出设定的上限，则判定为对象泄漏。</li><li><strong>Registion Leak：</strong> 如果注册IntentReceiver后没有调用unregisterReceiver()，则发生了泄漏</li><li><strong>File URI Exposure：</strong>这一项是安全性检查。通过file://的方式共享文件时，存在安全隐患。Android建议通过content://的方式共享文件。</li></ul><p>如同ThreadPolicy一样，VMPolicy也采用了构建者模式(Builder Pattern)进行初始化，在Closable Leak这一项的使用上，与BlockGuard有异曲同工之妙， 但除了Closable Leak是利用CloseGuard以外，其他违规项都是StrictMode自身的逻辑，需要在一些关键路径上植入StrictMode的代码，我们举出两例：</p><p>例1：Cursor Leak</p><p>以下是SQLite Cursor植入了StrictMode机制的代码片段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public SQLiteCursor(SQLiteCursorDriver driver, String editTable, SQLiteQuery query) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (StrictMode.vmSqliteObjectLeaksEnabled()) &#123;</span><br><span class="line">        mStackTrace = new DatabaseObjectNotClosedException().fillInStackTrace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStackTrace = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void <span class="function"><span class="title">finalize</span></span>() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        // <span class="keyword">if</span> the cursor hasn<span class="string">'t been closed yet, close it first</span></span><br><span class="line"><span class="string">        if (mWindow != null) &#123;</span></span><br><span class="line"><span class="string">            if (mStackTrace != null) &#123;</span></span><br><span class="line"><span class="string">                String sql = mQuery.getSql();</span></span><br><span class="line"><span class="string">                int len = sql.length();</span></span><br><span class="line"><span class="string">                StrictMode.onSqliteObjectLeaked(</span></span><br><span class="line"><span class="string">                    "Finalizing a Cursor that has not been deactivated or closed. " +</span></span><br><span class="line"><span class="string">                    "database = " + mQuery.getDatabase().getLabel() +</span></span><br><span class="line"><span class="string">                    ", table = " + mEditTable +</span></span><br><span class="line"><span class="string">                    ", query = " + sql.substring(0, (len &gt; 1000) ? 1000 : len),</span></span><br><span class="line"><span class="string">                    mStackTrace);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            close();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125; finally &#123;</span></span><br><span class="line"><span class="string">        super.finalize();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><p>在SQLiteCursor对象初始化时，设置一个变量mStackTrace，如果开启了DETECT_VM_CURSOR_LEAKS，则将其置为非空。 在SQLiteCursor对象销毁时，会对Cursor是否关闭进行判断(如果CursorWindow非空，则说明没有显示关闭Cursor)。此时，如果mStackTrace变量非空，则向StrictMode报告。</p><p>例2：Activity Leak</p><p>再来一例Activity植入StrictMode的逻辑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityThread.performLaunchActivity()</span><br><span class="line">└── StrictMode.incrementExpectedActivityCount()</span><br><span class="line"></span><br><span class="line">ActivityThread.performDestroyActivity()</span><br><span class="line">└── StrictMode.decrementExpectedActivityCount()</span><br></pre></td></tr></table></figure></p><p>StrictMode对象中维护了Activity的计数器，统计着Activity对象的数量。在Activity对象新建和销毁的时候，会分别调用increment和decrement，对计数进行增减调整。 每一次有Activity对象销毁，都会调用VMDebug.countInstancesOfClass()，计算虚拟机中实际的Activity对象数量，如果实际Activity对象的数量超出了StrictMode的统计值， 则说明Activity对象虽然销毁了，但其对象引用还在，这就存在泄漏。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void decrementExpectedActivityCount(Class klass) &#123;</span><br><span class="line">    ...</span><br><span class="line">    long instances = VMDebug.countInstancesOfClass(klass, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (instances &gt; <span class="built_in">limit</span>) &#123;</span><br><span class="line">        Throwable tr = new InstanceCountViolation(klass, instances, <span class="built_in">limit</span>);</span><br><span class="line">        onVmPolicyViolation(tr.getMessage(), tr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两例中，我们看到，虽然检测的形式各有不同，但本质都是在被检测的对象初始化时(constructor)设置一个标志，在对象销毁时(finalize)再对这个标志进行判断。其他的检测项的实现方式也都大同小异。</p><h2 id="StrictMode-Penalty"><a href="#StrictMode-Penalty" class="headerlink" title="StrictMode Penalty"></a>StrictMode Penalty</h2><p>当StrictMode发现有违规操作后，提供一些惩罚的方式，使用者可以自行组合。</p><ul><li><strong>penaltyDialog：</strong> 弹出对话框</li><li><strong>penaltyDeath：</strong> 杀掉进程</li><li><strong>penaltyDeathOnNetwork</strong></li><li><strong>penaltyFlashScreen：</strong> 在屏幕的最外围绘制一个红框</li><li><strong>penaltyLog：</strong>打印StrictMode日志</li><li><strong>penaltyDropBox：</strong>将日志保存到Dropbox中</li></ul><p>StrictMode内部是通过标志位来记录惩罚操作的类型的，并提供了上述的方法来设置不同的标志位。 StrictMode检测到违规操作后，最终都会调用StrictMode.handleViolation()方法，该方法中就会根据设置的标志位进行惩罚：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void handleViolation(final ViolationInfo info) &#123;</span><br><span class="line">    final boolean justDropBox = (info.policy &amp; THREAD_PENALTY_MASK) == PENALTY_DROPBOX;</span><br><span class="line">    <span class="keyword">if</span> (justDropBox) &#123;</span><br><span class="line">        dropboxViolationAsync(violationMaskSubset, info);</span><br><span class="line">        <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(</span><br><span class="line">                    RuntimeInit.getApplicationObject(),</span><br><span class="line">                    violationMaskSubset,</span><br><span class="line">                    info);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((info.policy &amp; PENALTY_DEATH) != 0) &#123;</span><br><span class="line">        executeDeathPenalty(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法的实现逻辑一目了然，最终通过Binder发起跨进程调用，走到ActivityManagerService.handleApplicationStrictModeViolation()中.</p><h1 id="StrictMode使用"><a href="#StrictMode使用" class="headerlink" title="StrictMode使用"></a>StrictMode使用</h1><p>StrictMode机制只是用于发现一些违规操作，这些违规操作一般都是我们编码的疏漏，在运行时会被StrictMode暴露出来，但StrictMode并非真正意思上的“动态代码检查”。 各位读者有必要知道StrictMode的使用范围：</p><blockquote><p>StrictMode只是用在开发调试阶段，在正式发布时，应该关掉StrictMode,</p><blockquote><p>AOSP的源码中，USER版并没有打开StrictMode<br>由于Android还会对StrictMode的检查策略进行调整，所以Google Play建议上架的APK都关闭StrictMode; 从另一个角度，Google认为所有StrictMode的错误，在正式发布前，都应该解决。<br>StrictMode并不能发现Native层的违规操作，仅仅是用在Java层<br>StrictMode的使用场景可以分为三类，使用方式也都比较固定，可见StrictMode的对外接口还是封装得比较优美的。 下面，我们逐个介绍一下StrictMode的使用场景。</p></blockquote></blockquote><h2 id="普通应用开启StrictMode"><a href="#普通应用开启StrictMode" class="headerlink" title="普通应用开启StrictMode"></a>普通应用开启StrictMode</h2><p>对于应用程序而言，Android提供了一个最佳使用实践：尽可能早的在android.app.Application或android.app.Activity的生命周期使能StrictMode， onCreate()方法就是一个最佳的时机，越早开启就能在更多的代码执行路径上发现违规操作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">onCreate</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEVELOPER_MODE) &#123;</span><br><span class="line">       StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()</span><br><span class="line">               .detectDiskReads()</span><br><span class="line">               .detectDiskWrites()</span><br><span class="line">               .detectNetwork()   // or .detectAll() <span class="keyword">for</span> all detectable problems</span><br><span class="line">               .penaltyLog()</span><br><span class="line">               .build());</span><br><span class="line">       StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()</span><br><span class="line">               .detectLeakedSqlLiteObjects()</span><br><span class="line">               .detectLeakedClosableObjects()</span><br><span class="line">               .penaltyLog()</span><br><span class="line">               .penaltyDeath()</span><br><span class="line">               .build());</span><br><span class="line">    &#125;</span><br><span class="line">    super.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上StrictMode的使能代码限定在DEVELOPER_MODE：</p><ul><li>设定了Disk Read, Disk Write, Network Access三项ThreadPolicy，惩罚是打印日志;</li><li>设定了Cursor Leak, Closable Leak两项VMPolicy，惩罚是打印日志和杀掉进程。<br>当出现一些ThreadPolicy相关违规操作时，Android也提供了很多标准的解决方案，譬如Handler， AsyncTask， IntentService，能够将耗时的操作从主线程中分离出来。</li></ul><h2 id="系统应用开启StrictMode"><a href="#系统应用开启StrictMode" class="headerlink" title="系统应用开启StrictMode"></a>系统应用开启StrictMode</h2><p>对于Android系统应用和系统进程(system_server)而言，其实默认就会开启StrictMode。 StrictMode提供了conditionallyEnableDebugLogging()方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static boolean <span class="function"><span class="title">conditionallyEnableDebugLogging</span></span>() &#123;</span><br><span class="line">    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, <span class="literal">false</span>)</span><br><span class="line">                &amp;&amp; !amTheSystemServerProcess();</span><br><span class="line">    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!doFlashes &amp;&amp; (IS_USER_BUILD || suppress)) &#123;</span><br><span class="line">        setCloseGuardEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   int threadPolicyMask = StrictMode.DETECT_DISK_WRITE |</span><br><span class="line">            StrictMode.DETECT_DISK_READ |</span><br><span class="line">            StrictMode.DETECT_NETWORK;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!IS_USER_BUILD) &#123;</span><br><span class="line">        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StrictMode.setThreadPolicyMask(threadPolicyMask);</span><br><span class="line">    <span class="keyword">if</span> (IS_USER_BUILD) &#123;</span><br><span class="line">        setCloseGuardEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll().penaltyDropBox();</span><br><span class="line">        ...</span><br><span class="line">        setVmPolicy(policyBuilder.build());</span><br><span class="line">        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的目的就是要设置ThreadPolicy和VMPolicy，不过会有一些条件判断，具体的逻辑不表。我们来看一下调用这个方法的地方：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.run()</span><br><span class="line">ServiceThread.run()</span><br><span class="line">ActivityThread.handleBindApplication()</span><br><span class="line">└── StrictMode.conditionallyEnableDebugLogging()</span><br></pre></td></tr></table></figure></p><p>这表示在system_server进程、一些全局的消息线程(IoThread, UiThread, FgThread, DisplayThread)、应用进程这些东西启动的时候开启StrictMode。 在ActivityThread.handleBindApplication()中有这么一段限制：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags &amp;</span><br><span class="line">         (ApplicationInfo.FLAG_SYSTEM |</span><br><span class="line">          ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != 0) &#123;</span><br><span class="line">        StrictMode.conditionallyEnableDebugLogging();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表示只为系统应用(FLAG_SYSTEM, FLAG_UPDATED_SYSTEM_APP)开启了StrictMode，其他应用还是需要自行开启。</p><h2 id="临时关闭StrictMode"><a href="#临时关闭StrictMode" class="headerlink" title="临时关闭StrictMode"></a>临时关闭StrictMode</h2><p>对于某些操作而言，我们明确知道是StrictMode定义的违规操作，但实际上对性能并没有什么影响，那么，在执行这类操作的时候，可以临时关闭StrictMode。 譬如针对一些主线程快速写磁盘的操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.ThreadPolicy old = StrictMode.getThreadPolicy();</span><br><span class="line">StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder(old)</span><br><span class="line">                                 .permitDiskWrites()</span><br><span class="line">                                 .build());</span><br><span class="line">// 进行磁盘写操作...</span><br><span class="line">StrictMode.setThreadPolicy(old);</span><br></pre></td></tr></table></figure></p><p>首先，将旧的ThreadPolicy缓存一把; 然后，设置新的ThreadPolicy，并允许写磁盘操作; 最后，在进行完正常的写磁盘操作后，还原旧的ThreadPolicy。 这样就临时性的避开了StrictMode对写磁盘操作的检查。</p><h2 id="查看开启StrictMode的结果"><a href="#查看开启StrictMode的结果" class="headerlink" title="查看开启StrictMode的结果"></a>查看开启StrictMode的结果</h2><p>严格模式有很多种报告违例的形式，但是想要分析具体违例情况，还是需要查看日志，终端下过滤StrictMode就能得到违例的具体stacktrace信息。<br>adb logcat -b all | grep -rn StrictMode</p><h2 id="解决违例"><a href="#解决违例" class="headerlink" title="解决违例"></a>解决违例</h2><ul><li>如果是主线程中出现文件读写违例，建议使用工作线程（必要时结合Handler）完成。</li><li>如果是对SharedPreferences写入操作，在API 9 以上 建议优先调用apply而非commit。</li><li>如果是存在未关闭的Closable对象，根据对应的stacktrace进行关闭。</li><li>如果是SQLite对象泄露，根据对应的stacktrace进行释放。</li></ul><p>举个例子<br>以主线程中的文件写入为例，引起违例警告的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">    File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">    try &#123;</span><br><span class="line">      OutputStream output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">        output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">        output.flush();</span><br><span class="line">        output.close();</span><br><span class="line">    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引起的警告为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">D/StrictMode( 9730): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode<span class="variable">$StrictModeDiskReadViolation</span>: policy=31 violation=2</span><br><span class="line">D/StrictMode( 9730):    at android.os.StrictMode<span class="variable">$AndroidBlockGuardPolicy</span>.onReadFromDisk(StrictMode.java:1176)</span><br><span class="line">D/StrictMode( 9730):    at libcore.io.BlockGuardOs.open(BlockGuardOs.java:106)</span><br><span class="line">D/StrictMode( 9730):    at libcore.io.IoBridge.open(IoBridge.java:390)</span><br><span class="line">D/StrictMode( 9730):    at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:88)</span><br><span class="line">D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.writeToExternalStorage(MainActivity.java:56)</span><br><span class="line">D/StrictMode( 9730):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:30)</span><br><span class="line">D/StrictMode( 9730):    at android.app.Activity.performCreate(Activity.java:4543)</span><br></pre></td></tr></table></figure></p><p>因为上述属于主线程中的IO违例，解决方法就是讲写入操作放入工作线程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          super.run();</span><br><span class="line">          File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">          File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">          try &#123;</span><br><span class="line">              OutputStream output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">              output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">              output.flush();</span><br><span class="line">              output.close();</span><br><span class="line">          &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; catch (IOException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而这并非完善，因为OutputStream.write方法可能抛出IOException，导致存在OutputStream对象未关闭的情况，仍然需要改进避免出现Closable对象未关闭的违例。改进如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void <span class="function"><span class="title">writeToExternalStorage</span></span>() &#123;</span><br><span class="line">    new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">      @Override</span><br><span class="line">        public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">          super.run();</span><br><span class="line">            File externalStorage = Environment.getExternalStorageDirectory();</span><br><span class="line">            File destFile = new File(externalStorage, <span class="string">"dest.txt"</span>);</span><br><span class="line">            OutputStream output = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                output = new FileOutputStream(destFile, <span class="literal">true</span>);</span><br><span class="line">                output.write(<span class="string">"droidyue.com"</span>.getBytes());</span><br><span class="line">                output.flush();</span><br><span class="line">                output.close();</span><br><span class="line">            &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="keyword">if</span> (null != output) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      output.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用StrictMode检测内存泄露"><a href="#使用StrictMode检测内存泄露" class="headerlink" title="使用StrictMode检测内存泄露"></a>使用StrictMode检测内存泄露</h2><p>通常情况下，检测内存泄露，我们需要使用MAT对heap dump 文件进行分析，这种操作不困难，但也不容易。使用严格模式，只需要过滤日志就能发现内存泄露。</p><p>这里以Activity为例说明，首先我们需要开启对检测Activity泄露的违例检测。使用上面的detectAll或者detectActivityLeaks()均可。其次写一段能够产生Activity泄露的代码。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class LeakyActivity extends Activity&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        MyApplication.sLeakyActivities.add(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>MyApplication中关于sLeakyActivities的部分实现<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">  public static final boolean IS_DEBUG = <span class="literal">true</span>;</span><br><span class="line">    public static ArrayList&lt;Activity&gt; sLeakyActivities = new ArrayList&lt;Activity&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们反复进入LeakyActivity再退出，过滤StrictMode就会得到这样的日志:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E/StrictMode( 2622): class com.example.strictmodedemo.LeakyActivity; instances=2; <span class="built_in">limit</span>=1</span><br><span class="line">E/StrictMode( 2622): android.os.StrictMode<span class="variable">$InstanceCountViolation</span>: class com.example.strictmodedemo.LeakyActivity; instances=2; <span class="built_in">limit</span>=1</span><br><span class="line">E/StrictMode( 2622):    at android.os.StrictMode.setClassInstanceLimit(StrictMode.java:1)</span><br></pre></td></tr></table></figure></p><p>分析日志，LeakyActivity本应该是只存在一份实例，但现在出现了2个，说明LeakyActivity发生了内存泄露。</p><p>严格模式除了可以检测Activity的内存泄露之外，还能自定义检测类的实例泄露。从API 11 开始，系统提供的这个方法可以实现我们的需求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)</span><br></pre></td></tr></table></figure><p>举个栗子，比如一个浏览器中只允许存在一个SearchBox实例，我们就可以这样设置已检测SearchBox实例的泄露<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.setVmPolicy(new VmPolicy.Builder().setClassInstanceLimit(SearchBox.class, 1).penaltyLog().build());</span><br></pre></td></tr></table></figure></p><h2 id="自定义-noteSlowCall"><a href="#自定义-noteSlowCall" class="headerlink" title="自定义 noteSlowCall"></a>自定义 noteSlowCall</h2><p>StrictMode从 API 11开始允许开发者自定义一些耗时调用违例，这种自定义适用于自定义的任务执行类中，比如我们有一个进行任务处理的类，为TaskExecutor。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutor &#123;</span><br><span class="line">    public void execute(Runnable task) &#123;</span><br><span class="line">        task.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先需要跟踪每个任务的耗时情况，如果大于500毫秒需要提示给开发者，noteSlowCall就可以实现这个功能，如下修改代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class TaskExecutor &#123;</span><br><span class="line"></span><br><span class="line">    private static long SLOW_CALL_THRESHOLD = 500;</span><br><span class="line">    public void executeTask(Runnable task) &#123;</span><br><span class="line">        long startTime = SystemClock.uptimeMillis();</span><br><span class="line">        task.run();</span><br><span class="line">        long cost = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">if</span> (cost &gt; SLOW_CALL_THRESHOLD) &#123;</span><br><span class="line">            StrictMode.noteSlowCall(<span class="string">"slowCall cost="</span> + cost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行一个耗时2000毫秒的任务<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TaskExecutor executor = new TaskExecutor();</span><br><span class="line">executor.executeTask(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">  @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p> 得到的违例日志，注意其中~duration=20 ms并非耗时任务的执行时间，而我们的自定义信息msg=slowCall cost=2000才包含了真正的耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">D/StrictMode(23890): StrictMode policy violation; ~duration=20 ms: android.os.StrictMode<span class="variable">$StrictModeCustomViolation</span>: policy=31 violation=8 msg=slowCall cost=2000</span><br><span class="line">D/StrictMode(23890):    at android.os.StrictMode<span class="variable">$AndroidBlockGuardPolicy</span>.onCustomSlowCall(StrictMode.java:1163)</span><br><span class="line">D/StrictMode(23890):    at android.os.StrictMode.noteSlowCall(StrictMode.java:1974)</span><br><span class="line">D/StrictMode(23890):    at com.example.strictmodedemo.TaskExecutor.executeTask(TaskExecutor.java:17)</span><br><span class="line">D/StrictMode(23890):    at com.example.strictmodedemo.MainActivity.onCreate(MainActivity.java:36)</span><br><span class="line">D/StrictMode(23890):    at android.app.Activity.performCreate(Activity.java:4543)</span><br><span class="line">D/StrictMode(23890):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1071)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2158)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2237)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.access<span class="variable">$600</span>(ActivityThread.java:139)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread<span class="variable">$H</span>.handleMessage(ActivityThread.java:1262)</span><br><span class="line">D/StrictMode(23890):    at android.os.Handler.dispatchMessage(Handler.java:99)</span><br><span class="line">D/StrictMode(23890):    at android.os.Looper.loop(Looper.java:156)</span><br><span class="line">D/StrictMode(23890):    at android.app.ActivityThread.main(ActivityThread.java:5005)</span><br><span class="line">D/StrictMode(23890):    at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">D/StrictMode(23890):    at java.lang.reflect.Method.invoke(Method.java:511)</span><br><span class="line">D/StrictMode(23890):    at com.android.internal.os.ZygoteInit<span class="variable">$MethodAndArgsCaller</span>.run(ZygoteInit.java:784)</span><br><span class="line">D/StrictMode(23890):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)</span><br><span class="line">D/StrictMode(23890):    at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><p>除了通过日志查看之外，我们也可以在开发者选项中开启严格模式，开启之后，如果主线程中有执行时间长的操作，屏幕则会闪烁，这是一个更加直接的方法。</p><p><strong>注意</strong></p><blockquote><p>在线上环境即Release版本不建议开启严格模式。<br>严格模式无法监控JNI中的磁盘IO和网络请求。<br>应用中并非需要解决全部的违例情况，比如有些IO操作必须在主线程中进行。</p></blockquote><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><blockquote><ol><li><a href="http://duanqz.github.io/2015-11-04-StrictMode-Analysis" target="_blank" rel="noopener">StrictMode机制以及使用场景</a></li><li><a href="https://www.cnblogs.com/yaowen/p/6024690.html" target="_blank" rel="noopener">Android严苛模式StrictMode使用详解</a> </li><li><a href="https://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/index.html" target="_blank" rel="noopener">Android性能调优利器StrictMode</a></li></ol></blockquote>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android StrictMode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Watchdog机制以及问题分析</title>
      <link href="/2018/06/01/Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/01/Watchdog%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Watchdog的中文的“看门狗”，有保护的意思。最早引入Watchdog是在单片机系统中，由于单片机的工作环境容易受到外界磁场的干扰，导致程序“跑飞”，造成整个系统无法正常工作，因此，引入了一个“看门狗”，对单片机的运行状态进行实时监测，针对运行故障做一些保护处理，譬如让系统重启。这种Watchdog属于硬件层面，必须有硬件电路的支持。</p><p>Linux也引入了Watchdog，在Linux内核下，当Watchdog启动后，便设定了一个定时器，如果在超时时间内没有对/dev/Watchdog进行写操作，则会导致系统重启。通过定时器实现的Watchdog属于软件层面。</p><p>Android设计了一个软件层面Watchdog，用于保护一些重要的系统服务，当出现故障时，通常会让Android系统重启。由于这种机制的存在，就经常会出现一些system_server进程被Watchdog杀掉而发生手机重启的问题。</p><p>本文期望回答以下问题：</p><ul><li>1)Watchdog是怎么工作的？这涉及到Watchdog的工作机制。</li><li>2)遇到Watchdog的问题该怎么办？这涉及到分析Watchdog问题的惯用方法。</li></ul><p><strong>本文主要分析的是Framework中的Watchdog，底层(Kernel)侧也有Watchdog机制。但本文不分析。</strong></p><h1 id="Watchdog机制"><a href="#Watchdog机制" class="headerlink" title="Watchdog机制"></a>Watchdog机制</h1><p>本文以<a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/Watchdog.java</a>为蓝本，分析Watchdog的实现逻辑。为了描述方便，ActivityManagerService， PackageManagerService， WindowManagerService会分别简称为AMS, PKMS, WMS。</p><h2 id="Watchdog的初始化"><a href="#Watchdog的初始化" class="headerlink" title="Watchdog的初始化"></a>Watchdog的初始化</h2><p>Android的Watchdog是一个单例线程，在System Server时就会初始化Watchdog。Watchdog在初始化时，会构建很多HandlerChecker，大致可以分为两类：</p><ul><li>Monitor Checker，用于检查是Monitor对象可能发生的死锁, AMS, PKMS, WMS等核心的系统服务都是Monitor对象。</li><li>Looper Checker，用于检查线程的消息队列是否长时间处于工作状态。Watchdog自身的消息队列，Ui, Io, Display这些全局的消息队列都是被检查的对象。此外，一些重要的线程的消息队列，也会加入到Looper Checker中，譬如AMS, PKMS，这些是在对应的对象初始化时加入的。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private <span class="function"><span class="title">Watchdog</span></span>() &#123;</span><br><span class="line">    ....</span><br><span class="line">    mMonitorChecker = new HandlerChecker(FgThread.getHandler(),</span><br><span class="line">                <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">    mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(new Handler(Looper.getMainLooper()),</span><br><span class="line">                <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(UiThread.getHandler(),</span><br><span class="line">                <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(IoThread.getHandler(),</span><br><span class="line">                <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    mHandlerCheckers.add(new HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">                <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两类HandlerChecker的侧重点不同，Monitor Checker预警我们不能长时间持有核心系统服务的对象锁，否则会阻塞很多函数的运行; Looper Checker预警我们不能长时间的霸占消息队列，否则其他消息将得不到处理。这两类都会导致系统卡住(System Not Responding)。</p><h2 id="添加Watchdog监测对象"><a href="#添加Watchdog监测对象" class="headerlink" title="添加Watchdog监测对象"></a>添加Watchdog监测对象</h2><p>Watchdog初始化以后，就可以作为system_server进程中的一个单独的线程运行了。但这个时候，还不能触发Watchdog的运行，因为AMS, PKMS等系统服务还没有加入到Watchdog的监测集。 所谓监测集，就是需要Watchdog关注的对象，Android中有成千上万的消息队列在同时运行，然而，Watchdog毕竟是系统层面的东西，它只会关注一些核心的系统服务。</p><p>Watchdog提供两个方法，分别用于添加Monitor Checker对象和Looper Checker对象:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void addMonitor(Monitor monitor) &#123;</span><br><span class="line">    // 将monitor对象添加到Monitor Checker中，</span><br><span class="line">    // 在Watchdog初始化时，可以看到Monitor Checker本身也是一个HandlerChecker对象</span><br><span class="line">    mMonitors.add(monitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addThread(Handler thread, long timeoutMillis) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">            throw new RuntimeException(<span class="string">"Threads can't be added once the Watchdog is running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        final String name = thread.getLooper().getThread().getName();</span><br><span class="line">        // 为Handler构建一个HandlerChecker对象，其实就是**Looper Checker**</span><br><span class="line">        mHandlerCheckers.add(new HandlerChecker(thread, name, timeoutMillis));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被Watchdog监测的对象，都需要将自己添加到Watchdog的监测集中。以下是AMS的类定义和构造器的代码片段：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class ActivityManagerService extends ActivityManagerNative</span><br><span class="line">        implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback &#123;</span><br><span class="line"></span><br><span class="line">    public ActivityManagerService(Context systemContext) &#123;</span><br><span class="line">        ...</span><br><span class="line">        Watchdog.getInstance().addMonitor(this);</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">monitor</span></span>() &#123;</span><br><span class="line">        synchronized (this) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AMS实现了Watchdog.Monitor接口，这个接口只有一个方法，就是monitor()，它的作用后文会再解释。这里可以看到在AMS的构造器中，将自己添加到Monitor Checker对象中，然后将自己的handler添加到Looper Checker对象中。 其他重要的系统服务添加到Watchdog的代码逻辑都与AMS差不多。</p><p>整个Android系统中，被monitor的对象并不多，十个手指头就能数出来Watchdog.Monitor的实现类的个数。</p><h2 id="Watchdog的监测机制"><a href="#Watchdog的监测机制" class="headerlink" title="Watchdog的监测机制"></a>Watchdog的监测机制</h2><p>Watchdog本身是一个线程，它的run()方法实现如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">    boolean waitedHalf = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            ...</span><br><span class="line">            // 1. 调度所有的HandlerChecker</span><br><span class="line">            <span class="keyword">for</span> (int i=0; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                hc.scheduleCheckLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            // 2. 开始定期检查</span><br><span class="line">            long start = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">while</span> (timeout &gt; 0) &#123;</span><br><span class="line">                ...</span><br><span class="line">                try &#123;</span><br><span class="line">                    <span class="built_in">wait</span>(timeout);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    Log.wtf(TAG, e);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 3. 检查HandlerChecker的完成状态</span><br><span class="line">            final int waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">            <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 4. 存在超时的HandlerChecker</span><br><span class="line">            blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">            subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">            allowRestart = mAllowRestart;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 5. 保存日志，判断是否需要杀掉系统进程</span><br><span class="line">        Slog.w(TAG, <span class="string">"*** GOODBYE!"</span>);</span><br><span class="line">        Process.killProcess(Process.myPid());</span><br><span class="line">        System.exit(10);</span><br><span class="line">    &#125; // end of <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码片段主要的运行逻辑如下：</p><ol><li>Watchdog运行后，便开始无限循环，依次调用每一个HandlerChecker的scheduleCheckLocked()方法</li><li>调度完HandlerChecker之后，便开始定期检查是否超时，每一次检查的间隔时间由CHECK_INTERVAL常量设定，为30秒</li><li>每一次检查都会调用evaluateCheckerCompletionLocked()方法来评估一下HandlerChecker的完成状态：<ul><li>COMPLETED表示已经完成</li><li>WAITING和WAITED_HALF表示还在等待，但未超时</li><li>OVERDUE表示已经超时。默认情况下，timeout是1分钟，但监测对象可以通过传参自行设定，譬如PKMS的Handler Checker的超时是10分钟</li></ul></li><li>如果超时时间到了，还有HandlerChecker处于未完成的状态(OVERDUE)，则通过getBlockedCheckersLocked()方法，获取阻塞的HandlerChecker，生成一些描述信息</li><li>保存日志，包括一些运行时的堆栈信息，这些日志是我们解决Watchdog问题的重要依据。如果判断需要杀掉system_server进程，则给当前进程(system_server)发送signal 9</li></ol><p>只要Watchdog没有发现超时的任务，HandlerChecker就会被不停的调度，那HandlerChecker具体做一些什么检查呢？ 直接上代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final class HandlerChecker implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    public void <span class="function"><span class="title">scheduleCheckLocked</span></span>() &#123;</span><br><span class="line">        // Looper Checker中是不包含monitor对象的，判断消息队列是否处于空闲</span><br><span class="line">        <span class="keyword">if</span> (mMonitors.size() == 0 &amp;&amp; mHandler.getLooper().isIdling()) &#123;</span><br><span class="line">            mCompleted = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 将Monitor Checker的对象置于消息队列之前，优先运行</span><br><span class="line">        mHandler.postAtFrontOfQueue(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        // 依次调用Monitor对象的monitor()方法</span><br><span class="line">        <span class="keyword">for</span> (int i = 0 ; i &lt; size ; i++) &#123;</span><br><span class="line">            synchronized (Watchdog.this) &#123;</span><br><span class="line">                mCurrentMonitor = mMonitors.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentMonitor.monitor();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>对于Looper Checker而言，会判断线程的消息队列是否处于空闲状态。 如果被监测的消息队列一直闲不下来，则说明可能已经阻塞等待了很长时间</li><li>对于Monitor Checker而言，会调用实现类的monitor方法，譬如上文中提到的AMS.monitor()方法， 方法实现一般很简单，就是获取当前类的对象锁，如果当前对象锁已经被持有，则monitor()会一直处于wait状态，直到超时，这种情况下，很可能是线程发生了死锁</li></ul><p>至此，我们已经分析了Watchdog的工作机制，回答了我们提出的第一个问题：<br>Watchdog定时检查一些重要的系统服务，举报长时间阻塞的事件，甚至杀掉system_server进程，让Android系统重启。</p><h1 id="问题分析方法"><a href="#问题分析方法" class="headerlink" title="问题分析方法"></a>问题分析方法</h1><h2 id="日志获取"><a href="#日志获取" class="headerlink" title="日志获取"></a>日志获取</h2><p>Andriod的日志门类繁多，而且，为了调试的需要，设备厂商和应用开发者都会在AOSP的基础上增加很多日志。 面对如此庞大复杂的日志系统，通常只有对应领域的专家才能看懂其透露的细节信息，就像去医院就诊，医生一看检查报告就知道患者身体出了什么问题，而外行对这些诊断信息往往是束手无策的。</p><p>解决Watchdog相关的问题，对日志的要求比较高，有些问题与当时的系统环境相关，仅仅凭借单一的日志并不能定位问题。 以下罗列出获取Android日志的一些重要手段，部分场景下，Watchdog相关的问题甚至需要以下所有的日志：</p><ul><li><p><strong>logcat</strong> 通过adb logcat命令输出Android的一些当前运行日志，可以通过logcat的 -b 参数指定要输出的日志缓冲区，缓冲区对应着logcat的一种日志类型。 高版本的logcat可以使用 -b all 获取到所有缓冲区的日志</p><ul><li><strong>event</strong> 通过android.util.EventLog工具类打印的日志，一些重要的系统事件会使用此类日志</li><li><strong>main</strong> 通过android.util.Log工具类打印的日志，应用程序，尤其是基于SDK的应用程序，会使用此类日志</li><li><strong>system</strong> 通过android.util.Slog工具类打印的日志，系统相关的日志一般都是使用此类日志，譬如SystemServer</li><li><strong>radio</strong> 通过android.util.Rlog工具类打印的日志，通信模块相关的日志一般都是使用此类日志，譬如RIL</li></ul></li><li><p><strong>dumpsys</strong> 通过adb dumpsys命令输出一些重要的系统服务信息，譬如内存、电源、磁盘等， 工作原理可以查阅dumpsys介绍一文</p></li><li><p><strong>traces</strong> 该文件记录了一个时间段的函数调用栈信息，通常在应用发生ANR(Application Not Responding)时，会触发打印各进程的函数调用栈。 站在Linux的角度，其实就是向进程发送SIGNAL_QUIT(3)请求，譬如，我们可以通过adb shell kill -3 <pid>命令，打印指定进程的的trace。 SIGNAL_QUIT(3)表面意思有一点误导，它其实并不会导致进程退出。输出一般在 <em>/data/anr/traces.txt</em> 文件中，当然，这是可以灵活配置的， Android提供的系统属性dalvik.vm.stack-trace-file可以用来配置生成traces文件的位置。</pid></p></li><li><p><strong>binder</strong> 通过Binder跨进程调用的日志，可以通过adb shell cat命令从 /proc/binder 下取出对应的日志</p><ul><li><strong>failed_transaction_log</strong></li><li><strong>transaction_log</strong></li><li><strong>transactions</strong></li><li><strong>stats</strong></li></ul></li><li><p><strong>dropbox</strong> 为了记录历史的logcat日志，Android引入了Dropbox，将历史日志持久化到磁盘中(/data/system/dropbox)。 logcat的缓冲区大小毕竟是有限的，所以需要循环利用，这样历史的日志信息就会被冲掉。在一些自动化测试的场景下，譬如Monkey需要长时间的运行， 就需要把历史的日志全都保存下来。</p></li><li><p><strong>tombstone</strong> tombstone错误一般由Dalvik错误、native层的代码问题导致的。当系统发生tombstone时，内核会上报一个严重的警告信号， 上层收到后，把当前的调用栈信息持久化到磁盘中(/data/tombstone)</p></li><li><p><strong>bugreport</strong> 通过adb bugreport命令输出，日志内容多到爆，logcat, traces, dmesg, dumpsys, binder的日志都包含在其中。 由于输出bugreport的时间很长，当系统发生错误时，我们再执行bugreport往往就来不及了(此时，系统可能都已经重启了)，所以，要动用bugreport就需要结合一些其他机制， 譬如在杀掉system_server进程之前，先让bugreport运行完。</p></li></ul><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>Watchdog出现的日志很明显，logcat中的event, system中都会有体现，要定位问题，可以从检索日志中的watchdog关键字开始。</p><p>发生Watchdog检测超时这么重要的系统事件，Android会打印一个EventLog：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchdog: Blocked <span class="keyword">in</span> handler XXX    <span class="comment"># 表示HandlerChecker超时了</span></span><br><span class="line">watchdog: Blocked <span class="keyword">in</span> monitor XXX    <span class="comment"># 表示MonitorChecker超时了</span></span><br></pre></td></tr></table></figure></p><p>Watchdog是运行在system_server进程中，会打印一些System类型的日志。在手机处于非调试状态时，伴随Watchdog出现的往往是system_server进程被杀，从而系统重启。 当Watchdog要主动杀掉system_server进程时，以下关键字就会出现在SystemLog中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: XXX</span><br><span class="line">Watchdog: XXX</span><br><span class="line">Watchdog: <span class="string">"*** GOODBYE!</span></span><br></pre></td></tr></table></figure></p><p>当我们在日志中检索到上述两类关键信息时，说明“Watchdog显灵”了，从另一个角度来理解，就是“System Not Responding”了。 接下来，我们需要进一步定位在watchdog出现之前，system_server进程在干什么，处于一个什么状态。 这与排除”Application Not Responding“问题差不多，我们需要进程的traces信息、当前系统的CPU运行信息、IO信息。</p><p>找到Watchddog出现之前的traces.txt文件，这个时间差最好不要太大，因为Watchdog默认的超时时间是1分钟，太久以前的traces并不能说明问题。 诱导Watchdong出现的直接原因其实就是system_server中某个线程被阻塞了，这个信息在event和system的log中清晰可见。 我们以一个systemLog为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="keyword">in</span> monitor com.android.server.wm.WindowManagerService on foreground thread (android.fg)</span><br></pre></td></tr></table></figure></p><p>Watchdog告诉我们Monitor Checker超时了，具体在哪呢？ 名为android.fg的线程在WindowManagerService的monitor()方法被阻塞了。这里隐含了两层意思：</p><ol><li>WindowManagerService实现了Watchdog.Monitor这个接口，并将自己作为Monitor Checker的对象加入到了Watchdog的监测集中</li><li>monitor()方法是运行在android.fg线程中的。Android将android.fg设计为一个全局共享的线程，意味着它的消息队列可以被其他线程共享， Watchdog的Monitor Checker就是使用的android.fg线程的消息队列。因此，出现Monitor Checker的超时，肯定是android.fg线程阻塞在monitor()方法上。</li></ol><p>我们打开system_server进程的traces，检索 android.fg 可以快速定位到该线程的函数调用栈：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"android.fg"</span> prio=5 tid=25 Blocked</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12eef900 self=0x7f7a8b1000</span><br><span class="line">  | sysTid=973 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f644e9000</span><br><span class="line">  | state=S schedstat=( 3181688530 2206454929 8991 ) utm=251 stm=67 core=1 HZ=100</span><br><span class="line">  | stack=0x7f643e7000-0x7f643e9000 stackSize=1036KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at com.android.server.wm.WindowManagerService.monitor(WindowManagerService.java:13125)</span><br><span class="line">  - waiting to lock &lt;0x126dccb8&gt; (a java.util.HashMap) held by thread 91</span><br><span class="line">  at com.android.server.Watchdog<span class="variable">$HandlerChecker</span>.run(Watchdog.java:204)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:194)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:61)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:46)</span><br></pre></td></tr></table></figure></p><p>android.fg线程调用栈告诉我们几个关键的信息：</p><ul><li>这个线程当前的状态是Blocked，阻塞</li><li>由Watchdog发起调用monitor()，这是一个Watchdog检查，阻塞已经超时</li><li>waiting to lock <0x126dccb8>： 阻塞的原因是monitor()方法中在等锁<0x126dccb8></0x126dccb8></0x126dccb8></li><li>held by thread 91： 这个锁被编号为91的线程持有，需要进一步观察91号线程的状态。</li></ul><blockquote><p>题外话：每一个进程都会对自己所辖的线程编号，从1开始。1号线程通常就是我们所说的主线程。 线程在Linux系统中还有一个全局的编号，由sysTid表示。我们在logcat等日志中看到的一般是线程的全局编号。 譬如，本例中android.fg线程在system_server进程中的编号是25，系统全局编号是973。</p></blockquote><p>可以在traces.txt文件中检索 tid=91 来快速找到91号线程的函数调用栈信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Binder_C"</span> prio=5 tid=91 Native</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12e540a0 self=0x7f63289000</span><br><span class="line">  | sysTid=1736 nice=0 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f6127c000</span><br><span class="line">  | state=S schedstat=( 96931835222 49673449591 260122 ) utm=7046 stm=2647 core=2 HZ=100</span><br><span class="line">  | stack=0x7f5ffbc000-0x7f5ffbe000 stackSize=1008KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at libcore.io.Posix.writeBytes(Native method)</span><br><span class="line">  at libcore.io.Posix.write(Posix.java:258)</span><br><span class="line">  at libcore.io.BlockGuardOs.write(BlockGuardOs.java:313)</span><br><span class="line">  at libcore.io.IoBridge.write(IoBridge.java:537)</span><br><span class="line">  at java.io.FileOutputStream.write(FileOutputStream.java:186)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.flushBytesLocked(FastPrintWriter.java:334)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.flushLocked(FastPrintWriter.java:355)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.appendLocked(FastPrintWriter.java:303)</span><br><span class="line">  at com.android.internal.util.FastPrintWriter.print(FastPrintWriter.java:466)</span><br><span class="line">  - locked &lt;@addr=0x134c4910&gt; (a com.android.internal.util.FastPrintWriter<span class="variable">$DummyWriter</span>)</span><br><span class="line">  at com.android.server.wm.WindowState.dump(WindowState.java:1510)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dumpWindowsNoHeaderLocked(WindowManagerService.java:12279)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dumpWindowsLocked(WindowManagerService.java:12266)</span><br><span class="line">  at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</span><br><span class="line">  - locked &lt;0x126dccb8&gt; (a java.util.HashMap)</span><br><span class="line">  at android.os.Binder.dump(Binder.java:324)</span><br><span class="line">  at android.os.Binder.onTransact(Binder.java:290)</span><br></pre></td></tr></table></figure></p><p>91号线程的名字是Binder_C，它的函数调用栈告诉我们几个关键信息：</p><ul><li>Native，表示线程处于运行状态(RUNNING)，并且正在执行JNI方法</li><li>在WindowManagerService.dump()方法申请了锁<0x126dccb8>，这个锁正是android.fg线程所等待的</0x126dccb8></li><li>FileOutputStream.write()表示Binder_C线程在执行IO写操作，正式因为这个写操作一直在阻塞，导致线程持有的锁不能释放</li></ul><blockquote><p>题外话：关于Binder线程。当Android进程启动时，就会创建一个线程池，专门处理Binder事务。线程池中会根据当前的binder线程计数器的值来构造新创建的binder线程, 线程名”Binder_%X”，X是十六进制。当然，线程池的线程数也有上限，默认情况下为16，所以，可以看到 Binder_1 ~ Binder_F 这样的线程命名。</p></blockquote><p>聪明的你看到这或许已经能够想到解决办法了，在这个IO写操作上加一个超时机制，并且这个超时小于Watchdog的超时，不就可以让线程释放它所占有的锁了吗？ 是的，这确实可以作为一个临时解决方案(Workaround)，或者说一个保护机制。但我们可以再往深处想一想，这个IO写操作为什么会阻塞：</p><ul><li>是不是IO缓冲区满了，导致写阻塞呢？</li><li>是不是写操作有什么锁，导致这个write方法在等锁呢？</li><li>是不是当前系统的IO负载过于高，导致写操作效率很低呢？</li></ul><p>这都需要我们再进一步从日志中去找原因。如果已有的日志不全，找不到论据，我们还需要设计场景来验证假设，解决问题的难度陡然上升。</p><h2 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h2><p>我们经历了两个关键步骤：</p><ol><li>通过event或system类型的日志，发现了Watchdog杀掉system_server导致系统重启</li><li>通过traces日志，发了导致Watchdog出现的具体线程操作</li></ol><p>这两个过程基本就涵盖了Watchdog的运行机制了，但这并没有解决问题啊。我们需要找到线程阻塞的原因是什么，然而，线程阻塞的原因就千奇百怪了。 如果有问题出现的现场，并且问题可以重现，那么我们可以通过调试的手段来分析问题产生的原因。 如果问题只是偶然出现，甚至只有一堆日志，我们就需要从日志中来还原问题出现的场景，这一步才是真正考验大家Android/Linux功底的地方。</p><p>继续以上述问题为例，我们来进一步还原问题出现的场景，从Java层的函数调用栈来看：</p><ul><li>首先，跨进程发起了Binder.dump()方法的调用：at android.os.Binder.dump(Binder.java:324)</li><li>然后，进入了WMS的dump()：at com.android.server.wm.WindowManagerService.dump(WindowManagerService.java:12654)</li><li>接着，发生了写文件操作：at java.io.FileOutputStream.write(FileOutputStream.java:186)</li><li>最后，调用了JNI方法：at libcore.io.Posix.writeBytes(Native method)</li></ul><p>Binder_C线程要出现这种函数调用栈，我们可以初步确定是Android接受了如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys window</span><br></pre></td></tr></table></figure></p><p>当通过命令行运行以上命令时，客户端(PC)的adb server会向服务端(手机)的adbd发送指令， adbd进程会fork出一个叫做dumpsys的子进程，dumpsys进程再利用Binder机制和system_server通信</p><p>仅凭这个还是分析不出问题所在，我们需要启用内核的日志了。当调用JNI方法libcore.io.Posix.writeBytes()时，会触发系统调用， Linux会从用户态切换到内核态，内核的函数调用栈也可以从traces中找到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel: __switch_to+0x74/0x8c</span><br><span class="line">kernel: pipe_wait+0x60/0x9c</span><br><span class="line">kernel: pipe_write+0x278/0x5cc</span><br><span class="line">kernel: do_sync_write+0x90/0xcc</span><br><span class="line">kernel: vfs_write+0xa4/0x194</span><br><span class="line">kernel: SyS_write+0x40/0x8c</span><br><span class="line">kernel: cpu_switch_to+0x48/0x4c</span><br></pre></td></tr></table></figure></p><p>在Java层，明确指明要写文件(FileOutputStream)，正常情况下，系统调用write()就完事了，但Kernel却打开了一个管道，最终阻塞在了pipe_wait()方法。 什么场景下会打开一个管道，而且管道会阻塞呢？一系列的猜想和验证过程接踵而至。</p><p>这里有必要先补充一些基础知识了：</p><blockquote><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/11/03/2751593.html" target="_blank" rel="noopener">Linux进程间通信之管道(pipe)</a><br>   Linux的管道实现借助了文件系统的file结构和VFS(Virtual File System)，通过将两个file结构指向同一个临时的VFS索引节点，而这个VFS索引节点又指向一个物理页面时， 实际上就建立了一个管道。<br>这就解释了为什么发起系统调用write的时候，打开了一个管道。因为dumpsys和system_server进程，将自己的file结构指向了同一个VFS索引节点。</p></blockquote><blockquote><p><a href="https://blog.csdn.net/sj13051180/article/details/47865803" target="_blank" rel="noopener">管道挂起的案例</a><br>  管道是一个生产者-消费者模型，当缓冲区满时，则生产者不能往管道中再写数据了，需等到消费者读数据。如果消费者来不及处理缓冲区的数据，或者锁定缓冲区，则生产者就挂起了。<br>结合到例子中的场景，system_server进程无法往管道中写数据，很可能是dumpsys进程一直忙碌来不及处理新的数据。</p></blockquote><p>接下来，需要再从日志中寻找dumpsys进程的运行状态了：</p><ul><li>是不是dumpsys进程的负载太高？</li><li>是不是dumpsys进程死掉了，导致一直没有处理缓冲区数据？</li><li>是不是dumpsys进程有死锁？</li></ul><p>接下来的分析过程已经偏离Watchdog机制越来越远了，我们点到为止。</p><p>小伙伴们可以看到，场景还原涉及到的知识点非常之宽泛，而且有一定的深度。在没有现场的情况下，伴随一系列的假设和验证过程，充满了不确定性和发现问题的喜悦。 正所谓，同问题做斗争，其乐无穷！</p><p>至此，我们分析Watchdog问题的惯用方法，回答前面提出来的第二个问题：<br>通过event或system类型的logcat日志，检索Watchdog出现的关键信息；通过traces，分析出导致Watchdog检查超时的直接原因；通过其他日志，还原出问题出现的场景。</p><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p>在上面介绍Watchdog问题分析方法的时候，我们其实已经举了一个例子。通常，比较容易定位导致Watchdog出现的直接原因(Direct Cause)，但很难找到更深层次的原因(Root Cause)。 这个小节，我们再介绍一个实例，来分析Watchdog出现的另一种场景。诚然，仅凭几个例子，远不够涵盖Watchdog的所有问题，我们的章法还是按照一定的方法论来深究问题。</p><p>回顾一下解决问题三部曲：</p><ol><li>日志获取。日志种类繁多，分析Watchdog问题，宁滥毋缺</li><li>问题定位。从logcat中锁定watchdog的出现，从traces锁定直接原因</li><li>场景还原。结合各类日志，不断假设验证</li></ol><p>以CPU占用过高的场景为例：<br>从sys_log中，检索到了Watchdog的出现关键信息</p><blockquote><p>TIPS: 在sys_log中搜索关键字”WATCHDOG KILLING SYSTEM PROCESS”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10-14 17:10:51.548   892  1403 W Watchdog: *** WATCHDOG KILLING SYSTEM PROCESS: Blocked <span class="keyword">in</span> handler on ActivityManager (ActivityManager)</span><br></pre></td></tr></table></figure></p></blockquote><p>这是一个Watchdog的Looper Checker超时，由于ActivityManager这个线程一直处于忙碌状态，导致Watchdog检查超时。 Watchdog出现的时间是10-14 17:10:51.548左右，需要从traces.txt中找到这个时间段的system_server进程的函数调用栈信息， system_server的进程号是892。</p><p>从traces.txt中找到对应的函数调用栈</p><p>traces.txt包含很多进程在不同时间段的函数调用栈信息，为了检索的方便，首先可以将traces.txt分块。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ActivityManager"</span> prio=5 tid=17 TimedWaiting</span><br><span class="line">  | group=<span class="string">"main"</span> sCount=1 dsCount=0 obj=0x12c0e6d0 self=0x7f84caf000</span><br><span class="line">  | sysTid=938 nice=-2 cgrp=default <span class="built_in">sched</span>=0/0 handle=0x7f7d887000</span><br><span class="line">  | state=S schedstat=( 107864628645 628257779012 60356 ) utm=7799 stm=2987 core=2 HZ=100</span><br><span class="line">  | stack=0x7f6e68f000-0x7f6e691000 stackSize=1036KB</span><br><span class="line">  | held mutexes=</span><br><span class="line">  at java.lang.Object.wait!(Native method)</span><br><span class="line">  - waiting on &lt;0x264ff09d&gt; (a com.android.server.am.ActivityManagerService<span class="variable">$5</span>)</span><br><span class="line">  at java.lang.Object.wait(Object.java:422)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5395)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.dumpStackTraces(ActivityManagerService.java:5282)</span><br><span class="line">  at com.android.server.am.ActivityManagerService<span class="variable">$AnrActivityManagerService</span>.dumpStackTraces(ActivityManagerService.java:22676)</span><br><span class="line">  at com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpMgr</span>.dumpAnrDebugInfoLocked(SourceFile:1023)</span><br><span class="line">  at com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpMgr</span>.dumpAnrDebugInfo(SourceFile:881)</span><br><span class="line">  at com.android.server.am.ActivityManagerService.appNotResponding(ActivityManagerService.java:6122)</span><br><span class="line">  - locked &lt;0x21c77912&gt; (a com.mediatek.anrmanager.ANRManager<span class="variable">$AnrDumpRecord</span>)</span><br><span class="line">  at com.android.server.am.BroadcastQueue<span class="variable">$AppNotResponding</span>.run(BroadcastQueue.java:228)</span><br><span class="line">  at android.os.Handler.handleCallback(Handler.java:815)</span><br><span class="line">  at android.os.Handler.dispatchMessage(Handler.java:104)</span><br><span class="line">  at android.os.Looper.loop(Looper.java:192)</span><br><span class="line">  at android.os.HandlerThread.run(HandlerThread.java:61)</span><br><span class="line">  at com.android.server.ServiceThread.run(ServiceThread.java:46)</span><br></pre></td></tr></table></figure></p><p>ActivityManager线程实际上运行着AMS的消息队列，这个函数调用栈的关键信息：</p><ul><li>线程状态为TimedWaiting, 这表示当前线程阻塞在一个超时的wait()方法</li><li>正在处理广播消息超时发生的ANR(Application Not Responding)，需要将当前的函数调用栈打印出来</li><li>最终在<0x264ff09d>等待，可以从AMS的源码 中找到这一处锁的源码，因为dumpStackTraces()会写文件，所以AMS设计了一个200毫秒的超时锁。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.wait(200);  // Wait <span class="keyword">for</span> write-close, give up after 200msec</span><br></pre></td></tr></table></figure></0x264ff09d></li></ul><p>还原问题的场景<br>从ActivityManager这个线程的调用栈，我们就会有一些疑惑：</p><ul><li>是哪个应用发生了ANR？为什么会发生ANR？</li><li>超时锁只用200毫秒就释放了，为什么会导致Watchdog检查超时？(AMS的Looper默认超时是1分钟)<br>带着这些疑惑，我们再回到日志中：</li></ul><p>从sys_log中，可以检索到Watchdog出现的时间点(17:10:51.548)之前，com.android.systemui发生了ANR，从而引发AMS打印函数调用栈:</p><blockquote><p>TIPS: 在sys_log中检索”ANR in”关键字或在event_log中检索”anr”关键字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10-14 17:10:04.215   892   938 E ANRManager: ANR <span class="keyword">in</span> com.android.systemui, time=27097912</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Reason: Broadcast of Intent &#123; act=android.intent.action.TIME_TICK flg=0x50000114 (has extras) &#125;</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Load: 89.22 / 288.15 / 201.91</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: Android time :[2015-10-14 17:10:04.14] [27280.396]</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager: CPU usage from 17016ms to 0ms ago:</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   358% 23682/float_bessel: 358% user + 0% kernel</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   57% 23604/debuggerd64: 3.8% user + 53% kernel / faults: 11369 minor</span><br><span class="line">10-14 17:10:04.215   892   938 E ANRManager:   2% 892/system_server: 0.9% user + 1% kernel / faults: 136 minor</span><br></pre></td></tr></table></figure></p></blockquote><p>从这个日志信息中，我们两个疑惑就释然了：</p><p>发生ANR之前的CPU负载远高于正常情况好几倍(Load： 89.22 / 288.15 / 201.91)，在这种CPU负载下，com.android.systemui进程发生处理广播消息超时(Reason: Broadcast of Intent)再正常不过了。 在这之前CPU都被float_bessel这个进程给占了，这货仅凭一己之力就耗了358%的CPU资源。</p><p>observer.wait(200)在调用后，便进入排队等待唤醒状态(Waiting)，在等待200毫秒后，便重新开始申请CPU资源，而此时，CPU资源一直被float_bessel占着没有释放，所以该线程一直在等CPU资源。 等了1分钟后，Watchdog跳出来说“不行，你已经等了1分钟了，handler处理其他消息了”。</p><p>在多核情况下，CPU的使用率统计会累加多个核的使用率，所以会出现超过100%的情况。那么float_bessel究竟是什么呢？它是一个Linux的测试样本，贝塞尔函数的计算，耗的就是CPU。</p><p>这样，该问题的场景我们就还原出来了：在压力测试的环境下，CPU被float_bessel运算占用，导致com.android.systemui进程发生ANR，从而引发AMS打印trace; 但由于AMS一直等不到CPU资源，Watchdog检测超时，杀掉system_server进程，系统重启。</p><p>对于压力测试而言，我们一般会设定一个通过标准，在某些压力情况下，出现一些错误是允许的。对于Android实际用户的使用场景而言，本例中的压力通常是不存在的，所以在实际项目中，这种类型的Watchdog问题，我们一般不解决。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Android中Watchdog用来看护system_server进程，system_server进程运行着系统最终要的服务，譬如AMS、PKMS、WMS等， 当这些服务不能正常运转时，Watchdog可能会杀掉system_server，让系统重启。</p><p>Watchdog的实现利用了锁和消息队列机制。当system_server发生死锁或消息队列一直处于忙碌状态时，则认为系统已经没有响应了(System Not Responding)。</p><p>在分析Watchdog问题的时候，首先要有详尽的日志，其次要能定位出导致Watchdog超时的直接原因，最重要的是能还原出问题发生的场景。</p><!-- 可以用来注释，参与编译，在Html文档中会有这句话，但是不会显示 ^-^ --><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://duanqz.github.io/2015-10-12-Watchdog-Analysis#section-2" target="_blank" rel="noopener">Watchdog机制以及问题分析</a><br><a href="https://blog.csdn.net/fu_kevin0606/article/details/64479489" target="_blank" rel="noopener">Android7.0 Watchdog机制</a><br><a href="https://blog.csdn.net/xichangbao/article/details/76727425" target="_blank" rel="noopener">Android系统高通平台Kernel Watchdog</a><br><a href="https://blog.csdn.net/yangwen123/article/details/11264461" target="_blank" rel="noopener">Android软Watchdog源码分析</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/Watchdog.java" target="_blank" rel="noopener">Watchdog.java</a> </p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Watchdog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中PackageManagerService相关的文件</title>
      <link href="/2018/05/31/Android%E4%B8%ADPackageManagerService%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6/"/>
      <url>/2018/05/31/Android%E4%B8%ADPackageManagerService%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="system-etc-sysconfig-目录下的文件"><a href="#system-etc-sysconfig-目录下的文件" class="headerlink" title="/system/etc/sysconfig 目录下的文件"></a>/system/etc/sysconfig 目录下的文件</h1><h2 id="framework-sysconfig-xml"><a href="#framework-sysconfig-xml" class="headerlink" title="framework-sysconfig.xml"></a>framework-sysconfig.xml</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;!-- Copyright (C) 2017 The Android Open Source Project</span><br><span class="line"></span><br><span class="line">     Licensed under the Apache License, Version 2.0 (the <span class="string">"License"</span>);</span><br><span class="line">     you may not use this file except <span class="keyword">in</span> compliance with the License.</span><br><span class="line">     You may obtain a copy of the License at</span><br><span class="line"></span><br><span class="line">          http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"></span><br><span class="line">     Unless required by applicable law or agreed to <span class="keyword">in</span> writing, software</span><br><span class="line">     distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line">     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">     See the License <span class="keyword">for</span> the specific language governing permissions and</span><br><span class="line">     limitations under the License.</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- These are configurations that must exist on all Android devices. --&gt;</span><br><span class="line">&lt;config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Broadcast actions that are currently exempted from O+ background</span><br><span class="line">         delivery restrictions. --&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.SIM_STATE_CHANGED"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.PACKAGE_CHANGED"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.intent.action.MEDIA_SCANNER_SCAN_FILE"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.media.action.OPEN_AUDIO_EFFECT_CONTROL_SESSION"</span> /&gt;</span><br><span class="line">    &lt;allow-implicit-broadcast action=<span class="string">"android.media.action.CLOSE_AUDIO_EFFECT_CONTROL_SESSION"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Whitelist of what components are permitted as backup data transports.  The</span><br><span class="line">         <span class="string">'service'</span> attribute here is a flattened ComponentName string. --&gt;</span><br><span class="line">    &lt;backup-transport-whitelisted-service</span><br><span class="line">        service=<span class="string">"android/com.android.internal.backup.LocalTransportService"</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Whitelist of bundled applications <span class="built_in">which</span> all handle URLs to their websites by default --&gt;</span><br><span class="line">    &lt;app-link package=<span class="string">"com.android.carrierdefaultapp"</span> /&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure><h2 id="QualCommon-platform-下的qti-whitelist-xml"><a href="#QualCommon-platform-下的qti-whitelist-xml" class="headerlink" title="QualCommon platform 下的qti_whitelist.xml"></a>QualCommon platform 下的qti_whitelist.xml</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> standalone=<span class="string">"yes"</span> ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">/* Copyright (c) 2017, The Linux Foundation. All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> * Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without</span><br><span class="line"> * modification, are permitted provided that the following conditions are</span><br><span class="line"> * met:</span><br><span class="line"> *     * Redistributions of <span class="built_in">source</span> code must retain the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer.</span><br><span class="line"> *     * Redistributions <span class="keyword">in</span> binary form must reproduce the above</span><br><span class="line"> *       copyright notice, this list of conditions and the following</span><br><span class="line"> *       disclaimer <span class="keyword">in</span> the documentation and/or other materials provided</span><br><span class="line"> *       with the distribution.</span><br><span class="line"> *     * Neither the name of The Linux Foundation nor the names of its</span><br><span class="line"> *       contributors may be used to endorse or promote products derived</span><br><span class="line"> *       from this software without specific prior written permission.</span><br><span class="line"> *</span><br><span class="line"> * THIS SOFTWARE IS PROVIDED <span class="string">"AS IS"</span> AND ANY EXPRESS OR IMPLIED</span><br><span class="line"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span><br><span class="line"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT</span><br><span class="line"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS</span><br><span class="line"> * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span><br><span class="line"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span><br><span class="line"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</span><br><span class="line"> * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</span><br><span class="line"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE</span><br><span class="line"> * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN</span><br><span class="line"> * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"> */</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;config&gt;</span><br><span class="line">    &lt;!-- These are telephony components that need to freely run <span class="keyword">in</span> the background --&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.atfwd"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.telephonyservice"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qulacomm.qcrilmsgtunnel"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.ims"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.radioconfiginterface"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.simcontacts"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.autoregistration"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.server.wigigapp"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.StatsPollManager"</span> /&gt;</span><br><span class="line">    &lt;allow-in-power-save package=<span class="string">"com.qualcomm.qti.gsma.services.nfc"</span> /&gt;</span><br><span class="line">&lt;/config&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android PackageManagerService </tag>
            
            <tag> File </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android中PackageManagerService机制分析</title>
      <link href="/2018/05/31/Android%E4%B8%ADPackageManagerService%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/31/Android%E4%B8%ADPackageManagerService%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>每一个社会群落都有管理机制，其中有三个要素：被管理者、管理者以及管理机制的运转。在Android的世界中，有一处群落叫“包管理”，要研究Android的包管理机制，同样可以从以下几个角度来思考：</p><ol><li>被管理的对象是什么？</li><li>管理者的职能是什么？</li><li>管理机制是如何运转的？<br>所谓包，其实就是一种文件格式，譬如APK包、JAR包等。在Android中存活着很多包，所有的应用程序都是APK包，很多构成Android运行环境的都是JAR包，还有一些以so为后缀的库文件，包管理者很重要的一个职能就是识别不同的包，统一维护这些包的信息。当有一个包进入或离开Android世界，都需要向包管理者申报，其他管理部门要获取包的具体信息，也都需要向包管理者申请。</li></ol><p>如同社会是由人与人的协作形成，不同的包之间也需要进行协作。既然有协作，自然就有协作的规范，一个包可以干什么，不可以干什么，都需要有一个明确的范围界定，这就是包管理中的权限设计。涉及到的内容非常广泛，Linux的UGO（User Group Other）和ACL（Access Control List，访问控制列表）权限管理、数字签名与验证、Android授权机制、Selinux，都是包管理中权限设计的组成部分。</p><p>Android的世界就如同一个井然有序的人类社会，除了包管理部门，还有其他各种管理部门，譬如电源管理、窗口管理、活动管理等等，大家不仅各司其职，而且也有交流往来。从APK的安装到Activity的显示这么一个看似简单的过程，却需要大量管理部门参与进来，不断地进行数据解析、封装、传递、呈现，内部机理十分复杂。</p><blockquote><p>PackageManagerService是包管理中最重要的服务，为了描述方便，本文会简写成PMS。<br>PMS的部分函数带有LI后缀，表示需要获取mInstalllock这个锁时才能执行；部分函数带有LP后缀，表示需要获取mPackages这个锁才能执行。</p></blockquote><p>PackageManagerService相关的代码路径如下：<br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/content/pm/" target="_blank" rel="noopener">frameworks/base/core/java/android/content/pm/</a><br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/pm/" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/pm</a></p><h1 id="被管理对象的形态"><a href="#被管理对象的形态" class="headerlink" title="被管理对象的形态"></a>被管理对象的形态</h1><p>Android中的APK和JAR包都以静态文件的形式分布在不同的硬件分区，包管理者面临的第一个任务就是将这些静态的文件转化成内存的数据结构，这样才能将其管理起来。Android中最重要的包管理对象就是APK，APK可以包含so文件，负责将静态文件转换内存中数据结构的工具就是PackageParser，包解析器。<br><img src="http://duanqz.github.io/assets/images/packagemanager/1-packagemanager-package-from-static-to-dynamic.png" alt="PackageParser"></p><p>Android L(5.0)以后，支持APK拆分，即一个APK可以分割成很多部分，位于相同的目录下，每一个部分都是一个单独的APK文件，所有的APK文件具备相同的签名，在APK解析过程中，会将拆分的APK重新组合成内存中的一个Package。对于一个完整的APK，Android称其为Monolithic；对于拆分后的APK，Android称其为Cluster。</p><blockquote><p>在Android L(5.0)以前，APK文件都是直接位于app或priv-app目录下，譬如短彩信APK的目录就是/system/priv-app/Mms.apk；到了Android L(5.0)之后，多了一级目录结构，譬如短彩信APK的目录是/system/priv-app/Mms/Mms.apk，这是Android为了支持APK拆分而做的改动，如果要将短彩信APK进行拆分，那所有被拆出来的APK都位于/system/priv-app/Mms/即可，这样在包解析时，就会变成以Cluster的方式解析目录。</p></blockquote><p>一个包在内存中的数据结构就是Package，那么，Package有一些什么属性?是怎么从APK文件中获取数据的呢？ 这就涉及到包解析器的工作原理。</p><h1 id="包解析器"><a href="#包解析器" class="headerlink" title="包解析器"></a>包解析器</h1><p>为了先让读者对被管理对象有一个初步的认识，我们先把一个包最终在内存中的数据结构拎出来。其实生成这个数据结构，需要包管理者进行大量的调度工作，调度中心是PMS，包解析的过程也都是由PMS驱动的。在分析包解析过程之前，我们先上包解析的结果：<br><img src="http://duanqz.github.io/assets/images/packagemanager/2-packagemanager-packageparser.png" alt="包解析结果"><br>这个类图，示意了一个包最终在内存中的数据结构Package，它包含很多属性，部分属性还是包解析器中的子数据结构。我们可以从设计的角度来理解这个类图：</p><ul><li><p>一个包中有很多组件，为此设计了一个高层的基类Component，所有具体的组件都是Component的子类。什么是组件呢？AndroidManifest.xml文件中所定义的的一些标签，就是组件，譬如<activity>，<service>，<provider>，<permission>等，这些标签分别对应到包解析器中的一个数据结构，它们各自有自身的属性。</permission></provider></service></activity></p></li><li><p>诸如<activity>，<service>标签，都可以配置<intent-filter>，来过滤其可以接收的Intent，这些信息也需要在包解析器中体现出来，为此组件Component依赖于IntentInfo这个数据结构。每一个具体的组件所依赖的IntentInfo不同，所以Component和IntentInfo之间的依赖关系采用了桥接(Bridge)这种设计模式，通过泛型的手段实现。</intent-filter></service></activity></p></li><li><p>各种组件最终聚合到Package这个数据结构中，形成了最终包解析器的输出。当然，在解析的过程中，还有利用了一些数据结构来优化设计，PackageLite和ApkLite就是一些很简单的数据封装。</p></li></ul><p>要得到以上的数据结构，包解析器<a href="https://android.googlesource.com/platform/frameworks/base/+/master/core/java/android/content/pm/PackageParser.java" target="_blank" rel="noopener">PackageParser</a>功不可没，从接收一个静态的文件(File类型)开始，会经过一个漫长的包解析过程，直到生成最终的Package：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parsePackages(File file...)</span><br><span class="line">└── parseClusterPackage(File packageDir...)</span><br><span class="line">    └── parseClusterPackageLite(File packageDir...)</span><br><span class="line">    |   └── parseApkLite(File apkFile...)</span><br><span class="line">    |       └── parseApkLite(String codePath...)</span><br><span class="line">    └── parseBaseApk()</span><br><span class="line">        └── parseBaseApplication()</span><br><span class="line">        |    └── parseActivity()</span><br><span class="line">        |    └── parseService()</span><br><span class="line">        |    └── ...</span><br><span class="line">        └── parseInstrumentation()</span><br><span class="line">        └── ...</span><br></pre></td></tr></table></figure></p><p>这些函数的具体逻辑本文不予分析，仅把关键的流程捋出来:</p><ol><li><p>PackageParser.parsePackages()是包解析器的入口函数，它首先会判定给定的输入是否为一个目录，如果是目录，则以为着目录下可能存在多个拆分后的APK，这就需要以Cluster的方式进行解析；如果仅仅是一个APK文件，就以Monolithic的方式解析；</p></li><li><p>解析APK，需要先得到一个中间数据结构PacakgeLite，包名、版本、拆分包等信息都会保存在这个数据结构中；由于一个包可能有多个拆分的APK，所以PackageLite可能关联到多个APK，每一个APK都对应到ApkLite这个数据结构，也是一些基本信息的封装。之所以以Lite为后缀命名，是因为这两个数据结构都比较轻量，只保存APK中很少信息；</p></li><li><p>一个APK真正的信息都写在AndroidManifest.xml这个文件中，PackageParser.parseBaseApk()这个函数就是用来解析该文件。其解析过程与AndroidManifest.xml的文件结构一一对应，譬如先解析<application>标签的内容，然后解析其下的<activity>,<service>等标签。由于AndroidManifest.xml文件的结构非常复杂，所以该函数逻辑也非常庞大，读者们可以自行分析源码。<br>至此，包解析器PackageParser就将一个静态的文件，转换成了内存中的数据结构Package，它包含了一个包的所有信息，如包名、包路径、权限、四大组件等，其数据来源主要就是AndroidManifest.xml文件。</service></activity></application></p></li></ol><h1 id="包信息体"><a href="#包信息体" class="headerlink" title="包信息体"></a>包信息体</h1><p>包解析器从静态文件中获取的数据，很多都是需要用于跨进程传递的，譬如初次启动Activity时，就需要把包信息从系统进程传递到应用进程，先完成应用进程的启动。在包解析器的类图中，我们看到Activity、Service、Provider、Permission、Instrumentaion这些类都有一个共同的特征：都具备info这个属性，其实这些类的结构非常简单，就是对info的一次封装，info这个结构体才是真正的包数据，笔者暂且称之为“包信息体”:<br><img src="http://duanqz.github.io/assets/images/packagemanager/3-packagemanager-packageparser-parcelable.png" alt="包信息体"><br>所有的info都实现了Parcelable接口，意图很明显，info是可以进行跨进程传递的。不同组件的info类型是不同的，除了实现了Parcelable接口，它们之间又构成了一个庞大的数据结构，把这些具体的info类型展开，就是以下的类图：<br><img src="http://duanqz.github.io/assets/images/packagemanager/4-packagemanager-packageparser-parcelable.png" alt="Info展开图"><br>可以看到，这个类图与PackageParser中的类图在结构上很相似，我们依旧是从设计的角度来理解这个类图：</p><ul><li>PackageItemInfo作为包每一项信息的高层基类：<ul><li>针对permission，permission，instrumentation等，分别为其设计了一个类，都继承自PackageItemInfo</li><li>针对activity，service，provider等四大组件，在PackageItemInfo之下又多设计了一层：ComponentInfo作为四大组件的基类</li></ul></li><li>ApplicationInfo也是包信息中的一项，但与四大组件紧密相连，四大组件肯定都属于某个Application，所以ComponentInfo与Application存在依赖关系，继而，具体到每个组件都与Application存在依赖关系</li><li>所有的包信息都聚合到PackageInfo这个类中，PackageInfo就是一个包向外提供的所有信息。其实除了上图列出来的类，还有一些类没有示意出来，譬如ConfigurationInfo，FeatureInfo，它们都可以对应到AndroidManifest.xml中的标签。<br>这些结构体中的数据，都是在包解析器时初始化的，譬如Activity依赖于ActivityInfo，在解析Activity时，就会创建一个ActivityInfo对象，把<activity>所定义的数据全都填充到ActivityInfo中。读者可以思考一下PackageParser中的Activity与此处的ActivityInfo的分开设计的目的和好处是什么？<blockquote><p>在分析包的形态时，我们见到了很多类，类的命名方式还有点相似，初读代码的时候，很容易陷入各个类之间复杂的关系网之中。不得不说，包在内存中的数据结构是比较庞大的，因为它蕴含的信息大多了。</p></blockquote></activity></li></ul><h1 id="PMS的启动过程"><a href="#PMS的启动过程" class="headerlink" title="PMS的启动过程"></a>PMS的启动过程</h1><p><a href="https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/pm/PackageManagerService.java" target="_blank" rel="noopener">frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</a></p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><h3 id="PMS部分属性初始化"><a href="#PMS部分属性初始化" class="headerlink" title="PMS部分属性初始化"></a>PMS部分属性初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段1：PMS部分属性的初始化</span><br><span class="line">public PackageManagerService(Context context, Installer installer,</span><br><span class="line">        boolean factoryTest, boolean onlyCore) &#123;</span><br><span class="line">    // 关键的Event日志，PMS开始启动了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_START,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mContext = context;</span><br><span class="line">    mFactoryTest = factoryTest;</span><br><span class="line">    mOnlyCore = onlyCore;</span><br><span class="line">    // 如果是eng版，则延迟做DexOpt</span><br><span class="line">    mLazyDexOpt = <span class="string">"eng"</span>.equals(SystemProperties.get(<span class="string">"ro.build.type"</span>));</span><br><span class="line">    mMetrics = new DisplayMetrics();</span><br><span class="line">    // Settings是包管理中一个很重要的数据结构，用于维护所有包的信息</span><br><span class="line">    mSettings = new Settings(mPackages);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>, Process.SYSTEM_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.phone"</span>, RADIO_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.log"</span>, LOG_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.nfc"</span>, NFC_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.bluetooth"</span>, BLUETOOTH_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">    mSettings.addSharedUserLPw(<span class="string">"android.uid.shell"</span>, SHELL_UID,</span><br><span class="line">            ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"></span><br><span class="line">    long dexOptLRUThresholdInMinutes;</span><br><span class="line">    <span class="keyword">if</span> (mLazyDexOpt) &#123;</span><br><span class="line">        dexOptLRUThresholdInMinutes = 30; // only last 30 minutes of apps <span class="keyword">for</span> eng builds.</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dexOptLRUThresholdInMinutes = 7 * 24 * 60; // apps used <span class="keyword">in</span> the 7 days <span class="keyword">for</span> users.</span><br><span class="line">    &#125;</span><br><span class="line">    mDexOptLRUThresholdInMills = dexOptLRUThresholdInMinutes * 60 * 1000;</span><br><span class="line">    ...</span><br><span class="line">    mInstaller = installer;</span><br><span class="line">    // DexOpt工具类</span><br><span class="line">    mPackageDexOptimizer = new PackageDexOptimizer(this);</span><br><span class="line">    mMoveCallbacks = new MoveCallbacks(FgThread.get().getLooper());</span><br><span class="line">    mOnPermissionChangeListeners = new OnPermissionChangeListeners(</span><br><span class="line">                FgThread.get().getLooper());</span><br><span class="line">    getDefaultDisplayMetrics(context, mMetrics);</span><br><span class="line">    // 读取系统默认的权限</span><br><span class="line">    SystemConfig systemConfig = SystemConfig.getInstance();</span><br><span class="line">    mGlobalGids = systemConfig.getGlobalGids();</span><br><span class="line">    mSystemPermissions = systemConfig.getSystemPermissions();</span><br><span class="line">    mAvailableFeatures = systemConfig.getAvailableFeatures();</span><br><span class="line"></span><br><span class="line">    // 这里上了两把锁: mInstallLock是安装APK时需要用到的锁；mPackage是更新APK信息时需要的锁</span><br><span class="line">    synchronized (mInstallLock) &#123;</span><br><span class="line">    synchronized (mPackages) &#123;</span><br><span class="line">        // 构建一个后台线程，并将线程的消息队列绑定到Handler</span><br><span class="line">        mHandlerThread = new ServiceThread(TAG,</span><br><span class="line">                Process.THREAD_PRIORITY_BACKGROUND, <span class="literal">true</span> /*allowIo*/);</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line">        mHandler = new PackageHandler(mHandlerThread.getLooper());</span><br><span class="line">        // 将PMS加入Watchdog的监控列表</span><br><span class="line">        Watchdog.getInstance().addThread(mHandler, WATCHDOG_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        // 初始化一些文件目录</span><br><span class="line">        File dataDir = Environment.getDataDirectory();</span><br><span class="line">        mAppDataDir = new File(dataDir, <span class="string">"data"</span>);</span><br><span class="line">        mAppInstallDir = new File(dataDir, <span class="string">"app"</span>);</span><br><span class="line">        mAppLib32InstallDir = new File(dataDir, <span class="string">"app-lib"</span>);</span><br><span class="line">        mAsecInternalPath = new File(dataDir, <span class="string">"app-asec"</span>).getPath();</span><br><span class="line">        mUserAppDataDir = new File(dataDir, <span class="string">"user"</span>);</span><br><span class="line">        mDrmAppPrivateInstallDir = new File(dataDir, <span class="string">"app-private"</span>);</span><br><span class="line"></span><br><span class="line">        // 初始化系统权限</span><br><span class="line">        ArrayMap&lt;String, SystemConfig.PermissionEntry&gt; permConfig</span><br><span class="line">                = systemConfig.getPermissions();</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;permConfig.size(); i++) &#123;</span><br><span class="line">            SystemConfig.PermissionEntry perm = permConfig.valueAt(i);</span><br><span class="line">            BasePermission bp = mSettings.mPermissions.get(perm.name);</span><br><span class="line">            <span class="keyword">if</span> (bp == null) &#123;</span><br><span class="line">                bp = new BasePermission(perm.name, <span class="string">"android"</span>, BasePermission.TYPE_BUILTIN);</span><br><span class="line">                mSettings.mPermissions.put(perm.name, bp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (perm.gids != null) &#123;</span><br><span class="line">                bp.setGids(perm.gids, perm.perUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 初始化PMS中的ShareLibraries</span><br><span class="line">        ArrayMap&lt;String, String&gt; libConfig = systemConfig.getSharedLibraries();</span><br><span class="line">        <span class="keyword">for</span> (int i=0; i&lt;libConfig.size(); i++) &#123;</span><br><span class="line">            mSharedLibraries.put(libConfig.keyAt(i),</span><br><span class="line">                    new SharedLibraryEntry(libConfig.valueAt(i), null));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 读取mac_permission.xml文件的内容</span><br><span class="line">        mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();</span><br><span class="line"></span><br><span class="line">        mRestoredSettings = mSettings.readLPw(this, sUserManager.getUsers(<span class="literal">false</span>),</span><br><span class="line">                mSdkVersion, mOnlyCore);</span><br><span class="line">        String customResolverActivity = Resources.getSystem().getString(</span><br><span class="line">                        R.string.config_customResolverActivity);</span><br><span class="line"></span><br><span class="line">// 未完接代码片段2</span><br></pre></td></tr></table></figure><p>【代码片段1】完成了很多PMS的属性初始化操作，几个重要的属性如下：</p><ul><li><p><strong>mSettings：</strong>PMS内部有一个Settings数据结构，用于维护所有包的信息。写过Android应用程序的朋友可能知道两个APK可以运行在相同的进程中，前提是两个APK具有相同的签名和ShareUid。Android系统中定义了一些默认的ShareUid，譬如android.uid.system表示系统进程的UID，如果有一个APK想要运行在系统进程中，则其需要在AndroidManifest.xml文件中声明ShareUid为android.uid.system，并且该APK的签名必须与framework-res.apk的签名一致，即platform签名。</p><p>PMS在创建完Settings对象之后，便把很多系统默认的ShareUid加入其中。</p></li><li><p><strong>mInstaller：</strong>Installer是一个系统服务，它封装了很多PMS进行包管理需要用到的函数，譬如install()、 dexopt()、rename()等。在Installer内部，其实是通过Socket连接installd，将执行指令发送到installd完成具体的操作。</p></li><li><p><strong>mPackageDexOptimizer:</strong> 进行Dex优化的工具类。对于一个APK而言，编译后其APK包中可执行文件的格式dex，安装到了手机上以后，需要经过文件格式转化才能运行，譬如APK需要转换成oat格式才能在ART虚拟机上运行，文件格式转换的过程就叫DexOpt。</p><p>DalvikVM的时代，Android可执行文件的格式是dex，有一种进一步优化的格式叫odex；ART虚拟机的时代，Android可执行文件的格式是oat。虽然都叫做DexOpt，但在DalvikVM和ART两种不同虚拟机的时代分别有不同的内涵。</p></li><li><p><strong>SystemConfig:</strong> 系统全局的配置信息的数据结构。原始的数据来源于/system/etc/sysconfig和/system/etc/permissions目录下的XML文件,XML文件的详细信息见 Android中PackageManagerService相关的文件 这篇文章，在SystemConfig对象构建时，会读取这两个目录下所有XML文件的内容，主要有以下几个维度：</p><ul><li><p>权限与GID的映射关系，譬如，以下内容表示属于inet这个组的用户都拥有android.permission.INTERNET权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;permission name=<span class="string">"android.permission.INTERNET"</span> &gt;</span><br><span class="line">  &lt;group git=<span class="string">"inet"</span>&gt;</span><br><span class="line">&lt;/permission&gt;</span><br></pre></td></tr></table></figure></li><li><p>权限与UID的映射关系，譬如，以下内容表示UID为meida用户拥有android.permission.CAMERA这个权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;assign-permission name=<span class="string">"android.permission.CAMERA"</span> uid=<span class="string">"media"</span> /&gt;</span><br></pre></td></tr></table></figure></li><li><p>公共库的定义。Android中有很多公共库，除了BOOTCLASSPATH中定义的，框架层还支持额外的扩展，譬如，以下内容表示公共库的包名和其路径的关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;library name=<span class="string">"android.test.runner"</span></span><br><span class="line">       file=<span class="string">"/system/framework/android.test.runner.jar"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mHandler：</strong> 创建PackageHandler对象，将其绑定到一个后台线程的消息队列。可想而知，一些厚重的活，譬如安装APK，就交由这个后台线程完成了。由于PMS是一个重要的系统服务，这个后台线程的消息队列如果过于忙碌，则会导致系统一直卡住，所以需要将这个消息队列加入Watchdog的监控列表，以便在这种情况下，Watchdog可以做出一些应急操作。</p></li><li><p><strong>初始化一些/data文件目录：</strong>应用程序的安装和运行都需要用到Data分区，PMS会在Data分区新建一些子目录。</p></li><li><p><strong>初始化系统权限：</strong>在SystemConfig初始化的时候，从/system/etc/permissions和/system/etc/sysconfig目录下读取了XML文件，这些信息要添加到Settings这个数据结构中。Android设计了一个BasePermission的数据结构，主要用于保存权限与包名之间的映射关系，此处，添加的权限是从SystemConfig中取出，包名是android，也就是先将系统权限添加到Settings中。</p></li><li><p><strong>mFoundPolicyFile:</strong> 有了SeLinux以后，Android会为每个文件打上SE Label，对于APK而言，打SE Label的准则就是签名，即根据签名信息打上不同的SE Label。Android将签名分类成为platform，testkey, media等，签名与类别的映射关系就存在一个叫mac_permission.xml的文件中。此处，需要读取该文件的内容。</p></li></ul><h3 id="PMS-系统文件Dexopt扫描"><a href="#PMS-系统文件Dexopt扫描" class="headerlink" title="PMS 系统文件Dexopt扫描"></a>PMS 系统文件Dexopt扫描</h3><p>在完成部分属性的初始化之后，PMS要进入扫描安装阶段了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">//代码片段2：DexOpt处理，扫描系统文件</span><br><span class="line">    // 关键日志，开始扫描系统APP</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SYSTEM_SCAN_START,</span><br><span class="line">            startTime);</span><br><span class="line"></span><br><span class="line">    // 设置扫描参数</span><br><span class="line">    final int scanFlags = SCAN_NO_PATHS | SCAN_DEFER_DEX | SCAN_BOOTING | SCAN_INITIAL;</span><br><span class="line">    // 1. 构建数组变量用于保存已经做过DexOpt的文件，后文中，会往这个数组变量中添加元素</span><br><span class="line">    final ArraySet&lt;String&gt; alreadyDexOpted = new ArraySet&lt;String&gt;();</span><br><span class="line">    final String bootClassPath = System.getenv(<span class="string">"BOOTCLASSPATH"</span>);</span><br><span class="line">    final String systemServerClassPath = System.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line"></span><br><span class="line">    // BOOTCLASSPATH环境变量所定义的文件已经做过DexOpt</span><br><span class="line">    <span class="keyword">if</span> (bootClassPath != null) &#123;</span><br><span class="line">        String[] bootClassPathElements = splitString(bootClassPath, <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : bootClassPathElements) &#123;</span><br><span class="line">            alreadyDexOpted.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // SYSTEMSERVERCLASSPATH环境变量所定义的文件已经做过了DexOpt</span><br><span class="line">    <span class="keyword">if</span> (systemServerClassPath != null) &#123;</span><br><span class="line">        String[] systemServerClassPathElements = splitString(systemServerClassPath, <span class="string">':'</span>);</span><br><span class="line">        <span class="keyword">for</span> (String element : systemServerClassPathElements) &#123;</span><br><span class="line">            alreadyDexOpted.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取指令集，以便后续进行DexOpt</span><br><span class="line">    final List&lt;String&gt; allInstructionSets = InstructionSets.getAllInstructionSets();</span><br><span class="line">    final String[] dexCodeInstructionSets =</span><br><span class="line">            getDexCodeInstructionSets(</span><br><span class="line">                        allInstructionSets.toArray(new String[allInstructionSets.size()]));</span><br><span class="line"></span><br><span class="line">    // 公共库是定义在 etc/sysconfig 和 etc/permissions 文件夹下的XML文件中</span><br><span class="line">    // 需要这些公共库进行DexOpt处理</span><br><span class="line">    <span class="keyword">if</span> (mSharedLibraries.size() &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SharedLibraryEntry libEntry : mSharedLibraries.values()) &#123;</span><br><span class="line">                final String lib = libEntry.path;</span><br><span class="line">                <span class="keyword">if</span> (lib == null) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int dexoptNeeded = DexFile.getDexOptNeeded(lib, null, dexCodeInstructionSet, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                        alreadyDexOpted.add(lib);</span><br><span class="line">                        mInstaller.dexopt(lib, Process.SYSTEM_UID, <span class="literal">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File frameworkDir = new File(Environment.getRootDirectory(), <span class="string">"framework"</span>);</span><br><span class="line">    alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/framework-res.apk"</span>);</span><br><span class="line">    alreadyDexOpted.add(frameworkDir.getPath() + <span class="string">"/core-libart.jar"</span>);</span><br><span class="line"></span><br><span class="line">    // system/framework目录下，除了framework-res.apk和core-libart.jar这两个文件外</span><br><span class="line">    // 其他的APK和JAR文件都需要进行DexOpt处理</span><br><span class="line">    String[] frameworkFiles = frameworkDir.list();</span><br><span class="line">    <span class="keyword">if</span> (frameworkFiles != null) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dexCodeInstructionSet : dexCodeInstructionSets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (int i=0; i&lt;frameworkFiles.length; i++) &#123;</span><br><span class="line">                File libPath = new File(frameworkDir, frameworkFiles[i]);</span><br><span class="line">                String path = libPath.getPath();</span><br><span class="line">                <span class="keyword">if</span> (alreadyDexOpted.contains(path)) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!path.endsWith(<span class="string">".apk"</span>) &amp;&amp; !path.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">                    <span class="built_in">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    int dexoptNeeded = DexFile.getDexOptNeeded(path, null, dexCodeInstructionSet, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                        mInstaller.dexopt(path, Process.SYSTEM_UID, <span class="literal">true</span>, dexCodeInstructionSet, dexoptNeeded);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch(...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. Android M的APK授权机制有了变化，此处是与授权相关的版本兼容处理</span><br><span class="line">    final VersionInfo ver = mSettings.getInternalVersion();</span><br><span class="line">    mIsUpgrade = !Build.FINGERPRINT.equals(ver.fingerprint);</span><br><span class="line">    mPromoteSystemApps =</span><br><span class="line">            mIsUpgrade &amp;&amp; ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1;</span><br><span class="line">    <span class="keyword">if</span> (mPromoteSystemApps) &#123;</span><br><span class="line">        Iterator&lt;PackageSetting&gt; pkgSettingIter = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (pkgSettingIter.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = pkgSettingIter.next();</span><br><span class="line">            <span class="keyword">if</span> (isSystemApp(ps)) &#123;</span><br><span class="line">                mExistingSystemPackages.add(ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 扫描系统文件</span><br><span class="line">    File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);</span><br><span class="line">    // 扫描 /vendor/overlay 目录下的文件</span><br><span class="line">    scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);</span><br><span class="line">    // 扫描 /system/framework 目录下的文件</span><br><span class="line">    scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">            | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line">            scanFlags | SCAN_NO_DEX, 0);</span><br><span class="line">    // 扫描 /system/priv-app 目录下的文件</span><br><span class="line">    final File privilegedAppDir = new File(Environment.getRootDirectory(), <span class="string">"priv-app"</span>);</span><br><span class="line">    scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">            | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);</span><br><span class="line">    // 扫描 /system/app 目录下的文件</span><br><span class="line">    final File systemAppDir = new File(Environment.getRootDirectory(), <span class="string">"app"</span>);</span><br><span class="line">    scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    // 扫描 /vendor/app 目录下的文件</span><br><span class="line">    File vendorAppDir = new File(<span class="string">"/vendor/app"</span>);</span><br><span class="line">    try &#123;</span><br><span class="line">        vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line">    &#125; catch (IOException e) &#123;&#125;</span><br><span class="line">    scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    // 扫描 /oem/app 目录下的文件</span><br><span class="line">    final File oemAppDir = new File(Environment.getOemDirectory(), <span class="string">"app"</span>);</span><br><span class="line">    scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">            | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);</span><br><span class="line">    mInstaller.moveFiles();</span><br><span class="line"></span><br><span class="line">    // 4. 对扫描到的系统文件善后处理</span><br><span class="line">    final List&lt;String&gt; possiblyDeletedUpdatedSystemApps = new ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        Iterator&lt;PackageSetting&gt; psit = mSettings.mPackages.values().iterator();</span><br><span class="line">        <span class="keyword">while</span> (psit.hasNext()) &#123;</span><br><span class="line">            PackageSetting ps = psit.next();</span><br><span class="line">            <span class="keyword">if</span> ((ps.pkgFlags &amp; ApplicationInfo.FLAG_SYSTEM) == 0) &#123;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            final PackageParser.Package scannedPkg = mPackages.get(ps.name);</span><br><span class="line">            <span class="keyword">if</span> (scannedPkg != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                    removePackageLI(ps, <span class="literal">true</span>);</span><br><span class="line">                    mExpectingBetter.put(ps.name, ps.codePath);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mSettings.isDisabledSystemPackageLPr(ps.name)) &#123;</span><br><span class="line">                psit.remove();</span><br><span class="line">                removeDataDirsLI(null, ps.name);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                final PackageSetting disabledPs = mSettings.getDisabledSystemPkgLPr(ps.name);</span><br><span class="line">                <span class="keyword">if</span> (disabledPs.codePath == null || !disabledPs.codePath.exists()) &#123;</span><br><span class="line">                    possiblyDeletedUpdatedSystemApps.add(ps.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;PackageSetting&gt; deletePkgsList = mSettings.getListOfIncompleteInstallPackagesLPr();</span><br><span class="line">    <span class="keyword">for</span>(int i = 0; i &lt; deletePkgsList.size(); i++) &#123;</span><br><span class="line">        cleanupInstallFailedPackage(deletePkgsList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    deleteTempPackageFiles();</span><br><span class="line">    mSettings.pruneSharedUsersLPw();</span><br><span class="line">// 未完接代码片段3</span><br></pre></td></tr></table></figure></p><p>【代码片段2】的主体逻辑如下：</p><ol><li><p>通过不断往alreadyDexOpted数组中填充元素，来略过不需要做DexOpt的文件：BOOTCLASSPATH和SYSTEMSERVERPATH这两个环境变量中定义的文件、system/framework-res.apk、system/core-libart.jar。除略过的文件外，其他APK和JAR文件都是需要做DexOpt处理的，通过调用Installer.dexopt()函数完成，这个函数只是将dexopt命令发送给installd。</p></li><li><p>由于Android M的APK授权机制发生了变化，在扫描系统文件之前，做了一些简单的记录，以便后续的授权处理：</p><blockquote><p>mIsUpgrade：如果当前版本的指纹与历史版本的指纹信息不一致，表示当前版本是一次OTA升级上来更新版本<br>mPromoteSystemApps：如果历史版本是Android M之前的版本(ver.sdkVersion &lt;= Build.VERSION_CODES.LOLLIPOP_MR1)，当前又有版本升级，则需要用一个布尔变量，表示当前需要对系统应用的授权做特殊处理，此时会先把已有的系统应用都保存在mExistingSystemPackages这个数组中</p></blockquote></li><li><p>扫描系统文件，PMS中所有的文件扫描都是调用scanDirLI()函数，扫描系统文件重要的参数就是 PackageParser.PARSE_IS_SYSTEM和PackageParser.PARSE_IS_SYSTEM_DIR，在后文中我们会剖析这个函数。此处，需要注意的是被扫描目录的顺序，这个顺序意味着：先被扫描到的文件，就是最终被用到的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/vendor/overlay &gt;&gt; /system/framework &gt;&gt; /system/priv-app &gt;&gt; /system/app &gt;&gt; /vendor/app &gt;&gt; /oem/app</span><br></pre></td></tr></table></figure></li><li><p>possiblyDeletedUpdatedSystemApps这个变量表示“可能被删除的系统APP”，这是一个什么概念呢？除了 possiblyDeletedUpdatedSystemApps ，还有mExpectingBetter，表示当前这个APK有更好的选择，这又是什么概念呢？对于一个系统APP而言，在一次OTA升级的过程中，有三种可能：</p><ul><li>保持原状。即这个系统APP没有任何更新。</li><li>更新版本。即新的OTA版本中，这个系统APP有更新。<br>-不复存在。在新的OTA版本中已经删除了这个系统APP。<br>当系统APP升级过后，PMS的Settings中会将原来的系统APP标识为Disable状态，这时候通过Settings.isDisabledSystemPackageLPr()函数调用便返回了false。因此，如果系统APP有更新版本，则属于mExpectingBetter这一类，接下来会扫描Data分区的文件，更新的系统APP就安装在Data分区。</li></ul></li></ol><p>如果一个系统APP不复存在，而且也没有被标记为Disable状态，说明这个系统APP已经彻底不存在了，需要把其在Data分区下的数据删除；如果不复存在的系统APP被标记为Disable状态，那还不能确定该系统APP是否已经被删除，因为还没有扫描Data分区的文件，所以，只能暂时将其放到possiblyDeletedUpdatedSystemApps变量中，表示“可能被删除”，在扫描Data分区之前，这是不能确定的。</p><h3 id="PMS-Data分区扫描"><a href="#PMS-Data分区扫描" class="headerlink" title="PMS Data分区扫描"></a>PMS Data分区扫描</h3><p>扫描完系统文件之后，接下来会扫描Data分区的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段3：扫描Data分区文件，更新公共库信息</span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        // 关键日志，PMS对Data分区的文件扫描开始了</span><br><span class="line">        EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_DATA_SCAN_START,</span><br><span class="line">                SystemClock.uptimeMillis());</span><br><span class="line">        // 1. 扫描Data分区的文件目录</span><br><span class="line">        scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">        scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,</span><br><span class="line">                scanFlags | SCAN_REQUIRE_KNOWN, 0);</span><br><span class="line">        // 2. 扫描完Data分区后，处理“可能被删除的系统应用”</span><br><span class="line">        <span class="keyword">for</span> (String deletedAppName : possiblyDeletedUpdatedSystemApps) &#123;</span><br><span class="line">            PackageParser.Package deletedPkg = mPackages.get(deletedAppName);</span><br><span class="line">            mSettings.removeDisabledSystemPackageLPw(deletedAppName);</span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (deletedPkg == null) &#123;</span><br><span class="line">                removeDataDirsLI(null, deletedAppName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               deletedPkg.applicationInfo.flags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">               PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);</span><br><span class="line">               deletedPs.pkgFlags &amp;= ~ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3. 处理有版本更新的系统应用</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; mExpectingBetter.size(); i++) &#123;</span><br><span class="line">            final String packageName = mExpectingBetter.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!mPackages.containsKey(packageName)) &#123;</span><br><span class="line">                final File scanFile = mExpectingBetter.valueAt(i);</span><br><span class="line">                final int reparseFlags;</span><br><span class="line">                // 设置重新扫描的解析参数</span><br><span class="line">                <span class="keyword">if</span> (FileUtils.contains(privilegedAppDir, scanFile)) &#123;</span><br><span class="line">                    reparseFlags = PackageParser.PARSE_IS_SYSTEM</span><br><span class="line">                            | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line">                            | PackageParser.PARSE_IS_PRIVILEGED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">                // 将原来的系统应用重新置为Enable状态</span><br><span class="line">                mSettings.enableSystemPackageLPw(packageName);</span><br><span class="line">                try &#123;</span><br><span class="line">                    scanPackageLI(scanFile, reparseFlags, scanFlags, 0, null);</span><br><span class="line">                &#125; catch (PackageManagerException e) &#123; ... &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // end of <span class="string">"if (!mOnlyCore)"</span></span><br><span class="line">    mExpectingBetter.clear();</span><br><span class="line"></span><br><span class="line">    // 4. 处理公共库</span><br><span class="line">    updateAllSharedLibrariesLPw();</span><br><span class="line">    <span class="keyword">for</span> (SharedUserSetting setting : mSettings.getAllSharedUsersLPw()) &#123;</span><br><span class="line">         adjustCpuAbisForSharedUserLPw(setting.packages, null /* scanned package */,</span><br><span class="line">                 <span class="literal">false</span> /* force dexopt */, <span class="literal">false</span> /* defer dexopt */);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPackageUsage.readLP();</span><br><span class="line">    // 关键日志，PMS扫描结束了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_SCAN_END,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line">// 未完接代码片段4</span><br></pre></td></tr></table></figure></p><p>Data分区文件的扫描都被mOnlyCore这个布尔变量笼罩，当其为true时，表示只需要扫描系统文件；当其为false时，才会扫描Data分区文件。【代码片段3】的主体逻辑如下：</p><ol><li><p>调用PMS.scanDirLI()函数扫描 /data/app 和 /data/app-private两个目录的文件。后文会详细剖析该函数。</p></li><li><p>扫描完Data分区的文件后，需要对之前系统文件的余孽做一些处理，第一类是possiblyDeletedUpdatedSystemApps，因为在扫描Data分区文件之前，不能确定系统应用有没有被彻底删除，如果在Data分区也无法找到了不复存在的系统应用，则需要彻底删除该系统应用；如果在Data分区找到了不复存在的系统应用，则需要去除其系统应用的标识。</p></li><li><p>另外一类系统应用的余孽是mExpectingBetter，表示系统应用已经升级过。如果在Data分区无法找到这些升级过的系统应用，那很可能是用户在OTA升级时，清除了Data分区的数据，对于这种场景，需要重新扫描一下该应用原来位于系统分区的文件。</p></li><li><p>SystemConfig中定义了公共库，在APK的AndroidManifest.xml文件中，会通过<use-library>标签标记该APK动态依赖的公共库，此处的逻辑就是将APK与SystemConfig中的公共库关联起来。如果APK使用的公共库并不存在，则会抛出异常(INSTALL_FAILED_MISSING_SHARED_LIBRARY)。</use-library></p></li></ol><h3 id="收尾工作"><a href="#收尾工作" class="headerlink" title="收尾工作"></a>收尾工作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 代码片段4：收尾工作</span><br><span class="line">    // 授权</span><br><span class="line">    int updateFlags = UPDATE_PERMISSIONS_ALL;</span><br><span class="line">    <span class="keyword">if</span> (ver.sdkVersion != mSdkVersion) &#123;</span><br><span class="line">        updateFlags |= UPDATE_PERMISSIONS_REPLACE_PKG | UPDATE_PERMISSIONS_REPLACE_ALL;</span><br><span class="line">    &#125;</span><br><span class="line">    updatePermissionsLPw(null, null, updateFlags);</span><br><span class="line">    ver.sdkVersion = mSdkVersion;</span><br><span class="line"></span><br><span class="line">    // 多用户场景下的版本兼容处理</span><br><span class="line">    <span class="keyword">if</span> (!onlyCore &amp;&amp; (mPromoteSystemApps || !mRestoredSettings)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (UserInfo user : sUserManager.getUsers(<span class="literal">true</span>)) &#123;</span><br><span class="line">            mSettings.applyDefaultPreferredAppsLPw(this, user.id);</span><br><span class="line">            applyFactoryDefaultBrowserLPw(user.id);</span><br><span class="line">            primeDomainVerificationsLPw(user.id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果是升级新版本，则需要清除已有的Code cache目录</span><br><span class="line">    <span class="keyword">if</span> (mIsUpgrade &amp;&amp; !onlyCore) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; mSettings.mPackages.size(); i++) &#123;</span><br><span class="line">            final PackageSetting ps = mSettings.mPackages.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, ps.volumeUuid)) &#123;</span><br><span class="line">                deleteCodeCacheDirsLI(ps.volumeUuid, ps.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ver.fingerprint = Build.FINGERPRINT;</span><br><span class="line">    &#125;</span><br><span class="line">    checkDefaultBrowser();</span><br><span class="line">    mExistingSystemPackages.clear();</span><br><span class="line">    mPromoteSystemApps = <span class="literal">false</span>;</span><br><span class="line">    ver.databaseVersion = Settings.CURRENT_DATABASE_VERSION;</span><br><span class="line">    mSettings.writeLPr();</span><br><span class="line"></span><br><span class="line">    // 关键日志，PMS已经启动完毕了</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_PMS_READY,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mRequiredVerifierPackage = getRequiredVerifierLPr();</span><br><span class="line">    mRequiredInstallerPackage = getRequiredInstallerLPr();</span><br><span class="line">    // 初始化包安装服务</span><br><span class="line">    mInstallerService = new PackageInstallerService(context, this);</span><br><span class="line">    mIntentFilterVerifierComponent = getIntentFilterVerifierComponentNameLPr();</span><br><span class="line">    mIntentFilterVerifier = new IntentVerifierProxy(mContext,</span><br><span class="line">            mIntentFilterVerifierComponent);</span><br><span class="line">    &#125; // synchronized (mPackages)</span><br><span class="line">    &#125; // synchronized (mInstallLock)</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">    LocalServices.addService(PackageManagerInternal.class, new PackageManagerInternalImpl());</span><br><span class="line">&#125; // PMS构造函数完结</span><br></pre></td></tr></table></figure><p>【代码片段4】主要进行一些收尾工作，有几个关键点：</p><ul><li>授权，通过调用PMS.updatePermissionsLPw()函数，后文会详细分析</li><li>版本兼容处理，Android M引入了多用户，需要更新每个APK关联到的userid</li><li>将PMS的Settings信息写入/system/packages.xml文件中，Settings是PMS中所有包信息的汇总的数据结构，PMS对包的管理极其依赖于这个数据结构。</li><li>初始化包安装服务PackageInstallerService。<br>至此，PMS对象的构建过程已经分析完毕，整个逻辑还是较为清晰的，但其实这是一个非常耗时的过程，开机时间大部分都耗在文件扫描上。</li></ul><h2 id="文件扫描"><a href="#文件扫描" class="headerlink" title="文件扫描"></a>文件扫描</h2><p>scanDirLI()只是文件扫描的起点，由此引发出一串的与文件扫描相关的函数。<br><img src="http://duanqz.github.io/assets/images/packagemanager/5-packagemanager-scan-seq.png" alt="文件扫描"><br>接下来，笔者会按照调用时序，对关键函数进行分析。PMS对象构建时，待扫描的目录有很多，不同目录的文件扫描，只是在扫描参数上略有区别，整体逻辑上并无不同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) &#123;</span><br><span class="line">    final File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line">         <span class="built_in">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        final boolean isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line">            &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line">        <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line">            <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</span><br><span class="line">                    scanFlags, currentTime, null);</span><br><span class="line">        &#125; catch (PackageManagerException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp;</span><br><span class="line">                    e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line">                // 如果扫描Data分区的APK失败，则删除Data分区扫描失败的文件</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                    mInstaller.rmPackageDir(file.getAbsolutePath());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    file.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://duanqz.github.io/2017-01-04-Package-Manage-Mechanism#1-%E6%A6%82%E8%A6%81" target="_blank" rel="noopener">Android包管理机制</a><br><a href="https://blog.csdn.net/linliang815/article/details/76640262" target="_blank" rel="noopener">Android 包管理（PackageManagerService）</a><br><a href="https://blog.csdn.net/innost/article/details/47253179" target="_blank" rel="noopener">第4章  深入理解PackageManagerService</a><br><a href="http://wiki.jikexueyuan.com/project/deep-android-v2/packagemanagerservice.html" target="_blank" rel="noopener">深入理解 PackageManagerService</a><br><a href="https://blog.csdn.net/gaugamela/article/details/52619720" target="_blank" rel="noopener">Android7.0 PackageManagerService (1) 通信结构、启动和main函数</a><br><a href="https://www.cnblogs.com/chenlong-50954265/p/5729553.html" target="_blank" rel="noopener">Android PackageManagerService详细分析</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/75129690" target="_blank" rel="noopener">Android8.0 PackageManagerService相关 – APK安装和install 的变更和源码浅析</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android PackageManagerService </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 配置 OpenGork 服务</title>
      <link href="/2018/05/31/year-06-23-Ubuntu-%E9%85%8D%E7%BD%AE-OpenGork-%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/05/31/year-06-23-Ubuntu-%E9%85%8D%E7%BD%AE-OpenGork-%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h1 id="OpenGork的配置"><a href="#OpenGork的配置" class="headerlink" title="OpenGork的配置"></a>OpenGork的配置</h1><p>OpenGork的好处，这里不做介绍了，可以参考<a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24369747</a><br>OpenGork是用Java实现的，源码见 <a href="https://github.com/oracle/opengrok/" target="_blank" rel="noopener">https://github.com/oracle/opengrok/</a><br>OpenGork官网：<a href="http://oracle.github.io/opengrok/" target="_blank" rel="noopener">http://oracle.github.io/opengrok/</a><br>OpenGork下载地址：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a> 这里可以下载编译好的文件，或者下载源码</p><p>配置OpenGork之前需要一些其他的环境：  </p><ol><li>Java环境：JDK 以及配置好环境变量<br>—如何实现请自行查找  </li><li>Tomcat 服务：需要下载Tomcat服务<br>下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a><br><strong>注意一：Tomcat7.0版本和JDK1.8版本无法兼容</strong>  </li><li>OpenGork：<a href="https://github.com/oracle/opengrok/releases" target="_blank" rel="noopener">https://github.com/oracle/opengrok/releases</a>  </li><li>遗漏了ctags，如果这个工具没有安装和在Opengork里面配置的话，就算Tomcat和Opengork都配置好了，且都能正常运行，还是无法进行搜索，而且Opengork网站里面也无法打开文件。根本原因是ctags 就是用来建立索引的工具，没了它，后面的搜索就无从说起。<br>Ubuntu 安装ctags命令:sudo apt-get install ctags<br>Ubuntu自带了exuberant ctags,在后面的OpenGork的配置文件中，需要FindExuberanCtags()函数的binary中需要填写为binay=”exuberant ctags”</li></ol><p><strong>注意二：Tomcat 和 Jdk不要直接用sudo apt-get install的命令方式来安装。这样做了，后面改配置文件会很痛苦</strong></p><p>前期准备工作做好了之后，下面来进行安装和配置：  </p><ol><li><p>安装Tomcat<br>1)解压下载下来的Tomcat压缩包<br>进入Tomcat解压目录/bin 下执行sudo ./startup.sh<br>启动Tomcat<br>2).在浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 或者192.168.0.1:8080<br>局域网内其他机器可以输入<a href="http://ip:8080" target="_blank" rel="noopener">http://ip:8080</a>来测试Tomcat服务是否启动成功</p></li><li><p>安装OpenGork<br>1)在/opt目录下新建opengork目录<br>2)将下载下来的opengork压缩包解压到/opt/opengork目录下<br>3)opengrok/lib目录下的source.war包拷贝到apache-tomcat/webapps目录下<br>4)在浏览器输入<a href="http://localhost:8080/source" target="_blank" rel="noopener">http://localhost:8080/source</a><br>5)能正常看到opengork起来了的界面就Ok了。<br>如果Tomcat版本是7.0，JDK版本是1.8的话，或在这个界面报各种http 400/500等各种乱七八糟的错误</p></li><li><p>配置OpenGork<br>在/opt/opengrok目录的bin文件下 vim OpenGork文件<br>找到DefaultInstanceConfiguration函数里面的<br>OPENGROK_INSTANCE_BASE=”${OPENGROK_INSTANCE_BASE:-/var/opengrok}”</p></li></ol><p>这一块<a href="https://blog.csdn.net/tyronne/article/details/34984805" target="_blank" rel="noopener">https://blog.csdn.net/tyronne/article/details/34984805</a> 这篇文章写的蛮好，可以参考</p><ol start="4"><li>客制化Opengork<br>由于Opengork的代码需要建立索引，一般是在/opt/opengork/有src data等目录<br>其实可以自己克制化这个目录<br>比如：在/home/xxx/Code/目录下新建一个opengork目录<br>在里面再建好src data etc三个目录</li></ol><p>在第三步的/opt/opengork/bin/OpenGork这个配置文件里面和Tomcat的web.xml文件里面<br>把路径都配置成/home/xxx/Code/opengork就可以了</p><p>后面可以把代码放在/home/xxx/Code/src目录下面</p><h1 id="Android源码-OpenGork"><a href="#Android源码-OpenGork" class="headerlink" title="Android源码 OpenGork"></a>Android源码 OpenGork</h1><p>以下三个OpenGork都已经部署好，可以查询从Android1.6到最新版本的Android 以及Kernel代码</p><p><a href="http://androidxref.com/" target="_blank" rel="noopener">androidxref</a><br><a href="https://www.androidos.net.cn/" target="_blank" rel="noopener">androidos</a><br><a href="http://android.macpod.net/" target="_blank" rel="noopener">macpod</a></p><p>这三个网站各有各自的优点</p>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android虚拟机Dalvik</title>
      <link href="/2018/05/29/Android%E8%99%9A%E6%8B%9F%E6%9C%BADalvik/"/>
      <url>/2018/05/29/Android%E8%99%9A%E6%8B%9F%E6%9C%BADalvik/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这个选题很大，但并不是一开始就有这么高大上的追求。最初之时，只是源于对Xposed的好奇。Xposed几乎是定制ROM的神器软件技术架构或者说方法了。它到底是怎么实现呢？我本意就是想搞明白Xposed的实现原理，但随着代码研究的深入，我发现如果不了解虚拟机的实现，而仅简单停留在Xposed的调用流程之上，那真是对Xposed最大的不敬了。另外，歪果仁为什么能写出Xposed？Android上的Java虚拟机对他们来说应该也是相对陌生的，何以他们能做而我们没有人搞出这样的东西？</p><p>所以，在研究Xposed之后，我决定把虚拟机方面的东西也来研究一番。诚如我在很多场合中提到的关于Android学习的三个终极问题（其实对其他各科学习也适用）：学什么？怎么学？学到什么程度为止？关于这三个问题，以本次研究的情况来看，回答如下：</p><ul><li>学习目标是：按顺序是dalvik虚拟机，然后是Xposed针对dalvik的实现，然后是art虚拟机。</li><li>学习方法：VM原理配合具体实现，以代码为主。Java VM有一套规范，各公司具体的VM实现必须遵守此规范。所以对VM学习而言，规范很重要，它是不变的，而代码实现只不过是该规范的一种实现罢了。这里也直接体现了我提出的关于专业知识学习的一句警语“基于Android，高于Android”。对VM而言，先掌握规范才是最最重要和核心的事情。</li><li>学到什么程度为止：对于dalvik虚拟机，我们以学会一段Java程序从代码，到字节码，最后到如何被VM加载并运行它为止。关于dalvik的内存管理我们不会介绍。对于XPosed，基于dalvik+selinux环境的代码我们会全部分析。对于ART，由于它是Google未来较长一段时期的重点，所以我们也会围绕它做更多的分析，诸如内存管理怕是肯定会加上的。</li></ul><p>除了这三个问题，其实还有一个隐含的疑问，学完之后有什么用呢？</p><ul><li>这个问题的答案要看各位的需求了。从本人角度来看，我就是想知道Xposed是怎么实现的。另外，如果了解虚拟机实现的话，我还想定制它，使得它在智能POS领域变得更安全一点。</li><li>当然，我自己有一个比较高大上的梦想，就是我一直想写Linux Kernel方面的书，而且我自认为已经找到了一个绝妙的学习它的入手点（我在魅族做分享的时候介绍过。到今天为止一年多过去了，不知道当初的有心人是否借此脱引而出，如果有的话也请和大家分享下你的学习经历）。Anyway，从目前的工作环境和需求来看，VM是当前更好的学习目标。</li></ul><h1 id="Class、dex、odex文件结构"><a href="#Class、dex、odex文件结构" class="headerlink" title="Class、dex、odex文件结构"></a>Class、dex、odex文件结构</h1><h2 id="Class-文件结构总览"><a href="#Class-文件结构总览" class="headerlink" title="Class 文件结构总览"></a>Class 文件结构总览</h2><p>Class文件是理解Vm实现的关键。关于Class文件的结构，这里介绍的内容直接参考JVM规范，因为它是最权威的资料。<br>Oracle的JVM SE7官方规范：<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/</a><br>还算很有良心，纯网页版的，也可以下载PDF版。另外，周志明老师曾经翻译过中文版的JVM规范，网上可搜索到。</p><p>Class文件到底是什么东西？我觉得一种通俗易懂的解释就是：</p><ol><li>*.java文件是人编写的，给人看的。</li><li><em>.class是通过工具处理</em>.java文件后的产物，它是给VM看的，给VM操作的<br>在某种哲学意义上看，java源文件和处理得到的class文件是同一种东西……</li></ol><p>那么，这个给VM使用的class文件，其内部结构是怎样的呢？Jvm规范很聪明，它通过一个C的数据结构表达了class文件结构。这个数据结构如图2所示：</p><p>没有图片，看的费劲!!!!!<br>没看完</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/innost/article/details/50377905" target="_blank" rel="noopener">深入理解Android之Java虚拟机Dalvik</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dalvik </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android系统性能调优工具</title>
      <link href="/2018/05/28/Android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/05/28/Android%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在软件开发过程中，想必很多读者都遇到过系统性能问题。而解决系统性能问题的几个主要步骤是：</p><ul><li>测评：对系统进行大量有针对性的测试，以得到合适的测试数据。</li><li>分析系统瓶颈：分析测试数据，找到其中的hotspot（热点，即bottleneck）。</li><li>性能优化：对hotspot相关的代码进行优化。<br>由上述步骤可知，性能优化的目标对象是hotspot。如果找到的hotspot并非真正的热点，则性能优化的结果必然是事倍功半甚至竹篮打水一场空。所以，作为Android性能调优相关知识的第一部分，本篇首先将向读者介绍Android平台中三个重要的性能测试工具，它们能很好得帮助开发者找到hotspot。</li></ul><p>Android官方的性能和功耗的优化介绍： <a href="https://developer.android.com/topic/performance/" target="_blank" rel="noopener">https://developer.android.com/topic/performance/</a></p><h1 id="Android性能相关的关键词"><a href="#Android性能相关的关键词" class="headerlink" title="Android性能相关的关键词:"></a>Android性能相关的关键词:</h1><ol><li><a href="https://developer.android.com/topic/performance/vitals/" target="_blank" rel="noopener">Android Vitals</a>：Android性能指标</li><li>[TraceView] ：Android性能分析工具</li><li>[dmtracedump] :Google提供的工具，能画函数调用图，dmtracedump和TraceView是一对兄弟，一起使用，用来分析性能</li></ol><h2 id="Android-性能指标"><a href="#Android-性能指标" class="headerlink" title="Android 性能指标"></a>Android 性能指标</h2><p>Android的性能指标，可以参考Google提供的 Android Vitals 仪表盘只能在Google play store上使用，用来监测APP性能数据.<br>见<a href="https://support.google.com/googleplay/android-developer/answer/7385505" target="_blank" rel="noopener">https://support.google.com/googleplay/android-developer/answer/7385505</a></p><ol><li>ANR比例</li><li>Crash 比例</li><li>过度唤醒 WakeLock ,AlarmManager</li><li>过度的后台Wifi扫描</li><li>过度的后台网络使用</li><li>渲染慢,UI 渲染要在16ms以下，60fps即60帧/s以上，不然的话就是Jank(不合格)，用户明显能够感受到卡顿现象。<blockquote><p>识别Jank的方法：<br>a) 通过在 开发者选项中打开 GPU 渲染开关后，查看柱形条<br>b)使用systrace<br>c)</p></blockquote></li><li></li></ol><h2 id="Android-性能指标监测工具"><a href="#Android-性能指标监测工具" class="headerlink" title="Android 性能指标监测工具"></a>Android 性能指标监测工具</h2><p><a href="https://blog.csdn.net/u011974987/article/details/51753774" target="_blank" rel="noopener">Android 性能指标检测工具</a></p><p>Android 常见问题:</p><ul><li>内存泄漏：不使用的内存空间(对象)一直被引用着没有得到释放。</li><li>内存抖动：短时间内大量创建对象又在短时间内频繁触发GC导致内存波动很大，android虚拟机执行GC操作时需要耗费CPU性能频繁GC会到来严重的性能问题。内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</li><li>内存溢出：内存泄漏到一定程度超出系统给进程分配的内存大小就会造成内存溢出程序奔溃，或者加载一个或多个大型文件(图片)到内存中也会导致内存溢出。</li><li>ANR：应用无响应，代码效率过低或者在主线程执行耗时操作。</li></ul><p>内存监控工具如下:</p><p><a href="https://blog.csdn.net/ekeuy/article/details/48661595" target="_blank" rel="noopener">Android性能测试工具列表</a></p><h1 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h1><h2 id="TraceView介绍与用途"><a href="#TraceView介绍与用途" class="headerlink" title="TraceView介绍与用途"></a>TraceView介绍与用途</h2><p>TraceView 是 Android SDK 中内置的一个工具，它可以加载 trace 文件，<strong>用图形的形式展示代码的执行时间、次数及调用栈</strong>，便于我们分析。</p><p>从代码层面分析性能问题，针对每个方法来分析，比如当我们发现我们的应用出现卡顿的时候，我们可以来分析出现卡顿时在方法的调用上有没有很耗时的操作，关注以下两个问题：</p><pre><code>- 调用次数不多，但是每一次执行都很耗时- 方法耗时不大，但是调用次数太多</code></pre><p>简单一点来说就是我们能找到频繁被调用的方法，也能找到执行非常耗时的方法，前者可能会造成Cpu频繁调用，手机发烫的问题，后者就是卡顿的问题</p><p>两方面用途： </p><ol><li>查看跟踪代码的执行时间，分析哪些是耗时操作，主要用于分析方法和线程</li><li>可以用于跟踪方法的调用，尤其是android Framework层的方法调用关系</li></ol><p>Traceview是Android平台特有的数据采集和分析工具，它主要用于分析Android中应用程序的hotspot。Traceview本身只是一个数据分析工具，而数据的采集则需要使用Android SDK中的Debug类或者利用DDMS工具。二者的用法如下：</p><ul><li>开发者在一些关键代码段开始前调用Android SDK中Debug类的startMethodTracing函数，并在关键代码段结束前调用stopMethodTracing函数。这两个函数运行过程中将采集运行时间内该应用所有线程（注意，只能是Java线程）的函数执行情况，并将采集数据保存到/mnt/sdcard/下的一个文件中。开发者然后需要利用SDK中的Traceview工具来分析这些数据。</li><li>借助Android SDK中的DDMS工具。DDMS可采集系统中某个正在运行的进程的函数调用信息。对开发者而言，此方法适用于没有目标应用源代码的情况。DDMS工具中Traceview的使用如图1-1所示。<br><img src="https://img-blog.csdn.net/20130602213318781" alt="图1-1"><br><center>图1-1  DDMS中Traceview使用示意图</center><br>点击图1-1中所示按钮即可以采集目标进程的数据。当停止采集时，DDMS会自动触发Traceview工具来浏览采集数据。</li></ul><h2 id="TraceView的使用"><a href="#TraceView的使用" class="headerlink" title="TraceView的使用"></a>TraceView的使用</h2><p><a href="https://blog.csdn.net/superxlcr/article/details/78219673" target="_blank" rel="noopener">TraceView工具如何使用</a><br>Google官方TraceView 教程：</p><ol><li>使用TraceView收集log <a href="https://developer.android.com/studio/profile/generate-trace-logs" target="_blank" rel="noopener">https://developer.android.com/studio/profile/generate-trace-logs</a></li><li>分析TraceView log <a href="https://developer.android.com/studio/profile/traceview#timelinepanel" target="_blank" rel="noopener">https://developer.android.com/studio/profile/traceview#timelinepanel</a></li></ol><p>Android代码调试工具 traceview 和 dmtracedump的波折演绎 <a href="https://blog.csdn.net/yiyaaixuexi/article/details/6716884" target="_blank" rel="noopener">https://blog.csdn.net/yiyaaixuexi/article/details/6716884</a> 此文的优点：可以使用dmtracedump来输出函数调用关系图</p><p>以下章节来自：<br><a href="https://blog.csdn.net/u011240877/article/details/54347396" target="_blank" rel="noopener">Android 性能优化：使用 TraceView 找到卡顿的元凶</a></p><h3 id="生成TraceView文件"><a href="#生成TraceView文件" class="headerlink" title="生成TraceView文件"></a>生成TraceView文件</h3><p>生成 trace 文件有三种方法：</p><ol><li>使用代码</li><li>使用 Android Studio</li><li>使用 DDMS</li></ol><h4 id="使用代码生成trace文件"><a href="#使用代码生成trace文件" class="headerlink" title="使用代码生成trace文件"></a>使用代码生成trace文件</h4><p>android.os.Debug类，其中重要的两个方法Debug.startMethodTracing()和Debug.stopMethodTracing()。这两个方法用来创建.trace文件，将从Debug.startMethodTracing()开始，到Debug.stopMethodTracing()结束，期间所有的调用过程保存在.trace文件中，包括调用的函数名称和执行的时间等信息。<br>    把下面代码分别在加在调试起始代码的位置，和终止位置。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(Environment.getExternalStorageDirectory().getPath()+<span class="string">"/"</span>+TAG);    //开始 trace，保存文件到外部存储空间的TAG.trace，/mnt/sdcard目录下</span><br><span class="line">    // ...</span><br><span class="line">Debug.stopMethodTracing();    //结束</span><br></pre></td></tr></table></figure></p><p>代码很简单，当你调用开始代码的时候，系统会生产 trace 文件，并且产生追踪数据，当你调用结束代码时，会将追踪数据写入到 trace 文件中。</p><p>下一步使用 adb 命令将 trace 文件导出到电脑：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/TAG.trace /tmp</span><br></pre></td></tr></table></figure></p><p>使用代码生成 trace 方式的好处是容易控制追踪的开始和结束，缺点就是步骤稍微多了一点。</p><h4 id="使用Android-Studio生成trace文件"><a href="#使用Android-Studio生成trace文件" class="headerlink" title="使用Android Studio生成trace文件"></a>使用Android Studio生成trace文件</h4><p>暂时没有用过</p><h3 id="使用Android-Device-Monitor生成Trace文件"><a href="#使用Android-Device-Monitor生成Trace文件" class="headerlink" title="使用Android Device Monitor生成Trace文件"></a>使用Android Device Monitor生成Trace文件</h3><p>参考: <a href="https://blog.csdn.net/itfootball/article/details/48792435" target="_blank" rel="noopener">Android性能专项测试之TraceView工具(Device Monitor)</a></p><h2 id="根据-TraceView-显示内容定位问题"><a href="#根据-TraceView-显示内容定位问题" class="headerlink" title="根据 TraceView 显示内容定位问题"></a>根据 TraceView 显示内容定位问题</h2><p>定位问题时 TraceView 的使用方式：</p><ul><li>从上半部分查看哪些线程执行时间长？什么时候开始执行？与主线程交错时间？</li><li>哪些方法的执行需要花费很长时间点击 TraceView 中的 Cpu Time/Call，按照占用 CPU 时间从高到低排序</li><li>哪些方法调用次数非常频繁,点击 TraceView 中的 Calls + Recur Calls/Total ，按照调用次数从高到底排序排序后，然后逐个排查是否有项目代码或者依赖库代码，有的话点击查看详情，查看是这个方法还是调用的子方法的问题，进一步定位问题。</li></ul><h1 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h1><h2 id="Systrace简介"><a href="#Systrace简介" class="headerlink" title="Systrace简介"></a>Systrace简介</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p><ul><li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li><li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li><li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/platform-tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。</li></ul><p>从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace。Android 4.1为系统中的几个关键进程和模块都添加了Systrace功能。以显示系统中重要模块Hwcomposer为例，其代码中使用Systrace的方法如图2-1所示：</p><h1 id="Oprofile"><a href="#Oprofile" class="headerlink" title="Oprofile"></a>Oprofile</h1><h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">Android 内存泄漏总结</a><br><a href="http://drakeet.me/android-leaks/" target="_blank" rel="noopener">Android 内存泄漏案例和解析</a><br><a href="https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%86%B3.md" target="_blank" rel="noopener">Handler内存泄漏分析及解决</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/innost/article/details/9008691" target="_blank" rel="noopener">Android系统性能调优工具介绍</a>  介绍了TraceView、Systrace、Oprofile等性能分析工具<br><a href="https://blog.csdn.net/cangely/article/details/80504292" target="_blank" rel="noopener">Android Vitals各性能指标介绍</a> Google官方的性能介绍<br><a href="https://blog.csdn.net/u011974987/article/details/51753774" target="_blank" rel="noopener">Android 性能指标检测工具</a><br><a href="http://www.cnblogs.com/sunzn/p/3192231.html" target="_blank" rel="noopener">Android 编程下的 TraceView 简介及其案例实战</a><br><a href="https://blog.csdn.net/u011240877/article/details/54347396" target="_blank" rel="noopener">Android 性能优化：使用 TraceView 找到卡顿的元凶</a><br><a href="https://juejin.im/post/5874bff0128fe1006b443fa0" target="_blank" rel="noopener">Android性能优化（一）之启动加速35%</a><br><a href="https://blog.csdn.net/u011240877/article/details/54141714" target="_blank" rel="noopener">Android 性能优化：使用 Lint 优化代码、去除多余资源</a><br><a href="https://blog.csdn.net/u011240877/article/details/53142177" target="_blank" rel="noopener">Android 性能优化：多线程</a></p><p><a href="https://race604.com/android-weekly-30/" target="_blank" rel="noopener">[第 30 期] Android 周报</a>  有些性能的文章</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 开发者指南阅读</title>
      <link href="/2018/05/02/Android-%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB/"/>
      <url>/2018/05/02/Android-%E5%BC%80%E5%8F%91%E8%80%85%E6%8C%87%E5%8D%97%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.android.com/guide/" target="_blank" rel="noopener">Android 开发者指南</a><br>进入<a href="https://developer.android.com" target="_blank" rel="noopener">https://developer.android.com</a> -&gt; Doc -&gt; Guides即可</p><p>由于东西太多，就先从自己感兴趣的开始翻译。<br>已经完成：<br>Best practices<br>└── Performance</p><h1 id="APP-Basics"><a href="#APP-Basics" class="headerlink" title="APP Basics"></a>APP Basics</h1><p>应用基础知识</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h2 id="Build-your-first-app"><a href="#Build-your-first-app" class="headerlink" title="Build your first app"></a>Build your first app</h2><h2 id="App-fundamentals"><a href="#App-fundamentals" class="headerlink" title="App fundamentals"></a>App fundamentals</h2><h2 id="App-resources"><a href="#App-resources" class="headerlink" title="App resources"></a>App resources</h2><h2 id="App-manifest-file"><a href="#App-manifest-file" class="headerlink" title="App manifest file"></a>App manifest file</h2><h2 id="App-permissions"><a href="#App-permissions" class="headerlink" title="App permissions"></a>App permissions</h2><h1 id="Devices"><a href="#Devices" class="headerlink" title="Devices"></a>Devices</h1><p>设备</p><h2 id="Device-compatibility"><a href="#Device-compatibility" class="headerlink" title="Device compatibility"></a>Device compatibility</h2><h2 id="Wear"><a href="#Wear" class="headerlink" title="Wear"></a>Wear</h2><h2 id="Android-TV"><a href="#Android-TV" class="headerlink" title="Android TV"></a>Android TV</h2><h2 id="Android-Auto"><a href="#Android-Auto" class="headerlink" title="Android Auto"></a>Android Auto</h2><h2 id="Android-Things"><a href="#Android-Things" class="headerlink" title="Android Things"></a>Android Things</h2><h2 id="Chrome-OS-devices"><a href="#Chrome-OS-devices" class="headerlink" title="Chrome OS devices"></a>Chrome OS devices</h2><h1 id="Core-topics"><a href="#Core-topics" class="headerlink" title="Core topics"></a>Core topics</h1><h2 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h2><h3 id="Introduction-to-activities"><a href="#Introduction-to-activities" class="headerlink" title="Introduction to activities"></a>Introduction to activities</h3><h3 id="The-activity-lifecycle"><a href="#The-activity-lifecycle" class="headerlink" title="The activity lifecycle"></a>The activity lifecycle</h3><h3 id="Activity-state-changes"><a href="#Activity-state-changes" class="headerlink" title="Activity state changes"></a>Activity state changes</h3><h3 id="Tasks-and-back-stack"><a href="#Tasks-and-back-stack" class="headerlink" title="Tasks and back stack"></a>Tasks and back stack</h3><h3 id="Processes-and-app-lifecycle"><a href="#Processes-and-app-lifecycle" class="headerlink" title="Processes and app lifecycle"></a>Processes and app lifecycle</h3><h3 id="Parcelables-and-bundles"><a href="#Parcelables-and-bundles" class="headerlink" title="Parcelables and bundles"></a>Parcelables and bundles</h3><h3 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h3><h3 id="Interact-with-other-apps"><a href="#Interact-with-other-apps" class="headerlink" title="Interact with other apps"></a>Interact with other apps</h3><h3 id="Handling-app-links"><a href="#Handling-app-links" class="headerlink" title="Handling app links"></a>Handling app links</h3><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><h3 id="Recents-screen"><a href="#Recents-screen" class="headerlink" title="Recents screen"></a>Recents screen</h3><h3 id="Multi-window-support"><a href="#Multi-window-support" class="headerlink" title="Multi-window support"></a>Multi-window support</h3><h3 id="App-shorcuts"><a href="#App-shorcuts" class="headerlink" title="App shorcuts"></a>App shorcuts</h3><h3 id="App-widgets"><a href="#App-widgets" class="headerlink" title="App widgets"></a>App widgets</h3><h2 id="Intents-and-intent-filters"><a href="#Intents-and-intent-filters" class="headerlink" title="Intents and intent filters"></a>Intents and intent filters</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Common-intents"><a href="#Common-intents" class="headerlink" title="Common intents"></a>Common intents</h3><h2 id="User-interface-amp-navigation"><a href="#User-interface-amp-navigation" class="headerlink" title="User interface &amp; navigation"></a>User interface &amp; navigation</h2><h3 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h3><h3 id="Look-and-feel"><a href="#Look-and-feel" class="headerlink" title="Look and feel"></a>Look and feel</h3><h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><h3 id="Add-the-app-bar"><a href="#Add-the-app-bar" class="headerlink" title="Add the app bar"></a>Add the app bar</h3><h3 id="Control-the-system-UI-visibility"><a href="#Control-the-system-UI-visibility" class="headerlink" title="Control the system UI visibility"></a>Control the system UI visibility</h3><h3 id="Designing-effective-navigation"><a href="#Designing-effective-navigation" class="headerlink" title="Designing effective navigation"></a>Designing effective navigation</h3><h3 id="Implementing-effective"><a href="#Implementing-effective" class="headerlink" title="Implementing effective"></a>Implementing effective</h3><h3 id="navigation"><a href="#navigation" class="headerlink" title="navigation"></a>navigation</h3><h3 id="Slide-between-fragments-using-ViewPager"><a href="#Slide-between-fragments-using-ViewPager" class="headerlink" title="Slide between fragments using ViewPager"></a>Slide between fragments using ViewPager</h3><h3 id="Supporting-swipe-to-refresh"><a href="#Supporting-swipe-to-refresh" class="headerlink" title="Supporting swipe-to-refresh"></a>Supporting swipe-to-refresh</h3><h3 id="Toasts-overview"><a href="#Toasts-overview" class="headerlink" title="Toasts overview"></a>Toasts overview</h3><h3 id="Pop-up-messages-overview"><a href="#Pop-up-messages-overview" class="headerlink" title="Pop-up messages overview"></a>Pop-up messages overview</h3><h3 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a>Dialogs</h3><h3 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h3><h3 id="Settings"><a href="#Settings" class="headerlink" title="Settings"></a>Settings</h3><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><h3 id="Copy-and-paste"><a href="#Copy-and-paste" class="headerlink" title="Copy and paste"></a>Copy and paste</h3><h3 id="Drag-and-drop"><a href="#Drag-and-drop" class="headerlink" title="Drag and drop"></a>Drag and drop</h3><h3 id="Creating-backward-compatible"><a href="#Creating-backward-compatible" class="headerlink" title="Creating backward-compatible"></a>Creating backward-compatible</h3><h3 id="Uis"><a href="#Uis" class="headerlink" title="Uis"></a>Uis</h3><h2 id="Animations-amp-transitions"><a href="#Animations-amp-transitions" class="headerlink" title="Animations &amp; transitions"></a>Animations &amp; transitions</h2><h3 id="Overview-2"><a href="#Overview-2" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Animations-overview"><a href="#Animations-overview" class="headerlink" title="Animations overview"></a>Animations overview</h3><h3 id="Property-animation-overview"><a href="#Property-animation-overview" class="headerlink" title="Property animation overview"></a>Property animation overview</h3><h3 id="Animate-drawable-graphics"><a href="#Animate-drawable-graphics" class="headerlink" title="Animate drawable graphics"></a>Animate drawable graphics</h3><h3 id="Reveal-or-hide-a-view-using-animation"><a href="#Reveal-or-hide-a-view-using-animation" class="headerlink" title="Reveal or hide a view using animation"></a>Reveal or hide a view using animation</h3><h3 id="Move-a-view-using-animation"><a href="#Move-a-view-using-animation" class="headerlink" title="Move a view using animation"></a>Move a view using animation</h3><h3 id="Move-a-view-using-fling-animation"><a href="#Move-a-view-using-fling-animation" class="headerlink" title="Move a view using fling animation"></a>Move a view using fling animation</h3><h3 id="Enlarge-a-view-using-a-zoom-animation"><a href="#Enlarge-a-view-using-a-zoom-animation" class="headerlink" title="Enlarge a view using a zoom animation"></a>Enlarge a view using a zoom animation</h3><h3 id="Animate-movement-using-spring-physics"><a href="#Animate-movement-using-spring-physics" class="headerlink" title="Animate movement using spring physics"></a>Animate movement using spring physics</h3><h3 id="Auto-animate-layout-updates"><a href="#Auto-animate-layout-updates" class="headerlink" title="Auto animate layout updates"></a>Auto animate layout updates</h3><h3 id="Animate-layout-changes-using-a-transtiton"><a href="#Animate-layout-changes-using-a-transtiton" class="headerlink" title="Animate layout changes using a transtiton"></a>Animate layout changes using a transtiton</h3><h3 id="Create-a-custom-transition"><a href="#Create-a-custom-transition" class="headerlink" title="Create a custom transition"></a>Create a custom transition</h3><h3 id="Start-an-activity-using-an-animation"><a href="#Start-an-activity-using-an-animation" class="headerlink" title="Start an activity using an animation"></a>Start an activity using an animation</h3><h2 id="Images-amp-graphics"><a href="#Images-amp-graphics" class="headerlink" title="Images &amp; graphics"></a>Images &amp; graphics</h2><h3 id="Overview-3"><a href="#Overview-3" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Drawable-overview"><a href="#Drawable-overview" class="headerlink" title="Drawable overview"></a>Drawable overview</h3><h3 id="Vector-drawables-overview"><a href="#Vector-drawables-overview" class="headerlink" title="Vector drawables overview"></a>Vector drawables overview</h3><h3 id="Handling-bitmaps"><a href="#Handling-bitmaps" class="headerlink" title="Handling bitmaps"></a>Handling bitmaps</h3><h3 id="Selecting-colors-with-the-palette-API"><a href="#Selecting-colors-with-the-palette-API" class="headerlink" title="Selecting colors with the palette API"></a>Selecting colors with the palette API</h3><h3 id="Reducing-image-download-size"><a href="#Reducing-image-download-size" class="headerlink" title="Reducing image download size"></a>Reducing image download size</h3><h3 id="Hardware-accelertation"><a href="#Hardware-accelertation" class="headerlink" title="Hardware accelertation"></a>Hardware accelertation</h3><h3 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h3><h3 id="Displaying-graphics-with-OpenGL"><a href="#Displaying-graphics-with-OpenGL" class="headerlink" title="Displaying graphics with OpenGL"></a>Displaying graphics with OpenGL</h3><h3 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h3><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><h3 id="Enhancing-graphics-with-wide-color-content"><a href="#Enhancing-graphics-with-wide-color-content" class="headerlink" title="Enhancing graphics with wide color content"></a>Enhancing graphics with wide color content</h3><h2 id="Audio-amp-Video"><a href="#Audio-amp-Video" class="headerlink" title="Audio &amp; Video"></a>Audio &amp; Video</h2><h3 id="Audio-amp-video-overview"><a href="#Audio-amp-video-overview" class="headerlink" title="Audio &amp; video overview"></a>Audio &amp; video overview</h3><h3 id="Supported-media-formats"><a href="#Supported-media-formats" class="headerlink" title="Supported media formats"></a>Supported media formats</h3><h3 id="Media-app-architecture"><a href="#Media-app-architecture" class="headerlink" title="Media app architecture"></a>Media app architecture</h3><h3 id="Routing-between-devices"><a href="#Routing-between-devices" class="headerlink" title="Routing between devices"></a>Routing between devices</h3><h3 id="Control-amplitude-with-VolumeShaper"><a href="#Control-amplitude-with-VolumeShaper" class="headerlink" title="Control amplitude with VolumeShaper"></a>Control amplitude with VolumeShaper</h3><h3 id="MediaPlayer-overview"><a href="#MediaPlayer-overview" class="headerlink" title="MediaPlayer overview"></a>MediaPlayer overview</h3><h3 id="MediaRecorder-overview"><a href="#MediaRecorder-overview" class="headerlink" title="MediaRecorder overview"></a>MediaRecorder overview</h3><h3 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h3><h2 id="Background-tasks"><a href="#Background-tasks" class="headerlink" title="Background tasks"></a>Background tasks</h2><h3 id="Overview-4"><a href="#Overview-4" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Guide-to-background-processing"><a href="#Guide-to-background-processing" class="headerlink" title="Guide to background processing"></a>Guide to background processing</h3><h3 id="Sending-operations-to-multiple"><a href="#Sending-operations-to-multiple" class="headerlink" title="Sending operations to multiple"></a>Sending operations to multiple</h3><h3 id="threads"><a href="#threads" class="headerlink" title="threads"></a>threads</h3><h3 id="Schedule-jobs-intelligently"><a href="#Schedule-jobs-intelligently" class="headerlink" title="Schedule jobs intelligently"></a>Schedule jobs intelligently</h3><h3 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h3><h3 id="Background-optimizations"><a href="#Background-optimizations" class="headerlink" title="Background optimizations"></a>Background optimizations</h3><h3 id="Broadcastes-overview"><a href="#Broadcastes-overview" class="headerlink" title="Broadcastes overview"></a>Broadcastes overview</h3><h3 id="Manage-device-awake-state"><a href="#Manage-device-awake-state" class="headerlink" title="Manage device awake state"></a>Manage device awake state</h3><h2 id="App-data-amp-files"><a href="#App-data-amp-files" class="headerlink" title="App data &amp; files"></a>App data &amp; files</h2><h3 id="Overview-5"><a href="#Overview-5" class="headerlink" title="Overview"></a>Overview</h3><h3 id="Storage-overview"><a href="#Storage-overview" class="headerlink" title="Storage overview"></a>Storage overview</h3><h3 id="Save-files-on-device-storage"><a href="#Save-files-on-device-storage" class="headerlink" title="Save files on device storage"></a>Save files on device storage</h3><p>…….太多了，先不加了</p><h1 id="Best-practices"><a href="#Best-practices" class="headerlink" title="Best practices"></a>Best practices</h1><h2 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h2><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>性能</p><h3 id="Overview-6"><a href="#Overview-6" class="headerlink" title="Overview"></a>Overview</h3><p>性能表现在：</p><ul><li>快速启动</li><li>快速响应用户交互<h3 id="Android-Vitals"><a href="#Android-Vitals" class="headerlink" title="Android Vitals"></a>Android Vitals</h3></li></ul><h3 id="Processes-and-Threads-Overview"><a href="#Processes-and-Threads-Overview" class="headerlink" title="Processes and Threads Overview"></a>Processes and Threads Overview</h3><h3 id="Better-Performance-through-Threading"><a href="#Better-Performance-through-Threading" class="headerlink" title="Better Performance through Threading"></a>Better Performance through Threading</h3><h3 id="Optimizing-for-Battery-Life"><a href="#Optimizing-for-Battery-Life" class="headerlink" title="Optimizing for Battery Life"></a>Optimizing for Battery Life</h3><h3 id="Reducing-APK-Size"><a href="#Reducing-APK-Size" class="headerlink" title="Reducing APK Size"></a>Reducing APK Size</h3><h3 id="Manager-Your-App’s-Memory"><a href="#Manager-Your-App’s-Memory" class="headerlink" title="Manager Your App’s Memory"></a>Manager Your App’s Memory</h3><h3 id="Overview-of-Memory-Managemement"><a href="#Overview-of-Memory-Managemement" class="headerlink" title="Overview of Memory Managemement"></a>Overview of Memory Managemement</h3><h3 id="Designing-for-Seamlessness"><a href="#Designing-for-Seamlessness" class="headerlink" title="Designing for Seamlessness"></a>Designing for Seamlessness</h3><h3 id="Keeping-Your-App-Responsive"><a href="#Keeping-Your-App-Responsive" class="headerlink" title="Keeping Your App Responsive"></a>Keeping Your App Responsive</h3><h3 id="Performance-Tips"><a href="#Performance-Tips" class="headerlink" title="Performance Tips"></a>Performance Tips</h3><h3 id="SMP-Primer-for-Android"><a href="#SMP-Primer-for-Android" class="headerlink" title="SMP Primer for Android"></a>SMP Primer for Android</h3><h3 id="Verifying-App-Behavior-on-th-ANdroid-Runtime-ART"><a href="#Verifying-App-Behavior-on-th-ANdroid-Runtime-ART" class="headerlink" title="Verifying App Behavior on th ANdroid Runtime(ART)"></a>Verifying App Behavior on th ANdroid Runtime(ART)</h3><h2 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h2><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h2 id="Build-for-Billions"><a href="#Build-for-Billions" class="headerlink" title="Build for Billions"></a>Build for Billions</h2><h2 id="Build-for-Enterprise"><a href="#Build-for-Enterprise" class="headerlink" title="Build for Enterprise"></a>Build for Enterprise</h2><h2 id="Google-Play"><a href="#Google-Play" class="headerlink" title="Google Play"></a>Google Play</h2>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指南 </tag>
            
            <tag> Guides </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发常用网站</title>
      <link href="/2017/04/23/2017-04-23-Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/"/>
      <url>/2017/04/23/2017-04-23-Android%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<h1 id="实用的OpenGork网站："><a href="#实用的OpenGork网站：" class="headerlink" title="实用的OpenGork网站："></a>实用的OpenGork网站：</h1><p><a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a><br><a href="https://www.androidos.net.cn/" target="_blank" rel="noopener">https://www.androidos.net.cn/</a><br><a href="http://android.macpod.net/" target="_blank" rel="noopener">http://android.macpod.net/</a></p><h1 id="Android工具网站："><a href="#Android工具网站：" class="headerlink" title="Android工具网站："></a>Android工具网站：</h1><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a></p><h1 id="Android-开发技术周报"><a href="#Android-开发技术周报" class="headerlink" title="Android 开发技术周报"></a>Android 开发技术周报</h1><p><a href="https://androidweekly.io/" target="_blank" rel="noopener">https://androidweekly.io/</a>  每周一篇最新的技术周报<br><a href="https://androidweekly.cn/" target="_blank" rel="noopener">https://androidweekly.cn/</a><br>Android 开发的技术文章、开源项目、开发工具、视频教程、Android 设计教程、设计资源等</p><h1 id="编程刷题网站："><a href="#编程刷题网站：" class="headerlink" title="编程刷题网站："></a>编程刷题网站：</h1><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">https://leetcode-cn.com/</a><br><a href="https://www.jiuzhang.com/solutions/" target="_blank" rel="noopener">https://www.jiuzhang.com/solutions/</a><br><a href="http://www.codevs.cn/" target="_blank" rel="noopener">http://www.codevs.cn/</a><br><a href="https://www.hackerrank.com/onboarding/challenge" target="_blank" rel="noopener">https://www.hackerrank.com/onboarding/challenge</a><br><a href="http://www.codeding.com/" target="_blank" rel="noopener">http://www.codeding.com/</a></p><h1 id="语言手册"><a href="#语言手册" class="headerlink" title="语言手册"></a>语言手册</h1><p><a href="https://mirrors.segmentfault.com/" target="_blank" rel="noopener">https://mirrors.segmentfault.com/</a><br>Introduction to Tornado 中文翻译<br>Android 设计指南简体中文版<br>Swift语言指南<br>PHP 中文手册<br>Node.js 手册<br>Golang 手册<br>Python 2.x 手册<br>Python 3.x 手册<br>Laravel 手册<br>Rust 手册<br>React 手册<br>Kotlin 手册</p>]]></content>
      
      <categories>
          
          <category> Android Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Tools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 好文</title>
      <link href="/2017/01/01/Android-%E5%A5%BD%E6%96%87/"/>
      <url>/2017/01/01/Android-%E5%A5%BD%E6%96%87/</url>
      <content type="html"><![CDATA[<h1 id="优秀的网站"><a href="#优秀的网站" class="headerlink" title="优秀的网站"></a>优秀的网站</h1><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge" target="_blank" rel="noopener">常用的Android开发的一些技能点汇集</a></p><p><a href="https://github.com/DanluTeam/ColdStart" target="_blank" rel="noopener">awesome-android-performance</a> 性能优化</p><p><a href="https://github.com/EricChows/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">免费的编程书籍</a></p><p><a href="https://github.com/EricChows/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">Android优质资源合集</a></p><h1 id="优秀的期刊"><a href="#优秀的期刊" class="headerlink" title="优秀的期刊"></a>优秀的期刊</h1><p><a href="https://www.androidweekly.cn/" target="_blank" rel="noopener">Android开发技术周刊</a></p><p><a href="http://www.androidblog.cn/" target="_blank" rel="noopener">Android博客周刊</a></p><h1 id="优秀的文章"><a href="#优秀的文章" class="headerlink" title="优秀的文章"></a>优秀的文章</h1><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge/blob/master/github_README/README%E6%96%87%E6%A1%A3%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95.md" target="_blank" rel="noopener">README文档的规范写法</a></p><p><a href="https://github.com/AweiLoveAndroid/CommonDevKnowledge/blob/master/interview/summary.md" target="_blank" rel="noopener">国内一线互联网公司面试题汇总</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMjQ0MTU0NA==&amp;mid=2247484617&amp;idx=1&amp;sn=3734e643d241ac9615424dd44462ee2d&amp;chksm=e82c3deedf5bb4f82e7be0823739774a0a2cf8372284c8409471c2752fea1f367ca3f6857795&amp;mpshare=1&amp;scene=23&amp;srcid=1128DKotEvTe4dheaTextbqp#rd" target="_blank" rel="noopener">阿里、腾讯、百度、华为、京东、搜狗和滴滴最新面试题汇集</a></p><p><a href="https://zhuanlan.zhihu.com/p/30016683" target="_blank" rel="noopener">2017下半年，一二线互联网公司Android面试题汇总</a></p><p><a href="https://zhuanlan.zhihu.com/p/26327485" target="_blank" rel="noopener">2017 年初、阿里、腾讯、百度、华为、京东、搜狗和滴滴面试题汇集（更新篇）</a>  带答案</p><p><a href="https://github.com/LRH1993/android_interview" target="_blank" rel="noopener">Android校招面试指南</a></p><p><a href="http://www.jackywang.tech/AndroidInterview-Q-A/" target="_blank" rel="noopener">The top Internet companies android interview questions and answers</a></p><p><a href="https://crossoverjie.top/2018/06/21/personal/Interview-experience/" target="_blank" rel="noopener">一个学渣的阿里之路</a></p><p><a href="https://github.com/DanluTeam/ColdStart" target="_blank" rel="noopener">App 启动优化</a></p><p>需要把 <a href="https://github.com/EricChows/Worth-Reading-the-Android-technical-articles" target="_blank" rel="noopener">https://github.com/EricChows/Worth-Reading-the-Android-technical-articles</a> 这里面的优秀文章一篇一篇的看完。</p><h1 id="Android开发工具"><a href="#Android开发工具" class="headerlink" title="Android开发工具"></a>Android开发工具</h1><p><a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">AndroidDevTools</a></p><p><a href="https://github.com/inferjay/AndroidDevTools/" target="_blank" rel="noopener">AndroidDevTools(Github)</a></p><p><a href="http://androidblog.cn/tools/" target="_blank" rel="noopener">Android开发工具汇总</a></p><h1 id="Android官方文档-中文版"><a href="#Android官方文档-中文版" class="headerlink" title="Android官方文档 中文版"></a>Android官方文档 中文版</h1><p><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">AndroidTraning中文版</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 好文 </tag>
            
            <tag> good </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>View及Viewgroup</title>
      <link href="/2015/08/01/View%E5%8F%8AViewgroup/"/>
      <url>/2015/08/01/View%E5%8F%8AViewgroup/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html" target="_blank" rel="noopener">http://www.cnblogs.com/hnrainll/archive/2011/11/14/2248564.html</a></p><p>.1.0 View及ViewGroup类关系<br>Android View和ViewGroup从组成架构上看，似乎ViewGroup在View之上，View需要继承ViewGroup，但实际上不是这样的。 View是基类，ViewGroup是它的子类。这就证明了一点，View代表了用户界面组件的一块可绘制的空间块。每一个View在屏幕上占据一个长方 形区域。在这个区域内，这个VIEW对象负责图形绘制和事件处理。View是小控件widgets和ViewGroup的父类。ViewGroup又是 Layout的基类。</p><p>image</p><p>image</p><p>从上面两图的对比中，可以看出，实际上ViewGroup是View的子类，因此，View的行为特征ViewGroup也具备，但同时因为 ViewGroup是Layout的祖先，所以具备了其它一些特点,View所未具有的。通常创建一个View，不论是通过XML还是通过代码创建。对任 何一个View及这个View的子类Widget，需要关注如下几个方面：<br>【1】设置属性，如长、宽、着色等。这些属性的设置通常可以用代码实现，也可以用XML文件。并用这些属性在运行时候也可以通常方法进行修改。<br>ID 属性，Android对每个UI元素的ID名称要求唯一，但也不绝对。同时在不同的Layout中是可以相同的元素名称的。给一个UI元素指定ID，有一个好处就是可以在代码中找得到。</p><p>image</p><p>Tags，同ID不同，这个不用来搜索View,类似于对View的一些描述性数据保存。<br>Animation，对任何一个View，可以使用动画对象进行操作。注意，如果View有子的话，子同样具备这个animation功能<br>Position, Size, padding and margins，对任一个View来说，表达这个View通常是宽和高。也可以设置padding和margins。不是所有的View都设置margins。</p><p>image</p><p>Orientatiion，对ViewGroup的子类Layout来说，设置Orienatation，可用来决定子类的位置<br>FillModel，出现这种情况主要是默认情况，某些元素不能完全占满父区域的空间，这时除非子VIEW已经设置具体和DPI，否则话需要告诉父控件，你所选择填充空间方式，如Fill-parent或者Wrap-content等。<br>Gravity，Gravity与Orientation是不同，Gravaity与Word文档中左对齐，右对齐类似。缺省是左上对齐。<br>Weight,这个在两个控制同时分配剩余空间，需要设置layout-weight决定两者谁的占比。<br>【2】请求焦点，可以通过函数实现焦点转换。不同的焦点可以实现不同的背景变换等功能。焦点在Android里分为几种情况，一种是可以获取焦点，另外一种是不能获取焦点，第三种是可获取焦点，但当前正取触摸状态下。<br>【3】设置事件监听者，所有的View都会在本身发生变化将自身的信息广播出去。比喻点击、焦点失去得到等。通常一个事件来到，Android会将事件传 递到相应的View，然后View将事件传递到相应的Listeners。这时View需要获取焦点，如果需要重新绘制View的话，需要调用 invalidate(0或者reqeustLayout重新绘制整个界面。<br>【4】设置显示与隐藏，还可以对其内容设置scrolling。<br>2.1.1 View、Window、Activity、Dispay之间的关系<br>这些都是组成Android 系统显示的关键元素。我们首先来了解Dispay。Dispay代表了硬件显示屏幕信息。</p><p>image</p><p>通过这些函数可以了解一个屏幕的宽、高及分辨率还有是横屏还坚屏等一些基本情况，透过这些函数，我们开发应用时可以方便的得到当前安装我这个应用的屏幕的 大小，以便调整应用使用户得到更好的用户体验。接下来我们看其它三者之间的关系，我想大家虽然看了前面的View的介绍和SDK中关系UI的基本介绍之后 还是对Android图形窗口十分困惑，看API也是，有WindowMangaer接口和Window类，但是在说明文档中，并未提到如何用这些。但实 际上这里面要去看到Android核心，Android核心底层GDI是SKIA，同chrome是一样的GDI，但是GUI是不一样的。这里面 Android实现的是C/S模式。如下图所示</p><p>image</p><p>从上图，我们可以理出大致的显示过程如下：<br>【1】ActivityManagerService创建Activity线程，激活一个activity<br>【2】系统调用Instrumentation.newActivity创建一个activity<br>【3】Activity创建后，attach到一个新创建的phonewindow中。这样Activity获取一个唯一的WindowManager服务的实例<br>【4】Activity创建过程中使用setcontentView设置用用户UI，这些VIEW被加入到PhoneWindow的ContentParent中。<br>【5】Activity线程继续执行，当执行到Activity.makeVisible是将根view DecoView加入到WindowManger中，WindowManger实全会为每个DecoView创建对应的ViewRoot<br>【6】每个ViewRoot拥有一个Surface，每个Surface将会调用底层库创建图形绘制的内存空间。这个底层库就是SurfaceFlinger。SurfaceFlinger同时也负责将个View绘制的图形合到一块（按照Z轴）显示到用户屏幕。<br>【7】如果用户直接在Canvas上绘制，实际上它直接操作Surface。但对每个View的变更，它是要通知到ViewRoot，然后 ViewRoot获取Canvas。如果绘制完成，surfaceFlinger得到通知，合并Surface成一个Surface到设备屏幕。<br>从上面的图形输出过程分析，我们可以知道真正显示图形的实际上跟Activity没有关系，完全由WindowManager来决定。 WindowManager是一个系统服务，因此可以直接调用这个服务来创建界面，并且更绝的是Dialog、Menu也是有WindowManager 来管理的。另外一个我们也可以看到，最底层都是Surface来，因此，常见开发游戏的人都推荐你使用SurfaceView来创建界面。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android 编程下 Touch 事件的分发和消费机制</title>
      <link href="/2015/08/01/Android-%E7%BC%96%E7%A8%8B%E4%B8%8B-Touch-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2015/08/01/Android-%E7%BC%96%E7%A8%8B%E4%B8%8B-Touch-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91%E5%92%8C%E6%B6%88%E8%B4%B9%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html</a></p><p>Android 中与 Touch 事件相关的方法包括：dispatchTouchEvent(MotionEvent ev)、onInterceptTouchEvent(MotionEvent ev)、onTouchEvent(MotionEvent ev)；能够响应这些方法的控件包括：ViewGroup、View、Activity。方法与控件的对应关系如下表所示：</p><p>Touch 事件相关方法 方法功能<br>ViewGroup<br>View<br>Activity<br>public boolean dispatchTouchEvent(MotionEvent ev) 事件分发<br>Yes Yes Yes<br>public boolean onInterceptTouchEvent(MotionEvent ev)<br>事件拦截<br>Yes Yes No<br>public boolean onTouchEvent(MotionEvent ev) 事件响应<br>Yes Yes Yes<br>从这张表中我们可以看到 ViewGroup 和 View 对与 Touch 事件相关的三个方法均能响应，而 Activity 对 onInterceptTouchEvent(MotionEvent ev) 也就是事件拦截不进行响应。另外需要注意的是 View 对 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev) 的响应的前提是可以向该 View 中添加子 View，如果当前的 View 已经是一个最小的单元 View（比如 TextView），那么就无法向这个最小 View 中添加子 View，也就无法向子 View 进行事件的分发和拦截，所以它没有 dispatchTouchEvent(MotionEvent ev) 和 onInterceptTouchEvent(MotionEvent ev)，只有 onTouchEvent(MotionEvent ev)。</p><p>一、Touch 事件分析</p><p>▐ 事件分发：public boolean dispatchTouchEvent(MotionEvent ev)</p><p>Touch 事件发生时 Activity 的 dispatchTouchEvent(MotionEvent ev) 方法会以隧道方式（从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递）将事件传递给最外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法，并由该 View 的 dispatchTouchEvent(MotionEvent ev) 方法对事件进行分发。dispatchTouchEvent 的事件分发逻辑如下：</p><p>如果 return true，事件会分发给当前 View 并由 dispatchTouchEvent 方法进行消费，同时事件会停止向下传递；<br>如果 return false，事件分发分为两种情况：<br>如果当前 View 获取的事件直接来自 Activity，则会将事件返回给 Activity 的 onTouchEvent 进行消费；<br>如果当前 View 获取的事件来自外层父控件，则会将事件返回给父 View 的 onTouchEvent 进行消费。<br>如果返回系统默认的 super.dispatchTouchEvent(ev)，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。<br>▐ 事件拦截：public boolean onInterceptTouchEvent(MotionEvent ev)</p><p>在外层 View 的 dispatchTouchEvent(MotionEvent ev) 方法返回系统默认的 super.dispatchTouchEvent(ev) 情况下，事件会自动的分发给当前 View 的 onInterceptTouchEvent 方法。onInterceptTouchEvent 的事件拦截逻辑如下：</p><p>如果 onInterceptTouchEvent 返回 true，则表示将事件进行拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理；<br>如果 onInterceptTouchEvent 返回 false，则表示将事件放行，当前 View 上的事件会被传递到子 View 上，再由子 View 的 dispatchTouchEvent 来开始这个事件的分发；<br>如果 onInterceptTouchEvent 返回 super.onInterceptTouchEvent(ev)，事件默认会被拦截，并将拦截到的事件交由当前 View 的 onTouchEvent 进行处理。<br>▐ 事件响应：public boolean onTouchEvent(MotionEvent ev)</p><p>在 dispatchTouchEvent 返回 super.dispatchTouchEvent(ev) 并且 onInterceptTouchEvent 返回 true 或返回 super.onInterceptTouchEvent(ev) 的情况下 onTouchEvent 会被调用。onTouchEvent 的事件响应逻辑如下：</p><p>如果事件传递到当前 View 的 onTouchEvent 方法，而该方法返回了 false，那么这个事件会从当前 View 向上传递，并且都是由上层 View 的 onTouchEvent 来接收，如果传递到上面的 onTouchEvent 也返回 false，这个事件就会“消失”，而且接收不到下一次事件。<br>如果返回了 true 则会接收并消费该事件。<br>如果返回 super.onTouchEvent(ev) 默认处理事件的逻辑和返回 false 时相同。<br>到这里，与 Touch 事件相关的三个方法就分析完毕了。下面的内容会通过各种不同的的测试案例来验证上文中三个方法对事件的处理逻辑。</p><p>二、Touch 案例介绍</p><p>同样在开始进行案例分析之前，我需要说明测试案例的结构，因为所有的测试都是针对这一个案例来进行的，测试中只是通过修改每个控件中与 Touch 事件相关的三个方法的返回值来体现不同的情况。先来看张图：</p><p>Touch 事件案例布局 UI</p><p>上面的图为测试案例的布局文件 UI 显示效果，布局文件代码如下：</p><p>复制代码</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2015/08/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/beyond0525/article/details/22814129" target="_blank" rel="noopener">http://blog.csdn.net/beyond0525/article/details/22814129</a></p><p>适配者模式是也是android中应用很广泛的设计模式，如我们常见用 BaseAdpter, ArrayAdapter, CursorAdapter,就是用的适配者模式，看到源码你是不是对这种设计方式很陌生，没事，下面我们通过实际的例子来取理解这种设计模式。</p><p>一、作用</p><p>适配器模式（Adapter）：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>二、适用场景</p><ol><li><p>业务的接口与工作的类不兼容，（比如：类中缺少实现接口的某些方法）但又需要两者一起工作</p></li><li><p>在现有接口和类的基础上为新的业务需求提供接口</p></li></ol><p>三、常见的使用方式</p><p>还是以Usb接口和Phone手机类的产品举例子，假设设计的Phone类中有 call(), sms(), takeAlong()属性方法，而在设计Usb接口时定义了 store(), takeAlong()的行为。如果现在有新的业务需求，需要生成 Xiaomi手机类具有 Phone类和Usb接口两者功能，假设Phone类和Usb接口已经在业务上投入使用，很显然，去修改原类中的方法和接口的行为去满足现在的新业务需求是不可取的，那么现在适配者模式就派上用场了。</p><p>（1）类适配模式</p><p>大致的意思是新的业务类Xiaomi通过继承旧业务的类Phone并实现接口Usb来满足新的业务的一种适配方式，如下图</p><p>Usb接口</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public interface Usb {</p><pre><code>void store();  void takeAlong();  </code></pre><p>}<br>Phone类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone {</p><pre><code>public void call() {      System.out.println(&quot;Phone call&quot;);  }  public void sms() {      System.out.println(&quot;Phone sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone takeAlong&quot;);  }  </code></pre><p>}<br>适配 Xiaomi 类<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 类的适配器模式<br>* phone + Usb<br>* 将Phone的功能扩展到Usb里<br>* @author xuzhaohu  </p><ul><li><p>*/<br>public class Xiaomi extends Phone implements Usb {</p><p> @Override<br> public void store() {  </p><pre><code>// TODO Auto-generated method stub  System.out.println(&quot;store implements usb&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配完后使用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Xiaomi mi1 = new Xiaomi();<br>mi1.takeAlong();<br>mi1.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>这样新的业务需求就可以通过适配的 Xiaomi类去满足了。是不是觉得很简单呢！！:) 有没有其他的方式去实现同样的功能呢？当然有，就是下面要讲的对象适配模式。<br>（2）对象适配模式</p><p>实现的方式很简单，其实就是在适配的时候通过构造函数将旧的业务Phone 当作新的适配类（XiaomiWrapper）一个成员对象去处理，然后适配类只需要实现接口 Usb即可。如下类关系图</p><p>适配类XiaomiWrapper如下，注意takeAlong()方法，是直接调用原类对象（Phone）去执行的。</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 对象的适配器模式  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public class XiaomiWrapper implements Usb {</p><p> /** </p><ul><li>1.创建一个Wrapper类，持有原类的一个实例， </li><li><p>2.在Wrapper类的方法中，调用实例的方法就行<br>*/<br>private Phone phone;  </p><p>public XiaomiWrapper(Phone phone) {  </p><p> this.phone = phone;<br>}  </p><p>@Override<br>public void store() {<br> // TODO Auto-generated method stub<br> System.out.println(“store implements usb”);  </p><p>}  </p><p>@Override<br>public void takeAlong() {<br> // TODO Auto-generated method stub<br> phone.takeAlong();<br>}  </p></li></ul></li></ul><p>}<br>适配完后通过构造函数将原对象传入即可。<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>XiaomiWrapper mi2 = new XiaomiWrapper(new Phone());<br>mi2.takeAlong();<br>mi2.store();<br>输出：<br>Phone takeAlong<br>store implements usb</p><p>或许到这里，你会觉得这种方式很简单吧。但是如果出现这个Usb接口中有很多方法（大于2个），但是新的业务需求中也只需要其中的一两个，而且是需要适配很多这样的业务，这样的话，用上面的方法每次适配一次就会去实现所有Usb接口中的方法，实际上适配的类中有很多是用不到的，没有必要把接口中不使用的类也适配进去，这时候，就轮到下面的接口适配模式出场了。</p><p>（3）接口适配模式</p><p>适配新的业务需求的时候借助抽象实现类（AbsPhone实现Usb接口），也就说，抽象实现类把Usb接口中的行为都实现了，新的适配是需要跟抽象类对话就行，因为抽象实现类就能满足了所有适配的需求，并且做到了只适配业务本身的行为，接口中不需要的行为我根本不需要关注。这就是抽象实现类的作用。类图关系如下：</p><p>抽象类AbsPhone实现</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>/*<em><br>\</em> 接口的适配器模式<br>* 1.借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法<br>* 2.继承类可以选择性的实现接口中的方法  </p><ul><li>* @author xuzhaohu  </li><li><p>*/<br>public abstract class AbsPhone implements Usb {</p><p> public void store() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s store methond&quot;);  </code></pre><p> }  </p><p> public void takeAlong() {  </p><pre><code>System.out.println(&quot;AbsPhone implements usb&apos;s takeAlong methond&quot;);  </code></pre><p> }  </p></li></ul><p>}<br>适配类只跟AbsPhone打交道，根本不需要关心接口的行为，只显示自己所要关注的。<br>如Phone1适配只需要store()行为</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone1 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone1 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone1 sms&quot;);  }  public void store() {      System.out.println(&quot;Phone1 need usb&apos;s store methond&quot;);  }  </code></pre><p>}<br>Phone2适配只需要takeAlong()行为<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>public class Phone2 extends AbsPhone {</p><pre><code>public void call() {      System.out.println(&quot;Phone2 call&quot;);  }  public void sms() {      System.out.println(&quot;Phone2 sms&quot;);  }  public void takeAlong() {      System.out.println(&quot;Phone2 need usb&apos;s takeAlong methond&quot;);  }  </code></pre><p>}<br>实例化调用<br>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p2.takeAlong();<br>输出：<br>Phone1 need usb’s store methond<br>Phone2 need usb’s takeAlong methond<br>来一次完整的调用</p><p>[java] view plaincopy在CODE上查看代码片派生到我的代码片<br>Phone1 p1 = new Phone1();<br>Phone2 p2 = new Phone2();<br>p1.store();<br>p1.takeAlong();<br>p2.takeAlong();<br>p2.store();<br>输出：<br>Phone1 need usb’s store methond<br>AbsPhone implements usb’s takeAlong methond<br>Phone2 need usb’s takeAlong methond<br>AbsPhone implements usb’s store methond<br>这样很清晰的知道适配的什么方法了。</p><p>总结：适配者模式在android源码中有很多这样的体现，大家看完这个再去看源码，是不是会感觉看懂了不少呢？</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2015/08/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangjq/archive/2012/07/12/2587966.html</a></p><ol><li><p>概述</p><p>　　有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></li><li><p>解决的问题</p><p>　　将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的。</p></li><li><p>模式中的角色</p><p>　　3.1 抽象主题（Subject）：它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。</p><p>　　3.2 具体主题（ConcreteSubject）：将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。</p><p>　　3.3 抽象观察者（Observer）：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</p><p>　　3.4 具体观察者（ConcreteObserver）：实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。</p></li><li><p>模式解读</p><p>　　4.1 观察者模式的类图　　</p><p>　　4.2 观察者模式的代码</p></li></ol><p>复制代码<br>///<br>/// 抽象主题类<br>///<br>public abstract class Subject<br>{<br>private IList observers = new List();</p><pre><code>    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(Observer observer)    {        observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(Observer observer)    {        observers.Remove(observer);    }    /// &lt;summary&gt;    /// 向观察者（们）发出通知    /// &lt;/summary&gt;    public void Notify()    {        foreach (Observer o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己/// &lt;/summary&gt;public abstract class Observer{    public abstract void Update();}/// &lt;summary&gt;/// 具体观察者或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。/// &lt;/summary&gt;public class ConcreteSubject : Subject{    private string subjectState;    /// &lt;summary&gt;    /// 具体观察者的状态    /// &lt;/summary&gt;    public string SubjectState    {        get { return subjectState; }        set { subjectState = value; }    }}/// &lt;summary&gt;/// 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调/// &lt;/summary&gt;public class ConcreteObserver : Observer{    private string observerState;    private string name;    private ConcreteSubject subject;    /// &lt;summary&gt;    /// 具体观察者用一个具体主题来实现    /// &lt;/summary&gt;    public ConcreteSubject Subject    {        get { return subject; }        set { subject = value; }    }    public ConcreteObserver(ConcreteSubject subject, string name)    {        this.subject = subject;        this.name = name;    }    /// &lt;summary&gt;    /// 实现抽象观察者中的更新操作    /// &lt;/summary&gt;    public override void Update()    {        observerState = subject.SubjectState;        Console.WriteLine(&quot;The observer&apos;s state of {0} is {1}&quot;, name, observerState);    }}</code></pre><p>复制代码<br>　　4.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{<br>// 具体主题角色通常用具体自来来实现<br>ConcreteSubject subject = new ConcreteSubject();</p><pre><code>        subject.Attach(new ConcreteObserver(subject, &quot;Observer A&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer B&quot;));        subject.Attach(new ConcreteObserver(subject, &quot;Observer C&quot;));        subject.SubjectState = &quot;Ready&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　运行结果</p><ol><li><p>模式总结</p><p>　　5.1 优点</p><p>　　　　5.1.1 观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。</p><p>　　5.2 缺点</p><p>　　　　5.2.1 依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。</p><p>　　5.3 适用场景</p><p>　　　　5.3.1 当一个对象的改变需要给变其它对象时，而且它不知道具体有多少个对象有待改变时。</p><p>　　　　5.3.2 一个抽象某型有两个方面，当其中一个方面依赖于另一个方面，这时用观察者模式可以将这两者封装在独立的对象中使它们各自独立地改变和复用。</p></li><li><p>模式引申，应用C#中的事件委托来彻底解除通知者和观察者之间的耦合。</p><p>　　　6.1 关于委托的定义：委托是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法有相同的行为。委托方法可以像其它任何方法一样，具有参数和返回值。委托可以看作是对函数（方法）的的抽象，是函数的“类”，委托的实例代表一个（或多个）具体的函数，它可以是多播的。</p><p>　　　6.2 关于事件：事件基于委托，为委托提供了一种发布/订阅机制。事件的订阅与取消与我们刚才讲的观察者模式中的订阅与取消类似，只是表现形式有所不同。在观察者模式中，订阅使用方法Attach（）来进行；在事件的订阅中使用“+=”。类似地，取消订阅在观察者模式中用Dettach（），而事件的取消用“-=”。</p></li><li><p>下面例子分别用观察者模式，事件机制来实现</p><p>　　7.1 实例描述：客户支付了订单款项，这时财务需要开具发票，出纳需要记账，配送员需要配货。</p><p>　　7.2 观察者模式的实现</p><p>　　　　7.2.1 类图</p><p>　　　　7.2.2 代码实现</p></li></ol><p>复制代码<br>///<br>/// 抽象观察者<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 工作岗位，作为这里的观察者的抽象/// &lt;/summary&gt;public abstract class JobStation{    public abstract void Update();}/// &lt;summary&gt;/// 具体主题，这里是客户/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    private IList&lt;JobStation&gt; observers = new List&lt;JobStation&gt;();    /// &lt;summary&gt;    /// 增加观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Attach(JobStation observer)    {        this.observers.Add(observer);    }    /// &lt;summary&gt;    /// 移除观察者    /// &lt;/summary&gt;    /// &lt;param name=&quot;observer&quot;&gt;&lt;/param&gt;    public void Detach(JobStation observer)    {        this.observers.Remove(observer);    }    /// &lt;summary&gt;    /// 客户状态    /// &lt;/summary&gt;    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }    public void Notify()    {        foreach (JobStation o in observers)        {            o.Update();        }    }}/// &lt;summary&gt;/// 会计/// &lt;/summary&gt;public class Accountant : JobStation{    private string accountantState;    private Customer customer;    public Accountant(Customer customer)    {        this.customer = customer;    }    /// &lt;summary&gt;    /// 更新状态    /// &lt;/summary&gt;    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);            accountantState = &quot;已开发票&quot;;        }    }}/// &lt;summary&gt;/// 出纳/// &lt;/summary&gt;public class Cashier : JobStation{    private string cashierState;    private Customer customer;    public Cashier(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);            cashierState = &quot;已入账&quot;;        }    }}/// &lt;summary&gt;/// 配送员/// &lt;/summary&gt;public class Dilliveryman : JobStation{    private string dillivierymanState;    private Customer customer;    public Dilliveryman(Customer customer)    {        this.customer = customer;    }    public override void Update()    {        if (customer.CustomerState == &quot;已付款&quot;)        {            Console.WriteLine(&quot;我是配送员，我来发货。&quot;);            dillivierymanState = &quot;已发货&quot;;        }    }}</code></pre><p>复制代码<br>　　　　7.2.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        subject.Attach(new Accountant(subject));        subject.Attach(new Cashier(subject));        subject.Attach(new Dilliveryman(subject));        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果：</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p><p>　　7.3 事件实现</p><p>　　　　7.3.1 类图</p><p>　　　　通过类图来看，观察者和主题之间已经不存在任何依赖关系了。</p><p>　　　　7.3.2 代码实现</p><p>复制代码<br>///<br>/// 抽象主题<br>///<br>public interface ISubject<br>{<br>void Notify();<br>}</p><pre><code>/// &lt;summary&gt;/// 声明委托/// &lt;/summary&gt;public delegate void CustomerEventHandler();/// &lt;summary&gt;/// 具体主题/// &lt;/summary&gt;public class Customer : ISubject{    private string customerState;    // 声明一个委托事件，类型为 CustomerEventHandler    public event CustomerEventHandler Update;    public void Notify()    {        if (Update != null)        {            // 使用事件来通知给订阅者            Update();        }    }    public string CustomerState    {        get { return customerState; }        set { customerState = value; }    }}/// &lt;summary&gt;/// 财务，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Accountant{    private string accountantState;    public Accountant()    { }    /// &lt;summary&gt;    /// 开发票    /// &lt;/summary&gt;    public void GiveInvoice()    {        Console.WriteLine(&quot;我是会计，我来开具发票。&quot;);        accountantState = &quot;已开发票&quot;;    }}/// &lt;summary&gt;/// 出纳，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Cashier{    private string cashierState;    public void Recoded()    {        Console.WriteLine(&quot;我是出纳员，我给登记入账。&quot;);        cashierState = &quot;已入账&quot;;    }}/// &lt;summary&gt;/// 配送员，已经不需要实现抽象的观察者类，并且不用引用具体的主题/// &lt;/summary&gt;public class Dilliveryman{    private string dillivierymanState;    public void Dilliver()    {        Console.WriteLine(&quot;我是配送员，我来发货。&quot;);        dillivierymanState = &quot;已发货&quot;;    }}</code></pre><p>复制代码<br>　　　　7.3.3 客户端代码</p><p>复制代码<br>class Program<br>{<br>static void Main(string[] args)<br>{</p><pre><code>        Customer subject = new Customer();        Accountant accountant = new Accountant();        Cashier cashier = new Cashier();        Dilliveryman dilliveryman = new Dilliveryman();        // 注册事件        subject.Update += accountant.GiveInvoice;        subject.Update += cashier.Recoded;        subject.Update += dilliveryman.Dilliver;        /*         * 以上写法也可以用下面代码来替换        subject.Update += new CustomerEventHandler(accountant.GiveInvoice);        subject.Update += new CustomerEventHandler(cashier.Recoded);        subject.Update += new CustomerEventHandler(dilliveryman.Dilliver);         */        subject.CustomerState = &quot;已付款&quot;;        subject.Notify();        Console.Read();    }}</code></pre><p>复制代码<br>　　　　运行结果</p><p>　　　　我是会计，我来开具发票。<br>　　　　我是出纳员，我给登记入账。<br>　　　　我是配送员，我来发货。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2015/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2015/08/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="noopener">http://cantellow.iteye.com/blog/838473</a></p><p>第一种（懒汉，线程不安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}</p><pre><code>public static Singleton getInstance() {  if (instance == null) {      instance = new Singleton();  }  return instance;  }  </code></pre><p>}</p><p>这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。<br>第二种（懒汉，线程安全）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance;<br>private Singleton (){}<br>public static synchronized Singleton getInstance() {<br>if (instance == null) {<br>instance = new Singleton();<br>}<br>return instance;<br>}<br>}</p><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。<br>第三种（饿汉）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static Singleton instance = new Singleton();<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return instance;<br>}<br>}</p><p>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。<br>第四种（饿汉，变种）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private Singleton instance = null;<br>static {<br>instance = new Singleton();<br>}<br>private Singleton (){}<br>public static Singleton getInstance() {<br>return this.instance;<br>}<br>}</p><p>表面上看起来差别挺大，其实更第三种方式差不多，都是在类初始化即实例化instance。<br>第五种（静态内部类）：</p><p>Java代码 收藏代码<br>public class Singleton {<br>private static class SingletonHolder {<br>private static final Singleton INSTANCE = new Singleton();<br>}<br>private Singleton (){}<br>public static final Singleton getInstance() {<br>return SingletonHolder.INSTANCE;<br>}<br>}</p><p>这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。<br>第六种（枚举）：</p><p>Java代码 收藏代码<br>public enum Singleton {<br>INSTANCE;<br>public void whateverMethod() {<br>}<br>}</p><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。<br>第七种（双重校验锁）：<br>Java代码 收藏代码<br>public class Singleton {<br>private volatile static Singleton singleton;<br>private Singleton (){}<br>public static Singleton getSingleton() {<br>if (singleton == null) {<br>synchronized (Singleton.class) {<br>if (singleton == null) {<br>singleton = new Singleton();<br>}<br>}<br>}<br>return singleton;<br>}<br>}</p><p>这个是第二种方式的升级版，俗称双重检查锁定，详细介绍请查看：<a href="http://www.ibm.com/developerworks/cn/java/j-dcl.html" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-dcl.html</a><br>在JDK1.5之后，双重检查锁定才能够正常达到单例效果。</p><p>总结<br>有两个问题需要注意：<br>1.如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>2.如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。<br>对第一个问题修复的办法是：</p><p>Java代码 收藏代码<br>private static Class getClass(String classname)<br>throws ClassNotFoundException {<br>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</p><pre><code>if(classLoader == null)        classLoader = Singleton.class.getClassLoader();     return (classLoader.loadClass(classname));     </code></pre><p>}<br>}<br>对第二个问题修复的办法是：</p><p>Java代码 收藏代码<br>public class Singleton implements java.io.Serializable {<br>public static Singleton INSTANCE = new Singleton();</p><p>protected Singleton() {</p><p>}<br>private Object readResolve() {<br>return INSTANCE;<br>}<br>}</p><h1 id="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。"><a href="#对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy-loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1-5已经没有双重检查锁定的问题了。" class="headerlink" title="对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。"></a>对我来说，我比较喜欢第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时我会试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。</h1><p>superheizai同学总结的很到位：</p><p>不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java中堆内存和栈内存详解</title>
      <link href="/2015/07/29/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/"/>
      <url>/2015/07/29/Java%E4%B8%AD%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html" target="_blank" rel="noopener">http://www.cnblogs.com/whgw/archive/2011/09/29/2194997.html</a></p><p>Java把内存分成两种，一种叫做栈内存，一种叫做堆内存</p><p>在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。<br>堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。<br>引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</p><p>java中内存分配策略及堆和栈的比较</p><p>　　1 内存分配策略</p><p>　　按照编译原理的观点,程序运行时的内存分配有三种策略,分别是静态的,栈式的,和堆式的.</p><p>　　静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求.</p><p>　　栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。</p><p>　　静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放.</p><p>　　2 堆和栈的比较</p><p>　　上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈:</p><p>　　从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又主要是由于堆和栈的特点决定的:</p><p>　　在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时.</p><p>　　堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~).</p><p>　　3 JVM中的堆和栈</p><p>　　JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>　　我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的.</p><p>　　从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。</p><p>　　每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++不同，Java中分配堆内存是自动初始化的。Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。</p><p>　　Java 中的堆和栈</p><p>　　Java把内存划分成两种：一种是栈内存，一种是堆内存。</p><p>　　在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。</p><p>　　当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。</p><p>　　堆内存用来存放由new创建的对象和数组。</p><p>　　在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。</p><p>　　在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。</p><p>　　引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。</p><p>　　具体的说：</p><p>　　栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><p>　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。</p><p>　　栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p><p>　　int a = 3;</p><p>　　int b = 3;</p><p>　　编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>android数字签名</title>
      <link href="/2015/07/22/android%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
      <url>/2015/07/22/android%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
      <content type="html"><![CDATA[<p><a href="http://www.oschina.net/question/157182_45890" target="_blank" rel="noopener">http://www.oschina.net/question/157182_45890</a></p><p>Android系统中，所有安装到系统的应用程序都必有一个数字证书，此数字证书用于标识应用程序的作者和在应用程序之间建立信任关系,如果一个permission的protectionLevel为signature，那么就只有那些跟该permission所在的程序拥有同一个数字证书的应用程序才能取得该权限。Android使用Java的数字证书相关的机制来给apk加盖数字证书，要理解android的数字证书，需要先了解以下数字证书的概念和java的数字证书机制。Android系统要求每一个安装进系统的应用程序都是经过数字证书签名的，数字证书的私钥则保存在程序开发者的手中。Android将数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，不是用来决定最终用户可以安装哪些应用程序。这个数字证书并不需要权威的数字证书签名机构认证，它只是用来让应用程序包自我认证的。<br>同一个开发者的多个程序尽可能使用同一个数字证书，这可以带来以下好处。</p><p>(1)有利于程序升级，当新版程序和旧版程序的数字证书相同时，Android系统才会认为这两个程序是同一个程序的不同版本。如果新版程序和旧版程序的数字证书不相同，则Android系统认为他们是不同的程序，并产生冲突，会要求新程序更改包名。</p><p>(2)有利于程序的模块化设计和开发。Android系统允许拥有同一个数字签名的程序运行在一个进程中，Android程序会将他们视为同一个程序。所以开发者可以将自己的程序分模块开发，而用户只需要在需要的时候下载适当的模块。</p><p>(3)可以通过权限(permission)的方式在多个程序间共享数据和代码。Android提供了基于数字证书的权限赋予机制，应用程序可以和其他的程序共享概功能或者数据给那那些与自己拥有相同数字证书的程序。如果某个权限(permission)的protectionLevel是signature，则这个权限就只能授予那些跟该权限所在的包拥有同一个数字证书的程序。</p><p>在签名时，需要考虑数字证书的有效期：</p><p>(1)数字证书的有效期要包含程序的预计生命周期，一旦数字证书失效，持有改数字证书的程序将不能正常升级。</p><p>(2)如果多个程序使用同一个数字证书，则该数字证书的有效期要包含所有程序的预计生命周期。</p><p>(3)Android Market强制要求所有应用程序数字证书的有效期要持续到2033年10月22日以后。</p><p>Android数字证书包含以下几个要点：</p><pre><code>(1)所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序(2)Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证(3)如果要正式发布一个Android ，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。(4)数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。(5)Android使用标准的java工具 Keytool and Jarsigner 来生成数字证书，并给应用程序包签名。（6）使用zipalign优化程序。</code></pre><p>Android系统不会安装运行任何一款未经数字签名的apk程序，无论是在模拟器上还是在实际的物理设备上。Android的开发工具(ADT插件和Ant)都可以协助开发者给apk程序签名，它们都有两种模式：调试模式(debug mode)和发布模式(release mode)。</p><p>在调试模式下，android的开发工具会在每次编译时使用调试用的数字证书给程序签名，开发者无须关心。</p><p>当要发布程序时，开发者就需要使用自己的数字证书给apk包签名，可以有两种方法。</p><p>(1)在命令行下使用JDK中的和Keytool(用于生成数字证书)和Jarsigner(用于使用数字证书签名)来给apk包签名。</p><p>(2)使用ADT Export Wizard进行签名(如果没有数字证书可能需要生成数字证书)。</p><p>使用Keytool和Jarsigner给程序签名</p><p>命令：keytool -genkey -v -keystore android.keystore -alias android -keyalg RSA -validity 20000</p><p>该命令中，-keystore ophone.keystore 表示生成的证书，可以加上路径（默认在用户主目录下）；-alias ophone 表示证书的别名是ophone；-keyalg RSA 表示采用的RSA算法；-validity 20000表示证书的有效期是20000天。</p><p>image</p><p>此时，我们会在互用主目录下看到ophone.keystore，即我们刚刚创建的证书。</p><p>接着对程序进行签名：</p><p>jarsigner用法： [选项] jar 文件别名<br>jarsigner -verify [选项] jar 文件</p><p>执行：jarsigner -verbose -keystore android.keystore -signedjar android123_signed.apk android123.apk android 就可以生成签名的apk文件，这里输入文件android123.apk，最终生成android123_signed.apk为Android签名后的APK执行文件。下面提示输入的密码和keytool输入的一样就行了。（不过在我的JDK目录下没有找到jarsigner这个程序，不知道是怎么回事）</p><p>image</p><p>使用ADT Export Wizard进行签名</p><p>应用程序（apk）签名,在EC中，右键单击应用程序工程，如图选择</p><p>image</p><p>选择证书的存放路径，填写相关资料，完成，即可生成被签名的apk文件。如下图所示：</p><p>image</p><p>如上图所示，我们可以看到也可以在这里选择”Create new keystore“来创建一个证书。输入密码，点击下一步，填写相关信息，如下图所示。</p><p>image</p><p>使用zipalign优化APK</p><p>根据官方文档的描述，Android系统中Application的数据都保存在它的APK文件中，同时可以被多个进程访问，安装的过程包括如下几个步骤：</p><p>Installer通过每个apk的manifest文件获取与当前应用程序相关联的permissions信息<br>Home application读取当前APK的Name和Icon等信息。<br>System server将读取一些与Application运行相关信息，例如：获取和处理Application的notifications请求等。<br>最后，APK所包含的内容不仅限于当前Application所使用，而且可以被其它的Application调用，提高系统资源的可复用性。</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>android的task任务栈</title>
      <link href="/2015/07/22/android%E7%9A%84task%E4%BB%BB%E5%8A%A1%E6%A0%88/"/>
      <url>/2015/07/22/android%E7%9A%84task%E4%BB%BB%E5%8A%A1%E6%A0%88/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/CSU-PL/p/3794280.html" target="_blank" rel="noopener">http://www.cnblogs.com/CSU-PL/p/3794280.html</a></p><p>上次我们讲到Activity的四种启动模式的时候，已经了解到一些关于task的技术，今天我再向大家介绍一下。task是一个具有栈结构的容器，可以放置多个Activity实例。启动一个应用，系统就会为之创建一个task，来放置根Activity；默认情况下，一个Activity启动另一个Activity时，两个Activity是放置在同一个task中的，后者被压入前者所在的task栈，当用户按下后退键，后者从task被弹出，前者又显示在幕前，特别是启动其他应用中的Activity时，两个Activity对用户来说就好像是属于同一个应用；系统task和task之间是互相独立的，当我们运行一个应用时，按下Home键回到主屏，启动另一个应用，这个过程中，之前的task被转移到后台，新的task被转移到前台，其根Activity也会显示到幕前，过了一会之后，在此按下Home键回到主屏，再选择之前的应用，之前的task会被转移到前台，系统仍然保留着task内的所有Activity实例，而那个新的task会被转移到后台，如果这时用户再做后退等动作，就是针对该task内部进行操作了。</p><p>我们今天就讲一下和task相关的知识，主要分一下几点：</p><p>1.Activity的affinity(亲和力)</p><p>2.Intent几种常见的flags</p><p>3.与task相关属性</p><p>affinity：</p><p>task对于Activity来说就好像它的身份证一样，可以告诉所在的task，自己属于这个task中的一员；拥有相同affinity的多个Activity理论同属于一个task，task自身的affinity决定于根Activity的affinity值。affinity在什么场合应用呢？1.根据affinity重新为Activity选择宿主task（与allowTaskReparenting属性配合工作）；2.启动一个Activity过程中Intent使用了FLAG_ACTIVITY_NEW_TASK标记，根据affinity查找或创建一个新的具有对应affinity的task。我们会在后面进行详细讲解。</p><p>默认情况下，一个应用内的所有Activity都具有相同的affinity，都是从Application（参考的taskAffinity属性）继承而来，而Application默认的affinity是中的包名，我们可以为设置taskAffinity属性值，这样可以应用到下的所有，也可以单独为某个Activity设置taskAffinity。例如：在系统自带的Browser中，package为com.android.browser，但是却自定义一个taskAffinity属性值：</p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 开发如何做内存优化</title>
      <link href="/2015/07/22/Android-%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
      <url>/2015/07/22/Android-%E5%BC%80%E5%8F%91%E5%A6%82%E4%BD%95%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>   不少人认为JAVA程序，因为有垃圾回收机制，应该没有内存泄露。其实如果我们一个程序中，已经不再使用某个对象，但是因为仍然有引用指向它，垃圾回收器就无法回收它，当然该对象占用的内存就无法被使用，这就造成了内存泄露。如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。  </p><p>   Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。  </p><h1 id="引用没释放造成的内存泄露"><a href="#引用没释放造成的内存泄露" class="headerlink" title="引用没释放造成的内存泄露"></a>引用没释放造成的内存泄露</h1><h2 id="注册没取消造成的内存泄露"><a href="#注册没取消造成的内存泄露" class="headerlink" title="注册没取消造成的内存泄露"></a>注册没取消造成的内存泄露</h2><p>　　这种Android的内存泄露比纯java的内存泄露还要严重，因为其他一些Android程序可能引用我们的Anroid程序的对象（比如注册机制）。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄露的内存依然不能被垃圾回收。<br>比如示例1:<br>　　假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。<br>　　但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。<br>　　虽然有些系统程序，它本身好像是可以自动取消注册的（当然不及时），但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。  </p><h2 id="集合中对象没清理造成的内存泄露"><a href="#集合中对象没清理造成的内存泄露" class="headerlink" title="集合中对象没清理造成的内存泄露"></a>集合中对象没清理造成的内存泄露</h2><p>　　我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。  </p><h1 id="资源对象没关闭造成的内存泄露"><a href="#资源对象没关闭造成的内存泄露" class="headerlink" title="资源对象没关闭造成的内存泄露"></a>资源对象没关闭造成的内存泄露</h1><p>　　资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。因为有些资源性对象，比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭），如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。<br>　　程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。  </p><h1 id="一些不良代码成内存压力"><a href="#一些不良代码成内存压力" class="headerlink" title="一些不良代码成内存压力"></a>一些不良代码成内存压力</h1><p>　　有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存，对内存的回收和分配造成很大影响的，容易迫使虚拟机不得不给该应用进程分配更多的内存，造成不必要的内存开支。  </p><h2 id="Bitmap没调用recycle"><a href="#Bitmap没调用recycle" class="headerlink" title="Bitmap没调用recycle()"></a>Bitmap没调用recycle()</h2><p>　　Bitmap对象在不使用时,我们应该先调用recycle()释放内存，然后才它设置为null.虽然recycle()从源码上看，调用它应该能立即释放Bitmap的主要内存，但是测试结果显示它并没能立即释放内存。但是我它应该还是能大大的加速Bitmap的主要内存的释放。  </p><h2 id="构造Adapter时，没有使用缓存的-convertView"><a href="#构造Adapter时，没有使用缓存的-convertView" class="headerlink" title="构造Adapter时，没有使用缓存的 convertView"></a>构造Adapter时，没有使用缓存的 convertView</h2><p>　　以构造ListView的BaseAdapter为例，在BaseAdapter中提共了方法：<br>public View getView(int position, View convertView, ViewGroup parent)来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>　　由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费时间，也造成内存垃圾，给垃圾回收增加压力，如果垃圾回收来不及的话，虚拟机将不得不给该应用进程分配更多的内存，造成不必要的内存开支。ListView回收list item的view对象的过程可以查看:<br>view plaincopy to clipboardprint?<br>android.widget.AbsListView.java –&gt; void addScrapView(View scrap) 方法。</p><p>示例代码：</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = new Xxx(…);<br>4<br>5 … …<br>6<br>7 return view;<br>8<br>9 }<br>复制代码<br>修正示例代码：</p><p>Android内存管理</p><p>复制代码<br>1 public View getView(int position, View convertView, ViewGroup parent) {<br>2<br>3 View view = null;<br>4<br>5 if (convertView != null) {<br>6<br>7 view = convertView;<br>8<br>9 populate(view, getItem(position));<br>10<br>11 …<br>12<br>13 } else {<br>14<br>15 view = new Xxx(…);<br>16<br>17 …<br>18<br>19 }<br>20<br>21 return view;<br>22<br>23 }<br>复制代码<br>概述：<br>　　在android的开发中，要时刻主要内存的分配和垃圾回收，因为系统为每一个dalvik虚拟机分配的内存是有限的，在google的G1中，分配的最大堆大小只有16M，后来的机器一般都为24M，实在是少的可怜。这样就需要我们在开发过程中要时刻注意。不要因为自己的代码问题而造成OOM错误。<br>JAVA的内存管理：<br>　　大家都知道，android应用层是由java开发的，android的davlik虚拟机与jvm也类似，只不过它是基于寄存器的。因此要了解android的内存管理就必须得了解java的内存分配和垃圾回收机制。<br>　　在java中，是通过new关键字来为对象分配内存的，而内存的释放是由垃圾收集器（GC）来回收的，工程师在开发的过程中，不需要显式的去管理内存。但是这样有可能在不知不觉中就会浪费了很多内存，最终导致java虚拟机花费很多时间去进行垃圾回收，更严重的是造成JVM的OOM。因此，java工程师还是有必要了解JAVA的内存分配和垃圾回收机制。</p><p>内存结构<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6926.png<br>上面这张图是JVM的结构图，它主要四个部分组成：Class Loader子系统和执行引擎，运行时方法区和本地方法区，我们主要来看下RUNTIME DATA AREA区，也就是我们常说的JVM内存。从图中可以看出，RUNTIMEDATA AREA区主要由5个部分组成：<br>· Method Area:被装载的class的元信息存储在Method Area中，它是线程共享的<br>· Heap(堆)：一个java虚拟机实例中只存在一个堆空间，存放一些对象信息，它是线程共享的<br>· Java栈： java虚拟机直接对java栈进行两种操作，以帧为单位的压栈和出栈（非线程共享）<br>· 程序计数器（非线程共享）<br>· 本地方法栈（非线程共享）</p><p>JVM的垃圾回收（GC）<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-12485.png<br>JVM的垃圾原理是这样的，它把对象分为年轻代（Young）、年老代（Tenured）、持久代（Perm），对不同生命周期的对象使用不同的垃圾回收算法。<br>· 年轻代(Young)<br>年轻代分为三个区，一个eden区，两个Survivor区。程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当此Survivor区的对象占用空间满了时，此区存活的对象又被复制到另外一个Survivor区，当这个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到年老代。<br>· 年老代（Tenured）<br>年老代存放的是上面年轻代复制过来的对象，也就是在年轻代中还存活的对象，并且区满了复制过来的。一般来说，年老代中的对象生命周期都比较长。<br>· 持久代（Perm）<br>用于存放静态的类和方法，持久代对垃圾回收没有显著的影响。<br>Android中内存泄露监测<br>在了解了JVM的内存管理后，我们再回过头来看看，在android中应该怎样来监测内存，从而看在应用中是否存在内存分配和垃圾回收问题而造成内存泄露情况。<br>在android中，有一个相对来说还不错的工具，可以用来监测内存是否存在泄露情况：DDMS—Heap<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-22715.png<br>使用方法比较简单：<br>· 选择DDMS视图，并打开Devices视图和Heap视图<br>· 点击选择要监控的进程，比如：上图中我选择的是system_process<br>· 选中Devices视图界面上的”update heap” 图标<br>· 点击Heap视图中的”Cause GC” 按钮（相当于向虚拟机发送了一次GC请求的操作）<br>在Heap视图中选择想要监控的Type，一般我们会观察dataobject的 total size的变化，正常情况下total size的值会稳定在一个有限的范围内，也就说程序中的代码良好，没有造成程序中的对象不被回收的情况。如果代码中存在没有释放对象引用的情况，那么data object的total size在每次GC之后都不会有明显的回落，随着操作次数的增加而total size也在不断的增加。（说明：选择好data object后，不断的操作应用，这样才可以看出total size的变化）。如果totalsize确实是在不断增加而没有回落，说明程序中有没有被释放的资源引用。那么我们应该怎么来定位呢？<br>Android中内存泄露定位<br>Mat(memory analyzer tools)是我们常用的用来定位内存泄露的工具，如果你使用ADT，并且安装了MAT的eclipse插件，你需要做的是进入DDMS视图的Devices视图：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-2165.png<br>点击”dump HPROF file”按钮，然后使用MAT分析下载下来的文件。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6565.png</p><p>下面列出了存在的问题，点击detail进去，会列出详细的，可能会存在问题的代码：<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-32625.png<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-21158.png<br>关于MAT的使用可以参考：<a href="http://www.blogjava.net/rosen/" target="_blank" rel="noopener">http://www.blogjava.net/rosen/</a> … .html<br>这位兄弟写的比较详细。</p><p>总结</p><p>不管是java还是android，都应该了解内存分配和垃圾回收机制，工程师要做到写的代码中没有bad code很难，关键是在出现问题的时候该怎么去排查Android内存优化<br>一、 Android的内存机制<br>　　Android的程序由Java语言编写，所以Android的内存管理与Java的内存管理相似。程序员通过new为对象分配内存，所有对象在java堆内分配空间；然而对象的释放是由垃圾回收器来完成的。C／C++中的内存机制是“谁污染，谁治理”，java的就比较人性化了，给我们请了一个专门的清洁工（GC）。<br>　　那么GC怎么能够确认某一个对象是不是已经被废弃了呢？Java采用了有向图的原理。Java将引用关系考虑为图的有向边，有向边从引用者指向引用对象。线程对象可以作为有向图的起始顶点，该图就是从起始顶点开始的一棵树，根顶点可以到达的对象都是有效对象，GC不会回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被GC回收。<br>二、Android的内存溢出<br>Android的内存溢出是如何发生的?<br>　　Android的虚拟机是基于寄存器的Dalvik，它的最大堆大小一般是16M，有的机器为24M。因此我们所能利用的内存空间是有限的。如果我们的内存占用超过了一定的水平就会出现OutOfMemory的错误。<br>为什么会出现内存不够用的情况呢？我想原因主要有两个：</p><p>由于我们程序的失误，长期保持某些资源（如Context）的引用，造成内存泄露，资源造成得不到释放。</p><p>保存了多个耗用内存过大的对象（如Bitmap），造成内存超出限制。</p><p>三、万恶的static<br>　　static是Java中的一个关键字，当用它来修饰成员变量时，那么该变量就属于该类，而不是该类的实例。所以用static修饰的变量，它的生命周期是很长的，如果用它来引用一些资源耗费过多的实例（Context的情况最多），这时就要谨慎对待了。</p><p>复制代码<br>1 public class ClassName {<br>2<br>3 private static Context mContext;<br>4<br>5 //省略<br>6<br>7 }<br>复制代码<br>　　以上的代码是很危险的，如果将Activity赋值到么mContext的话。那么即使该Activity已经onDestroy，但是由于仍有对象保存它的引用，因此该Activity依然不会被释放。<br>我们举Android文档中的一个例子。</p><p>复制代码<br>private static Drawable sBackground;</p><p>@Override</p><p>protected void onCreate(Bundle state) {</p><p>super.onCreate(state);</p><p>TextView label = new TextView(this);</p><p>label.setText(“Leaks are bad”);</p><p>if (sBackground == null) {</p><pre><code>sBackground = getDrawable(R.drawable.large_bitmap);  </code></pre><p>}</p><p>label.setBackgroundDrawable(sBackground);</p><p>setContentView(label);</p><p>}<br>复制代码<br>　　sBackground是一个静态的变量，但是我们发现，我们并没有显式的保存Contex的引用，但是，当Drawable与View连接之后，Drawable就将View设置为一个回调，由于View中是包含Context的引用的，所以，实际上我们依然保存了Context的引用。这个引用链如下：<br>Drawable-&gt;TextView-&gt;Context<br>　　所以，最终该Context也没有得到释放，发生了内存泄露。<br>如何才能有效的避免这种引用的发生呢？</p><p>应该尽量避免static成员变量引用资源耗费过多的实例，比如Context。</p><p>Context尽量使用Application Context，因为Application的Context的生命周期比较长，引用它不会出现内存泄露的问题。</p><p>使用WeakReference代替强引用。比如可以使用WeakReference mContextRef;</p><p>该部分的详细内容也可以参考Android文档中Article部分。<br>四、都是线程惹的祸<br>　　线程也是造成内存泄露的一个重要的源头。线程产生内存泄露的主要原因在于线程生命周期的不可控。我们来考虑下面一段代码。</p><p>复制代码<br>1 public class MyActivity extends Activity {<br>2<br>3 @Override<br>4<br>5 public void onCreate(Bundle savedInstanceState) {<br>6<br>7 super.onCreate(savedInstanceState);<br>8<br>9 setContentView(R.layout.main);<br>10<br>11 new MyThread().start();<br>12<br>13 }<br>14<br>15<br>16 private class MyThread extends Thread{<br>17<br>18 @Override<br>19<br>20 public void run() {<br>21<br>22 super.run();<br>23<br>24 //do somthing<br>25<br>26 }<br>27<br>28 }<br>29<br>30 }<br>复制代码<br>　　这段代码很平常也很简单，是我们经常使用的形式。我们思考一个问题：假设MyThread的run函数是一个很费时的操作，当我们开启该线程后，将设备的横屏变为了竖屏，一般情况下当屏幕转换时会重新创建Activity，按照我们的想法，老的Activity应该会被销毁才对，然而事实上并非如此。<br>　　由于我们的线程是Activity的内部类，所以MyThread中保存了Activity的一个引用，当MyThread的run函数没有结束时，MyThread是不会被销毁的，因此它所引用的老的Activity也不会被销毁，因此就出现了内存泄露的问题。<br>file:///C:/DOCUME~1/ADMINI~1/LOCALS~1/Temp/ksohtml/wps_clip_image-6439.png<br>　　有些人喜欢用Android提供的AsyncTask，但事实上AsyncTask的问题更加严重，Thread只有在run函数不结束时才出现这种内存泄露问题，然而AsyncTask内部的实现机制是运用了ThreadPoolExcutor,该类产生的Thread对象的生命周期是不确定的，是应用程序无法控制的，因此如果AsyncTask作为Activity的内部类，就更容易出现内存泄露的问题。<br>这种线程导致的内存泄露问题应该如何解决呢？</p><p>将线程的内部类，改为静态内部类。</p><p>在线程内部采用弱引用保存Context引用。</p><p>解决的模型如下：</p><p>复制代码<br>1 public abstract class WeakAsyncTask</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/kingOfPointer/archive/2012/12/21/2828018.html" target="_blank" rel="noopener">android 开发如何做内存优化</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android 内存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux脚本编写基础</title>
      <link href="/2015/06/29/Linux%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/"/>
      <url>/2015/06/29/Linux%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>本文主要介绍shell脚本编写的基础语法，开头、注释、变量和 环境变量，虽然不涉及具体东西，但打好基础确是最为关键的。<br>本文是一篇在学习中的文章，还没学习完，排版也还有一些问题，待继续</p><h1 id="shell脚本编写初步介绍"><a href="#shell脚本编写初步介绍" class="headerlink" title="shell脚本编写初步介绍"></a>shell脚本编写初步介绍</h1><p>##开头程序必须以下面的行开始（必须方在文件的第一行）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure></p><p>符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。<br>当编辑好脚本时，如果要执行该脚本，还必须使其可执行。<br>要使脚本可执行：<br>编译 chmod +x filename 这样才能用./filename 来运行  </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>　　以#开头的句子表示注释，直到这一行的结束。  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>　　在其他编程语言中您必须使用变量。在shell编程中，所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量，您可以这样写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#对变量赋值：</span></span><br><span class="line">a=<span class="string">"hello world"</span> 首先输入的应该是包含减号的参数.</span><br><span class="line"><span class="comment"># 现在打印变量a的内容： </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"A is:"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$a</span></span><br></pre></td></tr></table></figure></p><p>有时候变量名很容易与其他文字混淆，比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=2</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"this is the <span class="variable">$numnd</span>"</span></span><br></pre></td></tr></table></figure></p><p>这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：</p><p>num=2<br>echo “this is the {num}nd”</p><p>这将打印： this is the 2nd</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。</p><h2 id="Shell命令和流程控制"><a href="#Shell命令和流程控制" class="headerlink" title="Shell命令和流程控制"></a>Shell命令和流程控制</h2><p>在shell脚本中可以使用三类命令：     </p><h3 id="1-Unix-命令"><a href="#1-Unix-命令" class="headerlink" title="1)Unix 命令:"></a>1)Unix 命令:</h3><p>　　虽然在shell脚本中可以使用任意的unix命令，但是还是由一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。<br>常用命令语法及功能<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="built_in">echo</span> “some text”: 将文字内容打印在屏幕上     </span><br><span class="line">　　ls: 文件列表     </span><br><span class="line">　　wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数     </span><br><span class="line">　　cp sourcefile destfile: 文件拷贝     </span><br><span class="line">　　mv oldname newname : 重命名文件或移动文件     </span><br><span class="line">　　rm file: 删除文件     </span><br><span class="line">　　grep ‘pattern’ file: 在文件内搜索字符串比如：grep ‘searchstring’ file.txt     </span><br><span class="line">　　cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆,这是两个完全不同的命令     </span><br><span class="line">　　cat file.txt: 输出文件内容到标准输出设备（屏幕）上     </span><br><span class="line">　　file somefile: 得到文件类型     </span><br><span class="line">　　<span class="built_in">read</span> var: 提示用户输入，并将输入赋值给变量     </span><br><span class="line">　　sort file.txt: 对file.txt文件中的行进行排序     </span><br><span class="line">　　uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq     </span><br><span class="line">　　expr: 进行数学运算Example: add 2 and 3expr 2 “+” 3     </span><br><span class="line">　　find: 搜索文件比如：根据文件名搜索find . -name filename -<span class="built_in">print</span>     </span><br><span class="line">　　tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile     </span><br><span class="line">　　basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux     </span><br><span class="line">　　dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin     </span><br><span class="line">　　head file: 打印文本文件开头几行     </span><br><span class="line">　　tail file : 打印文本文件末尾几行     </span><br><span class="line">　　sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为LinuxFocus ：cat text.file | sed ‘s/linuxfocus/LinuxFocus/’ &gt; newtext.file     </span><br><span class="line">　　awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk -F, <span class="string">'&#123;print $1 "," $3 &#125;'</span></span><br></pre></td></tr></table></figure><p>这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA</p><h3 id="2-概念-管道-重定向和-backtick-这些不是系统命令，但是他们真的很重要。"><a href="#2-概念-管道-重定向和-backtick-这些不是系统命令，但是他们真的很重要。" class="headerlink" title="2) 概念: 管道, 重定向和 backtick 这些不是系统命令，但是他们真的很重要。"></a>2) 概念: 管道, 重定向和 backtick 这些不是系统命令，但是他们真的很重要。</h3><p>　　管道 (|) 将一个命令的输出作为另外一个命令的输入。<br>grep “hello” file.txt | wc -l<br>　　在file.txt中搜索包含有”hello”的行并计算其行数。<br>　　在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。<br>　　重定向：将命令的结果输出到文件，而不是标准输出（屏幕）。<br>　　> 写入文件并覆盖旧文件<br>　　&gt;> 加到文件的尾部，保留旧文件内容。<br>反短斜线<br>　 使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。<br>命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure><p>　　用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># The ticks are backticks (`) not normal quotes ('):</span></span><br><span class="line">tar -zcvf lastmod.tar.gz `find . -mtime -1 -<span class="built_in">type</span> f -<span class="built_in">print</span>`</span><br></pre></td></tr></table></figure><h3 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3) 流程控制"></a>3) 流程控制</h3><ol><li>if<br>　　“if” 表达式 如果条件为真则执行then后面的部分：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ….; <span class="keyword">then</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">elif</span> ….; <span class="keyword">then</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等…<br>　　通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。<br>[ -f “somefile” ] ：判断是否是一个文件<br>[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限<br>[ -n “var”]：判断var” ] ：判断var变量是否有值<br>[ “a”=”a” = “b” ] ：判断a和a和b是否相等<br>　　执行man test可以查看所有测试表达式可以比较和判断的类型。<br>　　直接执行以下脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$SHELL</span>"</span> = <span class="string">"/bin/bash"</span> ]; <span class="keyword">then</span></span><br><span class="line">　<span class="built_in">echo</span> <span class="string">"your login shell is the bash (bourne again shell)"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">　<span class="built_in">echo</span> <span class="string">"your login shell is not bash but <span class="variable">$SHELL</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">变量<span class="variable">$SHELL</span>包含了登录shell的名称，我们和/bin/bash进行了比较。  </span><br><span class="line">快捷操作符  </span><br><span class="line">熟悉C语言的朋友可能会很喜欢下面的表达式：  </span><br><span class="line">\[ -f “/etc/shadow” \] &amp;&amp; <span class="built_in">echo</span> “This computer uses shadow passwors”  </span><br><span class="line">　　这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mailfolder=/var/spool/mail/james</span><br><span class="line">[ -r <span class="string">"<span class="variable">$mailfolder</span>"</span> ]<span class="string">' '</span>&#123; <span class="built_in">echo</span> <span class="string">"Can not read <span class="variable">$mailfolder</span>"</span> ; <span class="built_in">exit</span> 1; &#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$mailfolder</span> has mail from:"</span></span><br><span class="line">grep <span class="string">"^From "</span> <span class="variable">$mailfolder</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：  </span><br><span class="line">　　-打印错误信息  </span><br><span class="line">　　-退出程序  </span><br><span class="line">　　我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。  </span><br><span class="line">　　不用与和或操作符，我们也可以用<span class="keyword">if</span>表达式作任何事情，但是使用与或操作符会更便利很多。</span><br><span class="line"></span><br><span class="line">2. <span class="keyword">case</span>  </span><br><span class="line"><span class="keyword">case</span> :表达式可以用来匹配一个给定的字符串，而不是数字。 </span><br><span class="line"></span><br><span class="line">``` bash </span><br><span class="line"><span class="keyword">case</span> … <span class="keyword">in</span>  </span><br><span class="line">…) <span class="keyword">do</span> something here ;;  </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>　　让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file lf.gz</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">　　这将返回：  </span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">lf.gz: gzip compressed data, deflated, original filename, last modified: Mon Aug 27 23:09:18 2001, os: Unix</span><br></pre></td></tr></table></figure><p>　我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">ftype=`file <span class="string">"<span class="variable">$1</span>"</span>`</span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$ftype</span>"</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">"<span class="variable">$1</span>: Zip archive"</span>*)</span><br><span class="line">　　unzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: gzip compressed"</span>*)</span><br><span class="line">　　gunzip <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line"><span class="string">"<span class="variable">$1</span>: bzip2 compressed"</span>*)</span><br><span class="line">　　bunzip2 <span class="string">"<span class="variable">$1</span>"</span> ;;</span><br><span class="line">*) <span class="built_in">echo</span> <span class="string">"File <span class="variable">$1</span> can not be uncompressed with smartzip"</span>;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>　　您可能注意到我们在这里使用了一个特殊的变量1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：smartziparticles.zip1。该变量包含了传递给该程序的第一个参数值。 也就是说，当我们运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartzip articles.zip</span><br></pre></td></tr></table></figure></p><p> $1 就是字符串 articles.zip </p><ol start="3"><li>selsect<br>select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select var <span class="keyword">in</span> … ; <span class="keyword">do</span>  </span><br><span class="line">　<span class="built_in">break</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><p>…. now $var can be used ….<br>下面是一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"What is your favourite OS?"</span></span><br><span class="line">select var <span class="keyword">in</span> <span class="string">"Linux"</span> <span class="string">"Gnu Hurd"</span> <span class="string">"Free BSD"</span> <span class="string">"Other"</span>; <span class="keyword">do</span></span><br><span class="line">　　　　<span class="built_in">break</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"You have selected <span class="variable">$var</span>"</span></span><br></pre></td></tr></table></figure></p><p>　　下面是该脚本运行的结果：<br>What is your favourite OS?<br>1) Linux<br>2) Gnu Hurd<br>3) Free BSD<br>4) Other</p><p>? 1</p><p>You have selected Linux </p><ol start="4"><li>loop<br>loop表达式： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> …; <span class="keyword">do</span>  </span><br><span class="line">….  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><p>　　while-loop 将运行直到表达式测试为真。will run while the expression that we test for is true.<br>关键字”break” 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。<br>　　<br>for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> ….; <span class="keyword">do</span>  </span><br><span class="line">　 ….  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>在下面的例子中，将分别打印ABC到屏幕上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> A B C ; <span class="keyword">do</span></span><br><span class="line">　 <span class="built_in">echo</span> <span class="string">"var is <span class="variable">$var</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># list a content summary of a number of RPM packages</span></span><br><span class="line"><span class="comment"># USAGE: showrpm rpmfile1 rpmfile2 ...</span></span><br><span class="line"><span class="comment"># EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpm</span></span><br><span class="line"><span class="keyword">for</span> rpmpackage <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line">　<span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$rpmpackage</span>"</span> ];<span class="keyword">then</span></span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">"=============== <span class="variable">$rpmpackage</span> =============="</span></span><br><span class="line">　　rpm -qi -p <span class="variable">$rpmpackage</span></span><br><span class="line">　<span class="keyword">else</span></span><br><span class="line">　　<span class="built_in">echo</span> <span class="string">"ERROR: cannot read file <span class="variable">$rpmpackage</span>"</span></span><br><span class="line">　<span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><p>这里出现了第二个特殊的变量$*，该变量包含了所有输入的命令行参数值。<br>如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm<br>此时 $* 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm.</p><ol start="5"><li><p>引号<br>在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符比如(*）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。<br>1.编译SHELL脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch<span class="comment">#!/bin/sh mod +x filename</span></span><br></pre></td></tr></table></figure><p>./filename 来执行您的脚本。<br>　　这将打印出”mail.jpg tux.jpg”的结果。<br>　  引号 (单引号和双引号) 将防止这种通配符扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"*.jpg"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'*.jpg'</span></span><br><span class="line">``` </span><br><span class="line">　　这将打印”\*.jpg” 两次。  </span><br><span class="line">　　单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。</span><br><span class="line">``` bash</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SHELL</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$SHELL'</span></span><br></pre></td></tr></table></figure></li></ol><p>运行结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash</span><br><span class="line">/bin/bash</span><br><span class="line"><span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></p><p>　　最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> *.jpg  </span><br><span class="line"><span class="built_in">echo</span> SHELL</span><br></pre></td></tr></table></figure></p><p>这将输出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∗.jpg SHELL</span><br></pre></td></tr></table></figure></p><ol start="6"><li>Here documents<br>当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents就不必用echo函数一行行输出。 一个 “Here document” 以 &lt;&lt; 开头，后面接上一个字符串，这个字符串还必须出现在here document的末尾。下面是一个例子，在该例子中，我们对多个文件进行重命名，并且使用here documents打印帮助：<pre><code class="bash"><span class="meta">#!/bin/sh</span><span class="comment"># we have less than 3 arguments. Print the help text:</span><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 3 ] ; <span class="keyword">then</span>cat &lt;<span class="comment">#ren -- renames a number of files using sed regular expressions</span>USAGE: ren <span class="string">'regexp'</span> <span class="string">'replacement'</span> files...EXAMPLE: rename all *.HTM files <span class="keyword">in</span> *.html:　ren <span class="string">'HTM$'</span> <span class="string">'html'</span> *.HTMHELP　<span class="built_in">exit</span> 0<span class="keyword">fi</span>OLD=<span class="string">"<span class="variable">$1</span>"</span>NEW=<span class="string">"<span class="variable">$2</span>"</span><span class="comment"># The shift command removes one argument from the list of</span><span class="comment"># command line arguments.</span><span class="built_in">shift</span><span class="built_in">shift</span><span class="comment"># $* contains now all the files:</span><span class="keyword">for</span> file <span class="keyword">in</span> $*; <span class="keyword">do</span>　　<span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$file</span>"</span> ] ; <span class="keyword">then</span>　　newfile=`<span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span> | sed <span class="string">"s/<span class="variable">${OLD}</span>/<span class="variable">${NEW}</span>/g"</span>`　　　<span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$newfile</span>"</span> ]; <span class="keyword">then</span>　　　　<span class="built_in">echo</span> <span class="string">"ERROR: <span class="variable">$newfile</span> exists already"</span>　　　<span class="keyword">else</span>　　　　<span class="built_in">echo</span> <span class="string">"renaming <span class="variable">$file</span> to <span class="variable">$newfile</span> ..."</span>　　　　mv <span class="string">"<span class="variable">$file</span>"</span> <span class="string">"<span class="variable">$newfile</span>"</span>　　　<span class="keyword">fi</span>　　<span class="keyword">fi</span><span class="keyword">done</span></code></pre>　这是一个复杂一些的例子。让我们详细讨论一下。第一个if表达式判断输入命令行参数是否小于3个 (特殊变量# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参数列表# 表示包含参数的个数) 。如果输入参数小于3个，则将帮助文字传递 给cat命令，然后由cat命令将其打印在屏幕上。打印帮助文字后程序退出。 如果输入参数等 于或大于3个，我们就将第一个参数赋值给变量OLD，第二个参数赋值给变量NEW。下一步，我 们使用shift命令将第一个和第二个参数从 参数列表中删除，这样原来的第三个参数就成为参 数列表*的第一个参数。然后我们开始循环，命令行参数列表被一个接一个地被赋值给变量$file。  接着我 们判断该文件是否存在，如果存在则通过sed命令搜索和替换来产生新的文件名。然后  将反短斜线内命令结果赋值给newfile。这样我们就达到了我们的目 的：得到了旧文件名和新  文件名。然后使用mv命令进行重命名。</li></ol><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4)函数"></a>4)函数</h3><p>如果您写了一些稍微复杂一些的程序，您就会发现在程序中可能在几个地方使用了相同的代码，<br>并且您也会发现，如果我们使用了函数，会方便很多。一个函数是这个样子的：<br>functionname()<br>{</p><h1 id="inside-the-body-1-is-the-first-argument-given-to-the-function"><a href="#inside-the-body-1-is-the-first-argument-given-to-the-function" class="headerlink" title="inside the body $1 is the first argument given to the function"></a>inside the body $1 is the first argument given to the function</h1><h1 id="2-the-second-…"><a href="#2-the-second-…" class="headerlink" title="$2 the second …"></a>$2 the second …</h1><p>body<br>}<br>您需要在每个程序的开始对函数进行声明。<br>　　下面是一个叫做xtitlebar的脚本，使用这个脚本您可以改变终端窗口的名称。<br>这里使用了一个叫做help的函数。正如您可以看到的那样，这个定义的函数被使用了两次。</p><h1 id="bin-sh"><a href="#bin-sh" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et"><a href="#vim-set-sw-4-ts-4-et" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　　cat &lt;<br>xtitlebar – change the name of an xterm, gnome-terminal or kde konsole<br>USAGE: xtitlebar [-h] “string_for_titelbar”<br>OPTIONS: -h help text<br>EXAMPLE: xtitlebar “cvs”<br>HELP<br>　　exit 0<br>}</p><h1 id="in-case-of-error-or-if-h-is-given-we-call-the-function-help"><a href="#in-case-of-error-or-if-h-is-given-we-call-the-function-help" class="headerlink" title="in case of error or if -h is given we call the function help:"></a>in case of error or if -h is given we call the function help:</h1><p>[ -z “1” ] &amp;&amp; help<br>[ “1” ] &amp;&amp; help [ “1” = “-h” ] &amp;&amp; help</p><h1 id="send-the-escape-sequence-to-change-the-xterm-titelbar"><a href="#send-the-escape-sequence-to-change-the-xterm-titelbar" class="headerlink" title="send the escape sequence to change the xterm titelbar:"></a>send the escape sequence to change the xterm titelbar:</h1><p>echo -e “33]0;107”     </p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。<br>命令行参数<br>　　我们已经见过107” # 在脚本中提供帮助是一种很好的编程习惯，这样方便其他用户（和您）使用和理解脚本。 命令行参数 　　我们已经见过* 和 1,1, 2 … $9 等特殊变量，这些特殊变量包含了用户从命令<br>行输入的参数。迄今为止，我们仅仅了解了一些简单的命令行语法（比如一些强制性的<br>参数和查看帮助的-h选项）。 但是在编写更复杂的程序时，您可能会发现您需要更多的<br>自定义的选项。通常的惯例是在所有可选的参数之前加一个减号，后面再加上参数值 (<br>比如文件名)。<br>有好多方法可以实现对输入参数的分析，但是下面的使用case表达式的例子无遗是一个不错的方法。</p><h1 id="bin-sh-1"><a href="#bin-sh-1" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><p>help()<br>{<br>　cat &lt;<br>This is a generic command line parser demo.<br>USAGE EXAMPLE: cmdparser -l hello -f – -somefile1 somefile2<br>HELP<br>　exit 0<br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　-f) opt_f=1;shift 1;; # variable opt_f is set<br>　　-l) opt_l=2;shift 2;; # -l takes an argument -&gt; shift by 2<br>　　–) shift;break;; # end of options<br>　　-<em>) echo “error: no such option2;shift 2;; # -l takes an argument -&gt; shift by 2 　　–) shift;break;; # end of options 　　-</em>) echo “error: no such option 1. -h for help”;exit 1;;<br>　　*) break;;<br>esac<br>done<br>echo “opt_f is optf”echo“optlisopt_f” echo “opt_l is opt_l”<br>echo “first arg is 1”echo“2ndargis1” echo “2nd arg is 2”<br>　　您可以这样运行该脚本：<br>cmdparser -l hello -f – -somefile1 somefile2<br>　　返回的结果是：<br>opt_f is 1<br>opt_l is hello<br>first arg is -somefile1<br>2nd arg is somefile2<br>　　这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数<br>与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，<br>首先输入的应该是包含减号的参数.<br>第2部分 实例<br>现在我们来讨论编写一个脚本的一般步骤。任何优秀的脚本都应该具有帮助和输入参数。并且写一个伪脚本（framework.sh），该脚本包含了大多数脚本都需要的框架结构，是一个非常不错的主意。这时候，在写一个新的脚本时我们只需要执行一下copy命令：<br>cp framework.sh myscript<br>　然后再插入自己的函数。<br>　　让我们再看两个例子：<br>　　二进制到十进制的转换<br>　　脚本 b2d 将二进制数 (比如 1101) 转换为相应的十进制数。这也是一个用expr命令进行数学运算的例子：</p><h1 id="bin-sh-2"><a href="#bin-sh-2" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-1"><a href="#vim-set-sw-4-ts-4-et-1" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>help()<br>{<br>　cat &lt;<br>b2h – convert binary to decimal<br>USAGE: b2h [-h] binarynum<br>OPTIONS: -h help text<br>EXAMPLE: b2h 111010<br>will return 58<br>HELP<br>　exit 0<br>}<br>error()<br>{<br>　　# print an error and exit<br>　　echo “1”<br>　　exit 1<br>}<br>lastchar()<br>{<br>　　# return the last character of a string in1” 　　exit 1 } lastchar() { 　　# return the last character of a string in rval<br>　　if [ -z “$1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　# now cut out the last char<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b $numofchar</code><br>}<br>chop()<br>{<br>　　# remove the last character in string and return it in rvalif[−z“rval 　　if [ -z “1” ]; then<br>　　　　# empty string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　# wc puts some space behind the output this is why we need sed:<br>　　numofchar=<code>echo -n &quot;$1&quot; | wc -c | sed &#39;s/ //g&#39;</code><br>　　if [ “$numofchar” = “1” ]; then<br>　　　　# only one char in string<br>　　　　rval=””<br>　　　　return<br>　　fi<br>　　numofcharminus1=<code>expr $numofchar &quot;-&quot; 1</code><br>　　# now cut all but the last char:<br>　　rval=<code>echo -n &quot;$1&quot; | cut -b 0-${numofcharminus1}</code><br>}<br>while [ -n “1”];docase1” ]; do case 1 in<br>　　-h) help;shift 1;; # function help is called<br>　　–) shift;break;; # end of options<br>　　-<em>) error “error: no such option $1. -h for help”;;  　　</em>) break;;<br>esac<br>done</p><h1 id="The-main-program"><a href="#The-main-program" class="headerlink" title="The main program"></a>The main program</h1><p>sum=0<br>weight=1</p><h1 id="one-arg-must-be-given"><a href="#one-arg-must-be-given" class="headerlink" title="one arg must be given:"></a>one arg must be given:</h1><p>[ -z “1” ] &amp;&amp; help<br>binnum=”1” ] &amp;&amp; help binnum=”1”<br>binnumorig=”1”while[−n“1” while [ -n “binnum” ]; do<br>　　lastchar “binnum”if[“binnum” 　　if [ “rval” = “1” ]; then<br>　　　　sum=<code>expr &quot;$weight&quot; &quot;+&quot; &quot;$sum&quot;</code><br>　　fi<br>　　# remove the last position in binnumchop“binnum 　　chop “binnum”<br>　　binnum=”$rval”<br>　　weight=<code>expr &quot;$weight&quot; &quot;*&quot; 2</code><br>done<br>echo “binary binnumorigisdecimalbinnumorig is decimal sum”<br>　该脚本使用的算法是利用十进制和二进制数权值 (1,2,4,8,16,..)，比如二进制”10”可<br>以这样转换成十进制：<br>0 <em> 1 + 1 </em> 2 = 2<br>　　为了得到单个的二进制数我们是用了lastchar 函数。该函数使用wc –c计算字符个数，<br>然后使用cut命令取出末尾一个字符。Chop函数的功能则是移除最后一个字符。<br>文件循环程序<br>　　或许您是想将所有发出的邮件保存到一个文件中的人们中的一员，但是在过了几个月<br>以后，这个文件可能会变得很大以至于使对该文件的访问速度变慢。下面的 脚本rotatefile<br>可以解决这个问题。这个脚本可以重命名邮件保存文件（假设为outmail）为outmail.1，<br>而对于outmail.1就变成了outmail.2 等等等等…</p><h1 id="bin-sh-3"><a href="#bin-sh-3" class="headerlink" title="!/bin/sh"></a>!/bin/sh</h1><h1 id="vim-set-sw-4-ts-4-et-2"><a href="#vim-set-sw-4-ts-4-et-2" class="headerlink" title="vim: set sw=4 ts=4 et:"></a>vim: set sw=4 ts=4 et:</h1><p>ver=”0.1”<br>help()<br>{<br>　　cat &lt;<br>rotatefile – rotate the file name<br>USAGE: rotatefile [-h] filename<br>OPTIONS: -h help text<br>EXAMPLE: rotatefile out<br>This will e.g rename out.2 to out.3, out.1 to out.2, out to out.1<br>and create an empty out-file<br>The max number is 10<br>version ver<br>HELP<br>　　exit 0<br>}<br>error()<br>{<br>　　echo “$1”<br>　　exit 1<br>}<br>while [ -n “ver HELP 　　exit 0 } error() { 　　echo “$1” 　　exit 1 } while [ -n “1” ]; do<br>case 1in−h)help;shift1;;–)break;;−∗)echo“error:nosuchoption1 in 　　-h) help;shift 1;; 　　–) break;; 　　-<em>) echo “error: no such option 1. -h for help”;exit 1;;  　　</em>) break;;<br>esac<br>done</p><h1 id="input-check"><a href="#input-check" class="headerlink" title="input check:"></a>input check:</h1><p>if [ -z “1”];thenerror“ERROR:youmustspecifyafile,use−hforhelp”fifilen=”1” ] ; then error “ERROR: you must specify a file, use -h for help” fi filen=”1”</p><h1 id="rename-any-1-2-etc-file"><a href="#rename-any-1-2-etc-file" class="headerlink" title="rename any .1 , .2 etc file:"></a>rename any .1 , .2 etc file:</h1><p>for n in 9 8 7 6 5 4 3 2 1; do<br>　　if [ -f “filen.filen.n” ]; then<br>　　　　p=<code>expr $n + 1</code><br>　　　　echo “mv filen.filen.n filen.filen.p”<br>　　　　mv filen.filen.n filen.filen.p<br>　　fi<br>done</p><h1 id="rename-the-original-file"><a href="#rename-the-original-file" class="headerlink" title="rename the original file:"></a>rename the original file:</h1><p>if [ -f “filen”];thenecho“mvfilen” ]; then 　　echo “mv filen filen.1”mvfilen.1” 　　mv filen filen.1fiechotouchfilen.1 fi echo touch filen<br>touch $filen<br>　　这个脚本是如何工作的呢？在检测用户提供了一个文件名以后，我们进行一个9到1的循环。文件9被命名为10，文件8重命名为9等等。循环完成之后，我们将原始文件命名为文件1同时建立一个与原始文件同名的空文件。<br>调试<br>　　最简单的调试命令当然是使用echo命令。您可以使用echo在任何怀疑出错的地方打印任何变量值。这也是绝大多数的shell程序员要花费80%的时间来调试程序的原因。Shell程序的好处在于不需要重新编译，插入一个echo命令也不需要多少时间。<br>　　shell也有一个真实的调试模式。如果在脚本”strangescript” 中有错误，您可以这样来进行调试：<br>sh -x strangescript<br>　　这将执行该脚本并显示所有变量的值。<br>　　shell还有一个不需要执行脚本只是检查语法的模式。可以这样使用：<br>sh -n your_script<br>　　这将返回所有语法错误</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/xmyzlz/article/details/8593228" target="_blank" rel="noopener">Linux脚本编写基础</a></p>]]></content>
      
      <categories>
          
          <category> Linux 脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 脚本 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 编译</title>
      <link href="/2015/06/29/Android-%E7%BC%96%E8%AF%91/"/>
      <url>/2015/06/29/Android-%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文的目的是讲述Android代码编译过程,以及编译过程中Android.mk,Android.bp等文件里面变量的作用分析</p><h1 id="Android编译过程分析"><a href="#Android编译过程分析" class="headerlink" title="Android编译过程分析"></a>Android编译过程分析</h1><p><a href="https://blog.csdn.net/lizekun2010/article/details/52598105" target="_blank" rel="noopener">Android7.0 编译系统流程分析</a><br><a href="https://blog.csdn.net/huangyabin001/article/details/36383031" target="_blank" rel="noopener">深入理解：Android 编译系统</a></p><h1 id="Android-mk"><a href="#Android-mk" class="headerlink" title="Android.mk"></a>Android.mk</h1><p>一个Android.mk file用来向编译系统描述你的源代码。具体来说：该文件是GNU Makefile的一小部分，会被编译系统解析一次或多次。你可以在每一个Android.mk file中定义一个或多个模块，你也可以在几个模块中使用同一个源代码文件。每个模块属下列类型之一：<br>1）APK程序，一般的Android程序，编译打包生成apk文件<br>2）JAVA库，java类库，编译打包生成jar文件<br>3) C\C++应用程序，可执行的C\C++应用程序<br>4）C\C++静态库，编译生成C\C++静态库，并打包成.a文件<br>5）C\C++共享库， 编译生成共享库（动态链接库），并打包成.so， 有且只有共享库才能被安装/复制到您的应用软件（APK）包中。<br>（1）先看一个简单的例子：一个简单的”hello world”，比如下面的文件：<br>sources/helloworld/helloworld.c<br>sources/helloworld/Android.mk<br>相应的Android.mk文件会像下面这样：<br>———- cut here ——————<br>[cpp] view plaincopyprint?<br>1. LOCAL_PATH := (callmy−dir)2.include(call my-dir) 2. include (CLEAR_VARS)<br>3. LOCAL_MODULE<br>4. := helloworld<br>5. LOCAL_SRC_FILES := helloworld.c<br>6. include (BUILDSHAREDLIBRARY)———cuthere——————我们来解释一下这几行代码：1，LOCALPATH:=(BUILD_SHARED_LIBRARY) ——— cut here —————— 我们来解释一下这几行代码： 1，LOCAL_PATH := (call my-dir) ，一个Android.mk file首先必须定义好LOCAL_PATH变量。它用于在开发树中查找源文件。在这个例子中，宏函数‘my-dir’, 由编译系统提供，用于返回当前路径（即包含Android.mk file文件的目录）。<br>2，include (CLEARVARS)，CLEARVARS由编译系统提供（(可以在android安装目录下的/build/core/config.mk文件看到其定义，为CLEARVARS:=( CLEAR_VARS)，CLEAR_VARS由编译系统提供（(可以在 android 安装目录下的/build/core/config.mk 文件看到其定义，为 CLEAR_VARS:= (BUILD_SYSTEM)/clear_vars.mk)），指定让GNU MAKEFILE为你清除许多LOCAL_XXX变量（例如 LOCAL_MODULE, LOCAL_SRC_FILES, LOCAL_STATIC_LIBRARIES, 等等…),除LOCAL_PATH 。这是必要的，因为所有的编译控制文件都在同一个GNU MAKE执行环境中，所有的变量都是全局的。<br>3，LOCAL_MODULE := helloworld，LOCAL_MODULE变量必须定义，以标识你在Android.mk文件中描述的每个模块。名称必须是唯一的，而且不包含任何空格。注意编译系统会自动产生合适的前缀和后缀，换句话说，一个被命名为’foo’的共享库模块，将会生成’libfoo.so’文件。<br>4，LOCAL_SRC_FILES := helloworld.c，LOCAL_SRC_FILES变量必须包含将要编译打包进模块中的C或C++源代码文件。注意，你不用在这里列出头文件和包含文件，因为编译系统将会自动为你找出依赖型的文件；仅仅列出直接传递给编译器的源代码文件就好。<br>此处虽没用到其他常用的还有：<br>5，LOCAL_C_INCLUDES：可选变量，表示头文件的搜索路径。默认的头文件的搜索路径是LOCAL_PATH目录。示例：LOCAL_C_INCLUDES := sources/foo或LOCAL_C_INCLUDES := (LOCALPATH)/../foo6，TARGETARCH：目标CPU平台的名字；TARGETPLATFORM：Android.mk解析的时候，目标Android平台的名字；ARGETARCHABI：暂时只支持两个value，armeabi和armeabi−v7a7，LOCALSTATICLIBRARIES:表示该模块需要使用哪些静态库，以便在编译时进行链接。8，LOCALSHAREDLIBRARIES:表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。9，LOCALLDLIBS:编译模块时要使用的附加的链接器选项。10，LOCALARMMODE:默认情况下，arm目标二进制会以thumb的形式生成(16位)，你可以通过设置这个变量为arm如果你希望你的module是以32位指令的形式11，LOCALCFLAGS:可选的编译器选项，在编译C代码文件的时候使用12，include(LOCAL_PATH)/../foo 6，TARGET_ARCH：目标 CPU平台的名字；TARGET_PLATFORM：Android.mk 解析的时候，目标 Android 平台的名字；ARGET_ARCH_ABI：暂时只支持两个 value，armeabi 和 armeabi-v7a 7，LOCAL_STATIC_LIBRARIES: 表示该模块需要使用哪些静态库，以便在编译时进行链接。 8，LOCAL_SHARED_LIBRARIES: 表示模块在运行时要依赖的共享库（动态库），在链接时就需要，以便在生成文件时嵌入其相应的信息。 9，LOCAL_LDLIBS: 编译模块时要使用的附加的链接器选项。 10，LOCAL_ARM_MODE: 默认情况下， arm目标二进制会以 thumb 的形式生成(16 位)，你可以通过设置这个变量为 arm如果你希望你的 module 是以 32 位指令的形式 11，LOCAL_CFLAGS: 可选的编译器选项，在编译 C 代码文件的时候使用 12，include (call all-subdir-makefiles)：返回一个位于当前’my-dir’路径的子目录中的所有Android.mk的列表。<br>（2）在Android中增加本地程序或者库，这些程序和库与其所载路径没有任何关系，只和它们的Android.mk文件有关系。Android.mk和普通的Makefile有所不同，它具有统一的写法，主要包含一些系统公共的宏。在一个Android.mk中可以生成多个可执行程序、动态库和静态库。<br>A，编译C/C++应用程序的模板：  </p><p>#Test Exe<br>LOCAL_PATH := (call my-dir)    </p><pre><code>#include(call my-dir) #include (CLEAR_VARS)  </code></pre><p>LOCAL_SRC_FILES:= main.c<br>LOCAL_MODULE:= test_exe  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILDEXECUTABLE)（菜鸟级别解释：:=是赋值的意思，+=是追加的意思，(BUILD_EXECUTABLE) （菜鸟级别解释：:=是赋值的意思，+=是追加的意思，是引用某变量的值）BUILD_EXECUTABLE表示以一个可执行程序的方式进行编译。补充说明：include (BUILDPACKAGE)则是编译出一个apk，include(BUILD_PACKAGE)则是编译出一个apk，include (BUILD_STATIC_JAVA_LIBRARY)则是编译出jar包。<br>B，编译静态库的模板：  </p><p>#Test Static Lib<br>LOCAL_PATH := (callmy−dir)include(call my-dir) include (CLEAR_VARS)<br>LOCAL_SRC_FILES:= /<br>helloworld.c<br>LOCAL_MODULE:= libtest_static  </p><p>#LOCAL_C_INCLUDES :=  </p><p>#LOCAL_STATIC_LIBRARIES :=  </p><p>#LOCAL_SHARED_LIBRARIES :=<br>include (BUILD_STATIC_LIBRARY)<br>一般的和上面相似，BUILD_STATIC_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。<br>C，编译动态库的模板：    </p><pre><code>#Test Shared Lib    LOCAL_PATH :=(BUILD\_STATIC\_LIBRARY) 一般的和上面相似，BUILD\_STATIC\_LIBRARY表示编译一个静态库.a文件。静态库不会复制到的APK包中，但是能够用于编译共享库。 C，编译动态库的模板： #Test Shared Lib LOCAL_PATH := (call my-dir)  </code></pre><p>include (CLEAR_VARS)<br>     LOCAL_SRC_FILES:= /<br>               helloworld.c<br>     LOCAL_MODULE:= libtest_shared<br>     TARGET_PRELINK_MODULES := false    </p><pre><code>#LOCAL\_C\_INCLUDES :=    #LOCAL\_STATIC\_LIBRARIES :=    #LOCAL\_SHARED\_LIBRARIES :=     include(CLEAR\_VARS) LOCAL\_SRC\_FILES:= / helloworld.c LOCAL\_MODULE:= libtest\_shared TARGET\_PRELINK\_MODULES := false #LOCAL\_C\_INCLUDES := #LOCAL\_STATIC\_LIBRARIES := #LOCAL\_SHARED_LIBRARIES := include (BUILD\_SHARED\_LIBRARY)  </code></pre><p>一般的和上面相似，BUILD_SHARED_LIBRARY表示编译一个动态库。<br>以上三者的生成结果分别在如下，generic依具体target会变：<br>out/target/product/generic/obj/EXECUTABLE<br>out/target/product/generic/obj/STATIC_LIBRARY<br>out/target/product/generic/obj/SHARED_LIBRARY<br>每个模块的目标文件夹分别为：<br>可执行程序：XXX_intermediates<br>静态库： XXX_static_intermediates<br>动态库： XXX_shared_intermediates<br>另外，在Android.mk文件中，还可以指定最后的目标安装路径，用LOCAL_MODULE_PATH和LOCAL_UNSTRIPPED_PATH来指定。不同的文件系统路径用以下的宏进行选择：<br>TARGET_ROOT_OUT：表示根文件系统out/target/product/generic/root。<br>TARGET_OUT：表示system文件系统out/target/product/generic/system。<br>TARGET_OUT_DATA：表示data文件系统out/target/product/generic/data。<br>OUT_DIR：代码工程编译时的out生成目录<br>PRODUCT_OUT：映象生成目录</p><h1 id="Android-bp"><a href="#Android-bp" class="headerlink" title="Android.bp"></a>Android.bp</h1><p>待补充</p>]]></content>
      
      <categories>
          
          <category> Android 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>问题锦集-速查</title>
      <link href="/2015/06/29/%E9%97%AE%E9%A2%98%E9%94%A6%E9%9B%86-%E9%80%9F%E6%9F%A5/"/>
      <url>/2015/06/29/%E9%97%AE%E9%A2%98%E9%94%A6%E9%9B%86-%E9%80%9F%E6%9F%A5/</url>
      <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文收集平常工作过程中遇到的一些常见问题，遇到的一些坑，把它们记录下来，以便日后再次遇到能快速排查。</p><h1 id="无法下载版本问题："><a href="#无法下载版本问题：" class="headerlink" title="无法下载版本问题："></a>无法下载版本问题：</h1><ol><li><p>确认主板中是否有download过软件——直接接电源开机，如可以开机，可以断定此主板已经down过版本了；如果无法开机，尝试焊接串口线，抓一下log，看看在哪一步停下来走不下去了。<br>一般而言，可以开机但是不能下载的，存在两种可能：<br>①新软件中未兼容主板上的Memory物料；<br>②分区表更新了。<br>对于这第一种情况，可以通过查配置表，找到Memory物料型号，然后跟软件开发人员核对，是否有兼容；或者查看flash download工具的log，发给开发人员，通过Memory ID来确认是否兼容该物料。<br>对于第二种情况，通常可以选择upgrade的升级方式，如实在不行，可以导出校准参数，然后格式化下载新软件，最后重新导入校准参数。 </p></li><li><p>如果遇到无法开机，又无法下载的，可能有三种种情况：<br>①软件中未兼容主板上的Memory物料；<br>②下载工具版本过旧，不支持当前平台的下载；<br>③主板有异常，尤其Memory可能有损坏。<br>第一种情况跟上面类似，不再赘述。第二种情况，可以先直接换一个新版本工具试试能否下载，如可以下载，说明工具需要更新，如仍然无法下载，说明跟工具无关。第三种情况，可以多找几块主板，如果有一块可以下载软件，基本就可以判断无法下载的主板存在硬件上的损坏。  </p></li><li><p>不开机问题：<br>1、 按开机键没有反应，屏幕不亮，用电源连接时发现电流无变化。这种情况，有两种可能：<br>①主板开机键或电池连接异常；<br>②单块主板损坏；<br>第一种情况，可以直接使用电源，然后用镊子连接主板power key测试点与地，如可以开机，说明开机键或电池异常；<br>第二种情况通常需要硬件同事介入分析。<br>2、开机到某个阶段停止不动。类似这样的情况，可以直接抓log分析。<br>比较实用的方法：①抓取不开机的uart log，部分手机不开机，同时抓取正常开机的uart log对比分析；②如果开机到android界面，可使用adb logcat -v time &gt; log.txt获取上层log信息。</p></li><li><p>部分手机开机时间非常长：<br>此类问题很大可能性是由于外设在读ID导致的，直接抓log查看即可。最方便的方式就是直接抓串口log来分析。此外还可以用adb shell logcat –v time &gt; 123.txt来抓取上层log来分析。</p></li><li><p>开机背光亮，有开机铃声，屏幕没有显示：<br>一般而言，问题在于屏没有兼容或者屏/主板单体损坏。如果是单体问题，我们可以做交叉实验，分析问题是主板还是屏导致的。如果全部显示都不对，可以跟软件开发同事确认是否软件不对，或者抓串口log，确认屏ID是否读到。</p></li><li><p>Camera应用丢失，Camera切换按钮丢失：<br>在MTK平台上，Camera的识别是在开机过程中完成的。如果开机时没有识别到任何Camera，开机之后Camera应用就会直接影藏；如果只识别到一个Camera，Camera切换按钮就是影藏。<br>1、如果有发现手机开机之后，Camera应用丢失，可以通过以下步骤去：<br>①将手机恢复出厂设置，然后重新开机，此时如果Camera应用显示出来，且多次使用都正常了，说明之前该机器很有可能是先开机过，然后再安装Camera的。<br>②如果恢复出厂设置还是无法显示Camera应用，首先需要确认此问题是单体（或小概率）问题还是大批量问题。单体问题的话，就需要去排查Camera焊接/连接是否正常。如焊接/连接正常，接着做交叉实验，确认是模组问题还是主板问题。模组问题就安排模组厂分析，主板问题就合硬件沟通解决。如果是大批量问题，一方面需要让模组厂参与进来分析，另一方面需要排查软件/硬件。软件上可以抓串口log给软件同事分析，硬件上排查走线、供电是否有异常。<br>③如果切换异常，通常是某个Camera的ID没有读到。可以在拨号界面输入“_#<em>#9375#</em>#_”（仅适用于MTK平台），确认下是否是没有读到ID，如确实ID没有读到，一方面检查Camera焊接/连接是否正常，另一方面抓下串口log给软件同事分析。</p></li><li><p>Camera花屏/闪绿线：<br>遇到Camera使用过程中花屏/闪绿线的问题，我们可以从两个方向去排查问题。首先还是按照惯例统计花屏的概率，如果是单体问题，需要去确认Camera数据线是否有问题，直接测量数据线信号即可，将波形发生给硬件同事检查。然后做交叉实验，确认是模组问题还是主板问题。模组问题让模组厂来分析，主板问题可以跟硬件沟通处理。<br>如果大批量都有问题，需要软件和硬件同事介入分析。软件上尝试修改Camera驱动能力，优化一个最好的组合，硬件上尝试包导电布、做接地处理。</p></li></ol>]]></content>
      
      <categories>
          
          <category> 问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题 锦集 速查 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>各类工具使用小技巧</title>
      <link href="/2015/06/29/%E5%90%84%E7%B1%BB%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2015/06/29/%E5%90%84%E7%B1%BB%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h1 id="VIM-使用小技巧"><a href="#VIM-使用小技巧" class="headerlink" title="VIM 使用小技巧"></a>VIM 使用小技巧</h1><h2 id="配置鼠标和显示行号"><a href="#配置鼠标和显示行号" class="headerlink" title="配置鼠标和显示行号"></a>配置鼠标和显示行号</h2><p>服务器在安装了加密之后，vim无法使用鼠标，也无法显示行号了，可以通过如下方法修改：  </p><ol><li>在~路径下创建.vimrc，然后加入两行<br>set mouse=a<br>set nu<br>修改完之后保存退出。  </li><li>关闭bash窗口，或者source .vimrc，接下来vim就可以使用鼠标和显示行号了。</li></ol><h1 id="shell-脚本小技巧"><a href="#shell-脚本小技巧" class="headerlink" title="shell 脚本小技巧"></a>shell 脚本小技巧</h1><h2 id="shell脚本注意事项"><a href="#shell脚本注意事项" class="headerlink" title="shell脚本注意事项"></a>shell脚本注意事项</h2><p>有些情况下，我们会碰到一个问题，在编译时，有些shell脚本会无法执行。相信大家会第一时间去检查脚本的权限，看看脚本是否有可执行权限——ls查看下。如果权限不对，使用chmod指令修改下就好了。<br>但是有些时候，发现权限对了，脚本执行仍然不对，如这种提示——bad interpreter:No such file or directory。这种情况，其实是脚本的文件结尾符是dos格式的，而非unix标准编码。<br>碰到这种情况，可以通过如下方式定位、解决。  </p><ol><li>使用vim打开文件，然后进入命令模式，输入set: ff（ ）并回车，此时，文件下方会有提示 或者 如果是第二种，那么恭喜你中招了，这个文件的格式是dos的（也就是windows一系列系统的格式），这种格式的脚本，是无法在shell中执行的。  </li><li>想要修改，也非常简单。输入命令 ，然后回车，问题搞定了。保存文件，会发现该脚本已经可以执行了。</li></ol><h1 id="Putty-使用小技巧"><a href="#Putty-使用小技巧" class="headerlink" title="Putty 使用小技巧"></a>Putty 使用小技巧</h1><h2 id="实现输入中文和log行数增加"><a href="#实现输入中文和log行数增加" class="headerlink" title="实现输入中文和log行数增加"></a>实现输入中文和log行数增加</h2><ol><li>在Translation标签页，将putty的字符集修改为UTF-8。  </li><li>将字体设置成Fixedsys。  </li><li>在Window标签页，将Lines of Scrollback设置成为20000。  </li><li>将Session中的IP地址和Saved Session填写好。选择Save。  </li><li>下次登录的时候，只要选择存储的Session就可以了。</li></ol>]]></content>
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小技巧 工具 vim shell putty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows批处理 BAT技巧</title>
      <link href="/2015/06/29/windows%E6%89%B9%E5%A4%84%E7%90%86-BAT%E6%8A%80%E5%B7%A7/"/>
      <url>/2015/06/29/windows%E6%89%B9%E5%A4%84%E7%90%86-BAT%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>Windows操作系统中，cmd可以执行bat格式的文件，可以自己编写bat文件完成一些重复性的工作。</p><h1 id="用批处理命令批量获取指定文件夹内的文件名"><a href="#用批处理命令批量获取指定文件夹内的文件名" class="headerlink" title="用批处理命令批量获取指定文件夹内的文件名"></a>用批处理命令批量获取指定文件夹内的文件名</h1><p>dir /s /w &gt;&gt;catalog.txt<br>::/s 表示只显示系统文件<br>::/w 表示只显示文件名，至于文件大小以及建立的日期和时间都省略<br>::dir *.doc /s /w &gt;&gt; catalog.txt 表示仅生成后缀为.doc文件</p><h1 id="BAT文件注释符"><a href="#BAT文件注释符" class="headerlink" title="::BAT文件注释符"></a>::BAT文件注释符</h1><p>:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>rem 注释内容（不能出现重定向符号和管道符号）<br>:注释内容（注释文本不能与已有标签重名）<br>%注释内容(可以用作行间注释，不能出现重定向符号和管道符号)%</p><p>rem 指定存放文件的目录<br>set originPath=C:\Documents and Settings\zhoudeshui\Desktop\临时文件</p><p>:@echo<br>:　　dir c:<em>.</em> &gt;a.txt　　　　　　　<br>:　　call c:\ucdos\ucdos.bat　　　　<br>:　　echo 你好 　　　　　　　　　　<br>:　　pause 　　　　　　　　　　　　</p><p>@echo off<br>for /f “delims=\” %%a in (‘dir /b /a-d /o-d “%originPath%<em>.</em>”’) do (<br>echo %%a &gt; aa.txt<br>)<br>pause</p><h1 id="使用bat-完成Android-log的自动抓取"><a href="#使用bat-完成Android-log的自动抓取" class="headerlink" title="使用bat 完成Android log的自动抓取"></a>使用bat 完成Android log的自动抓取</h1><p>可以将抓log的命令，做成一个合集，放在一个bat文件中，一步运行，抓取所有log。适合于工厂产线抓log。<br><a href="https://blog.csdn.net/maetelibom/article/details/51480980" target="_blank" rel="noopener">一种通过自动脚本抓取Android 手机log的方法</a><br><a href="https://blog.csdn.net/xxm282828/article/details/46433095" target="_blank" rel="noopener">使用脚本导出android 手机log</a></p>]]></content>
      
      <categories>
          
          <category> 批处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 批处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ADB (Android Debug Bridge)常用命令</title>
      <link href="/2015/06/29/ADB-Android-Debug-Bridge-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2015/06/29/ADB-Android-Debug-Bridge-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<!--修改记录：1.2016年完成第一版2.2018年修订完成目标：分析adb的源码    --><p>ADB (Android Debug Bridge)</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://android.googlesource.com/platform/system/core/+/master/adb/" target="_blank" rel="noopener">Android中Adb源码</a></p><p><strong>adb 源码分析： 待补充</strong></p><p>说明：下面一些命令需要有root权限才能执行成功<br>Windows环境下的adb<br>快速启动dos窗口执行adb：<br>1. adb.exe所在路径添加到系统环境变量中<br>2. 配置快捷键启动dos<br>进入C:\WINDOWS\system32目录下，找到cmd.exe.<br>右击菜单 “发送到” -> 桌面快捷方式。<br>在桌面上右击”快捷方式 到 cmd.exe” -&gt; “属性” -&gt; “快捷方式”页<br>-&gt; 光标高亮”快捷键” -> 按下自定义快捷键 (如：Ctrl + Alt + Z)</p><p>任何情况下，按下Ctrl + Alt + Z启动dos窗口就可以执行adb命令了</p><h1 id="查看设备连接状态-系列"><a href="#查看设备连接状态-系列" class="headerlink" title="查看设备连接状态 系列"></a>查看设备连接状态 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb get-serialno 获取设备的ID和序列号serialNumber  </span><br><span class="line">adb devices 查询当前计算机上连接那些设备（包括模拟器和手机），输出格式: \[serialNumber\] \[state\]  </span><br><span class="line">adb get-state 查看模拟器/设施的当前状态.</span><br></pre></td></tr></table></figure><p>说明：<br>序列号[serialNumber]——由adb创建的一个字符串，这个字符串通过自己的控制端口-<br>唯一地识别一个模拟器/设备实例。一个序列号的例子： emulator-5554</p><h1 id="发送命令到设备-系列"><a href="#发送命令到设备-系列" class="headerlink" title="发送命令到设备 系列"></a>发送命令到设备 系列</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb \[-d|-e|-s \]  </span><br><span class="line">-d 发送命令给usb连接的设备  </span><br><span class="line">-e 发送命令到模拟器设备  </span><br><span class="line">-s 发送命令到指定设备</span><br></pre></td></tr></table></figure><p>如启动手机设备shell: adb -d shell</p><p>adb forward 发布端口,可以设置任意的端口号，<br>做为主机向模拟器或设备的请求端口。如：adb forward tcp:5555 tcp:8000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">adb reboot 重启手机  </span><br><span class="line">adb remount 将system分区重新挂载为可读写分区  </span><br><span class="line">adb <span class="built_in">kill</span>-server 终止adb服务进程  </span><br><span class="line">adb start-server 重启adb服务进程  </span><br><span class="line">adb root 已root权限重启adb服务  </span><br><span class="line">adb <span class="built_in">wait</span>-for-device 在模拟器/设备连接之前把命令转载在adb的命令器中  </span><br><span class="line">adb jdwp 查看指定的设施的可用的JDWP信息.  Java Debug Wire Protocol (JDWP, Java调试线协议)是</span><br><span class="line">可以用 forward jdwp: 端口映射信息来连接指定的JDWP进程.例如：  </span><br><span class="line">adb forward tcp:8000 jdwp:472  </span><br><span class="line">jdb -attach localhost:8000</span><br></pre></td></tr></table></figure><h1 id="adb-shell-am-命令可以启动应用程序"><a href="#adb-shell-am-命令可以启动应用程序" class="headerlink" title="adb shell am 命令可以启动应用程序"></a>adb shell am 命令可以启动应用程序</h1><p>adb shell input text 向设备输入文本（光标所在的文本框）<br>adb shell input keyevent 向设备发送按键事件<br>如：<br>在编辑短信时，往文本框输入文本：adb shell input text “hello”<br>向手机发送键值回Home：adb shell input keyevent 3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">event\_code 参考view/KeyEvent.java中的 KEYCODE\_*  </span><br><span class="line">public static final int KEYCODE\_SOFT\_LEFT = 1;  </span><br><span class="line">public static final int KEYCODE\_SOFT\_RIGHT = 2;  </span><br><span class="line">public static final int KEYCODE_HOME = 3;  </span><br><span class="line">public static final int KEYCODE_BACK = 4;  </span><br><span class="line">public static final int KEYCODE_CALL = 5;  </span><br><span class="line">public static final int KEYCODE_ENDCALL = 6;</span><br></pre></td></tr></table></figure></p><h1 id="安装卸载-系列"><a href="#安装卸载-系列" class="headerlink" title="安装卸载 系列"></a>安装卸载 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb install \[-l\] \[-r\] - push this package file to the device and install it  </span><br><span class="line">(‘-l’ means forward-lock the app)  </span><br><span class="line">(‘-r’ means reinstall the app, keeping its data)  </span><br><span class="line">adb uninstall \[-k\] - remove this app package from the device  </span><br><span class="line">(‘-k’ means keep the data and cache directories)</span><br></pre></td></tr></table></figure><p>如：<br>adb install d:\hello.apk<br>adb unstall com.huawei.hello<br>说明：如果带-r选项重新安装apk时，安装在 /data/local/tmp/目录下，手机重启后还是使用原来的apk.</p><h1 id="文件操作-系列"><a href="#文件操作-系列" class="headerlink" title="文件操作 系列"></a>文件操作 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb push - copy file/dir to device  </span><br><span class="line">adb pull - copy file/dir from device</span><br></pre></td></tr></table></figure><h1 id="基本linux-shell命令-系列"><a href="#基本linux-shell命令-系列" class="headerlink" title="基本linux shell命令 系列"></a>基本linux shell命令 系列</h1><p>adb shell [command]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls 列出目录下的文件和文件夹  </span><br><span class="line"><span class="built_in">cd</span> 切换目录  </span><br><span class="line">rm 删除目录和文件  </span><br><span class="line">cat 查看文件内容  </span><br><span class="line">ps 可以看那个进程再跑  </span><br><span class="line">ps -x \[PID\] 查看单个进程的状态  </span><br><span class="line">top 可以看那个进程的占用率最高  </span><br><span class="line">su 切换到root用户  </span><br><span class="line"><span class="built_in">kill</span> \[pid\] 杀死一个进程  </span><br><span class="line">chmod 777 修改该文件为可执行权限</span><br></pre></td></tr></table></figure></p><p>从framework/base/cmds中查到的一些常用的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell am stack list 列出AM堆栈信息</span><br><span class="line">adb shell appops  应用权限授权管理框架,可以使用AppOps将其某项强制要求权限忽略掉</span><br><span class="line">adb shell appwidget 主要是设置apk是否有放在窗口的权限</span><br><span class="line">adb shell bmgr 备份用</span><br><span class="line">adb shell content</span><br><span class="line">adb shell dpm</span><br></pre></td></tr></table></figure></p><ol><li>打印某个进程中所有线程的backtrace<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell debuggerd -b pid</span><br></pre></td></tr></table></figure></li></ol><p>用于分析死锁</p><ol start="2"><li>打印系统所有注册的服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell service list</span><br></pre></td></tr></table></figure></li></ol><p>用于查看service是否注册成功</p><ol start="3"><li>查看某个应用时32位还是64位<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">adb shell ps --api</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">详细使用情况可以登录一台Linux服务器在shell下查看帮助手册, man</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统状态和信息 系列  </span></span><br><span class="line">``` bash</span><br><span class="line">adb shell procrank 查询各进程内存使用情况  </span><br><span class="line">adb shell service list 查看services信息  </span><br><span class="line">adb shell cat /proc/meminfo 查看当前的内存情况  </span><br><span class="line">adb shell cat /proc/cpuinfo 查看CPU信息（硬件）  </span><br><span class="line">adb shell cat /proc/iomem 查看IO内存分区</span><br><span class="line"></span><br><span class="line">adb shell getprop 列出系统所有属性  </span><br><span class="line">adb shell getprop | findstr “gsm” 列出包含gsm的属性  </span><br><span class="line">adb shell setprop 修改系统属性</span><br><span class="line"></span><br><span class="line">adb shell sqlite3 可以执行sql语句查看数据库信息， 具体使用情况待调查</span><br><span class="line"></span><br><span class="line">adb shell dmesg 查询内核缓冲区信息  </span><br><span class="line">adb shell dumpstate 各类信息，比如进程信息，内存信息，进程是否异常，kernnel的<span class="built_in">log</span>等  </span><br><span class="line">adb shell dumpcrash  </span><br><span class="line">adb shell dumpsys 查询所有service的状态</span><br></pre></td></tr></table></figure></li></ol><h1 id="Log-系列"><a href="#Log-系列" class="headerlink" title="Log 系列"></a>Log 系列</h1><p>adb logcat [ ] - View device log</p><h2 id="查看可用日志缓冲区"><a href="#查看可用日志缓冲区" class="headerlink" title="查看可用日志缓冲区:"></a>查看可用日志缓冲区:</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -b radio — 查看缓冲区的相关的信息.  </span><br><span class="line">adb logcat -b events — 查看和事件相关的的缓冲区.  </span><br><span class="line">adb logcat -b main — 查看主要的日志缓冲区</span><br></pre></td></tr></table></figure><h2 id="过滤日志输出"><a href="#过滤日志输出" class="headerlink" title="过滤日志输出:"></a>过滤日志输出:</h2><p>过滤器语句按照下面的格式描tag:priority … , tag 表示是标签, priority 是表示标签的报告的最低等级<br>adb logcat <em>:W 显示优先级为warning或更高的日志信息<br>adb logcat ActivityManager:I MyApp:D </em>:S</p><p>日志的标签是系统部件原始信息的一个简要的标志。（比如：“View”就是查看系统的标签）.<br>优先级有下列集中，是按照从低到高顺利排列的:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V — Verbose (lowest priority)  </span><br><span class="line">D — Debug  </span><br><span class="line">I — Info  </span><br><span class="line">W — Warning  </span><br><span class="line">E — Error  </span><br><span class="line">F — Fatal  </span><br><span class="line">S — Silent (highest priority, on <span class="built_in">which</span> nothing is ever printed)</span><br></pre></td></tr></table></figure></p><p>如果你电脑上运行logcat ，相比在远程adb shell端，你还可以为环境变量ANDROID_LOG_TAGS :输入一个参数来设置默认的过滤<br>export ANDROID_LOG_TAGS=”ActivityManager:I MyApp:D *:S”<br>需要注意的是ANDROID_LOG_TAGS 过滤器如果通过远程shell运行logcat 或用adb shell logcat 来运行模拟器/设备不能输出日志.</p><h2 id="控制日志输出格式"><a href="#控制日志输出格式" class="headerlink" title="控制日志输出格式:"></a>控制日志输出格式:</h2><p>日志信息包括了许多元数据域包括标签和优先级。可以修改日志的输出格式，所以可以显示出特定的元数据域。可以通过 -v 选项得到格式化输出日志的相关信息.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brief — Display priority/tag and PID of originating process (the default format).  </span><br><span class="line">process — Display PID only.  </span><br><span class="line">tag — Display the priority/tag only.  </span><br><span class="line">thread — Display process:thread and priority/tag only.  </span><br><span class="line">raw — Display the raw <span class="built_in">log</span> message, with no other metadata fields.  </span><br><span class="line">time — Display the date, invocation time, priority/tag, and PID of the originating process.  </span><br><span class="line">long — Display all metadata fields and separate messages with a blank lines.</span><br></pre></td></tr></table></figure><p>当启动了logcat ，你可以通过-v 选项来指定输出格式:</p><p>[adb] logcat [-v ]<br>下面是用 thread 来产生的日志格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -v thread</span><br></pre></td></tr></table></figure><p>需要注意的是你只能-v 选项来规定输出格式 option.</p><h2 id="Logcat命令列表"><a href="#Logcat命令列表" class="headerlink" title="Logcat命令列表"></a>Logcat命令列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b 加载一个可使用的日志缓冲区供查看，比如event 和radio . 默认值是main 。具体查看Viewing Alternative Log Buffers.  </span><br><span class="line">-c 清楚屏幕上的日志.  </span><br><span class="line">-d 输出日志到屏幕上.  </span><br><span class="line">-f 指定输出日志信息的 ，默认是stdout .  </span><br><span class="line">-g 输出指定的日志缓冲区，输出后退出.  </span><br><span class="line">-n 设置日志的最大数目 .，默认值是4，需要和 -r 选项一起使用。  </span><br><span class="line">-r 每 时输出日志，默认值为16，需要和-f 选项一起使用.  </span><br><span class="line">-s 设置默认的过滤级别为silent.  </span><br><span class="line">-v 设置日志输入格式，默认的是brief 格式，要知道更多的支持的格式，参看Controlling Log Output Format</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb bugreport - <span class="built_in">return</span> all information from the device  </span><br><span class="line">that should be included <span class="keyword">in</span> a bug report.</span><br></pre></td></tr></table></figure><p>———–其他 ———–</p><p>模拟器使用镜像sdcard<br>用SDK里的mksdcard工具来创建FAT32磁盘镜像并在模拟器启动时加载它。这样创建镜像：? mksdcard ,<br>比如我要创建一个64M的SD卡模拟文件，文件路径是在D:\workspace\sdcard.img<br>mksdcard 64000000 D:\workspace\sdcard.img</p><p>Emulator –sdcard D:\workspace\sdcard.img<br>或者在eclipse的run菜单的open run dialog对话框中配置启动参数。</p><h1 id="adb-shell-top-系列"><a href="#adb-shell-top-系列" class="headerlink" title="adb shell top 系列"></a>adb shell top 系列</h1><p>top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Usage: top \[ -m max\_procs \] \[ -n iterations \] \[ -d delay \] \[ -s sort\_column \] \[ -t \] \[ -h \]  </span><br><span class="line">-m num Maximum number of processes to display.  //最多显示m个进程</span><br><span class="line">-n num Updates to show before exiting.   //刷新次数</span><br><span class="line">-d num Seconds to <span class="built_in">wait</span> between updates.   //刷新间隔时间（默认5秒）</span><br><span class="line">-s col Column to sort by (cpu,vss,rss,thr).  //按哪列排序 </span><br><span class="line">-t Show threads instead of processes.  //显示线程信息而不是进程</span><br><span class="line">-h Display this <span class="built_in">help</span> screen.  //显示帮助文档</span><br><span class="line"></span><br><span class="line">**_*****_** simple selection **_*_** **_*****_** selection by list **_*_**  </span><br><span class="line">-A all processes -C by <span class="built_in">command</span> name  </span><br><span class="line">-N negate selection -G by real group ID (supports names)  </span><br><span class="line">-a all w/ tty except session leaders -U by real user ID (supports names)  </span><br><span class="line">-d all except session leaders -g by session OR by effective group name  </span><br><span class="line">-e all processes -p by process ID  </span><br><span class="line">T all processes on this terminal -s processes <span class="keyword">in</span> the sessions given  </span><br><span class="line">a all w/ tty, including other users -t by tty  </span><br><span class="line">g OBSOLETE – DO NOT USE -u by effective user ID (supports names)  </span><br><span class="line">r only running processes U processes <span class="keyword">for</span> specified users  </span><br><span class="line">x processes w/o controlling ttys t by tty  </span><br><span class="line">**_*****_** output format **_******_** **_\*\*\*_** long options **_*****_**  </span><br><span class="line">-o,o user-defined -f full –Group –User –pid –cols –ppid  </span><br><span class="line">-j,j job control s signal –group –user –sid –rows –info  </span><br><span class="line">-O,O preloaded -o v virtual memory –cumulative –format –deselect  </span><br><span class="line">-l,l long u user-oriented –sort –tty –forest –version  </span><br><span class="line">-F extra full X registers –heading –no-heading –context  </span><br><span class="line">**_*****_** misc options **_*_**  </span><br><span class="line">-V,V show version L list format codes f ASCII art forest  </span><br><span class="line">-m,m,-L,-T,H threads S children <span class="keyword">in</span> sum -y change -l format  </span><br><span class="line">-M,Z security data c <span class="literal">true</span> <span class="built_in">command</span> name -c scheduling class  </span><br><span class="line">-w,w wide output n numeric WCHAN,UID -H process hierarchy</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell top</span><br><span class="line"> </span><br><span class="line">User 13%, System 5%, IOW 0%, IRQ 0%</span><br><span class="line">User 85 + Nice 0 + Sys 37 + Idle 509 + IOW 0 + IRQ 0 + SIRQ 0 = 631   //第一组数据</span><br><span class="line"> </span><br><span class="line">  PID PR CPU% S  <span class="comment">#THR     VSS     RSS PCY UID      Name    //第二组数据</span></span><br><span class="line">22205  0  13% S    56 423416K  88160K  <span class="built_in">fg</span> u0_a92   com.tmall.wireless</span><br><span class="line">24310  1   2% R     1   1232K    536K     root     top</span><br><span class="line">22600  0   1% S    46 341712K  40872K  <span class="built_in">fg</span> u0_a90   com.wandoujia.phoenix2.usbproxy</span><br><span class="line">31125  1   1% S    31 319976K  33284K  <span class="built_in">fg</span> u0_a74   com.android.Chinpower</span><br><span class="line"> 1533  0   1% S    32  67320K  20552K  <span class="built_in">fg</span> system   /system/bin/surfaceflinger</span><br><span class="line"> 1852  0   1% S   112 445876K  80304K  <span class="built_in">fg</span> system   system_server</span><br><span class="line">    ...</span><br><span class="line">   10  0   0% S     1      0K      0K     root     watchdog/0</span><br><span class="line">   16  1   0% S     1      0K      0K     root     khelper</span><br><span class="line">   22  1   0% S     1      0K      0K     root     suspend_sys_syn</span><br><span class="line">   23  1   0% S     1      0K      0K     root     <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p>第一组数据的含义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User  处于用户态的运行时间，不包含优先值为负进程 </span><br><span class="line">Nice  优先值为负的进程所占用的CPU时间 </span><br><span class="line">Sys   处于核心态的运行时间 </span><br><span class="line">Idle  除IO等待时间以外的其它等待时间 </span><br><span class="line">IOW   IO等待时间 </span><br><span class="line">IRQ   硬中断时间 </span><br><span class="line">SIRQ  软中断时间</span><br></pre></td></tr></table></figure></p><p>第二组数据的含义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PID   进程id</span><br><span class="line">PR    优先级</span><br><span class="line">CPU%  当前瞬时CPU占用率</span><br><span class="line">S     进程状态:D=不可中断的睡眠状态, R=运行, S=睡眠, T=跟踪/停止, Z=僵尸进程</span><br><span class="line"><span class="comment">#THR  程序当前所用的线程数</span></span><br><span class="line">VSS   Virtual Set Size  虚拟耗用内存（包含共享库占用的内存）</span><br><span class="line">RSS   Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span><br><span class="line">PCY   调度策略优先级，SP_BACKGROUND/SP_FOREGROUND</span><br><span class="line">UID   进程所有者的用户id</span><br><span class="line">Name  进程的名称</span><br><span class="line">PID   进程id</span><br><span class="line">PR    优先级</span><br><span class="line">CPU%  当前瞬时CPU占用率</span><br><span class="line">S     进程状态:D=不可中断的睡眠状态, R=运行, S=睡眠, T=跟踪/停止, Z=僵尸进程</span><br><span class="line"><span class="comment">#THR  程序当前所用的线程数</span></span><br><span class="line">VSS   Virtual Set Size  虚拟耗用内存（包含共享库占用的内存）</span><br><span class="line">RSS   Resident Set Size 实际使用物理内存（包含共享库占用的内存）</span><br><span class="line">PCY   调度策略优先级，SP_BACKGROUND/SP_FOREGROUND</span><br><span class="line">UID   进程所有者的用户id</span><br><span class="line">Name  进程的名称</span><br></pre></td></tr></table></figure></p><h1 id="adb-shell-netstat-网络相关"><a href="#adb-shell-netstat-网络相关" class="headerlink" title="adb shell netstat 网络相关"></a>adb shell netstat 网络相关</h1><p>netstat -ano 查看网络连状态<br>显示协议统计信息和当前 TCP/IP 网络连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NETSTAT \[-a\] \[-b\] \[-e\] \[-n\] \[-o\] \[-p proto\] \[-r\] \[-s\] \[-v\] \[interval\]</span><br><span class="line">``` </span><br><span class="line">``` bash</span><br><span class="line">-a 显示所有连接和监听端口。  </span><br><span class="line">-b 显示包含于创建每个连接或监听端口的可执行组件。在某些情况下已知可执行组件拥有多个独立组件，并且在这些情况下包含于创建连接或监听端口的组件序列被显示。这种情况下，可执行组件名  </span><br><span class="line">在底部的 \[\] 中，顶部是其调用的组件，等等，直到 TCP/IP 部分。注意此选项 可能需要很长时间，如果没有足够权限可能失败。  </span><br><span class="line">-e 显示以太网统计信息。此选项可以与 -s  选项组合使用。  </span><br><span class="line">-n 以数字形式显示地址和端口号。  </span><br><span class="line">-o 显示与每个连接相关的所属进程 ID。  </span><br><span class="line">-p proto 显示 proto 指定的协议的连接；proto 可以是  </span><br><span class="line">下列协议之一: TCP、UDP、TCPv6 或 UDPv6。  </span><br><span class="line">如果与 -s 选项一起使用以显示按协议统计信息，proto 可以是下列协议之一:  </span><br><span class="line">IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 或 UDPv6。  </span><br><span class="line">-r 显示路由表。  </span><br><span class="line">-s 显示按协议统计信息。默认地，显示 IP、  </span><br><span class="line">IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6 的统计信息；  </span><br><span class="line">-p 选项用于指定默认情况的子集。  </span><br><span class="line">-v 与 -b 选项一起使用时将显示包含于  </span><br><span class="line">为所有可执行组件创建连接或监听端口的  </span><br><span class="line">组件。  </span><br><span class="line">interval 重新显示选定统计信息，每次显示之间  </span><br><span class="line">暂停时间间隔(以秒计)。按 CTRL+C 停止重新  </span><br><span class="line">显示统计信息。如果省略，netstat 显示当前  </span><br><span class="line">配置信息(只显示一次)</span><br></pre></td></tr></table></figure></p><h1 id="adb-shell-pm-包相关"><a href="#adb-shell-pm-包相关" class="headerlink" title="adb shell pm 包相关"></a>adb shell pm 包相关</h1><p><a href="https://blog.csdn.net/yelangjueqi/article/details/52575233" target="_blank" rel="noopener">https://blog.csdn.net/yelangjueqi/article/details/52575233</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">usage: pm \[list|path|install|uninstall\]  </span><br><span class="line">pm list packages \[-f\]  </span><br><span class="line">pm list permission-groups  </span><br><span class="line">pm list permissions \[-g\] \[-f\] \[-d\] \[-u\] \[GROUP\]  </span><br><span class="line">pm list instrumentation \[-f\] \[TARGET-PACKAGE\]  </span><br><span class="line">pm list features  </span><br><span class="line">pm path PACKAGE  </span><br><span class="line">pm dump PACKAGE</span><br><span class="line">pm install \[-l\] \[-r\] \[-t\] \[-i INSTALLER\_PACKAGE\_NAME\] PATH  </span><br><span class="line">pm uninstall \[-k\] PACKAGE  </span><br><span class="line">pm <span class="built_in">enable</span> PACKAGE\_OR\_COMPONENT  </span><br><span class="line">pm <span class="built_in">disable</span> PACKAGE\_OR\_COMPONENT</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line">The list packages <span class="built_in">command</span> prints all packages. Options:  </span><br><span class="line">-f: see their associated file.</span><br><span class="line"></span><br><span class="line">The list permission-groups <span class="built_in">command</span> prints all known  </span><br><span class="line">permission groups.</span><br><span class="line"></span><br><span class="line">The list permissions <span class="built_in">command</span> prints all known  </span><br><span class="line">permissions, optionally only those <span class="keyword">in</span> GROUP. Options:  </span><br><span class="line">-g: organize by group.  </span><br><span class="line">-f: <span class="built_in">print</span> all information.  </span><br><span class="line">-s: short summary.  </span><br><span class="line">-d: only list dangerous permissions.  </span><br><span class="line">-u: list only the permissions users will see.</span><br><span class="line"></span><br><span class="line">The list instrumentation <span class="built_in">command</span> prints all instrumentations,  </span><br><span class="line">or only those that target a specified package. Options:  </span><br><span class="line">-f: see their associated file.</span><br><span class="line"></span><br><span class="line">The list features <span class="built_in">command</span> prints all features of the system.</span><br><span class="line"></span><br><span class="line">The path <span class="built_in">command</span> prints the path to the .apk of a package.</span><br><span class="line"></span><br><span class="line">The install <span class="built_in">command</span> installs a package to the system. Options:  </span><br><span class="line">-l: install the package with FORWARD_LOCK.  </span><br><span class="line">-r: reinstall an exisiting app, keeping its data.  </span><br><span class="line">-t: allow <span class="built_in">test</span> .apks to be installed.  </span><br><span class="line">-i: specify the installer package name.</span><br><span class="line"></span><br><span class="line">The uninstall <span class="built_in">command</span> removes a package from the system. Options:  </span><br><span class="line">-k: keep the data and cache directories around.  </span><br><span class="line">after the package removal.</span><br><span class="line"></span><br><span class="line">The <span class="built_in">enable</span> and <span class="built_in">disable</span> commands change the enabled state of  </span><br><span class="line">a given package or component (written as “package/class”).</span><br></pre></td></tr></table></figure><p>查看stdout 和stderr<br>在默认状态下，Android系统有stdout 和 stderr (System.out和System.err )输出到/dev/null ，<br>在运行Dalvik VM的进程中，有一个系统可以备份日志文件。在这种情况下，系统会用stdout 和stderr 和优先级 I.来记录日志信息</p><p>通过这种方法指定输出的路径，停止运行的模拟器/设备，然后通过用setprop 命令远程输入日志</p><p>adbshellstop adb shell stop adb shell setprop log.redirect-stdio true<br>$ adb shell start系统直到你关闭模拟器/设备前设置会一直保留，可以通过添加/data/local.prop 可以使用模拟器/设备上的默认设置</p><p>UI/软件 试验程序 Monkey<br>当Monkey程序在模拟器或设备运行的时候，如果用户出发了比如点击，触摸，手势或一些系统级别的事件的时候，<br>它就会产生随机脉冲，所以可以用Monkey用随机重复的方法去负荷测试你开发的软件.<br>最简单的方法就是用用下面的命令来使用Monkey，这个命令将会启动你的软件并且触发500个事件.</p><h1 id="adb-shel-monkey-Monkey相关"><a href="#adb-shel-monkey-Monkey相关" class="headerlink" title="adb shel monkey Monkey相关"></a>adb shel monkey Monkey相关</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell monkey -v -p your.package.name 500</span><br></pre></td></tr></table></figure><p>更多的关于命令Monkey的命令的信息，可以查看UI/Application Exerciser Monkey documentation page.</p><h1 id="adb-shell-ps-系列"><a href="#adb-shell-ps-系列" class="headerlink" title="adb shell ps 系列"></a>adb shell ps 系列</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep -rn systemui</span><br><span class="line">ps -e | grep -rn system_server</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android ADB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Myblog</title>
      <link href="/2015/01/01/Myblog/"/>
      <url>/2015/01/01/Myblog/</url>
      <content type="html"><![CDATA[<p>This article is for self-summary, Only for myself.</p><h1 id="已经整理完成的文章"><a href="#已经整理完成的文章" class="headerlink" title="已经整理完成的文章"></a>已经整理完成的文章</h1><ol><li>ADB (Android Debug Bridge)常用命令<br>需要做的延伸是：分析adb 的源码</li><li><p>windows批处理 BAT技巧<br>需要延伸的是： 用bat脚本抓所有的Android log<br>在Ubuntu环境下，使用其他脚本抓所有的Android log</p></li><li><p>各类工具使用小技巧<br>需要延伸的是： 日常工作中使用过的工具的小技巧需要随时收录进来</p></li><li><p>问题锦集-速查<br>需要延伸的是： 日常工作中遇到的常见的一些问题，最好都记录下来，保存到这里来</p></li><li><p>Android 编译<br>需要延伸的是： Android编译流程 和 编译过程中各个文件的作用</p></li><li><p>Linux脚本编写基础<br>是一篇学习的文章： 还没有学习完，文章格式乱七八糟，徐继续维护</p></li><li><p>android 开发如何做内存优化</p></li></ol><h1 id="重点关注的文章"><a href="#重点关注的文章" class="headerlink" title="重点关注的文章"></a>重点关注的文章</h1><!--Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).## Quick Start### Create a new post<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a><br>–&gt;</p>-->]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Myblog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
